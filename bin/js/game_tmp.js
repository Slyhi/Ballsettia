var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Vector2 = /** @class */ (function () {
    function Vector2(x, y) {
        this.x = x;
        this.y = y;
    }
    Object.defineProperty(Vector2.prototype, "angle", {
        get: function () {
            var angle = M.atan2(this.y, this.x);
            if (angle < 0) {
                angle += 360;
            }
            return angle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "magnitude", {
        get: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "magnitudeSq", {
        get: function () {
            return this.x * this.x + this.y * this.y;
        },
        enumerable: false,
        configurable: true
    });
    Vector2.prototype.add = function (x, y) {
        if (typeof (x) === 'number') {
            this.x += x;
            this.y += y;
        }
        else {
            this.x += x.x;
            this.y += x.y;
        }
        return this;
    };
    Vector2.prototype.addMagnitude = function (amount) {
        return this.setMagnitude(this.magnitude + amount);
    };
    Vector2.prototype.clampMagnitude = function (maxMagnitude) {
        if (maxMagnitude < 0) {
            console.error('Tried to clamp vector magnitude with negative maxMagnitude');
            return this;
        }
        if (this.magnitude > maxMagnitude) {
            this.setMagnitude(maxMagnitude);
        }
        return this;
    };
    Vector2.prototype.clone = function () {
        return new Vector2(this.x, this.y);
    };
    Vector2.prototype.divide = function (x, y) {
        if (typeof (x) === 'number') {
            this.x /= x;
            this.y /= y;
        }
        else {
            this.x /= x.x;
            this.y /= x.y;
        }
        return this;
    };
    Vector2.prototype.isZero = function () {
        return this.x === 0 && this.y === 0;
    };
    Vector2.prototype.multiply = function (x, y) {
        if (typeof (x) === 'number') {
            this.x *= x;
            this.y *= y;
        }
        else {
            this.x *= x.x;
            this.y *= x.y;
        }
        return this;
    };
    Vector2.prototype.normalize = function () {
        var mag = this.magnitude;
        if (mag !== 0) {
            this.x /= mag;
            this.y /= mag;
        }
        return this;
    };
    Vector2.prototype.normalized = function () {
        var copy = this.clone();
        copy.normalize();
        return copy;
    };
    Vector2.prototype.projectOnto = function (other) {
        var factor = G.dot(this, other) / other.magnitudeSq;
        this.x = other.x * factor;
        this.y = other.y * factor;
        return this;
    };
    Vector2.prototype.projectedOnto = function (other) {
        var copy = this.clone();
        copy.projectOnto(other);
        return copy;
    };
    Vector2.prototype.rotate = function (angle) {
        var sin = M.sin(angle);
        var cos = M.cos(angle);
        var x = this.x;
        var y = this.y;
        this.x = cos * x - sin * y;
        this.y = sin * x + cos * y;
        return this;
    };
    Vector2.prototype.rotated = function (angle) {
        var copy = this.clone();
        copy.rotate(angle);
        return copy;
    };
    Vector2.prototype.set = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        this.x = x;
        this.y = y;
        return this;
    };
    Vector2.prototype.scale = function (amount) {
        this.x *= amount;
        this.y *= amount;
        return this;
    };
    Vector2.prototype.scaled = function (amount) {
        var copy = this.clone();
        copy.scale(amount);
        return copy;
    };
    Vector2.prototype.setMagnitude = function (magnitude) {
        this.normalize();
        this.scale(magnitude);
        return this;
    };
    Vector2.prototype.subtract = function (x, y) {
        if (typeof (x) === 'number') {
            this.x -= x;
            this.y -= y;
        }
        else {
            this.x -= x.x;
            this.y -= x.y;
        }
        return this;
    };
    Vector2.prototype.toPolar = function () {
        return new Vector2Polar(this.angle, this.magnitude);
    };
    Vector2.prototype.withMagnitude = function (magnitude) {
        var copy = this.clone();
        copy.setMagnitude(magnitude);
        return copy;
    };
    Vector2.fromPolar = function (radius, angle) {
        return new Vector2(radius * M.cos(angle), radius * M.sin(angle));
    };
    Object.defineProperty(Vector2, "UP_LEFT", {
        // Directions
        get: function () { return new Vector2(-1, -1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "UP", {
        get: function () { return new Vector2(0, -1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "UP_RIGHT", {
        get: function () { return new Vector2(1, -1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "LEFT", {
        get: function () { return new Vector2(-1, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "NONE", {
        get: function () { return new Vector2(0, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "RIGHT", {
        get: function () { return new Vector2(1, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "DOWN_LEFT", {
        get: function () { return new Vector2(-1, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "DOWN", {
        get: function () { return new Vector2(0, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "DOWN_RIGHT", {
        get: function () { return new Vector2(1, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "TOP_LEFT", {
        // Anchors
        get: function () { return new Vector2(0, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "TOP_CENTER", {
        get: function () { return new Vector2(0.5, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "TOP_RIGHT", {
        get: function () { return new Vector2(1, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "CENTER_LEFT", {
        get: function () { return new Vector2(0, 0.5); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "CENTER_CENTER", {
        get: function () { return new Vector2(0.5, 0.5); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "CENTER_RIGHT", {
        get: function () { return new Vector2(1, 0.5); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "BOTTOM_LEFT", {
        get: function () { return new Vector2(0, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "BOTTOM_CENTER", {
        get: function () { return new Vector2(0.5, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "BOTTOM_RIGHT", {
        get: function () { return new Vector2(1, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "TOP", {
        get: function () { return new Vector2(0.5, 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "CENTER", {
        get: function () { return new Vector2(0.5, 0.5); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "BOTTOM", {
        get: function () { return new Vector2(0.5, 1); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vector2, "ZERO", {
        // Misc
        get: function () { return new Vector2(0, 0); },
        enumerable: false,
        configurable: true
    });
    return Vector2;
}());
var Vector2Polar = /** @class */ (function () {
    function Vector2Polar(angle, radius) {
        this.angle = angle;
        this.radius = radius;
    }
    Vector2Polar.prototype.scale = function (amount) {
        this.radius *= amount;
        return this;
    };
    Vector2Polar.prototype.toCartesian = function () {
        return Vector2.fromPolar(this.radius, this.angle);
    };
    return Vector2Polar;
}());
/// <reference path="../utils/vector.ts"/>
var Point = PIXI.Point;
var Rectangle = PIXI.Rectangle;
function vec2(x, y) {
    if (typeof (x) === 'number')
        return new Vector2(x, y);
    return new Vector2(x.x, x.y);
}
function rect(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}
// Only meant to be populated by Preload
var AssetCache = /** @class */ (function () {
    function AssetCache() {
    }
    AssetCache.getPixiTexture = function (key) {
        if (!this.pixiTextures[key]) {
            console.error("Texture '" + key + "' does not exist.");
        }
        return this.pixiTextures[key];
    };
    AssetCache.getTexture = function (key) {
        if (this.isNoneTexture(key)) {
            return Texture.NONE;
        }
        if (!this.textures[key]) {
            console.error("Texture '" + key + "' does not exist.");
            return Texture.NONE;
        }
        return this.textures[key];
    };
    AssetCache.getSoundAsset = function (key) {
        if (!this.sounds[key]) {
            console.error("Sound '" + key + "' does not exist.");
            return { buffer: new AudioBuffer({ length: 1, sampleRate: 8000 }), volume: 1, speed: 1 };
        }
        return this.sounds[key];
    };
    AssetCache.getTileset = function (key) {
        if (!this.tilesets[key]) {
            console.error("Tileset '" + key + "' does not exist.");
        }
        return this.tilesets[key];
    };
    AssetCache.getTilemap = function (key) {
        if (!this.tilemaps[key]) {
            console.error("Tilemap '" + key + "' does not exist.");
        }
        return this.tilemaps[key];
    };
    AssetCache.getFont = function (key) {
        if (!this.fonts[key]) {
            console.error("Font '" + key + "' does not exist.");
        }
        return this.fonts[key];
    };
    AssetCache.getLciDocument = function (key) {
        if (!this.lciDocuments[key]) {
            console.error("LCI document '" + key + "' does not exist.");
        }
        return this.lciDocuments[key];
    };
    AssetCache.isNoneTexture = function (key) {
        return !key || key === 'none' || key.startsWith('none/');
    };
    AssetCache.pixiTextures = {};
    AssetCache.textures = {};
    AssetCache.sounds = {};
    AssetCache.tilesets = {};
    AssetCache.tilemaps = {};
    AssetCache.fonts = {};
    AssetCache.lciDocuments = {};
    return AssetCache;
}());
var Fullscreen = /** @class */ (function () {
    function Fullscreen() {
    }
    Object.defineProperty(Fullscreen, "supported", {
        get: function () { return document.fullscreenEnabled; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Fullscreen, "enabled", {
        get: function () { return !!document.fullscreenElement; },
        enumerable: false,
        configurable: true
    });
    Fullscreen.toggleFullscreen = function () {
        if (!this.supported)
            return;
        if (this.enabled) {
            this.stopFullscreen();
        }
        else {
            this.startFullscreen();
        }
    };
    Fullscreen.startFullscreen = function () {
        if (!this.supported || this.enabled)
            return;
        Main.renderer.view.requestFullscreen();
    };
    Fullscreen.stopFullscreen = function () {
        if (!this.supported || !this.enabled)
            return;
        document.exitFullscreen();
    };
    return Fullscreen;
}());
var Game = /** @class */ (function () {
    function Game(config) {
        this.entryPointMenu = config.entryPointMenu;
        this.mainMenu = config.mainMenu;
        this.pauseMenu = config.pauseMenu;
        this.theaterFactory = config.theaterFactory;
        this.soundManager = new SoundManager();
        this.musicManager = new MusicManager();
        this.menuSystem = new MenuSystem(this);
        this.overlay = new DebugOverlay();
        this.isShowingOverlay = true;
        this.allowPauseWithPauseKey = true;
    }
    Object.defineProperty(Game.prototype, "volume", {
        get: function () { return Options.volume * (Debug.SKIP_RATE >= 100 ? 0.2 : 1); },
        enumerable: false,
        configurable: true
    });
    ;
    Object.defineProperty(Game.prototype, "currentMusicKey", {
        get: function () { return this.musicManager ? this.musicManager.currentMusicKey : undefined; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "delta", {
        get: function () { return Main.delta; },
        enumerable: false,
        configurable: true
    });
    Game.prototype.start = function () {
        this.menuSystem.clear();
        this.menuSystem.loadMenu(this.entryPointMenu);
        if (Debug.SKIP_MAIN_MENU_STAGE) {
            this.loadMainMenu();
            this.startGame(Debug.SKIP_MAIN_MENU_STAGE);
        }
    };
    Game.prototype.update = function () {
        this.updatePause();
        if (this.menuSystem.inMenu) {
            this.menuSystem.update();
        }
        else {
            this.theater.isSkippingCutscene = false; // Safeguard
            this.theater.update();
        }
        this.updateOverlay();
        this.soundManager.volume = this.volume * Options.sfxVolume;
        this.soundManager.update(this.delta);
        this.musicManager.baseVolume = this.volume * Options.musicVolume;
        this.musicManager.update(this.delta);
    };
    Game.prototype.updatePause = function () {
        if (!this.menuSystem.inMenu && this.allowPauseWithPauseKey && this.theater.canPause && Input.justDown(Input.GAME_PAUSE)) {
            Input.consume(Input.GAME_PAUSE);
            this.pauseGame();
        }
    };
    Game.prototype.updateOverlay = function () {
        var _a;
        if (Input.justDown(Input.DEBUG_TOGGLE_OVERLAY)) {
            this.isShowingOverlay = !this.isShowingOverlay;
        }
        if (this.isShowingOverlay && Debug.SHOW_OVERLAY) {
            this.overlay.setCurrentWorldToDebug(this.menuSystem.inMenu ? this.menuSystem.currentMenu : (_a = this.theater) === null || _a === void 0 ? void 0 : _a.currentWorld);
            this.overlay.update();
        }
    };
    Game.prototype.render = function (screen) {
        if (this.menuSystem.inMenu) {
            this.menuSystem.render(screen);
        }
        else {
            this.theater.render(screen, 0, 0);
        }
        if (this.isShowingOverlay && Debug.SHOW_OVERLAY) {
            this.overlay.render(screen, 0, 0);
        }
        if (Debug.SHOW_TOUCHES) {
            this.renderTouches(screen);
        }
    };
    Game.prototype.loadMainMenu = function () {
        this.menuSystem.clear();
        this.menuSystem.loadMenu(this.mainMenu);
        Persist.persist();
    };
    Game.prototype.loadTheater = function (stageToLoad) {
        this.theater = this.theaterFactory();
        this.theater.loadStageImmediate(stageToLoad);
    };
    Game.prototype.pauseGame = function () {
        this.menuSystem.loadMenu(this.pauseMenu);
    };
    Game.prototype.pauseMusic = function (fadeTime) {
        if (fadeTime === void 0) { fadeTime = 0; }
        this.musicManager.pauseMusic(fadeTime);
    };
    Game.prototype.playMusic = function (key, fadeTime) {
        if (fadeTime === void 0) { fadeTime = 0; }
        this.musicManager.playMusic(key, fadeTime);
    };
    Game.prototype.playSound = function (key) {
        var _a;
        if ((_a = global.theater) === null || _a === void 0 ? void 0 : _a.isSkippingCutscene)
            return new Sound(key);
        return this.soundManager.playSound(key);
    };
    Game.prototype.startGame = function (stageToLoad) {
        this.loadTheater(stageToLoad);
        this.menuSystem.clear();
    };
    Game.prototype.stopMusic = function (fadeTime) {
        if (fadeTime === void 0) { fadeTime = 0; }
        this.musicManager.stopMusic(fadeTime);
    };
    Game.prototype.unpauseGame = function () {
        this.menuSystem.clear();
    };
    Game.prototype.unpauseMusic = function () {
        this.musicManager.unpauseMusic();
    };
    Game.prototype.renderTouches = function (screen) {
        if (IS_MOBILE && Input.isKeyCodeDown(Input.MOUSE_KEYCODES[0])) {
            Draw.brush.color = 0xFF0000;
            Draw.brush.alpha = 1;
            Draw.brush.thickness = 1;
            Draw.circleOutline(screen, Input.mouseX, Input.mouseY, Input.mouseRadius, Draw.ALIGNMENT_INNER);
        }
    };
    return Game;
}());
var Monitor = /** @class */ (function () {
    function Monitor() {
        this.points = [];
    }
    Monitor.prototype.addPoint = function (point) {
        this.points.push(point);
    };
    Monitor.prototype.clear = function () {
        this.points = [];
    };
    Monitor.prototype.getAvg = function () {
        return A.sum(this.points) / this.points.length;
    };
    Monitor.prototype.getP = function (p) {
        var count = (p === 100) ? 1 : Math.ceil(this.points.length * (100 - p) / 100);
        var sum = 0;
        A.sort(this.points, function (point) { return point; });
        for (var i = this.points.length - count; i < this.points.length; i++) {
            sum += this.points[i];
        }
        return sum / count;
    };
    Monitor.prototype.getQ = function (q) {
        var count = (q === 0) ? 1 : Math.ceil(this.points.length * q / 100);
        var sum = 0;
        A.sort(this.points, function (point) { return point; });
        for (var i = 0; i < count; i++) {
            sum += this.points[i];
        }
        return sum / count;
    };
    Monitor.prototype.isEmpty = function () {
        return _.isEmpty(this.points);
    };
    return Monitor;
}());
/// <reference path="./monitor.ts"/>
var FPSCalculator = /** @class */ (function () {
    function FPSCalculator(timePerReport) {
        this.monitor = new Monitor();
        this.timePerReport = timePerReport;
        this.fpsAvg = 0;
        this.fpsP = 0;
        this.startFrameTime = 0;
        this.totalTime = 0;
    }
    FPSCalculator.prototype.update = function () {
        var currentTime = performance.now();
        var delta = (currentTime - this.startFrameTime) / 1000;
        this.monitor.addPoint(delta);
        this.totalTime += delta;
        if (this.totalTime >= this.timePerReport) {
            this.fpsAvg = 1 / this.monitor.getAvg();
            this.fpsP = 1 / this.monitor.getP(95);
            this.monitor.clear();
            this.totalTime = 0;
        }
        this.startFrameTime = currentTime;
    };
    return FPSCalculator;
}());
/// <reference path="../metrics/fps.ts"/>
var global = /** @class */ (function () {
    function global() {
    }
    global.clearStacks = function () {
        this.scriptStack = [];
    };
    Object.defineProperty(global, "script", {
        // Update options
        get: function () { return this.scriptStack[this.scriptStack.length - 1]; },
        enumerable: false,
        configurable: true
    });
    ;
    global.pushScript = function (script) { this.scriptStack.push(script); };
    global.popScript = function () { return this.scriptStack.pop(); };
    Object.defineProperty(global, "game", {
        get: function () { return Main.game; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(global, "theater", {
        get: function () { return this.game.theater; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(global, "world", {
        get: function () { var _a; return (_a = this.theater) === null || _a === void 0 ? void 0 : _a.currentWorld; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(global, "skippingCutscene", {
        get: function () { var _a; return (_a = this.theater) === null || _a === void 0 ? void 0 : _a.isSkippingCutscene; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(global, "renderer", {
        get: function () { return Main.renderer; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(global, "soundManager", {
        get: function () { return Main.soundManager; },
        enumerable: false,
        configurable: true
    });
    global.scriptStack = [];
    global.fpsCalculator = new FPSCalculator(1);
    return global;
}());
var Input = /** @class */ (function () {
    function Input() {
    }
    Input.init = function () {
        var e_1, _a;
        var _this = this;
        this.keyCodesByName = O.deepClone(Options.getOption(Options.CONTROLS));
        this.isDownByKeyCode = {};
        this.keysByKeycode = {};
        for (var name_1 in this.keyCodesByName) {
            this.keyCodesByName[name_1].push(this.debugKeyCode(name_1));
            try {
                for (var _b = (e_1 = void 0, __values(this.keyCodesByName[name_1])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var keyCode = _c.value;
                    this.setupKeyCode(keyCode);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        TouchManager.onTouchDown = function () { return _this.handleTouchDown(); };
        TouchManager.onTouchUp = function () { return _this.handleTouchUp(); };
    };
    Input.update = function () {
        if (Debug.PROGRAMMATIC_INPUT) {
            this.clearKeys();
        }
        this.updateKeys();
        this.updateMousePosition();
    };
    Input.postUpdate = function () {
        this._mouseScrollDelta = 0;
        if (this.touchWentUp) {
            this._canvasMouseX = 0;
            this._canvasMouseY = 0;
            this._mouseRadius = 0;
            this.touchWentUp = false;
        }
    };
    Input.consume = function (key) {
        var e_2, _a;
        try {
            for (var _b = __values(this.keyCodesByName[key] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var keyCode = _c.value;
                this.keysByKeycode[keyCode].consume();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    Input.reset = function () {
        for (var key in this.isDownByKeyCode) {
            this.isDownByKeyCode[key] = false;
        }
    };
    Input.debugKeyDown = function (name) {
        if (!Debug.PROGRAMMATIC_INPUT)
            return;
        this.keysByKeycode[this.debugKeyCode(name)].setDown();
    };
    Input.debugKeyJustDown = function (name) {
        if (!Debug.PROGRAMMATIC_INPUT)
            return;
        this.keysByKeycode[this.debugKeyCode(name)].setJustDown();
    };
    Input.debugKeyUp = function (name) {
        if (!Debug.PROGRAMMATIC_INPUT)
            return;
        this.keysByKeycode[this.debugKeyCode(name)].setUp();
    };
    Input.debugKeyJustUp = function (name) {
        if (!Debug.PROGRAMMATIC_INPUT)
            return;
        this.keysByKeycode[this.debugKeyCode(name)].setJustUp();
    };
    Input.addControlBinding = function (controlName, keyCode) {
        var controls = Options.getOption(Options.CONTROLS);
        var controlBindings = controls[controlName];
        if (!controlBindings) {
            console.error("Cannot add control binding for '" + controlName + "' since the control does not exist");
            return;
        }
        if (!_.contains(controlBindings, keyCode)) {
            controlBindings.push(keyCode);
        }
        Options.saveOptions();
        this.init();
    };
    Input.removeControlBinding = function (controlName, keyCode) {
        var controls = Options.getOption(Options.CONTROLS);
        var controlBindings = controls[controlName];
        if (!controlBindings) {
            console.error("Cannot remove control binding for '" + controlName + "' since the control does not exist");
            return;
        }
        A.removeAll(controlBindings, keyCode);
        Options.saveOptions();
        this.init();
    };
    Input.updateControlBinding = function (controlName, oldKeyCode, newKeyCode) {
        var controls = Options.getOption(Options.CONTROLS);
        var controlBindings = controls[controlName];
        if (!controlBindings) {
            console.error("Cannot update control binding for '" + controlName + "' since the control does not exist");
            return;
        }
        if (!_.contains(controlBindings, oldKeyCode)) {
            console.error("Cannot update control binding '" + oldKeyCode + "' for '" + controlName + "' since that key is not bound to that control");
            return;
        }
        for (var i = 0; i < controlBindings.length; i++) {
            if (controlBindings[i] === oldKeyCode) {
                controlBindings[i] = newKeyCode;
                break;
            }
        }
        Options.saveOptions();
        this.init();
    };
    Input.debugKeyCode = function (name) {
        return this.DEBUG_PREFIX + name;
    };
    Input.updateKeys = function () {
        for (var keyCode in this.keysByKeycode) {
            if (!this.preventRegularKeyboardInput || keyCode.includes('Mouse')) {
                this.keysByKeycode[keyCode].update(this.isDownByKeyCode[keyCode]);
            }
            else {
                this.keysByKeycode[keyCode].setUp();
            }
        }
    };
    Input.clearKeys = function () {
        for (var keyCode in this.isDownByKeyCode) {
            this.isDownByKeyCode[keyCode] = false;
        }
    };
    Input.updateMousePosition = function () {
        if (this.isUsingTouch && this.simulateMouseWithTouches) {
            if (TouchManager.isTouching) {
                this._canvasMouseX = TouchManager.touch.x;
                this._canvasMouseY = TouchManager.touch.y;
                this._mouseRadius = TouchManager.touch.radius;
            }
        }
        else if (IS_MOBILE) {
            if (this.isDownByKeyCode[this.MOUSE_KEYCODES[0]]) {
                this._canvasMouseX = global.renderer.plugins.interaction.mouse.global.x;
                this._canvasMouseY = global.renderer.plugins.interaction.mouse.global.y;
                this._mouseRadius = IS_MOBILE ? 10 : 0;
            }
        }
        else {
            this._canvasMouseX = global.renderer.plugins.interaction.mouse.global.x;
            this._canvasMouseY = global.renderer.plugins.interaction.mouse.global.y;
        }
        if (Fullscreen.enabled) {
            var cw = global.renderer.width / global.renderer.resolution;
            var ch = global.renderer.height / global.renderer.resolution;
            var iw = window.innerWidth;
            var ih = window.innerHeight;
            var ratioW = iw / cw;
            var ratioH = ih / ch;
            if (ratioW < ratioH) {
                var h = ch * ch * ratioW / ih;
                var y1 = (ch - h) / 2;
                this._canvasMouseY = ch * (this._canvasMouseY - y1) / h;
            }
            else if (ratioW > ratioH) {
                var w = cw * cw * ratioH / iw;
                var x1 = (cw - w) / 2;
                this._canvasMouseX = cw * (this._canvasMouseX - x1) / w;
            }
        }
        this._lastMouseX = this._mouseX;
        this._lastMouseY = this._mouseY;
        //if (this.isMouseOnCanvas) {
        this._mouseX = Math.floor(this._canvasMouseX);
        this._mouseY = Math.floor(this._canvasMouseY);
        //}
        if (this.touchWentDown) {
            this._lastMouseX = this._mouseX;
            this._lastMouseY = this._mouseY;
            this.touchWentDown = false;
        }
    };
    Input.setupKeyCode = function (keyCode) {
        this.isDownByKeyCode[keyCode] = false;
        this.keysByKeycode[keyCode] = this.keysByKeycode[keyCode] || new Input.Key();
    };
    Input.consumeEventKey = function () {
        this.eventKey = undefined;
    };
    /**
     * Used to detect keypress when updating key binds.
     */
    Input.getEventKey = function () {
        return this.eventKey;
    };
    Input.isDown = function (key) {
        var _this = this;
        if (key === Input.GAME_ADVANCE_CUTSCENE && global.skippingCutscene)
            return true;
        return this.keyCodesByName[key] && this.keyCodesByName[key].some(function (keyCode) { return _this.keysByKeycode[keyCode].isDown; });
    };
    Input.isUp = function (key) {
        var _this = this;
        return this.keyCodesByName[key] && this.keyCodesByName[key].every(function (keyCode) { return _this.keysByKeycode[keyCode].isUp; });
    };
    Input.justDown = function (key) {
        var _this = this;
        if (key === Input.GAME_ADVANCE_CUTSCENE && global.skippingCutscene)
            return true;
        return this.keyCodesByName[key] && this.keyCodesByName[key].some(function (keyCode) { return _this.keysByKeycode[keyCode].justDown; });
    };
    Input.justUp = function (key) {
        var _this = this;
        return this.keyCodesByName[key] && this.keyCodesByName[key].some(function (keyCode) { return _this.keysByKeycode[keyCode].justUp; })
            && this.keyCodesByName[key].every(function (keyCode) { return _this.keysByKeycode[keyCode].isUp || _this.keysByKeycode[keyCode].justUp; });
    };
    Input.isKeyCodeDown = function (keyCode) {
        return this.isDownByKeyCode[keyCode];
    };
    Object.defineProperty(Input, "mouseX", {
        get: function () {
            return this._mouseX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "mouseY", {
        get: function () {
            return this._mouseY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "mousePosition", {
        get: function () {
            return new Vector2(this.mouseX, this.mouseY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "lastMouseX", {
        get: function () {
            return this._lastMouseX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "lastMouseY", {
        get: function () {
            return this._lastMouseY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "lastMousePosition", {
        get: function () {
            return new Vector2(this.lastMouseX, this.lastMouseY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "canvasMouseX", {
        get: function () {
            return this._canvasMouseX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "canvasMouseY", {
        get: function () {
            return this._canvasMouseY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "canvasMousePosition", {
        get: function () {
            return new Vector2(this.canvasMouseX, this.canvasMouseY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "isMouseOnCanvas", {
        get: function () {
            return 0 <= this.canvasMouseX && this.canvasMouseX < global.gameWidth && 0 <= this.canvasMouseY && this.canvasMouseY < global.gameHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "mouseScrollDelta", {
        get: function () {
            return this._mouseScrollDelta;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "mouseRadius", {
        get: function () {
            return this._mouseRadius;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input, "mouseSpeed", {
        get: function () {
            if (Main.delta === 0)
                return 0;
            return M.distance(this.mouseX, this.mouseY, this.lastMouseX, this.lastMouseY) / Main.delta;
        },
        enumerable: false,
        configurable: true
    });
    Input.handleKeyDownEvent = function (event) {
        var keyCode = Input.getKeyFromEventKey(event.key);
        this.eventKey = keyCode;
        if (this.isDownByKeyCode[keyCode] !== undefined) {
            event.preventDefault();
        }
        this.isDownByKeyCode[keyCode] = true;
        // Handle fullscreen toggle
        if (!this.preventRegularKeyboardInput && _.contains(this.keyCodesByName[Input.FULLSCREEN], keyCode)) {
            Fullscreen.toggleFullscreen();
        }
    };
    Input.handleKeyUpEvent = function (event) {
        var keyCode = Input.getKeyFromEventKey(event.key);
        if (this.eventKey === keyCode)
            this.eventKey = undefined;
        if (this.isDownByKeyCode[keyCode] !== undefined) {
            event.preventDefault();
        }
        this.isDownByKeyCode[keyCode] = false;
    };
    Input.handleMouseDownEvent = function (event) {
        var keyCode = this.MOUSE_KEYCODES[event.button];
        this.eventKey = keyCode;
        if (keyCode && this.isDownByKeyCode[keyCode] !== undefined) {
            if (this.isMouseOnCanvas) {
                // Prevent game-clicks outside the canvas
                this.isDownByKeyCode[keyCode] = true;
            }
            // Prevent default for all inputs except LMB
            if (event.button !== 0)
                event.preventDefault();
        }
        if (IS_MOBILE && keyCode === this.MOUSE_KEYCODES[0]) {
            this.touchWentDown = true;
        }
    };
    Input.handleMouseUpEvent = function (event) {
        var keyCode = this.MOUSE_KEYCODES[event.button];
        if (this.eventKey === keyCode)
            this.eventKey = undefined;
        if (keyCode && this.isDownByKeyCode[keyCode] !== undefined) {
            this.isDownByKeyCode[keyCode] = false;
            event.preventDefault();
        }
        if (IS_MOBILE && keyCode === this.MOUSE_KEYCODES[0]) {
            this.touchWentUp = true;
        }
    };
    Input.handleMouseScrollEvent = function (event, preventScrollOnCanvas) {
        this._mouseScrollDelta = Math.sign(event.deltaY);
        if (preventScrollOnCanvas && this.isMouseOnCanvas && !event.ctrlKey && !event.metaKey) {
            event.preventDefault();
        }
    };
    Input.handleTouchDown = function () {
        if (this.simulateMouseWithTouches) {
            this.isDownByKeyCode[this.MOUSE_KEYCODES[0]] = true;
            this.isUsingTouch = true;
            this.touchWentDown = true;
        }
    };
    Input.handleTouchUp = function () {
        if (this.simulateMouseWithTouches) {
            this.isDownByKeyCode[this.MOUSE_KEYCODES[0]] = false;
            this.touchWentUp = true;
        }
    };
    Input._mouseX = 0;
    Input._mouseY = 0;
    Input._canvasMouseX = 0;
    Input._canvasMouseY = 0;
    Input._mouseRadius = 0;
    Input._mouseScrollDelta = 0;
    Input.isUsingTouch = false;
    Input.touchWentDown = false; // Did a touch event happen this frame that caused touch to start?
    Input.touchWentUp = false; // Did a touch event happen this frame that caused touch to stop?
    Input.simulateMouseWithTouches = false;
    Input.preventRegularKeyboardInput = false;
    Input.MOUSE_KEYCODES = ["MouseLeft", "MouseMiddle", "MouseRight", "MouseBack", "MouseForward"];
    Input.DEBUG_PREFIX = "debug::";
    return Input;
}());
(function (Input) {
    Input.FULLSCREEN = 'fullscreen';
    Input.GAME_ADVANCE_CUTSCENE = 'game_advanceCutscene';
    Input.GAME_PAUSE = 'game_pause';
    Input.GAME_CLOSE_MENU = 'game_closeMenu';
    Input.GAME_SELECT = 'game_select';
    Input.DEBUG_MOVE_CAMERA_UP = 'debug_moveCameraUp';
    Input.DEBUG_MOVE_CAMERA_DOWN = 'debug_moveCameraDown';
    Input.DEBUG_MOVE_CAMERA_LEFT = 'debug_moveCameraLeft';
    Input.DEBUG_MOVE_CAMERA_RIGHT = 'debug_moveCameraRight';
    Input.DEBUG_RECORD_METRICS = 'debug_recordMetrics';
    Input.DEBUG_SHOW_METRICS_MENU = 'debug_showMetricsMenu';
    Input.DEBUG_TOGGLE_OVERLAY = 'debug_toggleOverlay';
    Input.DEBUG_FRAME_SKIP_STEP = 'debug_frameSkipStep';
    Input.DEBUG_FRAME_SKIP_RUN = 'debug_frameSkipRun';
    Input.DEBUG_FRAME_SKIP_DISABLE = 'debug_frameSkipDisable';
    Input.DEBUG_SKIP_RATE = 'debug_skipRate';
    var Key = /** @class */ (function () {
        function Key() {
            this._isDown = false;
        }
        Object.defineProperty(Key.prototype, "isDown", {
            get: function () { return this._isDown; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Key.prototype, "isUp", {
            get: function () { return !this._isDown; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Key.prototype, "justDown", {
            get: function () { return this._isDown && !this._lastDown; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Key.prototype, "justUp", {
            get: function () { return !this._isDown && this._lastDown; },
            enumerable: false,
            configurable: true
        });
        Key.prototype.update = function (isDown) {
            this._lastDown = this._isDown;
            this._isDown = isDown;
        };
        Key.prototype.consume = function () {
            this._lastDown = this._isDown;
        };
        Key.prototype.reset = function () {
            this.setUp();
        };
        Key.prototype.setDown = function () {
            this._isDown = true;
            this._lastDown = true;
        };
        Key.prototype.setJustDown = function () {
            this._isDown = true;
            this._lastDown = false;
        };
        Key.prototype.setUp = function () {
            this._isDown = false;
            this._lastDown = false;
        };
        Key.prototype.setJustUp = function () {
            this._isDown = false;
            this._lastDown = true;
        };
        return Key;
    }());
    Input.Key = Key;
    /**
     * Translate possible capital letters/symbols to their lowercase key form.
     */
    function getKeyFromEventKey(key) {
        if (!key)
            return key;
        if (key.length === 1 && 'A' <= key && key <= 'Z')
            return key.toLowerCase();
        if (key in CAPS_TO_KEYS)
            return CAPS_TO_KEYS[key];
        return key;
    }
    Input.getKeyFromEventKey = getKeyFromEventKey;
    var CAPS_TO_KEYS = {
        '~': '`', '!': '1', '@': '2', '#': '3', '$': '4', '%': '5', '^': '6', '&': '7', '*': '8', '(': '9', ')': '0',
        '_': '-', '+': '=', '{': '[', '}': ']', '|': '\\', ':': ';', '"': '\'', '<': ',', '>': '.', '?': '/',
    };
})(Input || (Input = {}));
function debug(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (Debug.DEBUG) {
        console.log.apply(console, __spread([message], optionalParams));
    }
}
var Preload = /** @class */ (function () {
    function Preload() {
    }
    Preload.preload = function (options) {
        var loaders = [];
        for (var key in options.textures) {
            var texture = options.textures[key];
            if (texture.url && texture.url.endsWith('.lci')) {
                loaders.push(new LciLoader(key, options.textures[key]));
            }
            else {
                loaders.push(new TextureLoader(key, options.textures[key]));
            }
        }
        for (var key in options.sounds) {
            loaders.push(new SoundLoader(key, options.sounds[key]));
        }
        for (var key in options.tilesets) {
            loaders.push(new TilesetLoader(key, options.tilesets[key]));
        }
        for (var key in options.pyxelTilemaps) {
            loaders.push(new PyxelTilemapLoader(key, options.pyxelTilemaps[key]));
        }
        for (var key in options.fonts) {
            loaders.push(new FontLoader(key, options.fonts[key]));
        }
        for (var key in options.custom) {
            loaders.push(new CustomResourceLoader(options.custom[key].load));
        }
        this.loaderSystem = new LoaderSystem(loaders);
        this.loaderSystem.load(options.progressCallback, options.onLoad);
    };
    return Preload;
}());
/// <reference path="../load/preload.ts" />
var Main = /** @class */ (function () {
    function Main() {
    }
    Main.loadConfig = function (configFactory) {
        this.configFactory = configFactory;
    };
    Main.start = function () {
        if (!this.configFactory) {
            console.error('No main config loaded! Must load config by calling `Main.loadConfig(config);`');
            return;
        }
        this.config = this.configFactory();
        this.preload();
    };
    Main.preload = function () {
        var _this = this;
        var _a, _b;
        if (MobileUtils.isMobileBrowser()) {
            IS_MOBILE = true;
        }
        if (!PIXI.utils.isWebGLSupported()) {
            var errorText = document.createElement('p');
            errorText.innerHTML = "Error: WebGL is not supported in your browser.<br/><br/>The most common fix for this is to enable \"Use hardware acceleration\" in your browser's settings.";
            errorText.style.fontSize = "24px";
            errorText.style.color = "#FFFFFF";
            document.body.appendChild(errorText);
            return;
        }
        PIXI.utils.sayHello(PIXI.utils.isWebGLSupported() ? 'WebGL' : 'Canvas');
        PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
        LocalStorage.init();
        Debug.init(this.config.debug);
        global.gameCodeName = this.config.gameCodeName;
        global.gameWidth = this.config.gameWidth;
        global.gameHeight = this.config.gameHeight;
        global.backgroundColor = this.config.backgroundColor;
        WorldObject.DEFAULT_Z_BEHAVIOR = (_a = this.config.defaultZBehavior) !== null && _a !== void 0 ? _a : 'noop';
        SpriteText.addTags((_b = this.config.spriteTextTags) !== null && _b !== void 0 ? _b : {});
        SpriteText.DEFAULT_FONT = this.config.defaultSpriteTextFont;
        DialogProfiles.initProfiles(this.config.dialogProfiles);
        Main.renderer = PIXI.autoDetectRenderer({
            width: global.gameWidth,
            height: global.gameHeight,
            resolution: this.config.canvasScale,
            backgroundColor: global.backgroundColor,
        });
        document.body.appendChild(Main.renderer.view);
        Main.renderer.view.style.setProperty('image-rendering', 'pixelated'); // Chrome
        Main.renderer.view.style.setProperty('image-rendering', 'crisp-edges'); // Firefox
        if (MobileUtils.isMobileBrowser()) {
            document.body.style.backgroundColor = "black";
            MobileScaleManager.init();
        }
        // AccessibilityManager causes game to crash when Tab is pressed.
        // Deleting it as per https://github.com/pixijs/pixi.js/issues/5111#issuecomment-420047824
        Main.renderer.plugins.accessibility.destroy();
        delete Main.renderer.plugins.accessibility;
        Main.screen = new BasicTexture(global.gameWidth, global.gameHeight, 'Main.screen');
        this.soundManager = new GlobalSoundManager();
        WebAudio.initContext();
        Persistence.init();
        if (this.config.beforePreload)
            this.config.beforePreload();
        Preload.preload({
            textures: this.config.textures,
            sounds: this.config.sounds,
            tilesets: this.config.tilesets,
            pyxelTilemaps: this.config.pyxelTilemaps,
            fonts: this.config.fonts,
            custom: this.config.customResources,
            progressCallback: function (progress) { return _this.renderPreloadProgress(progress); },
            onLoad: function () {
                Main.load();
                Main.play();
            }
        });
    };
    Main.load = function () {
        var _this = this;
        //Options.updateCallbacks.push(() => Input.init()); // TODO: fix this for continuous volume slider
        Options.init(global.gameCodeName, this.config.defaultOptions);
        Input.init(); // TODO: remove this when fixed above
        Input.simulateMouseWithTouches = this.config.simulateMouseWithTouches;
        Persist.init(this.config.persistIntervalSeconds, function () { return _this.config.persist(); });
        this.initEvents();
        this.delta = 0;
        this.game = new Game(this.config.game);
        if (this.config.beforeStart)
            this.config.beforeStart();
        this.game.start();
        this.game.update(); // Update game once just to make sure everything is set up correctly.
    };
    Main.play = function () {
        var _this = this;
        PIXI.Ticker.shared.add(function (frameDelta) {
            Main.delta = M.clamp(frameDelta / 60, 0, 1 / _this.config.fpsLimit);
            if (Main.fixedDelta > 0) {
                Main.fixedDeltaBucket += Main.delta;
                Main.delta = Main.fixedDelta;
                if (Main.fixedDeltaBucket < Main.fixedDelta) {
                    return;
                }
                while (Main.fixedDeltaBucket >= Main.fixedDelta)
                    Main.fixedDeltaBucket -= Main.fixedDelta;
            }
            global.fpsCalculator.update();
            global.clearStacks();
            for (var i = 0; i < Debug.SKIP_RATE; i++) {
                Input.update();
                Debug.update();
                if (Debug.frameStepSkipFrame())
                    break;
                Main.soundManager.preGameUpdate();
                Main.game.update();
                Main.soundManager.postGameUpdate();
                Input.postUpdate();
            }
            Persistence.update(frameDelta / 60);
            Persist.update(frameDelta / 60);
            if (MobileUtils.isMobileBrowser()) {
                MobileScaleManager.update();
            }
            Main.screen.clear();
            Main.game.render(Main.screen);
            Main.renderScreenToCanvas();
        });
    };
    Main.renderScreenToCanvas = function () {
        Main.renderer.render(Utils.NOOP_DISPLAYOBJECT, undefined, true); // Clear the renderer
        Main.renderer.render(Main.screen.renderTextureSprite);
    };
    Main.forceRender = function () {
        Main.screen.clear();
        Main.game.render(Main.screen);
        Main.renderScreenToCanvas();
    };
    // For use in preload.
    Main.renderPreloadProgress = function (progress) {
        Main.screen.clear();
        Draw.brush.color = this.config.preloadBackgroundColor;
        Draw.brush.alpha = 1;
        Draw.fill(Main.screen);
        var barw = global.gameWidth / 2;
        var barh = 16;
        var barx = global.gameWidth / 2 - barw / 2;
        var bary = global.gameHeight / 2 - barh / 2;
        Draw.brush.color = this.config.preloadProgressBarColor;
        Draw.brush.thickness = 1;
        Draw.rectangleSolid(Main.screen, barx, bary, barw * progress, barh);
        Draw.rectangleOutline(Main.screen, barx, bary, barw, barh, Draw.ALIGNMENT_INNER);
        Main.renderScreenToCanvas();
    };
    Main.initEvents = function () {
        var _this = this;
        window.addEventListener("keypress", function (event) {
            WebAudio.start();
        });
        window.addEventListener("keydown", function (event) {
            WebAudio.start();
            Input.handleKeyDownEvent(event);
            if (event.key === 'Tab') {
                event.preventDefault();
            }
        });
        window.addEventListener("keyup", function (event) {
            WebAudio.start();
            Input.handleKeyUpEvent(event);
        });
        window.addEventListener("mousedown", function (event) {
            WebAudio.start();
            Input.handleMouseDownEvent(event);
        });
        window.addEventListener("mouseup", function (event) {
            WebAudio.start();
            Input.handleMouseUpEvent(event);
        });
        window.addEventListener("wheel", function (event) {
            Input.handleMouseScrollEvent(event, _this.config.preventScrollOnCanvas);
        }, { passive: false });
        window.addEventListener("touchstart", function (event) {
            TouchManager.handleTouchStartEvent(event);
        });
        window.addEventListener("touchmove", function (event) {
            TouchManager.handleTouchMoveEvent(event);
        });
        window.addEventListener("touchend", function (event) {
            TouchManager.handleTouchEndEvent(event);
        });
        window.addEventListener("touchcancel", function (event) {
            TouchManager.handleTouchCancelEvent(event);
        });
        window.addEventListener("contextmenu", function (event) {
            WebAudio.start();
            event.preventDefault();
        });
        window.addEventListener("blur", function (event) {
            Input.reset();
            if (IS_MOBILE) {
                Persist.persist();
            }
        });
        window.addEventListener(PageVisibility.VISIBILITY_CHANGE, function () {
            if (document[PageVisibility.HIDDEN]) {
                global.soundManager.pause();
            }
            else {
                global.soundManager.unpause();
            }
        }, false);
        window.addEventListener("beforeunload", function (event) {
            Persist.persist();
        }, false);
    };
    Main.getRemotePath = function () {
        var node = document.getElementById("data-remote-root");
        if (!node)
            return undefined;
        var path = node.getAttribute("data-remote-root");
        if (St.isBlank(path))
            return undefined;
        return path;
    };
    Main.hasRemotePath = function () {
        return !St.isBlank(Main.getRemotePath());
    };
    Main.getRootPath = function () {
        if (window.location.href.includes('localhost') || !Main.hasRemotePath()) {
            return '';
        }
        return Main.getRemotePath();
    };
    Main.getScaledWidth = function () {
        return global.gameWidth * Main.config.canvasScale;
    };
    Main.getScaledHeight = function () {
        return global.gameHeight * Main.config.canvasScale;
    };
    Main.fixedDeltaBucket = 0;
    return Main;
}());
var Options = /** @class */ (function () {
    function Options() {
    }
    Object.defineProperty(Options, "volume", {
        get: function () { return this.getOption(Options.VOLUME); },
        set: function (value) { this.updateOption(Options.VOLUME, value); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Options, "sfxVolume", {
        get: function () { return this.getOption(Options.SFX_VOLUME); },
        set: function (value) { this.updateOption(Options.SFX_VOLUME, value); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Options, "musicVolume", {
        get: function () { return this.getOption(Options.MUSIC_VOLUME); },
        set: function (value) { this.updateOption(Options.MUSIC_VOLUME, value); },
        enumerable: false,
        configurable: true
    });
    Options.init = function (name, defaultOptions) {
        this.optionsName = name;
        this.defaultOptions = defaultOptions;
        this.loadOptions();
        if (Debug.RESET_OPTIONS_AT_START) {
            this.resetOptions();
        }
    };
    Options.getOption = function (option) {
        return this.options[option];
    };
    Options.updateOption = function (option, value) {
        this.options[option] = value;
        this.saveOptions();
    };
    Options.resetOption = function (option) {
        this.options[option] = O.deepClone(this.defaultOptions[option]);
        this.saveOptions();
    };
    Options.resetOptions = function () {
        this.options = O.deepClone(this.defaultOptions);
        this.saveOptions();
    };
    Options.saveOptions = function () {
        LocalStorage.setJson(this.getOptionsLocalStorageName(), this.options);
        this.onUpdate();
    };
    Options.loadOptions = function () {
        this.options = O.deepClone(this.defaultOptions);
        var loadedOptions = LocalStorage.getJson(this.getOptionsLocalStorageName()) || {};
        for (var option in loadedOptions) {
            if (option === Options.CONTROLS) {
                /* NOOP FOR NOW, DEAL WITH CONTROLS OVERRIDING LATER */
                // let controls = this.options[Options.CONTROLS];
                // let loadedControls = loadedOptions[Options.CONTROLS]
                // for (let control in controls) {
                //     if (control in loadedControls) {
                //         controls[control] = loadedControls[controls];
                //     }
                // }
            }
            else {
                this.options[option] = loadedOptions[option];
            }
        }
        if (_.isEmpty(loadedOptions)) {
            this.onUpdate();
        }
    };
    Options.onUpdate = function () {
        var e_3, _a;
        try {
            for (var _b = __values(this.updateCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
                var callback = _c.value;
                callback();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    Options.getOptionsLocalStorageName = function () {
        return this.optionsName + "_options";
    };
    Options.VOLUME = 'volume';
    Options.SFX_VOLUME = 'sfx_volume';
    Options.MUSIC_VOLUME = 'music_volume';
    Options.CONTROLS = 'controls';
    Options.updateCallbacks = [];
    return Options;
}());
var Persist = /** @class */ (function () {
    function Persist() {
    }
    Persist.init = function (intervalSeconds, doPersist) {
        var _this = this;
        this.doPersist = doPersist;
        this.timer = new Timer(intervalSeconds, function () { return _this.persist(); }, Infinity);
    };
    Persist.persist = function () {
        this.doPersist();
        this.timer.reset();
    };
    Persist.update = function (delta) {
        this.timer.update(delta);
    };
    return Persist;
}());
var CutsceneManager = /** @class */ (function () {
    function CutsceneManager(theater) {
        this.theater = theater;
        this.current = null;
        this.seenCutsceneKeys = new Set();
    }
    Object.defineProperty(CutsceneManager.prototype, "isCutscenePlaying", {
        get: function () { return !!this.current; },
        enumerable: false,
        configurable: true
    });
    CutsceneManager.prototype.update = function () {
        this.updateCurrentCutscene();
    };
    CutsceneManager.prototype.updateCurrentCutscene = function () {
        if (this.current) {
            this.current.script.update(this.theater.delta);
            if (this.current.script.done) {
                this.finishCurrentCutscene();
            }
        }
    };
    CutsceneManager.prototype.canPlayCutscene = function (cutscene) {
        if (!cutscene)
            return false;
        return true;
    };
    CutsceneManager.prototype.canSkipCurrentCutscene = function () {
        return this.current && !this.current.node.unskippable;
    };
    CutsceneManager.prototype.fastForwardCutscene = function (cutscene) {
        this.playCutscene(cutscene);
        this.finishCurrentCutscene();
    };
    CutsceneManager.prototype.hasSeenCutscene = function (cutscene) {
        if (!cutscene.seenKey)
            return false;
        return this.seenCutsceneKeys.has(cutscene.seenKey);
    };
    CutsceneManager.prototype.markCutsceneAsSeen = function (cutscene) {
        if (!cutscene.seenKey)
            return;
        this.seenCutsceneKeys.add(cutscene.seenKey);
    };
    CutsceneManager.prototype.playCutscene = function (cutscene) {
        if (this.current) {
            console.error('Cannot play cutscene:', cutscene, 'because a cutscene is already playing:', this.current);
            return;
        }
        this.current = {
            node: cutscene,
            script: new Script(cutscene.script),
        };
        this.updateCurrentCutscene();
    };
    CutsceneManager.prototype.playCutsceneIfNotSeen = function (cutscene) {
        if (this.hasSeenCutscene(cutscene))
            return;
        this.playCutscene(cutscene);
    };
    CutsceneManager.prototype.reset = function () {
        if (this.current) {
            this.current.script.done = true;
        }
        this.current = null;
    };
    CutsceneManager.prototype.onStageLoad = function () {
    };
    CutsceneManager.prototype.finishCurrentCutscene = function () {
        if (!this.isCutscenePlaying)
            return;
        this.markCutsceneAsSeen(this.current.node);
        this.current = null;
        this.theater.dialogBox.complete();
        this.theater.clearSlides();
    };
    return CutsceneManager;
}());
var S;
(function (S) {
    function cameraTransition(duration, toMode, toMovement, easingFunction) {
        if (easingFunction === void 0) { easingFunction = Tween.Easing.OutExp; }
        return function () {
            var camera, cameraPoint, startPoint;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        camera = global.world.camera;
                        if (!toMovement)
                            toMovement = camera.movement;
                        cameraPoint = vec2(camera.x, camera.y);
                        camera.setModeFollow(cameraPoint);
                        camera.setMovementSnap();
                        startPoint = vec2(cameraPoint.x, cameraPoint.y);
                        return [4 /*yield*/, S.doOverTime(duration, function (t) {
                                var toPoint = toMode.getTargetPt(camera);
                                cameraPoint.x = M.lerp(startPoint.x, toPoint.x, easingFunction(t));
                                cameraPoint.y = M.lerp(startPoint.y, toPoint.y, easingFunction(t));
                                camera.snapPosition();
                            })];
                    case 1:
                        _a.sent();
                        camera.setMode(toMode);
                        camera.setMovement(toMovement);
                        return [2 /*return*/];
                }
            });
        };
    }
    S.cameraTransition = cameraTransition;
    function dialog(profileKey, text) {
        return function () {
            var _a, profile, entry;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = __read(DialogProfile.splitKey(profileKey), 2), profile = _a[0], entry = _a[1];
                        global.theater.dialogBox.setProfile(profile, entry);
                        global.theater.dialogBox.showDialog(text);
                        _b.label = 1;
                    case 1:
                        if (!!global.theater.dialogBox.done) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
    }
    S.dialog = dialog;
    function dialogAdd(profileKey, text) {
        return function () {
            var _a, profile, entry;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = __read(DialogProfile.splitKey(profileKey), 2), profile = _a[0], entry = _a[1];
                        global.theater.dialogBox.setProfile(profile, entry);
                        global.theater.dialogBox.addToDialog(text);
                        _b.label = 1;
                    case 1:
                        if (!!global.theater.dialogBox.done) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
    }
    S.dialogAdd = dialogAdd;
    function fadeSlides(duration) {
        return function () {
            var slideAlphas, timer, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isEmpty(global.theater.slides))
                            return [2 /*return*/];
                        slideAlphas = global.theater.slides.map(function (slide) { return slide.alpha; });
                        timer = new Timer(duration);
                        _a.label = 1;
                    case 1:
                        if (!!timer.done) return [3 /*break*/, 3];
                        for (i = 0; i < global.theater.slides.length; i++) {
                            global.theater.slides[i].alpha = slideAlphas[i] * (1 - timer.progress);
                        }
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        global.theater.clearSlides();
                        return [2 /*return*/];
                }
            });
        };
    }
    S.fadeSlides = fadeSlides;
    function fadeOut(duration, tint) {
        if (duration === void 0) { duration = 0; }
        if (tint === void 0) { tint = 0x000000; }
        return showSlide(function () {
            var slide = new Slide({ timeToLoad: duration, fadeIn: true });
            slide.setTexture(Texture.filledRect(global.gameWidth, global.gameHeight, tint));
            return slide;
        });
    }
    S.fadeOut = fadeOut;
    function jumpZ(duration, sprite, peakDelta, landOnGround) {
        if (landOnGround === void 0) { landOnGround = false; }
        return function () {
            var start, groundDelta;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = sprite.z;
                        groundDelta = landOnGround ? start : 0;
                        return [4 /*yield*/, S.doOverTime(duration, function (t) {
                                sprite.z = M.jumpParabola(start, peakDelta, groundDelta, t);
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    }
    S.jumpZ = jumpZ;
    function moveTo(worldObject, x, y, maxTime) {
        if (maxTime === void 0) { maxTime = 10; }
        return S.simul(moveToX(worldObject, x, maxTime), moveToY(worldObject, y, maxTime));
    }
    S.moveTo = moveTo;
    function moveToX(worldObject, x, maxTime) {
        if (maxTime === void 0) { maxTime = 10; }
        return function () {
            var dx, timer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dx = x - worldObject.x;
                        if (dx === 0)
                            return [2 /*return*/];
                        timer = new Timer(maxTime);
                        if (!(dx > 0)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        if (!(worldObject.x < x && !timer.done)) return [3 /*break*/, 3];
                        worldObject.controller.right = true;
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3: return [3 /*break*/, 6];
                    case 4:
                        if (!(worldObject.x > x && !timer.done)) return [3 /*break*/, 6];
                        worldObject.controller.left = true;
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 6:
                        worldObject.x = x;
                        return [2 /*return*/];
                }
            });
        };
    }
    S.moveToX = moveToX;
    function moveToY(worldObject, y, maxTime) {
        if (maxTime === void 0) { maxTime = 10; }
        return function () {
            var dy, timer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dy = y - worldObject.y;
                        if (dy === 0)
                            return [2 /*return*/];
                        timer = new Timer(maxTime);
                        if (!(dy > 0)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        if (!(worldObject.y < y && !timer.done)) return [3 /*break*/, 3];
                        worldObject.controller.down = true;
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3: return [3 /*break*/, 6];
                    case 4:
                        if (!(worldObject.y > y && !timer.done)) return [3 /*break*/, 6];
                        worldObject.controller.up = true;
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 6:
                        worldObject.y = y;
                        return [2 /*return*/];
                }
            });
        };
    }
    S.moveToY = moveToY;
    function playAnimation(sprite, animationName, force, waitForCompletion) {
        if (force === void 0) { force = true; }
        if (waitForCompletion === void 0) { waitForCompletion = true; }
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sprite.playAnimation(animationName, force);
                        if (!waitForCompletion) return [3 /*break*/, 3];
                        _a.label = 1;
                    case 1:
                        if (!(sprite.getCurrentAnimationName() === animationName)) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
    }
    S.playAnimation = playAnimation;
    function shake(intensity, time) {
        return function () {
            var timer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        global.world.camera.shakeIntensity += intensity;
                        timer = new Timer(time);
                        _a.label = 1;
                    case 1:
                        if (!!timer.done) return [3 /*break*/, 3];
                        timer.update(global.script.delta);
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        global.world.camera.shakeIntensity -= intensity;
                        return [2 /*return*/];
                }
            });
        };
    }
    S.shake = shake;
    function showSlide(factory, waitForCompletion) {
        if (waitForCompletion === void 0) { waitForCompletion = true; }
        var slide;
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        slide = global.theater.addSlide(factory());
                        if (!waitForCompletion) return [3 /*break*/, 3];
                        _a.label = 1;
                    case 1:
                        if (!!slide.fullyLoaded) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
    }
    S.showSlide = showSlide;
})(S || (S = {}));
var Debug = /** @class */ (function () {
    function Debug() {
    }
    Debug.init = function (config) {
        Debug.DEBUG = config.debug;
        Debug.DEBUG_TOGGLE_ENABLED = Debug.DEBUG;
        Debug.FONT = config.font;
        Debug.FONT_STYLE = config.fontStyle;
        Debug.SHOW_ALL_PHYSICS_BOUNDS = config.showAllPhysicsBounds;
        Debug.SHOW_TOUCHES = config.showTouches;
        Debug.MOVE_CAMERA_WITH_ARROWS = config.moveCameraWithArrows;
        Debug.SHOW_OVERLAY = Debug.DEBUG && config.showOverlay;
        Debug.OVERLAY_FEEDS = config.overlayFeeds;
        Debug.SKIP_RATE = config.skipRate;
        Debug.PROGRAMMATIC_INPUT = config.programmaticInput;
        Debug.AUTOPLAY = config.autoplay;
        Debug.SKIP_MAIN_MENU_STAGE = config.skipMainMenuStage;
        Debug.FRAME_STEP_ENABLED = config.frameStepEnabled;
        Debug.RESET_OPTIONS_AT_START = config.resetOptionsAtStart;
        Debug.EXPERIMENTS = config.experiments;
    };
    Debug.update = function () {
        for (var experiment in Debug.EXPERIMENTS) {
            Debug.EXPERIMENTS[experiment].update(experiment);
        }
        if (Input.justDown(Input.DEBUG_FRAME_SKIP_STEP) || Input.justDown(Input.DEBUG_FRAME_SKIP_RUN)) {
            Debug.FRAME_STEP_ENABLED = true;
        }
        if (Input.justDown(Input.DEBUG_FRAME_SKIP_DISABLE)) {
            Debug.FRAME_STEP_ENABLED = false;
        }
        Debug._SKIP_RATE_KEY_MODIFIER = Input.isDown(Input.DEBUG_SKIP_RATE) ? 10 : 1;
    };
    Object.defineProperty(Debug, "DEBUG", {
        get: function () { return this._DEBUG; },
        set: function (value) { this._DEBUG = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "SHOW_ALL_PHYSICS_BOUNDS", {
        get: function () { return this.DEBUG && this._SHOW_ALL_PHYSICS_BOUNDS; },
        set: function (value) { this._SHOW_ALL_PHYSICS_BOUNDS = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "SHOW_TOUCHES", {
        get: function () { return this.DEBUG && this._SHOW_TOUCHES; },
        set: function (value) { this._SHOW_TOUCHES = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "MOVE_CAMERA_WITH_ARROWS", {
        get: function () { return this.DEBUG && this._MOVE_CAMERA_WITH_ARROWS; },
        set: function (value) { this._MOVE_CAMERA_WITH_ARROWS = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "SKIP_RATE", {
        get: function () { return this.DEBUG ? this._SKIP_RATE * this._SKIP_RATE_KEY_MODIFIER : 1; },
        set: function (value) { this._SKIP_RATE = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "PROGRAMMATIC_INPUT", {
        get: function () { return this.DEBUG && this._PROGRAMMATIC_INPUT; },
        set: function (value) { this._PROGRAMMATIC_INPUT = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "AUTOPLAY", {
        get: function () { return this.DEBUG && this._AUTOPLAY; },
        set: function (value) { this._AUTOPLAY = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "SKIP_MAIN_MENU_STAGE", {
        get: function () { return this.DEBUG ? this._SKIP_MAIN_MENU_STAGE : undefined; },
        set: function (value) { this._SKIP_MAIN_MENU_STAGE = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Debug, "FRAME_STEP_ENABLED", {
        get: function () { return this.DEBUG && this._FRAME_STEP_ENABLED; },
        set: function (value) { this._FRAME_STEP_ENABLED = value; },
        enumerable: false,
        configurable: true
    });
    Debug.frameStepSkipFrame = function () {
        return this.FRAME_STEP_ENABLED && !(Input.justDown(Input.DEBUG_FRAME_SKIP_STEP) || Input.isDown(Input.DEBUG_FRAME_SKIP_RUN));
    };
    Object.defineProperty(Debug, "RESET_OPTIONS_AT_START", {
        get: function () { return this.DEBUG && this._RESET_OPTIONS_AT_START; },
        set: function (value) { this._RESET_OPTIONS_AT_START = value; },
        enumerable: false,
        configurable: true
    });
    Debug._SKIP_RATE_KEY_MODIFIER = 1;
    return Debug;
}());
function get(nameOrType) {
    var worldObject = _.isString(nameOrType)
        ? global.world.select.nameAll(nameOrType)
        : global.world.select.typeAll(nameOrType);
    if (_.isEmpty(worldObject))
        return undefined;
    if (worldObject.length === 1)
        return worldObject[0];
    return worldObject;
}
var Timer = /** @class */ (function () {
    function Timer(duration, callback, count) {
        if (count === void 0) { count = 1; }
        this.duration = duration;
        this.speed = 1;
        this.time = 0;
        this.paused = false;
        this.callback = callback;
        this.count = count;
        this.currentIter = 0;
    }
    Object.defineProperty(Timer.prototype, "running", {
        get: function () { return !this.done && !this.paused; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "done", {
        get: function () { return this.currentIter >= this.count; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "progress", {
        get: function () {
            if (this.duration === 0)
                return 1;
            return Math.min(this.time / this.duration, 1);
        },
        enumerable: false,
        configurable: true
    });
    Timer.prototype.update = function (delta) {
        if (this.running) {
            this.time += delta * this.speed;
            if (this.time >= this.duration) {
                if (this.callback)
                    this.callback();
                this.currentIter++;
                if (this.currentIter < this.count) {
                    this.time -= this.duration;
                    while (this.time >= this.duration && this.currentIter < this.count) {
                        this.time -= this.duration;
                        if (this.callback)
                            this.callback();
                        this.currentIter++;
                    }
                }
                else {
                    this.time = this.duration;
                }
            }
        }
    };
    Timer.prototype.finish = function () {
        this.time = this.duration;
    };
    Timer.prototype.reset = function () {
        this.time = 0;
        this.currentIter = 0;
    };
    return Timer;
}());
var RandomNumberGenerator = /** @class */ (function () {
    function RandomNumberGenerator(seed) {
        this.seed(seed);
    }
    Object.defineProperty(RandomNumberGenerator.prototype, "value", {
        /**
         * Random float between 0 and 1.
         */
        get: function () {
            return this.generate();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Random angle from 0 to 360.
     */
    RandomNumberGenerator.prototype.angle = function () {
        return this.float(0, 360);
    };
    /**
     * Random boolean, true or false.
     * @param trueChance Default: 0.5
     */
    RandomNumberGenerator.prototype.boolean = function (trueChance) {
        if (trueChance === void 0) { trueChance = 0.5; }
        return this.value < trueChance;
    };
    /**
     * Random color from 0x000000 to 0xFFFFFF.
     */
    RandomNumberGenerator.prototype.color = function () {
        return this.int(0x000000, 0xFFFFFF);
    };
    /**
     * Random float between {min} and {max}.
     * @param min Default: 0
     * @param max Default: 1
     */
    RandomNumberGenerator.prototype.float = function (min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        return min + (max - min) * this.value;
    };
    /**
     * Random element from array, uniformly.
     */
    RandomNumberGenerator.prototype.element = function (array) {
        if (_.isEmpty(array))
            return undefined;
        return array[this.index(array)];
    };
    /**
     * Random element from array, weighted by a given weights array.
     */
    RandomNumberGenerator.prototype.elementWeighted = function (array, weights) {
        if (_.isEmpty(array))
            return undefined;
        if (_.isEmpty(weights)) {
            console.error("Weights are empty, using uniform weighting:", array, weights);
            return this.element(array);
        }
        if (weights.length !== array.length) {
            console.error("Weights length does not match array length:", array, weights);
        }
        var weightSum = A.sum(weights);
        var value = this.float(0, weightSum);
        for (var i = 0; i < array.length; i++) {
            if (value < weights[i])
                return array[i];
            value -= weights[i];
        }
        return _.last(array);
    };
    /**
     * Random Vector2 uniformly in a unit circle.
     * @param radius Default: 1
     */
    RandomNumberGenerator.prototype.inCircle = function (radius) {
        if (radius === void 0) { radius = 1; }
        var angle = this.float(0, 360);
        var r = radius * Math.sqrt(this.value);
        return new Vector2(r * M.cos(angle), r * M.sin(angle));
    };
    /**
     * Random Vector2 uniformly in a disc.
     */
    RandomNumberGenerator.prototype.inDisc = function (radiusSmall, radiusLarge) {
        var angle = this.float(0, 360);
        var r = radiusLarge * Math.sqrt(this.float(radiusSmall / radiusLarge, 1));
        return new Vector2(r * M.cos(angle), r * M.sin(angle));
    };
    /**
     * Random int from {0} to {array.length - 1}.
     */
    RandomNumberGenerator.prototype.index = function (array) {
        return this.int(0, array.length - 1);
    };
    /**
     * Random int between {min} and {max}, inclusive.
     */
    RandomNumberGenerator.prototype.int = function (min, max) {
        return Math.floor(this.float(min, max + 1));
    };
    /**
     * Random Vector2 on a unit circle.
     * @param radius Default: 1
     */
    RandomNumberGenerator.prototype.onCircle = function (radius) {
        if (radius === void 0) { radius = 1; }
        var angle = this.float(0, 360);
        return new Vector2(radius * M.cos(angle), radius * M.sin(angle));
    };
    /**
     * Random sample of {count} elements from an array.
     */
    RandomNumberGenerator.prototype.sample = function (array, count) {
        if (count > _.size(array)) {
            console.error('Trying to sample an array for more elements than it contains', array, count);
            count = _.size(array);
        }
        if (_.isEmpty(array))
            return [];
        var copiedArray = A.clone(array);
        var result = [];
        for (var i = 0; i < count; i++) {
            var j = this.int(0, copiedArray.length - 1);
            result.push(copiedArray.splice(j, 1)[0]);
        }
        return result;
    };
    /**
     * Shuffles an array in place using the Fischer-Yates shuffle.
     * See https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    RandomNumberGenerator.prototype.shuffle = function (array) {
        if (_.isEmpty(array))
            return array;
        for (var i = 0; i < array.length - 1; i++) {
            var j = this.int(i, array.length - 1);
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    };
    /**
     * Returns a new array using the elements of the input array shuffled using the Fischer-Yates shuffle.
     * See https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    RandomNumberGenerator.prototype.shuffled = function (array) {
        var result = A.clone(array);
        this.shuffle(result);
        return result;
    };
    /**
     * Random sign, -1 or +1.
     */
    RandomNumberGenerator.prototype.sign = function () {
        return this.value < 0.5 ? -1 : 1;
    };
    /**
     * Sets the seed of the random number generator.
     * @param seed
     */
    RandomNumberGenerator.prototype.seed = function (seed) {
        // seeded random generator from seedrandom.min.js
        // @ts-ignore
        this.generate = new Math.seedrandom(seed);
    };
    return RandomNumberGenerator;
}());
var Random = new RandomNumberGenerator();
/// <reference path="random.ts" />
var UIDGenerator = /** @class */ (function () {
    function UIDGenerator() {
        this.rng = new RandomNumberGenerator();
        this.pastUIDs = new Set();
    }
    UIDGenerator.prototype.generate = function () {
        var uid;
        do {
            uid = this.generateUid();
        } while (this.pastUIDs.has(uid));
        this.pastUIDs.add(uid);
        return uid;
    };
    UIDGenerator.prototype.generateUid = function () {
        var result = '';
        for (var i = 0; i < UIDGenerator.UID_LENGTH; i++) {
            result += this.rng.element(UIDGenerator.VALID_CHARS);
        }
        return result;
    };
    UIDGenerator.UID_LENGTH = 8;
    UIDGenerator.VALID_CHARS = [
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
        'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
        'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9'
    ];
    return UIDGenerator;
}());
/// <reference path="../utils/timer.ts" />
/// <reference path="../utils/uid.ts" />
var WorldObject = /** @class */ (function () {
    function WorldObject(config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.localx = (_a = config.x) !== null && _a !== void 0 ? _a : (config.p ? config.p.x : 0);
        this.localy = (_b = config.y) !== null && _b !== void 0 ? _b : (config.p ? config.p.y : 0);
        this.localz = (_c = config.z) !== null && _c !== void 0 ? _c : 0;
        this.activeOutsideWorldBoundsBuffer = (_d = config.activeOutsideWorldBoundsBuffer) !== null && _d !== void 0 ? _d : Infinity;
        this.life = new WorldObject.LifeTimer((_e = config.life) !== null && _e !== void 0 ? _e : Infinity, function () { return _this.kill(); });
        this.zBehavior = (_f = config.zBehavior) !== null && _f !== void 0 ? _f : WorldObject.DEFAULT_Z_BEHAVIOR;
        this.timeScale = (_g = config.timeScale) !== null && _g !== void 0 ? _g : 1;
        this.useGlobalTime = (_h = config.useGlobalTime) !== null && _h !== void 0 ? _h : false;
        this.updateOnNonUpdate = (_j = config.updateOnNonUpdate) !== null && _j !== void 0 ? _j : false;
        this.data = config.data ? O.deepClone(config.data) : {};
        this.setVisible((_k = config.visible) !== null && _k !== void 0 ? _k : true);
        this.setActive((_l = config.active) !== null && _l !== void 0 ? _l : true);
        this.ignoreCamera = (_m = config.ignoreCamera) !== null && _m !== void 0 ? _m : false;
        this.copyFromParent = config.copyFromParent ? A.clone(config.copyFromParent) : [];
        this.alive = true;
        this.name = config.name;
        this.tags = config.tags ? A.clone(config.tags) : [];
        this.lastx = this.x;
        this.lasty = this.y;
        this.lastz = this.z;
        this._isInsideWorldBoundsBufferThisFrame = false;
        this.controller = new Controller();
        this.behavior = new NullBehavior();
        this.modules = [];
        this.timers = config.timers ? A.clone(config.timers) : [];
        this.uid = WorldObject.UID.generate();
        this._world = null;
        this._children = [];
        this._parent = null;
        this.internalSetLayerWorldObject(config.layer);
        this.internalSetPhysicsGroupWorldObject(config.physicsGroup);
        this.scriptManager = new ScriptManager();
        this.stateMachine = new StateMachine();
        this.onAddCallback = config.onAdd;
        this.onRemoveCallback = config.onRemove;
        this.updateCallback = config.update;
        this.postUpdateCallback = config.postUpdate;
        this.renderCallback = config.render;
        this.debugFollowMouse = false;
    }
    Object.defineProperty(WorldObject.prototype, "x", {
        get: function () { return this.localx + (this.parent ? this.parent.x : 0); },
        set: function (value) { this.localx = value - (this.parent ? this.parent.x : 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "y", {
        get: function () { return this.localy + (this.parent ? this.parent.y : 0); },
        set: function (value) { this.localy = value - (this.parent ? this.parent.y : 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "z", {
        get: function () { return this.localz + (this.parent ? this.parent.z : 0); },
        set: function (value) { this.localz = value - (this.parent ? this.parent.z : 0); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "world", {
        get: function () { return this._world; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "layer", {
        get: function () {
            this.resolveLayer();
            return this._layer;
        },
        set: function (value) { World.Actions.setLayer(this, value); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "physicsGroup", {
        get: function () {
            this.resolvePhysicsGroup();
            return this._physicsGroup;
        },
        set: function (value) { World.Actions.setPhysicsGroup(this, value); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "children", {
        get: function () { return this._children; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "delta", {
        //
        get: function () { return ((this.useGlobalTime || !this.world) ? global.game.delta : this.world.delta) * this.timeScale; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WorldObject.prototype, "state", {
        get: function () { return this.stateMachine.getCurrentStateName(); },
        enumerable: false,
        configurable: true
    });
    WorldObject.prototype.onAdd = function () {
        if (this.onAddCallback)
            this.onAddCallback();
    };
    WorldObject.prototype.onRemove = function () {
        if (this.onRemoveCallback)
            this.onRemoveCallback();
    };
    WorldObject.prototype.preUpdate = function () {
        this.lastx = this.x;
        this.lasty = this.y;
        this.lastz = this.z;
        this.behavior.update(this.delta);
        this.updateController();
    };
    WorldObject.prototype.update = function () {
        var e_4, _a, e_5, _b;
        this.scriptManager.update(this.delta);
        this.stateMachine.update(this.delta);
        if (this.debugFollowMouse) {
            this.x = this.world.getWorldMouseX();
            this.y = this.world.getWorldMouseY();
        }
        if (this.updateCallback)
            this.updateCallback();
        try {
            for (var _c = __values(this.modules), _d = _c.next(); !_d.done; _d = _c.next()) {
                var module = _d.value;
                module.update();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_4) throw e_4.error; }
        }
        try {
            for (var _e = __values(this.timers), _f = _e.next(); !_f.done; _f = _e.next()) {
                var timer = _f.value;
                timer.update(this.delta);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.life.update(this.delta);
        if (this.parent && this.ignoreCamera) {
            debug("Warning: ignoreCamera is set to true on a child object. This will be ignored!");
        }
    };
    WorldObject.prototype.postUpdate = function () {
        this.controller.reset();
        if (this.postUpdateCallback)
            this.postUpdateCallback();
        this.resolveCopyFromParent();
    };
    WorldObject.prototype.fullUpdate = function () {
        this.preUpdate();
        this.update();
        this.postUpdate();
    };
    WorldObject.prototype.getRenderScreenX = function () {
        var result;
        if (this.parent) {
            result = this.parent.getRenderScreenX();
        }
        else {
            result = this.shouldIgnoreCamera() ? 0 : -Math.round(this.world.camera.worldOffsetX);
        }
        result += Math.round(this.localx);
        return result;
    };
    WorldObject.prototype.getRenderScreenY = function () {
        var result;
        if (this.parent) {
            result = this.parent.getRenderScreenY();
        }
        else {
            result = this.shouldIgnoreCamera() ? 0 : -Math.round(this.world.camera.worldOffsetY);
        }
        result += Math.round(this.localy);
        if (this.zBehavior === 'threequarters') {
            var parentz = this.parent ? this.parent.z : 0;
            result += parentz - this.z;
        }
        return result;
    };
    WorldObject.prototype.render = function (texture, x, y) {
        var e_6, _a;
        if (this.renderCallback)
            this.renderCallback(texture, x, y);
        try {
            for (var _b = __values(this.modules), _c = _b.next(); !_c.done; _c = _b.next()) {
                var module = _c.value;
                module.render(texture, x, y);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    WorldObject.prototype.addChild = function (child) {
        return World.Actions.addChildToParent(child, this);
    };
    WorldObject.prototype.addChildKeepWorldPosition = function (child) {
        var x = child.x;
        var y = child.y;
        var z = child.z;
        var result = this.addChild(child);
        child.x = x;
        child.y = y;
        child.z = z;
        return result;
    };
    WorldObject.prototype.addChildren = function (children) {
        return World.Actions.addChildrenToParent(children, this);
    };
    WorldObject.prototype.addModule = function (module) {
        this.modules.push(module);
        module.init(this);
        return module;
    };
    WorldObject.prototype.addTag = function (tag) {
        if (!_.contains(this.tags, tag)) {
            this.tags.push(tag);
        }
    };
    WorldObject.prototype.addTimer = function (durationOrTimer, callback, count) {
        if (count === void 0) { count = 1; }
        if (_.isNumber(durationOrTimer)) {
            durationOrTimer = new Timer(durationOrTimer, callback, count);
        }
        this.timers.push(durationOrTimer);
        return durationOrTimer;
    };
    WorldObject.prototype.doAfterTime = function (time, callback) {
        this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.wait(time)];
                    case 1:
                        _a.sent();
                        callback();
                        return [2 /*return*/];
                }
            });
        });
    };
    WorldObject.prototype.everyNFrames = function (n) {
        return Math.floor((this.life.frames + 1) / n) !== Math.floor(this.life.frames / n);
    };
    WorldObject.prototype.everyNSeconds = function (n) {
        return Math.floor((this.life.time + this.delta) / n) !== Math.floor(this.life.time / n);
    };
    WorldObject.prototype.getChildByIndex = function (index) {
        if (this.children.length < index) {
            console.error("Parent has no child at index " + index + ":", this);
            return undefined;
        }
        return this.children[index];
    };
    WorldObject.prototype.getChildByName = function (name) {
        var e_7, _a;
        try {
            for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (child.name === name)
                    return child;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        console.error("Cannot find child named " + name + " on parent:", this);
        return undefined;
    };
    WorldObject.prototype.getModule = function (type) {
        var e_8, _a;
        try {
            for (var _b = __values(this.modules), _c = _b.next(); !_c.done; _c = _b.next()) {
                var module = _c.value;
                if (module instanceof type)
                    return module;
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return undefined;
    };
    WorldObject.prototype.getPosition = function () {
        return vec2(this.x, this.y);
    };
    WorldObject.prototype.getTimers = function () {
        return A.clone(this.timers);
    };
    WorldObject.prototype.getVisibleScreenBounds = function () {
        return undefined;
    };
    WorldObject.prototype.hasTag = function (tag) {
        return _.contains(this.tags, tag);
    };
    WorldObject.prototype.isActive = function () {
        return this._active && (!this.parent || this.parent.isActive());
    };
    WorldObject.prototype.isControlRevoked = function () {
        var _a;
        return (_a = global.theater) === null || _a === void 0 ? void 0 : _a.isCutscenePlaying;
    };
    WorldObject.prototype.isOnScreen = function (buffer) {
        if (buffer === void 0) { buffer = 0; }
        var bounds = this.getVisibleScreenBounds();
        if (!bounds)
            return true;
        return bounds.x + bounds.width >= -buffer
            && bounds.x <= this.world.width + buffer
            && bounds.y + bounds.height >= -buffer
            && bounds.y <= this.world.height + buffer;
    };
    WorldObject.prototype.isVisible = function () {
        return this._visible && (!this.parent || this.parent.isVisible());
    };
    WorldObject.prototype.kill = function () {
        this.alive = false;
    };
    WorldObject.prototype.oscillateNFrames = function (n) {
        return Math.floor(this.life.frames / n) % 2 === 1;
    };
    WorldObject.prototype.oscillateNSeconds = function (n) {
        return Math.floor(this.life.time / n) % 2 === 1;
    };
    WorldObject.prototype.removeAllChildren = function () {
        return this.removeChildren(this.children);
    };
    WorldObject.prototype.removeChild = function (child) {
        if (!child)
            return undefined;
        if (_.isString(child)) {
            child = this.getChildByName(child);
            if (!child)
                return undefined;
        }
        if (child.parent !== this) {
            console.error("Cannot remove child " + child.name + " from parent " + this.name + ", but no such relationship exists");
            return undefined;
        }
        return World.Actions.removeChildFromParent(child);
    };
    WorldObject.prototype.removeChildKeepWorldPosition = function (child) {
        var x = child.x;
        var y = child.y;
        var z = child.z;
        var result = this.removeChild(child);
        child.x = x;
        child.y = y;
        child.z = z;
        return result;
    };
    WorldObject.prototype.removeChildren = function (children) {
        var _this = this;
        if (_.isEmpty(children))
            return [];
        return children.map(function (child) { return _this.removeChild(child); }).filter(function (child) { return child; });
    };
    WorldObject.prototype.removeFromParent = function () {
        if (!this.parent)
            return this;
        return this.parent.removeChild(this);
    };
    WorldObject.prototype.removeFromParentKeepWorldPosition = function () {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var result = this.removeFromParent();
        this.x = x;
        this.y = y;
        this.z = z;
        return result;
    };
    WorldObject.prototype.removeFromWorld = function () {
        if (!this.world)
            return this;
        return World.Actions.removeWorldObjectFromWorld(this);
    };
    WorldObject.prototype.removeTag = function (tag) {
        A.removeAll(this.tags, tag);
    };
    WorldObject.prototype.runScript = function (script) {
        return this.scriptManager.runScript(script);
    };
    WorldObject.prototype.setActive = function (active) {
        this._active = active;
    };
    WorldObject.prototype.setIsInsideWorldBoundsBufferThisFrame = function () {
        this._isInsideWorldBoundsBufferThisFrame = isFinite(this.activeOutsideWorldBoundsBuffer)
            ? this.isOnScreen(this.activeOutsideWorldBoundsBuffer)
            : true;
    };
    WorldObject.prototype.setState = function (state) {
        this.stateMachine.setState(state);
    };
    WorldObject.prototype.setVisible = function (visible) {
        this._visible = visible;
    };
    WorldObject.prototype.shouldIgnoreCamera = function () {
        if (this.ignoreCamera)
            return true;
        if (this.parent)
            return this.parent.shouldIgnoreCamera();
        return false;
    };
    WorldObject.prototype.resolveLayer = function () {
        if (_.contains(this.copyFromParent, 'layer') && this.parent && this._layer !== this.parent.layer) {
            this.layer = this.parent.layer;
        }
    };
    WorldObject.prototype.resolvePhysicsGroup = function () {
        if (_.contains(this.copyFromParent, 'physicsGroup') && this.parent && this._physicsGroup !== this.parent.physicsGroup) {
            this.physicsGroup = this.parent.physicsGroup;
        }
    };
    WorldObject.prototype.resolveCopyFromParent = function () {
        var e_9, _a;
        if (!this.parent)
            return;
        try {
            for (var _b = __values(this.copyFromParent), _c = _b.next(); !_c.done; _c = _b.next()) {
                var path = _c.value;
                if (path === 'layer') {
                    this.resolveLayer();
                    continue;
                }
                if (path === 'physicsGroup') {
                    this.resolvePhysicsGroup();
                    continue;
                }
                if (!O.hasPath(this, path) || !O.hasPath(this.parent, path)) {
                    console.error('Cannot copy from parent because path does not exist on both objects:', path, this, this.parent);
                    continue;
                }
                var thisValue = O.getPath(this, path);
                var parentValue = O.getPath(this.parent, path);
                if (thisValue === parentValue)
                    continue;
                O.setPath(this, path, parentValue);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
    };
    WorldObject.prototype.updateController = function () {
        if (this.isControlRevoked())
            return;
        this.controller.updateFromBehavior(this.behavior);
    };
    // For use with World.Actions.addWorldObjectToWorld
    WorldObject.prototype.internalAddWorldObjectToWorldWorldObject = function (world) {
        this._world = world;
        if (!this._layer)
            this._layer = World.DEFAULT_LAYER;
    };
    // For use with World.Actions.removeWorldObjectFromWorld
    WorldObject.prototype.internalRemoveWorldObjectFromWorldWorldObject = function (world) {
        this._world = null;
    };
    // For use with World.Actions.setLayer
    WorldObject.prototype.internalSetLayerWorldObject = function (layer) {
        this._layer = layer;
    };
    // For use with World.Actions.setPhysicsGroup
    WorldObject.prototype.internalSetPhysicsGroupWorldObject = function (physicsGroup) {
        this._physicsGroup = physicsGroup;
    };
    // For use with World.Actions.addChildToParent
    WorldObject.prototype.internalAddChildToParentWorldObjectChild = function (parent) {
        this._parent = parent;
    };
    // For use with World.Actions.addChildToParent
    WorldObject.prototype.internalAddChildToParentWorldObjectParent = function (child) {
        this._children.push(child);
    };
    // For use with World.Actions.removeChildFromParent
    WorldObject.prototype.internalRemoveChildFromParentWorldObjectChild = function () {
        this._parent = null;
    };
    // For use with World.Actions.removeChildFromParent
    WorldObject.prototype.internalRemoveChildFromParentWorldObjectParent = function (child) {
        A.removeAll(this._children, child);
    };
    WorldObject.DEFAULT_Z_BEHAVIOR = 'noop';
    return WorldObject;
}());
(function (WorldObject) {
    WorldObject.UID = new UIDGenerator();
    var LifeTimer = /** @class */ (function (_super) {
        __extends(LifeTimer, _super);
        function LifeTimer(life, onFinish) {
            var _this = _super.call(this, life, onFinish) || this;
            _this.frames = 0;
            return _this;
        }
        LifeTimer.prototype.update = function (delta) {
            _super.prototype.update.call(this, delta);
            this.frames++;
        };
        return LifeTimer;
    }(Timer));
    WorldObject.LifeTimer = LifeTimer;
})(WorldObject || (WorldObject = {}));
/// <reference path="./worldObject.ts" />
var PhysicsWorldObject = /** @class */ (function (_super) {
    __extends(PhysicsWorldObject, _super);
    function PhysicsWorldObject(config) {
        if (config === void 0) { config = {}; }
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var _this = _super.call(this, config) || this;
        _this._v = config.v ? vec2(config.v.x, config.v.y) : vec2((_a = config.vx) !== null && _a !== void 0 ? _a : 0, (_b = config.vy) !== null && _b !== void 0 ? _b : 0);
        _this.vz = (_c = config.vz) !== null && _c !== void 0 ? _c : 0;
        _this.mass = (_d = config.mass) !== null && _d !== void 0 ? _d : 1;
        _this._gravity = vec2((_e = config.gravityx) !== null && _e !== void 0 ? _e : 0, (_f = config.gravityy) !== null && _f !== void 0 ? _f : 0);
        _this.gravityz = (_g = config.gravityz) !== null && _g !== void 0 ? _g : 0;
        _this.affectedByGravity = (_h = config.affectedByGravity) !== null && _h !== void 0 ? _h : true;
        _this.bounce = (_j = config.bounce) !== null && _j !== void 0 ? _j : 1;
        _this.bounds = (_k = config.bounds) !== null && _k !== void 0 ? _k : new NullBounds();
        _this._immovable = (_l = config.immovable) !== null && _l !== void 0 ? _l : false;
        _this.colliding = (_m = config.colliding) !== null && _m !== void 0 ? _m : true;
        _this.simulating = (_o = config.simulating) !== null && _o !== void 0 ? _o : true;
        _this.physicslastx = _this.x;
        _this.physicslasty = _this.y;
        _this.debugDrawBounds = false;
        return _this;
    }
    Object.defineProperty(PhysicsWorldObject.prototype, "v", {
        get: function () { return this._v; },
        set: function (value) {
            this._v.x = value.x;
            this._v.y = value.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PhysicsWorldObject.prototype, "gravity", {
        get: function () { return this._gravity; },
        set: function (value) {
            this._gravity.x = value.x;
            this._gravity.y = value.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PhysicsWorldObject.prototype, "bounds", {
        get: function () { return this._bounds; },
        set: function (value) {
            this._bounds = value;
            this._bounds.parent = this;
        },
        enumerable: false,
        configurable: true
    });
    PhysicsWorldObject.prototype.preUpdate = function () {
        _super.prototype.preUpdate.call(this);
        this.physicslastx = this.x;
        this.physicslasty = this.y;
    };
    PhysicsWorldObject.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.simulating) {
            this.simulate();
        }
    };
    PhysicsWorldObject.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        if (!isFinite(this.v.x) || !isFinite(this.v.y)) {
            console.error("Non-finite velocity " + this.v + " on object", this);
            if (!isFinite(this.v.x))
                this.v.x = 0;
            if (!isFinite(this.v.y))
                this.v.y = 0;
        }
    };
    PhysicsWorldObject.prototype.render = function (texture, x, y) {
        if (Debug.SHOW_ALL_PHYSICS_BOUNDS || this.debugDrawBounds) {
            var zoffset = 0; // offset to cancel out the z-factor when drawing bounds
            if (this.zBehavior === 'threequarters') {
                var parentz = this.parent ? this.parent.z : 0;
                zoffset = parentz - this.z;
            }
            this.drawBounds(texture, x, y - zoffset);
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    PhysicsWorldObject.prototype.getSpeed = function () {
        return this.v.magnitude;
    };
    PhysicsWorldObject.prototype.getWorldBounds = function () {
        return this.bounds.getBoundingBox();
    };
    PhysicsWorldObject.prototype.isCollidingWith = function (other) {
        return this.isOverlapping(other.bounds);
    };
    PhysicsWorldObject.prototype.isGrounded = function (groundGroups) {
        this.bounds.y++;
        var ground = this.world.select.overlap(this.bounds, groundGroups);
        this.bounds.y--;
        return !_.isEmpty(ground);
    };
    PhysicsWorldObject.prototype.isImmovable = function () {
        return this._immovable || (this.world && this.world.getPhysicsGroupByName(this.physicsGroup).immovable);
    };
    PhysicsWorldObject.prototype.isOverlapping = function (bounds) {
        return this.bounds.isOverlapping(bounds);
    };
    PhysicsWorldObject.prototype.onCollide = function (collision) {
    };
    PhysicsWorldObject.prototype.setImmovable = function (immovable) {
        this._immovable = immovable;
    };
    PhysicsWorldObject.prototype.setSpeed = function (speed) {
        this.v.setMagnitude(speed);
    };
    PhysicsWorldObject.prototype.teleport = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        this.x = x;
        this.y = y;
        this.physicslastx = x;
        this.physicslasty = y;
    };
    PhysicsWorldObject.prototype.applyGravity = function () {
        this.v.x += this.gravity.x * this.delta;
        this.v.y += this.gravity.y * this.delta;
        this.vz += this.gravityz * this.delta;
    };
    PhysicsWorldObject.prototype.move = function () {
        this.localx += this.v.x * this.delta;
        this.localy += this.v.y * this.delta;
        this.localz += this.vz * this.delta;
    };
    PhysicsWorldObject.prototype.simulate = function () {
        if (this.affectedByGravity)
            this.applyGravity();
        this.move();
    };
    PhysicsWorldObject.prototype.drawBounds = function (texture, x, y) {
        Draw.brush.color = 0x00FF00;
        Draw.brush.alpha = 1;
        if (this.bounds instanceof RectBounds) {
            var box = this.bounds.getBoundingBox();
            box.x += x - this.x;
            box.y += y - this.y;
            Draw.rectangleOutline(texture, box.x, box.y, box.width, box.height);
        }
        else if (this.bounds instanceof InvertedRectBounds) {
            var box = this.bounds.getInnerBox();
            box.x += x - this.x;
            box.y += y - this.y;
            Draw.rectangleOutline(texture, box.x, box.y, box.width, box.height);
        }
        else if (this.bounds instanceof CircleBounds) {
            var center = this.bounds.getCenter();
            center.x += x - this.x;
            center.y += y - this.y;
            Draw.circleOutline(texture, center.x, center.y, this.bounds.radius);
        }
        else if (this.bounds instanceof SlopeBounds) {
            var box = this.bounds.getBoundingBox();
            box.x += x - this.x;
            box.y += y - this.y;
            if (this.bounds.direction === 'upleft') {
                Draw.line(texture, box.left, box.bottom, box.right, box.bottom);
                Draw.line(texture, box.right, box.bottom, box.right, box.top);
                Draw.line(texture, box.right, box.top, box.left, box.bottom);
            }
            else if (this.bounds.direction === 'upright') {
                Draw.line(texture, box.left, box.bottom, box.right, box.bottom);
                Draw.line(texture, box.left, box.bottom, box.left, box.top);
                Draw.line(texture, box.left, box.top, box.right, box.bottom);
            }
            else if (this.bounds.direction === 'downright') {
                Draw.line(texture, box.left, box.bottom, box.left, box.top);
                Draw.line(texture, box.left, box.top, box.right, box.top);
                Draw.line(texture, box.right, box.top, box.left, box.bottom);
            }
            else {
                Draw.line(texture, box.left, box.top, box.right, box.top);
                Draw.line(texture, box.right, box.top, box.right, box.bottom);
                Draw.line(texture, box.right, box.bottom, box.left, box.top);
            }
        }
    };
    return PhysicsWorldObject;
}(WorldObject));
/// <reference path="../physicsWorldObject.ts" />
var Sprite = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    function Sprite(config) {
        var e_10, _a;
        if (config === void 0) { config = {}; }
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        var _this = _super.call(this, config) || this;
        _this.setTexture(config.texture);
        _this.animationManager = new AnimationManager(_this);
        try {
            for (var _q = __values(config.animations || []), _r = _q.next(); !_r.done; _r = _q.next()) {
                var animation = _r.value;
                _this.addAnimation(animation);
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_r && !_r.done && (_a = _q.return)) _a.call(_q);
            }
            finally { if (e_10) throw e_10.error; }
        }
        if (config.defaultAnimation) {
            _this.playAnimation(config.defaultAnimation);
        }
        else if (!_.isEmpty(config.animations)) {
            _this.playAnimation(config.animations[0].name);
        }
        _this.flipX = (_b = config.flipX) !== null && _b !== void 0 ? _b : false;
        _this.flipY = (_c = config.flipY) !== null && _c !== void 0 ? _c : false;
        _this.offsetX = (_d = config.offsetX) !== null && _d !== void 0 ? _d : 0;
        _this.offsetY = (_e = config.offsetY) !== null && _e !== void 0 ? _e : 0;
        _this.angle = (_f = config.angle) !== null && _f !== void 0 ? _f : 0;
        _this.angleOffset = (_g = config.angleOffset) !== null && _g !== void 0 ? _g : 0;
        _this.vangle = (_h = config.vangle) !== null && _h !== void 0 ? _h : 0;
        _this.scaleX = (_j = config.scaleX) !== null && _j !== void 0 ? _j : ((_k = config.scale) !== null && _k !== void 0 ? _k : 1);
        _this.scaleY = (_l = config.scaleY) !== null && _l !== void 0 ? _l : ((_m = config.scale) !== null && _m !== void 0 ? _m : 1);
        _this.tint = (_o = config.tint) !== null && _o !== void 0 ? _o : 0xFFFFFF;
        _this.alpha = (_p = config.alpha) !== null && _p !== void 0 ? _p : 1;
        _this.effects = new Effects();
        _this.effects.updateFromConfig(config.effects);
        _this.mask = config.mask;
        _this.blendMode = config.blendMode;
        _this.onScreenPadding = 1;
        return _this;
    }
    Object.defineProperty(Sprite.prototype, "scale", {
        get: function () {
            if (this.scaleX !== this.scaleY)
                console.error('Warning: scaleX and scaleY differ! Attempted to get scale!');
            return this.scaleX;
        },
        set: function (value) {
            this.scaleX = value;
            this.scaleY = value;
        },
        enumerable: false,
        configurable: true
    });
    Sprite.prototype.update = function () {
        _super.prototype.update.call(this);
        this.animationManager.update(this.delta);
        this.effects.updateEffects(this.delta);
        this.angle += this.vangle * this.delta;
    };
    Sprite.prototype.render = function (texture, x, y) {
        this.texture.renderTo(texture, {
            x: x + this.offsetX,
            y: y + this.offsetY,
            scaleX: (this.flipX ? -1 : 1) * this.scaleX,
            scaleY: (this.flipY ? -1 : 1) * this.scaleY,
            angle: this.angle + this.angleOffset,
            tint: this.tint,
            alpha: this.alpha,
            filters: this.effects.getFilterList(),
            mask: TextureFilters.Mask.getTextureMaskForWorldObject(this.mask, this, x, y),
            blendMode: this.blendMode,
        });
        _super.prototype.render.call(this, texture, x, y);
    };
    Sprite.prototype.addAnimation = function (animation) {
        this.animationManager.addAnimation(animation.name, animation.frames);
    };
    Sprite.prototype.getCurrentAnimationName = function () {
        return this.animationManager.getCurrentAnimationName();
    };
    Sprite.prototype.getTexture = function () {
        return this.texture;
    };
    Sprite.prototype.getTextureKey = function () {
        return this.textureKey;
    };
    Sprite.prototype.getTextureWorldBounds = function () {
        var bounds = this.getTextureLocalBounds();
        bounds.x += this.x + this.offsetX;
        bounds.y += this.y + this.offsetY;
        return bounds;
    };
    Sprite.prototype.getVisibleScreenBounds = function () {
        if (this.texture === Texture.EFFECT_ONLY) {
            return undefined;
        }
        var bounds = this.getTextureLocalBounds();
        bounds.x += this.getRenderScreenX() + this.offsetX - this.onScreenPadding;
        bounds.y += this.getRenderScreenY() + this.offsetY - this.onScreenPadding;
        bounds.width += 2 * this.onScreenPadding;
        bounds.height += 2 * this.onScreenPadding;
        return bounds;
    };
    Sprite.prototype.hasAnimation = function (name) {
        return this.animationManager.hasAnimation(name);
    };
    Sprite.prototype.playAnimation = function (name, force) {
        if (force === void 0) { force = false; }
        this.animationManager.playAnimation(name, force);
    };
    Sprite.prototype.setTexture = function (key) {
        if (!key) {
            this.texture = Texture.NONE;
            this.textureKey = undefined;
            return;
        }
        this.textureKey = _.isString(key) ? key : undefined;
        this.texture = _.isString(key) ? AssetCache.getTexture(key) : key;
    };
    Sprite.prototype.getTextureLocalBounds = function () {
        if (!this.texture)
            return rect(0, 0, 0, 0);
        return this.texture.getLocalBounds({
            angle: this.angle + this.angleOffset,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
        });
    };
    return Sprite;
}(PhysicsWorldObject));
/// <reference path="../worldObject/sprite/sprite.ts" />
/// <reference path="../worldObject/worldObject.ts" />
var World = /** @class */ (function () {
    function World(config) {
        if (config === void 0) { config = {}; }
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        this.scriptManager = new ScriptManager();
        this.soundManager = new SoundManager();
        this.select = new WorldSelecter(this);
        this.volume = (_a = config.volume) !== null && _a !== void 0 ? _a : 1;
        this.allowSounds = true;
        this.globalSoundHumanizePercent = (_b = config.globalSoundHumanizePercent) !== null && _b !== void 0 ? _b : 0;
        this.width = (_c = config.width) !== null && _c !== void 0 ? _c : global.gameWidth;
        this.height = (_d = config.height) !== null && _d !== void 0 ? _d : global.gameHeight;
        this.time = 0;
        this.timeScale = (_e = config.timescale) !== null && _e !== void 0 ? _e : 1;
        this.allowPause = (_f = config.allowPause) !== null && _f !== void 0 ? _f : true;
        this.data = config.data ? O.deepClone(config.data) : {};
        this.scaleX = (_g = config.scaleX) !== null && _g !== void 0 ? _g : 1;
        this.scaleY = (_h = config.scaleY) !== null && _h !== void 0 ? _h : 1;
        this.physicsGroups = this.createPhysicsGroups(config.physicsGroups);
        this.collisions = (_j = config.collisions) !== null && _j !== void 0 ? _j : [];
        this.collisionIterations = (_k = config.collisionIterations) !== null && _k !== void 0 ? _k : 1;
        this.useRaycastDisplacementThreshold = (_l = config.useRaycastDisplacementThreshold) !== null && _l !== void 0 ? _l : 1;
        this.maxDistancePerCollisionStep = (_m = config.maxDistancePerCollisionStep) !== null && _m !== void 0 ? _m : Infinity;
        this.minDistanceIgnoreCollisionStepCalculation = (_o = config.minDistanceIgnoreCollisionStepCalculation) !== null && _o !== void 0 ? _o : Infinity;
        this.worldObjects = [];
        this.layers = this.createLayers(config.layers);
        this.effects = new Effects(config.effects);
        this.mask = config.mask;
        this.backgroundColor = (_p = config.backgroundColor) !== null && _p !== void 0 ? _p : global.backgroundColor;
        this.backgroundAlpha = (_q = config.backgroundAlpha) !== null && _q !== void 0 ? _q : 1;
        this.worldTexture = new BasicTexture(this.width, this.height, 'World.worldTexture');
        this.layerTexture = new BasicTexture(this.width, this.height, 'World.layerTexture');
        this.camera = new Camera((_r = config.camera) !== null && _r !== void 0 ? _r : {}, this);
        this.mouseBounds = new CircleBounds(0, 0, 0);
    }
    Object.defineProperty(World.prototype, "delta", {
        get: function () {
            if (global.skippingCutscene)
                return Theater.SKIP_CUTSCENE_DELTA;
            return global.game.delta * this.timeScale;
        },
        enumerable: false,
        configurable: true
    });
    World.prototype.onTransitioned = function () {
    };
    World.prototype.update = function () {
        var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
        this.updateScriptManager();
        try {
            for (var _e = __values(this.worldObjects), _f = _e.next(); !_f.done; _f = _e.next()) {
                var worldObject = _f.value;
                worldObject.setIsInsideWorldBoundsBufferThisFrame();
                if (worldObject.isActive() && worldObject._isInsideWorldBoundsBufferThisFrame) {
                    worldObject.preUpdate();
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_11) throw e_11.error; }
        }
        try {
            for (var _g = __values(this.worldObjects), _h = _g.next(); !_h.done; _h = _g.next()) {
                var worldObject = _h.value;
                if (worldObject.isActive() && worldObject._isInsideWorldBoundsBufferThisFrame) {
                    worldObject.update();
                }
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_12) throw e_12.error; }
        }
        this.handleCollisions();
        try {
            for (var _j = __values(this.worldObjects), _k = _j.next(); !_k.done; _k = _j.next()) {
                var worldObject = _k.value;
                if (worldObject.isActive() && worldObject._isInsideWorldBoundsBufferThisFrame) {
                    worldObject.postUpdate();
                }
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            }
            finally { if (e_13) throw e_13.error; }
        }
        this.removeDeadWorldObjects();
        if (this.updateCallback)
            this.updateCallback();
        this.camera.update();
        try {
            for (var _l = __values(this.layers), _m = _l.next(); !_m.done; _m = _l.next()) {
                var layer = _m.value;
                layer.effects.updateEffects(this.delta);
            }
        }
        catch (e_14_1) { e_14 = { error: e_14_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
            }
            finally { if (e_14) throw e_14.error; }
        }
        this.effects.updateEffects(this.delta);
        this.soundManager.volume = this.volume * global.game.volume * Options.sfxVolume;
        this.soundManager.update(this.delta);
        this.time += this.delta;
    };
    World.prototype.updateScriptManager = function () {
        this.scriptManager.update(this.delta);
    };
    World.prototype.render = function (screen, x, y) {
        var e_15, _a;
        this.worldTexture.clear();
        // Render background color.
        Draw.brush.color = this.backgroundColor;
        Draw.brush.alpha = this.backgroundAlpha;
        Draw.rectangleSolid(this.worldTexture, 0, 0, this.width, this.height);
        try {
            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var layer = _c.value;
                if (layer.shouldRenderToOwnLayer) {
                    this.layerTexture.clear();
                    this.renderLayerToTexture(layer, this.layerTexture);
                    this.layerTexture.renderTo(this.worldTexture, {
                        filters: layer.effects.getFilterList(),
                        mask: TextureFilters.Mask.getTextureMaskForWorld(layer.mask),
                    });
                }
                else {
                    this.renderLayerToTexture(layer, this.worldTexture);
                }
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_15) throw e_15.error; }
        }
        // Apply world effects.
        this.worldTexture.renderTo(screen, {
            x: x, y: y,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            filters: this.effects.getFilterList(),
            mask: TextureFilters.Mask.getTextureMaskForWorld(this.mask),
        });
    };
    World.prototype.renderLayerToTexture = function (layer, texture) {
        var e_16, _a;
        layer.sort();
        try {
            for (var _b = __values(layer.worldObjects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var worldObject = _c.value;
                if (worldObject.isVisible() && worldObject.isOnScreen()) {
                    worldObject.render(texture, worldObject.getRenderScreenX(), worldObject.getRenderScreenY());
                }
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_16) throw e_16.error; }
        }
    };
    World.prototype.addWorldObject = function (obj) {
        return World.Actions.addWorldObjectToWorld(obj, this);
    };
    World.prototype.addWorldObjects = function (objs) {
        return World.Actions.addWorldObjectsToWorld(objs, this);
    };
    World.prototype.getDeadWorldObjects = function () {
        return this.worldObjects.filter(function (obj) { return !obj.alive; });
    };
    World.prototype.getLayerByName = function (name) {
        var e_17, _a;
        try {
            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var layer = _c.value;
                if (layer.name === name)
                    return layer;
            }
        }
        catch (e_17_1) { e_17 = { error: e_17_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_17) throw e_17.error; }
        }
        return undefined;
    };
    World.prototype.getPhysicsGroupByName = function (name) {
        return this.physicsGroups[name];
    };
    World.prototype.getPhysicsGroupsThatCollideWith = function (physicsGroup) {
        var e_18, _a;
        var result = [];
        try {
            for (var _b = __values(this.collisions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var collision = _c.value;
                if (collision.move === physicsGroup) {
                    result.push(collision.from);
                }
                else if (collision.from === physicsGroup) {
                    result.push(collision.move);
                }
            }
        }
        catch (e_18_1) { e_18 = { error: e_18_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_18) throw e_18.error; }
        }
        return A.removeDuplicates(result);
    };
    World.prototype.getWorldMouseX = function () {
        return Math.floor(Input.mouseX / this.scaleX + this.camera.worldOffsetX);
    };
    World.prototype.getWorldMouseY = function () {
        return Math.floor(Input.mouseY / this.scaleY + this.camera.worldOffsetY);
    };
    /**
     * @deprecated Use getWorldMouseBounds instead
     */
    World.prototype.getWorldMousePosition = function () {
        return new Vector2(this.getWorldMouseX(), this.getWorldMouseY());
    };
    World.prototype.getWorldMouseBounds = function () {
        this.mouseBounds.x = this.getWorldMouseX();
        this.mouseBounds.y = this.getWorldMouseY();
        var scale = (this.scaleX + this.scaleY) / 2;
        this.mouseBounds.radius = Input.mouseRadius / scale;
        return this.mouseBounds;
    };
    World.prototype.getWorldMouseSpeed = function () {
        if (this.delta === 0)
            return 0;
        var lastMouseX = Math.floor(Input.lastMouseX / this.scaleX + this.camera.worldOffsetX);
        var lastMouseY = Math.floor(Input.lastMouseY / this.scaleY + this.camera.worldOffsetY);
        return M.distance(this.getWorldMouseX(), this.getWorldMouseY(), lastMouseX, lastMouseY) / this.delta;
    };
    World.prototype.handleCollisions = function () {
        if (_.isEmpty(this.collisions))
            return;
        Physics.resolveCollisions(this);
    };
    World.prototype.nonUpdate = function () {
        var e_19, _a;
        try {
            for (var _b = __values(this.worldObjects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var worldObject = _c.value;
                if (!worldObject.updateOnNonUpdate)
                    continue;
                worldObject.setIsInsideWorldBoundsBufferThisFrame();
                if (worldObject.isActive() && worldObject._isInsideWorldBoundsBufferThisFrame) {
                    worldObject.preUpdate();
                    worldObject.update();
                    worldObject.postUpdate();
                }
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_19) throw e_19.error; }
        }
        if (this.nonUpdateCallback)
            this.nonUpdateCallback();
    };
    /**
     * By default, sounds are:
     *   - Humanized (if set globally and sound duration less than 1 second)
     */
    World.prototype.playSound = function (key, config) {
        var _a, _b, _c, _d, _e;
        if (((_a = global.theater) === null || _a === void 0 ? void 0 : _a.isSkippingCutscene) || !this.allowSounds)
            return new Sound(key);
        var limit = (_b = config === null || config === void 0 ? void 0 : config.limit) !== null && _b !== void 0 ? _b : Infinity;
        // Check limit
        if (this.soundManager.getSoundsByKey(key).length >= limit) {
            return new Sound(key);
        }
        var sound = this.soundManager.playSound(key);
        sound.volume = (_c = config === null || config === void 0 ? void 0 : config.volume) !== null && _c !== void 0 ? _c : 1;
        sound.speed = (_d = config === null || config === void 0 ? void 0 : config.speed) !== null && _d !== void 0 ? _d : 1;
        var humanized = (_e = config === null || config === void 0 ? void 0 : config.humanized) !== null && _e !== void 0 ? _e : (sound.duration < 1);
        if (humanized && this.globalSoundHumanizePercent > 0) {
            sound.humanize(this.globalSoundHumanizePercent);
        }
        return sound;
    };
    World.prototype.removeWorldObject = function (obj) {
        if (!obj)
            return undefined;
        if (_.isString(obj)) {
            obj = this.select.name(obj);
            if (!obj)
                return undefined;
        }
        if (!obj.world)
            return undefined;
        if (obj.world !== this) {
            console.error("Cannot remove object " + obj.name + " from world because it does not exist in the world. World:", this);
            return undefined;
        }
        return World.Actions.removeWorldObjectFromWorld(obj);
    };
    World.prototype.removeWorldObjects = function (objs) {
        var _this = this;
        if (_.isEmpty(objs))
            return [];
        return objs.map(function (obj) { return _this.removeWorldObject(obj); }).filter(function (obj) { return obj; });
    };
    World.prototype.runScript = function (script, name) {
        return this.scriptManager.runScript(script, name);
    };
    World.prototype.stopScriptByName = function (name) {
        this.scriptManager.stopScriptByName(name);
    };
    World.prototype.takeSnapshot = function () {
        var screen = new BasicTexture(this.width * this.scaleX, this.height * this.scaleY, 'World.takeSnapshot', false);
        this.render(screen, 0, 0);
        return screen;
    };
    World.prototype.createLayers = function (layers) {
        var e_20, _a;
        if (_.isEmpty(layers))
            layers = [];
        layers.push({ name: World.DEFAULT_LAYER });
        var result = [];
        try {
            for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
                var layer = layers_1_1.value;
                _.defaults(layer, {
                    reverseSort: false,
                });
                result.push(new World.Layer(layer.name, layer));
            }
        }
        catch (e_20_1) { e_20 = { error: e_20_1 }; }
        finally {
            try {
                if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
            }
            finally { if (e_20) throw e_20.error; }
        }
        return result;
    };
    World.prototype.createPhysicsGroups = function (physicsGroups) {
        if (_.isEmpty(physicsGroups))
            return {};
        var result = {};
        for (var name_2 in physicsGroups) {
            _.defaults(physicsGroups[name_2], {
                collidesWith: [],
            });
            result[name_2] = new World.PhysicsGroup(name_2, physicsGroups[name_2]);
        }
        return result;
    };
    World.prototype.removeDeadWorldObjects = function () {
        this.removeWorldObjects(this.getDeadWorldObjects());
    };
    // For use with World.Actions.addWorldObjectToWorld
    World.prototype.internalAddWorldObjectToWorldWorld = function (obj) {
        this.worldObjects.push(obj);
        if (obj.layer) {
            World.Actions.setLayer(obj, obj.layer);
        }
        else {
            World.Actions.setLayer(obj, World.DEFAULT_LAYER);
        }
        if (obj instanceof PhysicsWorldObject && obj.physicsGroup) {
            World.Actions.setPhysicsGroup(obj, obj.physicsGroup);
        }
    };
    // For use with World.Actions.removeWorldObjectFromWorld
    World.prototype.internalRemoveWorldObjectFromWorldWorld = function (obj) {
        this.removeFromAllLayers(obj);
        this.removeFromAllPhysicsGroups(obj);
        A.removeAll(this.worldObjects, obj);
    };
    // For use with World.Actions.setLayer
    World.prototype.internalSetLayerWorld = function (obj, layerName) {
        var e_21, _a;
        this.removeFromAllLayers(obj);
        try {
            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var layer = _c.value;
                if (layer.name === layerName) {
                    layer.worldObjects.push(obj);
                    return;
                }
            }
        }
        catch (e_21_1) { e_21 = { error: e_21_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_21) throw e_21.error; }
        }
    };
    // For use with World.Actions.setPhysicsGroup
    World.prototype.internalSetPhysicsGroupWorld = function (obj, physicsGroupName) {
        this.removeFromAllPhysicsGroups(obj);
        if (!_.isEmpty(physicsGroupName)) {
            this.getPhysicsGroupByName(physicsGroupName).worldObjects.push(obj);
        }
    };
    // For use with World.Actions.addChildToParent
    World.prototype.internalAddChildToParentWorld = function (child, obj) {
        if (child.world !== this) {
            World.Actions.addWorldObjectToWorld(child, this);
        }
    };
    // For use with World.Actions.removeChildFromParent
    World.prototype.internalRemoveChildFromParentWorld = function (child) {
    };
    World.prototype.removeFromAllLayers = function (obj) {
        var e_22, _a;
        try {
            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var layer = _c.value;
                A.removeAll(layer.worldObjects, obj);
            }
        }
        catch (e_22_1) { e_22 = { error: e_22_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_22) throw e_22.error; }
        }
    };
    World.prototype.removeFromAllPhysicsGroups = function (obj) {
        for (var name_3 in this.physicsGroups) {
            A.removeAll(this.physicsGroups[name_3].worldObjects, obj);
        }
    };
    World.DEFAULT_LAYER = 'default';
    return World;
}());
(function (World) {
    var Layer = /** @class */ (function () {
        function Layer(name, config) {
            var _a;
            this.name = name;
            this.worldObjects = [];
            this.sortKey = config.sortKey;
            this.reverseSort = (_a = config.reverseSort) !== null && _a !== void 0 ? _a : false;
            this.effects = new Effects(config.effects);
            this.mask = config.mask;
        }
        Object.defineProperty(Layer.prototype, "shouldRenderToOwnLayer", {
            get: function () {
                return this.effects.hasEffects() || !!this.mask;
            },
            enumerable: false,
            configurable: true
        });
        Layer.prototype.sort = function () {
            var _this = this;
            if (!this.sortKey)
                return;
            var r = this.reverseSort ? -1 : 1;
            this.worldObjects.sort(function (a, b) { return r * (_this.sortKey(a) - _this.sortKey(b)); });
        };
        return Layer;
    }());
    World.Layer = Layer;
    var PhysicsGroup = /** @class */ (function () {
        function PhysicsGroup(name, config) {
            var _a;
            this.name = name;
            this.immovable = (_a = config.immovable) !== null && _a !== void 0 ? _a : false;
            this.worldObjects = [];
        }
        return PhysicsGroup;
    }());
    World.PhysicsGroup = PhysicsGroup;
    var Actions;
    (function (Actions) {
        /**
         * Adds a WorldObject to the world. Returns the object added.
         */
        function addWorldObjectToWorld(obj, world) {
            if (!obj || !world)
                return obj;
            if (obj.world) {
                console.error("Cannot add object " + obj.name + " to world because it aleady exists in another world! You must remove object from previous world first. World:", world, 'Previous world:', obj.world);
                return undefined;
            }
            /// @ts-ignore
            obj.internalAddWorldObjectToWorldWorldObject(world);
            /// @ts-ignore
            world.internalAddWorldObjectToWorldWorld(obj);
            World.Actions.addWorldObjectsToWorld(obj.children, world);
            obj.onAdd();
            return obj;
        }
        Actions.addWorldObjectToWorld = addWorldObjectToWorld;
        /**
         * Adds a list of WorldObjects to a world. Returns as a list the objects added successfully.
         */
        function addWorldObjectsToWorld(objs, world) {
            if (_.isEmpty(objs))
                return [];
            return objs.filter(function (obj) { return addWorldObjectToWorld(obj, world); });
        }
        Actions.addWorldObjectsToWorld = addWorldObjectsToWorld;
        /**
         * Removes a WorldObject from its containing world. Returns the object removed.
         */
        function removeWorldObjectFromWorld(obj, unlinkFromParent) {
            if (unlinkFromParent === void 0) { unlinkFromParent = true; }
            if (!obj)
                return obj;
            if (!obj.world) {
                return obj;
            }
            obj.onRemove();
            var world = obj.world;
            /// @ts-ignore
            obj.internalRemoveWorldObjectFromWorldWorldObject(world);
            /// @ts-ignore
            world.internalRemoveWorldObjectFromWorldWorld(obj);
            World.Actions.removeWorldObjectsFromWorld(obj.children, false);
            if (unlinkFromParent && obj.parent) {
                World.Actions.removeChildFromParent(obj);
            }
            return obj;
        }
        Actions.removeWorldObjectFromWorld = removeWorldObjectFromWorld;
        /**
         * Removes a list of WorldObjects from their containing worlds. Returns as a list the objects successfully removed.
         */
        function removeWorldObjectsFromWorld(objs, unlinkFromParent) {
            if (unlinkFromParent === void 0) { unlinkFromParent = true; }
            if (_.isEmpty(objs))
                return [];
            return A.clone(objs).filter(function (obj) { return removeWorldObjectFromWorld(obj, unlinkFromParent); });
        }
        Actions.removeWorldObjectsFromWorld = removeWorldObjectsFromWorld;
        /**
         * Sets the layer of a WorldObject. Returns the new layer name of the object.
         */
        function setLayer(obj, layerName) {
            if (!obj)
                return undefined;
            if (obj.world && !obj.world.getLayerByName(layerName)) {
                console.error("Cannot set layer on object '" + obj.name + "' as no layer named " + layerName + " exists in world!", obj.world);
                setLayer(obj, World.DEFAULT_LAYER);
                return obj.layer;
            }
            /// @ts-ignore
            obj.internalSetLayerWorldObject(layerName);
            if (obj.world) {
                /// @ts-ignore
                obj.world.internalSetLayerWorld(obj, layerName);
            }
            return obj.layer;
        }
        Actions.setLayer = setLayer;
        /**
         * Sets the physics group of a WorldObject. Returns the new physics group name of the object.
         */
        function setPhysicsGroup(obj, physicsGroupName) {
            if (!obj)
                return undefined;
            if (obj.world && !_.isEmpty(physicsGroupName) && !obj.world.getPhysicsGroupByName(physicsGroupName)) {
                console.error("Cannot set physicsGroup on object '" + obj.name + "' as no physicsGroup named " + physicsGroupName + " exists in world!", obj.world);
                return obj.physicsGroup;
            }
            /// @ts-ignore
            obj.internalSetPhysicsGroupWorldObject(physicsGroupName);
            if (obj.world) {
                /// @ts-ignore
                obj.world.internalSetPhysicsGroupWorld(obj, physicsGroupName);
            }
            return obj.physicsGroup;
        }
        Actions.setPhysicsGroup = setPhysicsGroup;
        /**
         * Adds a WorldObject as a child to a parent. Returns the child object if successful.
         */
        function addChildToParent(child, obj) {
            if (!child || !obj)
                return child;
            if (child.parent) {
                console.error("Cannot add child " + child.name + " to parent " + obj.name + " becase the child is already the child of another parent!", child.parent);
                return undefined;
            }
            if (child.world && child.world !== obj.world) {
                console.error("Cannot add child " + child.name + " to parent " + obj.name + " becase the child exists in a different world!", child.world);
                return undefined;
            }
            var cyclicCheckParent = obj.parent;
            while (cyclicCheckParent) {
                if (cyclicCheckParent === child) {
                    console.error("Cannot add child " + child.name + " to parent " + obj.name + " because this would result in a cyclic hierarchy");
                    return undefined;
                }
                cyclicCheckParent = cyclicCheckParent.parent;
            }
            /// @ts-ignore
            child.internalAddChildToParentWorldObjectChild(obj);
            /// @ts-ignore
            obj.internalAddChildToParentWorldObjectParent(child);
            if (obj.world) {
                /// @ts-ignore
                obj.world.internalAddChildToParentWorld(child, obj);
            }
            return child;
        }
        Actions.addChildToParent = addChildToParent;
        /**
         * Adds a list of WorldObjects as children to a parent. Returns as a list the children successfully added.
         */
        function addChildrenToParent(children, obj) {
            if (_.isEmpty(children))
                return [];
            return children.filter(function (child) { return addChildToParent(child, obj); });
        }
        Actions.addChildrenToParent = addChildrenToParent;
        /**
         * Removes a child from its parent. Returns the child if successfully removed.
         */
        function removeChildFromParent(child) {
            if (!child)
                return child;
            if (!child.parent) {
                debug("Tried to remove child " + child.name + " from its parent, but its parent does not exist! Child:", child);
                return child;
            }
            /// @ts-ignore
            child.parent.internalRemoveChildFromParentWorldObjectParent(child);
            /// @ts-ignore
            child.internalRemoveChildFromParentWorldObjectChild();
            if (child.world) {
                /// @ts-ignore
                child.world.internalRemoveChildFromParentWorld(child);
            }
            return child;
        }
        Actions.removeChildFromParent = removeChildFromParent;
        /**
         * Removes a list of children from their parents. Returns as a list the children successfully removed.
         */
        function removeChildrenFromParent(children) {
            if (_.isEmpty(children))
                return [];
            return A.clone(children).filter(function (child) { return removeChildFromParent(child); });
        }
        Actions.removeChildrenFromParent = removeChildrenFromParent;
        /**
         * Orders a WorldObject before another WorldObject so that it is rendered earlier.
         */
        function orderWorldObjectBefore(obj, before) {
            if (!obj || !before)
                return;
            if (!obj.world || obj.world !== before.world) {
                console.error('Cannot reorder objects due to null or mismatched worlds:', obj, before);
                return;
            }
            if (obj.layer === before.layer) {
                A.moveBefore(obj.world.getLayerByName(obj.layer).worldObjects, obj, before);
            }
        }
        Actions.orderWorldObjectBefore = orderWorldObjectBefore;
        /**
         * Orders a WorldObject after another WorldObject so that it is rendered later.
         */
        function orderWorldObjectAfter(obj, after) {
            if (!obj || !after)
                return;
            if (!obj.world || obj.world !== after.world) {
                console.error('Cannot reorder objects due to null or mismatched worlds:', obj, after);
                return;
            }
            if (obj.layer === after.layer) {
                A.moveAfter(obj.world.getLayerByName(obj.layer).worldObjects, obj, after);
            }
        }
        Actions.orderWorldObjectAfter = orderWorldObjectAfter;
        /**
         * Moves a WorldObject to the front of its layer so it is rendered later.
         */
        function moveWorldObjectToFront(obj) {
            if (!obj)
                return;
            if (!obj.world) {
                console.error('Cannot move object since it is not in a world:', obj);
                return;
            }
            var layerObjects = obj.world.getLayerByName(obj.layer).worldObjects;
            var i = layerObjects.indexOf(obj);
            if (i === layerObjects.length - 1)
                return;
            layerObjects.push(layerObjects.splice(i, 1)[0]);
        }
        Actions.moveWorldObjectToFront = moveWorldObjectToFront;
        /**
         * Moves a WorldObject to the front of its layer so it is rendered earlier.
         */
        function moveWorldObjectToBack(obj) {
            if (!obj)
                return;
            if (!obj.world) {
                console.error('Cannot move object since it is not in a world:', obj);
                return;
            }
            var layerObjects = obj.world.getLayerByName(obj.layer).worldObjects;
            var i = layerObjects.indexOf(obj);
            if (i === 0)
                return;
            layerObjects.unshift(layerObjects.splice(i, 1)[0]);
        }
        Actions.moveWorldObjectToBack = moveWorldObjectToBack;
        /**
         * Shifts provided WorldObjects equally to balance them around a point.
         * @return the new bounds containing all of the objects
         */
        function balanceWorldObjects(objs, aroundX, aroundY, anchor, deep) {
            var e_23, _a, e_24, _b;
            if (anchor === void 0) { anchor = Vector2.CENTER; }
            if (deep === void 0) { deep = false; }
            if (_.isEmpty(objs))
                return undefined;
            var bounds = {
                left: objs[0].x,
                right: objs[0].x,
                top: objs[0].y,
                bottom: objs[0].y,
            };
            try {
                for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
                    var obj = objs_1_1.value;
                    expandWorldObjectBounds(bounds, obj, deep);
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
                }
                finally { if (e_23) throw e_23.error; }
            }
            var anchorPoint = vec2(M.lerp(bounds.left, bounds.right, anchor.x), M.lerp(bounds.top, bounds.bottom, anchor.y));
            if (!isFinite(anchorPoint.x) || !isFinite(anchorPoint.y)) {
                console.error('Non-finite anchorPoint for balancing:', objs, anchorPoint);
            }
            try {
                for (var objs_2 = __values(objs), objs_2_1 = objs_2.next(); !objs_2_1.done; objs_2_1 = objs_2.next()) {
                    var obj = objs_2_1.value;
                    obj.x += aroundX - anchorPoint.x;
                    obj.y += aroundY - anchorPoint.y;
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (objs_2_1 && !objs_2_1.done && (_b = objs_2.return)) _b.call(objs_2);
                }
                finally { if (e_24) throw e_24.error; }
            }
            bounds.left += aroundX - anchorPoint.x;
            bounds.right += aroundX - anchorPoint.x;
            bounds.top += aroundY - anchorPoint.y;
            bounds.bottom += aroundY - anchorPoint.y;
            return bounds;
        }
        Actions.balanceWorldObjects = balanceWorldObjects;
        function expandWorldObjectBounds(bounds, obj, deep) {
            var e_25, _a;
            bounds.left = Math.min(bounds.left, obj.x);
            bounds.right = Math.max(bounds.right, obj.x);
            bounds.top = Math.min(bounds.top, obj.y);
            bounds.bottom = Math.max(bounds.bottom, obj.y);
            if (deep) {
                try {
                    for (var _b = __values(obj.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        expandWorldObjectBounds(bounds, child, deep);
                    }
                }
                catch (e_25_1) { e_25 = { error: e_25_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_25) throw e_25.error; }
                }
            }
        }
    })(Actions = World.Actions || (World.Actions = {}));
})(World || (World = {}));
/// <reference path="../world/world.ts" />
var DebugOverlay = /** @class */ (function (_super) {
    __extends(DebugOverlay, _super);
    function DebugOverlay() {
        var _this = _super.call(this) || this;
        _this.backgroundAlpha = 0;
        var debugOverlay = _this;
        _this.addWorldObject(new SpriteText({
            name: 'debuginfo',
            x: 0, y: 0,
            font: Debug.FONT,
            style: Debug.FONT_STYLE,
            effects: { outline: { color: 0x000000 } },
            update: function () {
                this.setText(debugOverlay.getDebugInfo());
            }
        }));
        return _this;
    }
    DebugOverlay.prototype.setCurrentWorldToDebug = function (world) {
        this.currentWorldToDebug = world;
    };
    DebugOverlay.prototype.getDebugInfo = function () {
        var e_26, _a;
        if (!this.currentWorldToDebug)
            return "";
        var mousePositionText = "mpos: "
            + St.padLeft(this.currentWorldToDebug.getWorldMouseX().toString(), 3) + " "
            + St.padLeft(this.currentWorldToDebug.getWorldMouseY().toString(), 3);
        var fpsText = "fps: "
            + global.fpsCalculator.fpsAvg.toFixed(0) + " "
            + "(-" + (global.fpsCalculator.fpsAvg - global.fpsCalculator.fpsP).toFixed(0) + ")";
        var feedText = "";
        try {
            for (var _b = __values(Debug.OVERLAY_FEEDS), _c = _b.next(); !_c.done; _c = _b.next()) {
                var feed = _c.value;
                feedText += feed(this.currentWorldToDebug) + "\n";
            }
        }
        catch (e_26_1) { e_26 = { error: e_26_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_26) throw e_26.error; }
        }
        return mousePositionText + "\n" + fpsText + "\n" + feedText;
    };
    return DebugOverlay;
}(World));
var Experiment = /** @class */ (function () {
    function Experiment(toggleKey) {
        this.toggleKey = toggleKey;
        this.enabled = false;
    }
    Experiment.prototype.update = function (name) {
        if (Input.justDown(this.toggleKey)) {
            this.enabled = !this.enabled;
            debug("Experiment '" + name + "' turned " + (this.enabled ? 'on' : 'off'));
        }
    };
    Experiment.prototype.isEnabled = function () {
        return Debug.DEBUG && this.enabled;
    };
    return Experiment;
}());
function addSlider(startValue, set, min, max, step) {
    var slider = document.createElement('input');
    slider.type = 'range';
    slider.min = "" + min;
    slider.max = "" + max;
    slider.step = "" + step;
    slider.value = "" + startValue;
    slider.oninput = function () {
        set(parseFloat(slider.value));
    };
    document.body.appendChild(slider);
}
/// <reference path="../worldObject/sprite/sprite.ts" />
var DialogBox = /** @class */ (function (_super) {
    __extends(DialogBox, _super);
    function DialogBox(config) {
        var _this = _super.call(this, config) || this;
        _this.textAreaFull = config.textAreaFull;
        _this.textAreaPortrait = config.textAreaPortrait;
        _this.defaultTextFont = config.defaultTextFont;
        _this.defaultDialogStart = config.defaultDialogStart;
        _this.defaultDialogSpeak = config.defaultDialogSpeak;
        _this.dialogStart = config.defaultDialogStart;
        _this.dialogSpeak = config.defaultDialogSpeak;
        _this.done = true;
        _this.spriteText = _this.addChild(new SpriteText({ font: _this.defaultTextFont }));
        _this.spriteTextOffset = 0;
        _this.portrait = _this.addChild(new WorldObject({ x: config.portraitPosition.x, y: config.portraitPosition.y }));
        _this.nameSprite = _this.addChild(new Sprite({ x: config.namePosition.x, y: config.namePosition.y, texture: config.nameTexture }));
        _this.nameText = _this.nameSprite.addChild(new SpriteText({ x: config.nameTextOffset.x, y: config.nameTextOffset.y, font: config.nameFont, anchor: Vector2.CENTER }));
        _this.characterTimer = new Timer(0.05, function () { return _this.advanceCharacter(); }, Infinity);
        _this.speakSoundTimer = new Timer(0.05, function () {
            var p = _this.getDialogProgression() < 0.9 ? 0.85 : 1; // 85% normally, but 100% if dialog is close to ending
            if (_this.dialogSpeak && Debug.SKIP_RATE < 2 && !_this.isPageComplete() && Random.boolean(p)) {
                var sound = _this.world.playSound(_this.dialogSpeak);
                sound.speed = Random.float(0.95, 1.05);
            }
        }, Infinity);
        return _this;
    }
    Object.defineProperty(DialogBox.prototype, "textArea", {
        get: function () { return this.portraitObject ? this.textAreaPortrait : this.textAreaFull; },
        enumerable: false,
        configurable: true
    });
    DialogBox.prototype.update = function () {
        _super.prototype.update.call(this);
        this.spriteText.localx = this.textArea.x;
        this.spriteText.localy = this.textArea.y - this.spriteTextOffset;
        this.spriteText.maxWidth = this.textArea.width;
        this.spriteText.mask = {
            type: 'world',
            texture: this.spriteText.mask ? this.spriteText.mask.texture : Texture.filledRect(this.textArea.width, this.textArea.height, 0xFFFFFF),
            offsetx: this.x + this.textArea.x,
            offsety: this.y + this.textArea.y,
        };
        // Visibility must be set before dialog progression to avoid a 1-frame flicker.
        this.setVisible(!this.done);
        if (!this.done) {
            this.updateDialogProgression();
            this.speakSoundTimer.update(this.delta);
        }
    };
    DialogBox.prototype.updateDialogProgression = function () {
        this.characterTimer.update(this.delta);
        if (Input.justDown(Input.GAME_ADVANCE_CUTSCENE)) {
            Input.consume(Input.GAME_ADVANCE_CUTSCENE);
            this.advanceDialog();
        }
    };
    DialogBox.prototype.advanceDialog = function () {
        if (this.isPageComplete()) {
            this.advancePage();
        }
        else {
            this.completePage();
        }
    };
    DialogBox.prototype.showDialog = function (dialogText) {
        this.spriteText.clear();
        this.spriteTextOffset = 0;
        this.done = false;
        this.spriteText.setText(dialogText);
        this.spriteText.visibleCharCount = 0;
        this.spriteTextOffset = 0;
        this.characterTimer.reset();
        this.advanceCharacter(); // Advance character once to start the dialog with one displayed character.
        if (this.dialogStart) {
            this.world.playSound(this.dialogStart);
        }
    };
    DialogBox.prototype.addToDialog = function (additionalText) {
        this.done = false;
        var newCurrentText = this.spriteText.getCurrentText() + additionalText;
        var newVisibleCharCount = this.spriteText.visibleCharCount;
        this.spriteText.setText(newCurrentText);
        this.spriteText.visibleCharCount = newVisibleCharCount;
        this.characterTimer.reset();
        this.advanceCharacter(); // Advance character once to start the dialog with one displayed character.
        if (this.dialogStart) {
            this.world.playSound(this.dialogStart);
        }
    };
    DialogBox.prototype.setProfile = function (profileKey, entry) {
        if (profileKey === this.currentProfileKey && entry === this.currentProfileEntry)
            return;
        var profile = DialogProfiles.getProfile(profileKey);
        if (!profile)
            return;
        // Portrait
        if (this.portraitObject) {
            this.portraitObject.removeFromWorld();
            this.portraitObject = null;
        }
        var portrait = profile.getPortrait(entry);
        if (portrait) {
            this.portraitObject = this.portrait.addChild(portrait);
        }
        // Name
        var name = profile.getName(entry);
        if (name) {
            this.nameText.setText(name);
            this.nameSprite.setVisible(true);
        }
        else {
            this.nameSprite.setVisible(false);
        }
        // Font
        this.spriteText.setFont(profile.getFont(entry) || this.defaultTextFont);
        // Dialog sounds
        this.dialogStart = profile.getDialogStart(entry) || this.defaultDialogStart;
        this.dialogSpeak = profile.getDialogSpeak(entry) || this.defaultDialogSpeak;
        this.currentProfileKey = profileKey;
        this.currentProfileEntry = entry;
        this.update();
    };
    DialogBox.prototype.complete = function () {
        while (!this.done) {
            this.completePage();
            this.advancePage();
        }
    };
    DialogBox.prototype.advanceCharacter = function () {
        if (!this.isPageComplete()) {
            this.spriteText.visibleCharCount++;
        }
    };
    DialogBox.prototype.advancePage = function () {
        if (this.isDialogComplete()) {
            this.done = true;
        }
        else {
            this.spriteTextOffset = this.spriteText.getTextHeight();
        }
    };
    DialogBox.prototype.completePage = function () {
        var iters = 0;
        while (!this.isPageComplete() && iters < DialogBox.MAX_COMPLETE_PAGE_ITERS) {
            this.advanceCharacter();
            iters++;
        }
        if (!this.isPageComplete()) {
            this.advancePage();
        }
    };
    DialogBox.prototype.isDialogComplete = function () {
        return this.getDialogProgression() >= 1;
    };
    DialogBox.prototype.getDialogProgression = function () {
        return this.spriteText.visibleCharCount / this.spriteText.getCharList().length;
    };
    DialogBox.prototype.isPageComplete = function () {
        if (this.isDialogComplete())
            return true;
        var nextHeight = SpriteText.getHeightOfCharList(this.spriteText.getCharList(), this.spriteText.visibleCharCount + 1);
        return nextHeight > this.textArea.height + this.spriteTextOffset;
    };
    DialogBox.MAX_COMPLETE_PAGE_ITERS = 10000;
    return DialogBox;
}(Sprite));
var SingleKeyPool = /** @class */ (function () {
    function SingleKeyPool(factory, keyToStringFn) {
        if (keyToStringFn === void 0) { keyToStringFn = function (key) { return "" + key; }; }
        this.factory = factory;
        this.keyToStringFn = keyToStringFn;
        this.pool = {};
    }
    SingleKeyPool.prototype.borrow = function (key) {
        var keyString = this.keyToStringFn(key);
        if (_.isEmpty(this.pool[keyString])) {
            return this.factory(key);
        }
        return this.pool[keyString].pop();
    };
    SingleKeyPool.prototype.return = function (key, value) {
        var keyString = this.keyToStringFn(key);
        if (!(keyString in this.pool)) {
            this.pool[keyString] = [];
        }
        this.pool[keyString].push(value);
    };
    return SingleKeyPool;
}());
var DualKeyPool = /** @class */ (function () {
    function DualKeyPool(factory, keysToStringFn) {
        if (keysToStringFn === void 0) { keysToStringFn = function (key1, key2) { return key1 + "|/|" + key2; }; }
        this.factory = factory;
        this.keysToStringFn = keysToStringFn;
        this.pool = {};
    }
    DualKeyPool.prototype.borrow = function (key1, key2) {
        var keyString = this.keysToStringFn(key1, key2);
        if (_.isEmpty(this.pool[keyString])) {
            return this.factory(key1, key2);
        }
        return this.pool[keyString].pop();
    };
    DualKeyPool.prototype.return = function (key1, key2, value) {
        var keyString = this.keysToStringFn(key1, key2);
        if (!(keyString in this.pool)) {
            this.pool[keyString] = [];
        }
        this.pool[keyString].push(value);
    };
    return DualKeyPool;
}());
var Perlin = /** @class */ (function () {
    function Perlin(seed) {
        this.random = new RandomNumberGenerator(seed);
    }
    // Normalized to [-1, 1].
    // Algorithm taken from https://adrianb.io/2014/08/09/perlinnoise.html
    Perlin.prototype.get = function (x, y, z) {
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        var xi = Math.floor(x) & 255;
        var yi = Math.floor(y) & 255;
        var zi = Math.floor(z) & 255;
        var xf = x - Math.floor(x);
        var yf = y - Math.floor(y);
        var zf = z - Math.floor(z);
        var u = this.fade(xf);
        var v = this.fade(yf);
        var w = this.fade(zf);
        var aaa = this.hash(xi, yi, zi);
        var aba = this.hash(xi, yi + 1, zi);
        var aab = this.hash(xi, yi, zi + 1);
        var abb = this.hash(xi, yi + 1, zi + 1);
        var baa = this.hash(xi + 1, yi, zi);
        var bba = this.hash(xi + 1, yi + 1, zi);
        var bab = this.hash(xi + 1, yi, zi + 1);
        var bbb = this.hash(xi + 1, yi + 1, zi + 1);
        var x11 = M.lerp(this.grad(aaa, xf, yf, zf), this.grad(baa, xf - 1, yf, zf), u);
        var x12 = M.lerp(this.grad(aba, xf, yf - 1, zf), this.grad(bba, xf - 1, yf - 1, zf), u);
        var x21 = M.lerp(this.grad(aab, xf, yf, zf - 1), this.grad(bab, xf - 1, yf, zf - 1), u);
        var x22 = M.lerp(this.grad(abb, xf, yf - 1, zf - 1), this.grad(bbb, xf - 1, yf - 1, zf - 1), u);
        var y1 = M.lerp(x11, x12, v);
        var y2 = M.lerp(x21, x22, v);
        return M.lerp(y1, y2, w);
    };
    Perlin.prototype.seed = function (seed) {
        this.random.seed(seed);
    };
    Perlin.prototype.fade = function (t) {
        // 6t^5 - 15t^4 + 10t^3
        return t * t * t * (t * (t * 6 - 15) + 10);
    };
    Perlin.prototype.grad = function (hash, x, y, z) {
        switch (hash & 0xF) {
            case 0x0: return x + y;
            case 0x1: return -x + y;
            case 0x2: return x - y;
            case 0x3: return -x - y;
            case 0x4: return x + z;
            case 0x5: return -x + z;
            case 0x6: return x - z;
            case 0x7: return -x - z;
            case 0x8: return y + z;
            case 0x9: return -y + z;
            case 0xA: return y - z;
            case 0xB: return -y - z;
            case 0xC: return y + x;
            case 0xD: return -y + z;
            case 0xE: return y - x;
            case 0xF: return -y - z;
            default: return 0;
        }
    };
    Perlin.prototype.hash = function (x, y, z) {
        return Perlin.PERMUTATION[Perlin.PERMUTATION[Perlin.PERMUTATION[x] + y] + z];
    };
    // Hash lookup table as defined by Ken Perlin.  This is a randomly
    // arranged array of all numbers from 0-255 inclusive.
    // TODO: get rid of the repeat
    Perlin.PERMUTATION = [151, 160, 137, 91, 90, 15,
        131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
        190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
        88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
        77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
        102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
        135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
        5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
        223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
        129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
        251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
        49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        151, 160, 137, 91, 90, 15,
        131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
        190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
        88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
        77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
        102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
        135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
        5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
        223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
        129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
        251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
        49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
        138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
    ];
    // From https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
    // Normalized to (-1, 1)
    Perlin.SHADER_SOURCE = "\n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n        vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n        // Normalized to (-1, 1)\n        float pnoise(vec3 P) {\n            vec3 Pi0 = floor(P); // Integer part for indexing\n            vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n            Pi0 = mod(Pi0, 289.0);\n            Pi1 = mod(Pi1, 289.0);\n            vec3 Pf0 = fract(P); // Fractional part for interpolation\n            vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n            vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n            vec4 iy = vec4(Pi0.yy, Pi1.yy);\n            vec4 iz0 = Pi0.zzzz;\n            vec4 iz1 = Pi1.zzzz;\n\n            vec4 ixy = permute(permute(ix) + iy);\n            vec4 ixy0 = permute(ixy + iz0);\n            vec4 ixy1 = permute(ixy + iz1);\n\n            vec4 gx0 = ixy0 / 7.0;\n            vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n            gx0 = fract(gx0);\n            vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n            vec4 sz0 = step(gz0, vec4(0.0));\n            gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n            gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n            vec4 gx1 = ixy1 / 7.0;\n            vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n            gx1 = fract(gx1);\n            vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n            vec4 sz1 = step(gz1, vec4(0.0));\n            gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n            gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n            vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n            vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n            vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n            vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n            vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n            vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n            vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n            vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n            vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n            g000 *= norm0.x;\n            g010 *= norm0.y;\n            g100 *= norm0.z;\n            g110 *= norm0.w;\n            vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n            g001 *= norm1.x;\n            g011 *= norm1.y;\n            g101 *= norm1.z;\n            g111 *= norm1.w;\n\n            float n000 = dot(g000, Pf0);\n            float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n            float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n            float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n            float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n            float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n            float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n            float n111 = dot(g111, Pf1);\n\n            vec3 fade_xyz = fade(Pf0);\n            vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n            vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n            float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n            return 2.2 * n_xyz;\n        }\n\n        // Normalized to (-1, 1)\n        float pnoise(float x, float y, float z) {\n            return pnoise(vec3(x, y, z));\n        }\n    ";
    return Perlin;
}());
///<reference path="../../utils/pool.ts"/>
///<reference path="../../utils/perlin.ts"/>
var TextureFilter = /** @class */ (function () {
    function TextureFilter(config) {
        var _a;
        this.code = (_a = config.code) !== null && _a !== void 0 ? _a : '';
        this.uniformCode = this.constructUniformCode(config.uniforms);
        this.uniforms = this.constructUniforms(config.uniforms);
        this.setUniform('posx', 0);
        this.setUniform('posy', 0);
        this.setUniform('dimx', 0);
        this.setUniform('dimy', 0);
        this.setUniform('t', 0);
        this.enabled = true;
        this.borrowedPixiFilter = null;
    }
    TextureFilter.prototype.borrowPixiFilter = function () {
        this.borrowedPixiFilter = TextureFilter.cache.borrow(this);
        for (var uniform in this.uniforms) {
            this.borrowedPixiFilter.uniforms[uniform] = this.uniforms[uniform];
        }
        return this.borrowedPixiFilter;
    };
    TextureFilter.prototype.returnPixiFilter = function () {
        if (!this.borrowedPixiFilter)
            return;
        TextureFilter.cache.return(this, this.borrowedPixiFilter);
        this.borrowedPixiFilter = null;
    };
    TextureFilter.prototype.constructPixiFilter = function () {
        return new PIXI.Filter(PIXI.Filter.defaultVertexSrc, TextureFilter.constructFragCode(this.uniformCode, this.code), {});
    };
    TextureFilter.prototype.getCacheCode = function () {
        return "TextureFilter:" + this.uniformCode + this.code;
    };
    TextureFilter.prototype.getUniform = function (uniform) {
        return this.uniforms[uniform];
    };
    TextureFilter.prototype.getUniformCode = function () {
        return this.uniformCode;
    };
    TextureFilter.prototype.setTextureDimensions = function (dimx, dimy) {
        this.uniforms['dimx'] = dimx;
        this.uniforms['dimy'] = dimy;
    };
    TextureFilter.prototype.setTexturePosition = function (posx, posy) {
        this.uniforms['posx'] = posx;
        this.uniforms['posy'] = posy;
    };
    TextureFilter.prototype.setUniform = function (uniform, value) {
        this.uniforms[uniform] = value;
    };
    TextureFilter.prototype.setUniforms = function (uniforms) {
        if (!uniforms)
            return;
        for (var key in uniforms) {
            this.uniforms[key] = uniforms[key];
        }
    };
    TextureFilter.prototype.update = function () {
    };
    TextureFilter.prototype.updateTime = function (delta) {
        this.setUniform('t', this.getUniform('t') + delta);
    };
    TextureFilter.prototype.constructUniformCode = function (uniformDeclarations) {
        if (_.isEmpty(uniformDeclarations))
            return '';
        var uniformCode = '';
        for (var decl in uniformDeclarations) {
            uniformCode += "uniform " + decl + ";";
        }
        return uniformCode;
    };
    TextureFilter.prototype.constructUniforms = function (uniformDeclarations) {
        if (_.isEmpty(uniformDeclarations))
            return {};
        var uniformMap = {};
        for (var decl in uniformDeclarations) {
            var uniformName = decl.trim().substring(decl.lastIndexOf(' ') + 1);
            uniformMap[uniformName] = uniformDeclarations[decl];
        }
        return uniformMap;
    };
    return TextureFilter;
}());
(function (TextureFilter) {
    TextureFilter.cache = new SingleKeyPool(function (filter) { return filter.constructPixiFilter(); }, function (filter) { return filter.getCacheCode(); });
    function constructFragCode(uniformCode, code) {
        return fragPreUniforms + uniformCode + fragStartFunc + code + fragEndFunc;
    }
    TextureFilter.constructFragCode = constructFragCode;
    var fragPreUniforms = "\n        precision highp float;\n        varying vec2 vTextureCoord;\n        uniform vec4 inputSize;\n        uniform sampler2D uSampler;\n\n        uniform float posx;\n        uniform float posy;\n        uniform float dimx;\n        uniform float dimy;\n        uniform float t;\n\n        float width;\n        float height;\n        float destWidth;\n        float destHeight;\n    ";
    var fragStartFunc = "\n        vec4 getColor(float localx, float localy) {\n            float tx = (localx + posx) / destWidth;\n            float ty = (localy + posy) / destHeight;\n            vec4 color = texture2D(uSampler, vec2(tx, ty));\n            if (color.a > 0.0) {\n                // Un-premultiply alpha, like inp.\n                color.rgb /= color.a;\n            }\n            return color;\n        }\n\n        vec4 getDestColor(float destx, float desty) {\n            float tx = destx / destWidth;\n            float ty = desty / destHeight;\n            vec4 color = texture2D(uSampler, vec2(tx, ty));\n            if (color.a > 0.0) {\n                // Un-premultiply alpha, like inp.\n                color.rgb /= color.a;\n            }\n            return color;\n        }\n\n        // Source: https://stackoverflow.com/a/17897228\n        // All components are in the range [0,1], including hue.\n        vec3 rgb2hsv(vec3 c) {\n            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n            float d = q.x - min(q.w, q.y);\n            float e = 1.0e-10;\n            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n        }\n\n        // Source: https://stackoverflow.com/a/17897228\n        // All components are in the range [0,1], including hue.\n        vec3 hsv2rgb(vec3 c) {\n            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n        }\n\n        float map(float value, float min1, float max1, float min2, float max2) {\n            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n        }\n\n        float mapClamp(float value, float min1, float max1, float min2, float max2) {\n            return clamp(map(value, min1, max1, min2, max2), min2, max2);\n        }\n\n        float lerp(float a, float b, float t) {\n            return a*(1.0-t) + b*t;\n        }\n\n        vec2 lerp(vec2 a, vec2 b, float t) {\n            return a*(1.0-t) + b*t;\n        }\n\n        vec3 lerp(vec3 a, vec3 b, float t) {\n            return a*(1.0-t) + b*t;\n        }\n\n        vec4 lerp(vec4 a, vec4 b, float t) {\n            return a*(1.0-t) + b*t;\n        }\n\n        bool approx(float x, float y) {\n            return abs(x - y) < 0.0001;\n        }\n\n        float round(float x) {\n            return floor(x + 0.5);\n        }\n\n        vec2 round(vec2 x) {\n            return vec2(round(x.x), round(x.y));\n        }\n\n        vec3 round(vec3 x) {\n            return vec3(round(x.x), round(x.y), round(x.z));\n        }\n\n        vec4 round(vec4 x) {\n            return vec4(round(x.x), round(x.y), round(x.z), round(x.w));\n        }\n\n        bool convolute44(float x, float y, float p00, float p10, float p20, float p30, float p01, float p11, float p21, float p31, float p02, float p12, float p22, float p32, float p03, float p13, float p23, float p33) {\n            return approx(getColor(x, y).a, p00) && approx(getColor(x+1.0, y).a, p10) && approx(getColor(x+2.0, y).a, p20) && approx(getColor(x+3.0, y).a, p30)\n                && approx(getColor(x, y+1.0).a, p01) && approx(getColor(x+1.0, y+1.0).a, p11) && approx(getColor(x+2.0, y+1.0).a, p21) && approx(getColor(x+3.0, y+1.0).a, p31)\n                && approx(getColor(x, y+2.0).a, p02) && approx(getColor(x+1.0, y+2.0).a, p12) && approx(getColor(x+2.0, y+2.0).a, p22) && approx(getColor(x+3.0, y+2.0).a, p32)\n                && approx(getColor(x, y+3.0).a, p03) && approx(getColor(x+1.0, y+3.0).a, p13) && approx(getColor(x+2.0, y+3.0).a, p23) && approx(getColor(x+3.0, y+3.0).a, p33);\n        }\n\n        " + Perlin.SHADER_SOURCE + "\n\n        void main(void) {\n            #define PI 3.14159265358979\n            #define TWOPI 6.28318530717958\n\n            width = dimx;\n            height = dimy;\n            destWidth = inputSize.x;\n            destHeight = inputSize.y;\n            float destx = vTextureCoord.x * destWidth;\n            float desty = vTextureCoord.y * destHeight;\n            float x = destx - posx;\n            float y = desty - posy;\n            vec4 inp = texture2D(uSampler, vTextureCoord);\n            // Un-premultiply alpha before applying the color matrix. See PIXI issue #3539.\n            if (inp.a > 0.0) {\n                inp.rgb /= inp.a;\n            }\n            vec4 outp = vec4(inp.r, inp.g, inp.b, inp.a);\n    ";
    var fragEndFunc = "\n            // Clamp output to the interval [0,1] to avoid issues with alpha premultiplication.\n            outp = clamp(outp, vec4(0.0, 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0));\n            // Premultiply alpha again.\n            outp.rgb *= outp.a;\n            gl_FragColor = outp;\n        }\n    ";
    var _sliceFilter;
    function SLICE_FILTER(rect) {
        if (!_sliceFilter) {
            _sliceFilter = new TextureFilters.Slice(rect);
        }
        else {
            _sliceFilter.setSlice(rect);
        }
        return _sliceFilter;
    }
    TextureFilter.SLICE_FILTER = SLICE_FILTER;
})(TextureFilter || (TextureFilter = {}));
/// <reference path="../texture/filter/textureFilter.ts" />
var DialogProfile = /** @class */ (function () {
    function DialogProfile(config) {
        this.name = config.name;
        this.font = config.font;
        this.dialogStart = config.dialogStart;
        this.dialogSpeak = config.dialogSpeak;
        this.defaultPortrait = config.defaultPortrait;
        this.entries = config.entries;
    }
    DialogProfile.prototype.getName = function (entry) {
        var _a, _b;
        return (_b = (_a = this.getEntry(entry)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : this.name;
    };
    DialogProfile.prototype.getPortrait = function (entry) {
        var _a, _b;
        var portrait = (_b = (_a = this.getEntry(entry)) === null || _a === void 0 ? void 0 : _a.portrait) !== null && _b !== void 0 ? _b : this.defaultPortrait;
        if (!portrait)
            return undefined;
        return portrait();
    };
    DialogProfile.prototype.getDialogStart = function (entry) {
        var _a, _b;
        return (_b = (_a = this.getEntry(entry)) === null || _a === void 0 ? void 0 : _a.dialogStart) !== null && _b !== void 0 ? _b : this.dialogStart;
    };
    DialogProfile.prototype.getDialogSpeak = function (entry) {
        var _a, _b;
        return (_b = (_a = this.getEntry(entry)) === null || _a === void 0 ? void 0 : _a.dialogSpeak) !== null && _b !== void 0 ? _b : this.dialogSpeak;
    };
    DialogProfile.prototype.getFont = function (entry) {
        var _a, _b;
        return (_b = (_a = this.getEntry(entry)) === null || _a === void 0 ? void 0 : _a.font) !== null && _b !== void 0 ? _b : this.font;
    };
    DialogProfile.prototype.getEntry = function (entry) {
        if (entry in this.entries) {
            return this.entries[entry];
        }
        return this.entries['default'];
    };
    DialogProfile.splitKey = function (profileKey) {
        var parts = profileKey.split('/');
        if (parts.length === 1) {
            return [parts[0], 'default'];
        }
        if (parts.length > 2) {
            console.error("Dialog profile key has more than two parts: " + profileKey);
        }
        return [parts[0], parts[1]];
    };
    return DialogProfile;
}());
var DialogProfiles;
(function (DialogProfiles) {
    var profilesByCharacter = {};
    function initProfiles(profiles) {
        for (var key in profiles) {
            profilesByCharacter[key] = new DialogProfile(profiles[key]);
        }
    }
    DialogProfiles.initProfiles = initProfiles;
    function getProfile(profileKey) {
        var profile = profilesByCharacter[profileKey];
        if (!profile) {
            console.error("No profile found for: " + profileKey);
            return undefined;
        }
        return profile;
    }
    DialogProfiles.getProfile = getProfile;
    function simplePortrait(key) {
        return function () { return new Sprite({ texture: key }); };
    }
    DialogProfiles.simplePortrait = simplePortrait;
    function simplePortraitWithOutline(key) {
        return function () { return new Sprite({ texture: key, effects: { pre: { filters: [new DialogOutlineFilter()] } } }); };
    }
    DialogProfiles.simplePortraitWithOutline = simplePortraitWithOutline;
    var DialogOutlineFilter = /** @class */ (function (_super) {
        __extends(DialogOutlineFilter, _super);
        function DialogOutlineFilter() {
            return _super.call(this, {
                code: "\n                    if (x >= 0.0 && x < width && y >= 0.0 && y < height && inp.a == 0.0 && (getColor(x-1.0, y).a > 0.0 || getColor(x+1.0, y).a > 0.0 || getColor(x, y-1.0).a > 0.0 || getColor(x, y+1.0).a > 0.0)) {\n                        outp = vec4(1.0, 1.0, 1.0, 1.0);\n                    }\n                "
            }) || this;
        }
        return DialogOutlineFilter;
    }(TextureFilter));
})(DialogProfiles || (DialogProfiles = {}));
var Lci;
(function (Lci) {
    var HEADER = '.LCI';
    function parseDocument(lciString) {
        if (!lciString.startsWith(HEADER)) {
            console.error('Error loading LCI: bad header', lciString);
            return undefined;
        }
        var lciJson = lciString.substr(HEADER.length);
        return JSON.parse(lciJson);
    }
    Lci.parseDocument = parseDocument;
    function getLayerTextureKey(documentKey, layerName) {
        return documentKey + "/" + layerName;
    }
    Lci.getLayerTextureKey = getLayerTextureKey;
})(Lci || (Lci = {}));
function lciDocumentToWorldObjects(key) {
    var e_27, _a, e_28, _b;
    var _c, _d, _e, _f, _g;
    var lciDocument = AssetCache.getLciDocument(key);
    if (!lciDocument)
        return [];
    var worldObjects = [];
    try {
        for (var _h = __values(lciDocument.layers), _j = _h.next(); !_j.done; _j = _h.next()) {
            var layer = _j.value;
            var worldLayer = St.isBlank(layer.properties.layer) ? undefined : layer.properties.layer;
            var physicsGroup = St.isBlank(layer.properties.physicsGroup) ? undefined : layer.properties.physicsGroup;
            var bounds = layer.properties.bounds;
            if (!St.isBlank(layer.properties.placeholder)) {
                var constructor = window[layer.properties.placeholder];
                if (!constructor || !constructor.prototype || !constructor.prototype.constructor.name) {
                    console.error("LCI placeholder '" + layer.properties.placeholder + "' does not exist.");
                    continue;
                }
                var worldObject = void 0;
                try {
                    worldObject = new constructor(layer.position.x, layer.position.y);
                    worldObject.name = layer.name;
                }
                catch (err) {
                    console.error("Cannot instantiate LCI placeholder '" + layer.properties.placeholder + "':", err);
                    continue;
                }
                worldObjects.push(worldObject);
                continue;
            }
            if (!_.isEmpty(layer.properties.multiBounds)) {
                try {
                    for (var _k = (e_28 = void 0, __values(layer.properties.multiBounds)), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var rect_1 = _l.value;
                        var bounds_1 = new PhysicsWorldObject({
                            x: rect_1.x, y: rect_1.y,
                            physicsGroup: physicsGroup,
                            bounds: new RectBounds(0, 0, rect_1.width, rect_1.height),
                            immovable: true,
                        });
                        worldObjects.push(bounds_1);
                    }
                }
                catch (e_28_1) { e_28 = { error: e_28_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_b = _k.return)) _b.call(_k);
                    }
                    finally { if (e_28) throw e_28.error; }
                }
            }
            if (layer.isDataLayer)
                continue;
            var sprite = new Sprite({
                name: layer.name,
                x: layer.position.x,
                y: layer.position.y,
                texture: Lci.getLayerTextureKey(key, layer.name),
                offsetX: (_d = (_c = layer.properties.offset) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : 0,
                offsetY: (_f = (_e = layer.properties.offset) === null || _e === void 0 ? void 0 : _e.y) !== null && _f !== void 0 ? _f : 0,
                blendMode: ((_g = layer.blendMode) !== null && _g !== void 0 ? _g : 0),
                alpha: layer.opacity / 255,
                layer: worldLayer,
                physicsGroup: physicsGroup,
                bounds: bounds ? new RectBounds(bounds.x, bounds.y, bounds.width, bounds.height) : undefined,
                immovable: true,
            });
            worldObjects.push(sprite);
        }
    }
    catch (e_27_1) { e_27 = { error: e_27_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
        }
        finally { if (e_27) throw e_27.error; }
    }
    return worldObjects;
}
var CustomResourceLoader = /** @class */ (function () {
    function CustomResourceLoader(loadFn) {
        this.loadFn = loadFn;
        this._completionPercent = 0;
    }
    Object.defineProperty(CustomResourceLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    CustomResourceLoader.prototype.load = function (callback) {
        var _this = this;
        async(function () {
            _this.loadFn();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    return CustomResourceLoader;
}());
var FontLoader = /** @class */ (function () {
    function FontLoader(key, font) {
        this.key = key;
        this.font = font;
        this._completionPercent = 0;
    }
    Object.defineProperty(FontLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    FontLoader.prototype.load = function (callback) {
        var _this = this;
        var _a;
        var url = (_a = this.font.url) !== null && _a !== void 0 ? _a : this.key + ".png";
        new TextureLoader(this.key, {
            url: url,
            spritesheet: { frameWidth: this.font.charWidth, frameHeight: this.font.charHeight, anchor: Vector2.TOP_LEFT },
        }).load(function () {
            _this.onLoad();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    FontLoader.prototype.onLoad = function () {
        var mainTexture = AssetCache.textures[this.key];
        if (!mainTexture) {
            console.error("Failed to load tileset texture " + this.key);
            return;
        }
        var numCharsX = Math.floor(mainTexture.width / this.font.charWidth);
        var numCharsY = Math.floor(mainTexture.height / this.font.charHeight);
        if (numCharsX !== FontLoader.FONT_CHARACTERS[0].length || numCharsY !== FontLoader.FONT_CHARACTERS.length) {
            console.error("Font '" + this.key + "' does not have the proper number of characters in each dimension: " + numCharsX + "," + numCharsY + " (should be " + FontLoader.FONT_CHARACTERS[0].length + "," + FontLoader.FONT_CHARACTERS.length + ")");
            return;
        }
        var charTextures = {};
        for (var y = 0; y < FontLoader.FONT_CHARACTERS.length; y++) {
            for (var x = 0; x < FontLoader.FONT_CHARACTERS[y].length; x++) {
                var i = x + y * numCharsX;
                var char = FontLoader.FONT_CHARACTERS[y][x];
                AssetCache.textures[this.key + "/chars/" + char] = AssetCache.textures[this.key + "/" + i];
                delete AssetCache.textures[this.key + "/" + i];
                charTextures[char] = this.key + "/chars/" + char;
            }
        }
        if (this.font.customCharacters) {
            for (var char in this.font.customCharacters) {
                charTextures[char] = this.font.customCharacters[char];
            }
        }
        AssetCache.fonts[this.key] = {
            charTextures: charTextures,
            charWidth: this.font.charWidth,
            charHeight: this.font.charHeight,
            spaceWidth: this.font.spaceWidth,
            newlineHeight: this.font.newlineHeight
        };
    };
    FontLoader.FONT_CHARACTERS = [
        ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'],
        ['K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'],
        ['U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd'],
        ['e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],
        ['o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x'],
        ['y', 'z', '0', '1', '2', '3', '4', '5', '6', '7'],
        ['8', '9', '!', '@', '#', '$', '%', '^', '&', '*'],
        ['(', ')', '-', '_', '=', '+', '{', '}', '[', ']'],
        ['\\', '|', ';', ':', "'", '"', ',', '.', '<', '>'],
        ['/', '?', '`', '~', 'garbage1', 'garbage2', 'garbage3', 'garbage4', 'garbage5', 'missing'],
    ];
    return FontLoader;
}());
var LciLoader = /** @class */ (function () {
    function LciLoader(key, texture) {
        this.key = key;
        this.texture = texture;
        this._completionPercent = 0;
    }
    Object.defineProperty(LciLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    LciLoader.prototype.load = function (callback) {
        var _this = this;
        var _a;
        var url = Main.getRootPath() + 'assets/' + ((_a = this.texture.url) !== null && _a !== void 0 ? _a : this.key + ".lci");
        this.pixiLoader = new PIXI.Loader();
        this.pixiLoader.add(this.key, url);
        this.pixiLoader.load(function () { return _this.onLoadLci(callback); });
    };
    LciLoader.prototype.onLoadLci = function (callback) {
        var _this = this;
        this.lci = Lci.parseDocument(this.pixiLoader.resources[this.key].data);
        AssetCache.lciDocuments[this.key] = this.lci;
        new LoaderSystem(this.lci.layers
            .filter(function (layer) { return !layer.isDataLayer; })
            .map(function (layer) { return new TextureLoader(Lci.getLayerTextureKey(_this.key, layer.name), __assign(__assign({}, _this.texture), { anchor: layer.properties.anchor ? vec2(layer.properties.anchor) : _this.texture.anchor, url: layer.image })); })).load(function (t) { return null; }, function () {
            _this.onLoadTextures();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    LciLoader.prototype.onLoadTextures = function () {
        var e_29, _a;
        var _b, _c, _d, _e, _f;
        var fullTexture = new AnchoredTexture(new BasicTexture(this.lci.width, this.lci.height, 'LciLoader.onLoadTextures'));
        if (this.texture.anchor) {
            fullTexture.anchorX = this.texture.anchor.x;
            fullTexture.anchorY = this.texture.anchor.y;
        }
        try {
            for (var _g = __values(this.lci.layers), _h = _g.next(); !_h.done; _h = _g.next()) {
                var layer = _h.value;
                if (layer.isDataLayer)
                    continue;
                if (!layer.visible)
                    continue;
                var layerTexture = AssetCache.textures[Lci.getLayerTextureKey(this.key, layer.name)];
                if (!layerTexture) {
                    console.error("Failed to load LCI layer texture: " + Lci.getLayerTextureKey(this.key, layer.name));
                    continue;
                }
                layerTexture.renderTo(fullTexture, {
                    x: layer.position.x + ((_c = (_b = layer.properties.offset) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : 0),
                    y: layer.position.y + ((_e = (_d = layer.properties.offset) === null || _d === void 0 ? void 0 : _d.y) !== null && _e !== void 0 ? _e : 0),
                    alpha: layer.opacity / 255,
                    blendMode: ((_f = layer.blendMode) !== null && _f !== void 0 ? _f : 0),
                });
            }
        }
        catch (e_29_1) { e_29 = { error: e_29_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_29) throw e_29.error; }
        }
        AssetCache.textures[this.key] = fullTexture;
    };
    return LciLoader;
}());
var LoaderSystem = /** @class */ (function () {
    function LoaderSystem(loaders) {
        this.loaders = loaders;
    }
    LoaderSystem.prototype.load = function (progressCallback, callback) {
        var e_30, _a;
        var _this = this;
        this.progressCallback = progressCallback;
        this.callback = callback;
        try {
            for (var _b = __values(this.loaders), _c = _b.next(); !_c.done; _c = _b.next()) {
                var loader = _c.value;
                loader.load(function () { return _this.onLoaderLoad(); });
            }
        }
        catch (e_30_1) { e_30 = { error: e_30_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_30) throw e_30.error; }
        }
    };
    LoaderSystem.prototype.onLoaderLoad = function () {
        this.progressCallback(this.getLoadProgress());
        if (this.isLoadComplete()) {
            this.callback();
        }
    };
    LoaderSystem.prototype.getLoadProgress = function () {
        return A.sum(this.loaders, function (loader) { return loader.completionPercent; }) / this.loaders.length;
    };
    LoaderSystem.prototype.isLoadComplete = function () {
        return this.loaders.every(function (loader) { return loader.completionPercent >= 1; });
    };
    return LoaderSystem;
}());
var PyxelTilemapLoader = /** @class */ (function () {
    function PyxelTilemapLoader(key, tilemap) {
        this.key = key;
        this.tilemap = tilemap;
        this._completionPercent = 0;
    }
    Object.defineProperty(PyxelTilemapLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    PyxelTilemapLoader.prototype.load = function (callback) {
        var _this = this;
        var _a;
        var url = Main.getRootPath() + 'assets/' + ((_a = this.tilemap.url) !== null && _a !== void 0 ? _a : this.key + ".json");
        this.pixiLoader = new PIXI.Loader();
        this.pixiLoader.add(this.key, url);
        this.pixiLoader.load(function () {
            _this.onLoad();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    PyxelTilemapLoader.prototype.onLoad = function () {
        var e_31, _a;
        var tilemapResource = this.pixiLoader.resources[this.key];
        if (!tilemapResource || !tilemapResource.data) {
            console.error("Failed to load PyxelTilemap " + this.key);
            return;
        }
        var tilemapJson = tilemapResource.data;
        var tilemapForCache = {
            layers: [],
        };
        for (var i = 0; i < tilemapJson.layers.length; i++) {
            var tiles = A.filledArray2D(tilemapJson.tileshigh, tilemapJson.tileswide);
            try {
                for (var _b = (e_31 = void 0, __values(tilemapJson.layers[i].tiles)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tile = _c.value;
                    tiles[tile.y][tile.x] = {
                        index: Math.max(tile.tile, -1),
                        angle: tile.rot * 90,
                        flipX: tile.flipX,
                    };
                }
            }
            catch (e_31_1) { e_31 = { error: e_31_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_31) throw e_31.error; }
            }
            tilemapForCache.layers.unshift({
                name: tilemapJson.layers[i].name,
                tiles: tiles,
            });
        }
        AssetCache.tilemaps[this.key] = tilemapForCache;
    };
    return PyxelTilemapLoader;
}());
var SoundLoader = /** @class */ (function () {
    function SoundLoader(key, sound) {
        this.key = key;
        this.sound = sound;
        this._completionPercent = 0;
    }
    Object.defineProperty(SoundLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    SoundLoader.prototype.load = function (callback) {
        var _this = this;
        var _a;
        var url = Main.getRootPath() + 'assets/' + ((_a = this.sound.url) !== null && _a !== void 0 ? _a : this.key + ".aac");
        if (url.endsWith('.ogg')) {
            console.error("Do not use .ogg!", url);
        }
        WebAudio.preloadSound(this.key, url, function () {
            _this.onLoad();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    SoundLoader.prototype.onLoad = function () {
        var _a, _b;
        var preloadedSound = WebAudio.preloadedSounds[this.key];
        if (!preloadedSound) {
            console.error("Failed to load sound " + this.key);
            return;
        }
        var volume = (_a = this.sound.volume) !== null && _a !== void 0 ? _a : 1;
        if (volume < 0 || volume > Sound.MAX_VOLUME) {
            console.error("Sound " + this.key + " has invalid volume:", this.sound);
            volume = M.clamp(volume, 0, Sound.MAX_VOLUME);
        }
        var speed = (_b = this.sound.speed) !== null && _b !== void 0 ? _b : 1;
        if (speed < 0 || speed > Sound.MAX_SPEED) {
            console.error("Sound " + this.key + " has invalid speed:", this.sound);
            speed = M.clamp(speed, 0, Sound.MAX_SPEED);
        }
        AssetCache.sounds[this.key] = {
            buffer: preloadedSound.buffer,
            volume: volume,
            speed: speed
        };
    };
    return SoundLoader;
}());
var TextureLoader = /** @class */ (function () {
    function TextureLoader(key, texture) {
        this.key = key;
        this.texture = texture;
        this._completionPercent = 0;
    }
    Object.defineProperty(TextureLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    TextureLoader.prototype.load = function (callback) {
        var _this = this;
        var url = this.getUrl();
        this.pixiLoader = new PIXI.Loader();
        this.pixiLoader.add(this.key, url);
        this.pixiLoader.load(function () {
            _this.onLoad();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    TextureLoader.prototype.getUrl = function () {
        var _a;
        if (this.texture.url && this.texture.url.startsWith('data:'))
            return this.texture.url;
        return Main.getRootPath() + 'assets/' + ((_a = this.texture.url) !== null && _a !== void 0 ? _a : this.key + ".png");
    };
    TextureLoader.prototype.onLoad = function () {
        var baseTexture = this.pixiLoader.resources[this.key].texture.baseTexture;
        if (!baseTexture) {
            console.error("Failed to load texture " + this.key);
            return;
        }
        var mainTexture = new PIXI.Texture(baseTexture);
        var rect = this.texture.rect;
        var anchor = this.texture.anchor;
        if (rect) {
            mainTexture.frame = new Rectangle(rect.x, rect.y, rect.width, rect.height);
        }
        if (anchor) {
            mainTexture.defaultAnchor = new Point(anchor.x, anchor.y);
        }
        AssetCache.pixiTextures[this.key] = mainTexture;
        AssetCache.textures[this.key] = Texture.fromPixiTexture(mainTexture);
        var frames = TextureLoader.getAllFrames(this.key, this.texture);
        for (var frame in frames) {
            var frameTexture = new PIXI.Texture(baseTexture);
            var rect_2 = frames[frame].rect || this.texture.rect;
            var anchor_1 = frames[frame].anchor || this.texture.anchor;
            if (rect_2) {
                frameTexture.frame = new Rectangle(rect_2.x, rect_2.y, rect_2.width, rect_2.height);
            }
            if (anchor_1) {
                frameTexture.defaultAnchor = new Point(anchor_1.x, anchor_1.y);
            }
            AssetCache.pixiTextures[frame] = frameTexture;
            AssetCache.textures[frame] = Texture.fromPixiTexture(frameTexture);
        }
    };
    TextureLoader.getAllFrames = function (key, texture, width, height) {
        var _a;
        if (width === void 0) { width = AssetCache.textures[key].width; }
        if (height === void 0) { height = AssetCache.textures[key].height; }
        var frames = {};
        if (texture.spritesheet) {
            var numFramesX = Math.floor(width / texture.spritesheet.frameWidth);
            var numFramesY = Math.floor(height / texture.spritesheet.frameHeight);
            for (var y = 0; y < numFramesY; y++) {
                for (var x = 0; x < numFramesX; x++) {
                    var frameKeyPrefix = (_a = texture.spritesheet.prefix) !== null && _a !== void 0 ? _a : key + "/";
                    var frameKey = "" + frameKeyPrefix + (x + y * numFramesX);
                    frames[frameKey] = {
                        rect: {
                            x: x * texture.spritesheet.frameWidth,
                            y: y * texture.spritesheet.frameHeight,
                            width: texture.spritesheet.frameWidth,
                            height: texture.spritesheet.frameHeight
                        },
                        anchor: texture.spritesheet.anchor,
                    };
                }
            }
        }
        if (texture.frames) {
            for (var frame in texture.frames) {
                frames[frame] = texture.frames[frame];
            }
        }
        return frames;
    };
    return TextureLoader;
}());
var TilesetLoader = /** @class */ (function () {
    function TilesetLoader(key, tileset) {
        this.key = key;
        this.tileset = tileset;
        this._completionPercent = 0;
    }
    Object.defineProperty(TilesetLoader.prototype, "completionPercent", {
        get: function () { return this._completionPercent; },
        enumerable: false,
        configurable: true
    });
    TilesetLoader.prototype.load = function (callback) {
        var _this = this;
        var _a;
        var url = (_a = this.tileset.url) !== null && _a !== void 0 ? _a : this.key + ".png";
        new TextureLoader(this.key, {
            url: url,
            spritesheet: { frameWidth: this.tileset.tileWidth, frameHeight: this.tileset.tileHeight, anchor: Vector2.CENTER },
        }).load(function () {
            _this.onLoad();
            _this._completionPercent = 1;
            if (callback)
                callback();
        });
    };
    TilesetLoader.prototype.onLoad = function () {
        var _this = this;
        var mainTexture = AssetCache.textures[this.key];
        if (!mainTexture) {
            console.error("Failed to load tileset texture " + this.key);
            return;
        }
        var numTilesX = Math.floor(mainTexture.width / this.tileset.tileWidth);
        var numTilesY = Math.floor(mainTexture.height / this.tileset.tileHeight);
        var numTiles = numTilesX * numTilesY;
        var tiles = A.range(numTiles).map(function (i) { return _this.key + "/" + i; });
        AssetCache.tilesets[this.key] = {
            tileWidth: this.tileset.tileWidth,
            tileHeight: this.tileset.tileHeight,
            tiles: tiles,
            collisionIndices: this.tileset.collisionIndices,
        };
    };
    return TilesetLoader;
}());
/// <reference path="../world/world.ts" />
var Menu = /** @class */ (function (_super) {
    __extends(Menu, _super);
    function Menu(config) {
        if (config === void 0) { config = {}; }
        return _super.call(this, config) || this;
    }
    return Menu;
}(World));
/// <reference path="../worldObject.ts" />
var SpriteText = /** @class */ (function (_super) {
    __extends(SpriteText, _super);
    function SpriteText(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        var _this = _super.call(this, config) || this;
        _this.tagCache = {};
        if (config.font || SpriteText.DEFAULT_FONT) {
            _this._fontKey = (_a = config.font) !== null && _a !== void 0 ? _a : SpriteText.DEFAULT_FONT;
            _this.font = AssetCache.getFont(_this._fontKey);
        }
        else {
            console.error("SpriteText must have a font provided, or a default font set");
        }
        if (!_this.font) {
            _this.font = {
                charTextures: {},
                charWidth: 0,
                charHeight: 0,
                spaceWidth: 0,
                newlineHeight: 0
            };
        }
        _this._style = _.defaults(O.deepClone((_b = config.style) !== null && _b !== void 0 ? _b : {}), requireType({
            color: 0xFFFFFF,
            alpha: 1,
            offsetX: 0,
            offsetY: 0,
            filters: [],
        }));
        _this.visibleCharCount = Infinity;
        _this.maxWidth = (_c = config.maxWidth) !== null && _c !== void 0 ? _c : Infinity;
        _this.anchor = (_d = config.anchor) !== null && _d !== void 0 ? _d : Vector2.TOP_LEFT;
        _this.justify = (_e = config.justify) !== null && _e !== void 0 ? _e : 'left';
        _this.alpha = (_f = config.alpha) !== null && _f !== void 0 ? _f : 1;
        _this.flipX = (_g = config.flipX) !== null && _g !== void 0 ? _g : false;
        _this.flipY = (_h = config.flipY) !== null && _h !== void 0 ? _h : false;
        _this.scaleX = (_j = config.scaleX) !== null && _j !== void 0 ? _j : ((_k = config.scale) !== null && _k !== void 0 ? _k : 1);
        _this.scaleY = (_l = config.scaleY) !== null && _l !== void 0 ? _l : ((_m = config.scale) !== null && _m !== void 0 ? _m : 1);
        _this.angle = (_o = config.angle) !== null && _o !== void 0 ? _o : 0;
        _this.angleOffset = (_p = config.angleOffset) !== null && _p !== void 0 ? _p : 0;
        _this.effects = new Effects();
        _this.effects.updateFromConfig(config.effects);
        _this.mask = config.mask;
        _this.setText((_q = config.text) !== null && _q !== void 0 ? _q : "");
        _this.dirty = true;
        return _this;
    }
    Object.defineProperty(SpriteText.prototype, "fontKey", {
        get: function () { return this._fontKey; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteText.prototype, "style", {
        get: function () { return this._style; },
        set: function (value) {
            this._style.alpha = value.alpha;
            this._style.color = value.color;
            this._style.offsetX = value.offsetX;
            this._style.offsetY = value.offsetY;
            this._style.filters = A.clone(value.filters);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteText.prototype, "maxWidth", {
        get: function () { return this._maxWidth; },
        set: function (value) {
            if (this._maxWidth === value)
                return;
            this._maxWidth = value;
            this.dirty = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteText.prototype, "visibleCharCount", {
        get: function () { return this._visibleCharCount; },
        set: function (value) {
            this._visibleCharCount = value;
            this.dirty = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteText.prototype, "justify", {
        get: function () { return this._justify; },
        set: function (value) {
            this._justify = value;
            this.dirty = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteText.prototype, "scale", {
        get: function () {
            if (this.scaleX !== this.scaleY)
                console.error('Warning: scaleX and scaleY differ! Attempted to get scale!');
            return this.scaleX;
        },
        set: function (value) {
            this.scaleX = value;
            this.scaleY = value;
        },
        enumerable: false,
        configurable: true
    });
    SpriteText.prototype.onRemove = function () {
        _super.prototype.onRemove.call(this);
        SpriteTextConverter.returnStaticTextures(this.staticTextures);
        this.staticTextures = undefined;
        this.dirty = true;
    };
    SpriteText.prototype.update = function () {
        var e_32, _a;
        _super.prototype.update.call(this);
        this.effects.updateEffects(this.delta);
        for (var key in this.tagCache) {
            if (_.isEmpty(this.tagCache[key].filters))
                continue;
            try {
                for (var _b = (e_32 = void 0, __values(this.tagCache[key].filters)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var filter = _c.value;
                    filter.updateTime(this.delta);
                }
            }
            catch (e_32_1) { e_32 = { error: e_32_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_32) throw e_32.error; }
            }
        }
    };
    SpriteText.prototype.render = function (texture, x, y) {
        if (this.dirty) {
            this.renderSpriteText();
            this.dirty = false;
        }
        var anchorOffsetX = Math.round(-this.anchor.x * this.getTextWidth());
        var anchorOffsetY = Math.round(-this.anchor.y * this.getTextHeight());
        for (var key in this.staticTextures) {
            var data = this.staticTextures[key];
            var style = this.getStyleFromTags(data.tagData, this.style);
            data.texture.renderTo(texture, {
                x: x + anchorOffsetX + (data.x + style.offsetX) * (this.flipX ? -1 : 1) * this.scaleX,
                y: y + anchorOffsetY + (data.y + style.offsetY) * (this.flipY ? -1 : 1) * this.scaleY,
                tint: style.color,
                alpha: this.alpha * style.alpha,
                scaleX: (this.flipX ? -1 : 1) * this.scaleX,
                scaleY: (this.flipY ? -1 : 1) * this.scaleY,
                angle: this.angle + this.angleOffset,
                filters: __spread(style.filters, this.effects.getFilterList()),
                mask: TextureFilters.Mask.getTextureMaskForWorldObject(this.mask, this, x, y),
            });
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    SpriteText.prototype.renderSpriteText = function () {
        SpriteText.justify(this.chars, this.justify);
        var chars = _.flatten(this.chars);
        var charCount = Math.min(this.visibleCharCount, chars.length);
        SpriteTextConverter.returnStaticTextures(this.staticTextures);
        this.staticTextures = SpriteTextConverter.getStaticTexturesForCharList(chars, charCount);
        for (var i = 0; i < charCount; i++) {
            var char = chars[i];
            var charTexture = AssetCache.getTexture(this.font.charTextures[char.char]);
            var staticTextureData = this.staticTextures[char.part];
            charTexture.renderTo(staticTextureData.texture, {
                x: char.x - staticTextureData.x,
                y: char.y - staticTextureData.y,
            });
        }
    };
    SpriteText.prototype.addText = function (text) {
        this.setText("" + this.currentText + text);
    };
    SpriteText.prototype.allCharactersVisible = function () {
        return this.visibleCharCount >= this.getCharList().length;
    };
    SpriteText.prototype.clear = function () {
        this.setText("");
    };
    SpriteText.prototype.getCharList = function () {
        return _.flatten(this.chars);
    };
    SpriteText.prototype.getCurrentText = function () {
        return this.currentText;
    };
    SpriteText.prototype.getTextWidth = function () {
        return SpriteText.getWidthOfCharList(_.flatten(this.chars), this.visibleCharCount) * this.scaleX;
    };
    SpriteText.prototype.getTextHeight = function () {
        return SpriteText.getHeightOfCharList(_.flatten(this.chars), this.visibleCharCount) * this.scaleY;
    };
    SpriteText.prototype.getTextWorldBounds = function () {
        var textWidth = this.getTextWidth();
        var textHeight = this.getTextHeight();
        return {
            x: this.x - this.anchor.x * textWidth,
            y: this.y - this.anchor.y * textHeight,
            width: textWidth,
            height: textHeight,
        };
    };
    SpriteText.prototype.getVisibleScreenBounds = function () {
        var bounds = this.getTextWorldBounds();
        bounds.x += this.getRenderScreenX() - this.x;
        bounds.y += this.getRenderScreenY() - this.y;
        return bounds;
    };
    SpriteText.prototype.setFont = function (fontKey) {
        if (fontKey === this.fontKey)
            return;
        var font = AssetCache.getFont(fontKey);
        if (!font) {
            console.error("Cannot set SpriteText font, font not found: " + fontKey);
            return;
        }
        this.font = font;
        this._fontKey = fontKey;
        this.dirty = true;
    };
    SpriteText.prototype.setText = function (text) {
        if (text === this.currentText)
            return;
        this.chars = SpriteTextConverter.textToCharListWithWordWrap(text, this.font, this.maxWidth);
        this.currentText = text;
        this.dirty = true;
    };
    // May still need work
    SpriteText.prototype.toTexture = function () {
        var width = this.getTextWidth();
        var height = this.getTextHeight();
        var texture = new BasicTexture(width, height, 'SpriteText.toTexture', false);
        var anchorOffsetX = Math.round(this.anchor.x * width);
        var anchorOffsetY = Math.round(this.anchor.y * height);
        this.render(texture, anchorOffsetX, anchorOffsetY);
        return new AnchoredTexture(texture, this.anchor.x, this.anchor.y);
    };
    SpriteText.prototype.getStyleFromTags = function (tagData, defaults) {
        var e_33, _a, _b;
        var result = { filters: [] };
        try {
            for (var tagData_1 = __values(tagData), tagData_1_1 = tagData_1.next(); !tagData_1_1.done; tagData_1_1 = tagData_1.next()) {
                var data = tagData_1_1.value;
                var style = this.getTagStyle(data.tag, data.params);
                if (style.color !== undefined)
                    result.color = style.color;
                if (style.alpha !== undefined)
                    result.alpha = style.alpha;
                if (style.offsetX !== undefined)
                    result.offsetX = style.offsetX;
                if (style.offsetY !== undefined)
                    result.offsetY = style.offsetY;
                if (!_.isEmpty(style.filters))
                    (_b = result.filters).push.apply(_b, __spread(style.filters));
            }
        }
        catch (e_33_1) { e_33 = { error: e_33_1 }; }
        finally {
            try {
                if (tagData_1_1 && !tagData_1_1.done && (_a = tagData_1.return)) _a.call(tagData_1);
            }
            finally { if (e_33) throw e_33.error; }
        }
        _.defaults(result, defaults);
        return result;
    };
    SpriteText.prototype.getTagStyle = function (name, params) {
        var cacheKey = __spread([name], params).join(' ');
        if (cacheKey in this.tagCache) {
            return this.tagCache[cacheKey];
        }
        var tag = SpriteText.TAGS[name];
        if (!tag) {
            console.error("Tag not found: " + name);
            tag = SpriteText.TAGS[SpriteText.NOOP_TAG];
        }
        var style = tag(params);
        this.tagCache[cacheKey] = style;
        return style;
    };
    SpriteText.DEFAULT_FONT = undefined;
    return SpriteText;
}(WorldObject));
(function (SpriteText) {
    var _a;
    var Character = /** @class */ (function () {
        function Character() {
        }
        Object.defineProperty(Character.prototype, "left", {
            get: function () {
                return this.x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Character.prototype, "right", {
            get: function () {
                return this.x + this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Character.prototype, "top", {
            get: function () {
                return this.y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Character.prototype, "bottom", {
            get: function () {
                return this.y + this.height;
            },
            enumerable: false,
            configurable: true
        });
        return Character;
    }());
    SpriteText.Character = Character;
    function addTags(tags) {
        for (var key in tags) {
            if (key in SpriteText.TAGS) {
                debug("A SpriteText tag already exists with name " + key + ":", SpriteText.TAGS[key]);
            }
            SpriteText.TAGS[key] = tags[key];
        }
    }
    SpriteText.addTags = addTags;
    function getWidthOfCharList(list, charCount) {
        if (_.isEmpty(list))
            return 0;
        charCount = Math.min(charCount !== null && charCount !== void 0 ? charCount : list.length, list.length);
        var min = M.min(list, function (char) { return char.left; });
        var max = M.max(list, function (char) { return char.right; });
        return max - min;
    }
    SpriteText.getWidthOfCharList = getWidthOfCharList;
    function getHeightOfCharList(list, charCount) {
        if (_.isEmpty(list))
            return 0;
        charCount = Math.min(charCount !== null && charCount !== void 0 ? charCount : list.length, list.length);
        var result = 0;
        for (var i = 0; i < charCount; i++) {
            if (list[i].bottom > result)
                result = list[i].bottom;
        }
        return result;
    }
    SpriteText.getHeightOfCharList = getHeightOfCharList;
    function justify(lines, justify) {
        var e_34, _a, e_35, _b;
        var maxWidth = SpriteText.getWidthOfCharList(_.flatten(lines));
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                if (line.length === 0)
                    continue;
                var lineWidth = SpriteText.getWidthOfCharList(line);
                var lineX = (maxWidth - lineWidth) * justifyToX(justify);
                var minX = M.min(line, function (char) { return char.x; });
                var dx = lineX - minX;
                try {
                    for (var line_1 = (e_35 = void 0, __values(line)), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
                        var char = line_1_1.value;
                        char.x += dx;
                    }
                }
                catch (e_35_1) { e_35 = { error: e_35_1 }; }
                finally {
                    try {
                        if (line_1_1 && !line_1_1.done && (_b = line_1.return)) _b.call(line_1);
                    }
                    finally { if (e_35) throw e_35.error; }
                }
            }
        }
        catch (e_34_1) { e_34 = { error: e_34_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_34) throw e_34.error; }
        }
    }
    SpriteText.justify = justify;
    function justifyToX(justify) {
        if (justify === 'left')
            return 0;
        if (justify === 'center')
            return 0.5;
        return 1;
    }
    SpriteText.NOOP_TAG = 'noop';
    SpriteText.TAGS = (_a = {},
        _a[SpriteText.NOOP_TAG] = function (params) {
            return {};
        },
        _a['y'] = function (params) {
            return { color: 0xFFFF00 };
        },
        _a['g'] = function (params) {
            return { color: 0x00FF00 };
        },
        _a['r'] = function (params) {
            return { color: 0xFF0000 };
        },
        _a['color'] = function (params) {
            return { color: getInt(params[0], undefined) };
        },
        _a['offset'] = function (params) {
            return { offsetX: getFloat(params[0], undefined), offsetY: getFloat(params[1], undefined) };
        },
        _a['offsetx'] = function (params) {
            return { offsetX: getFloat(params[0], undefined) };
        },
        _a['offsety'] = function (params) {
            return { offsetY: getFloat(params[0], undefined) };
        },
        _a);
    function getInt(text, def) {
        var result = parseInt(text);
        if (!isFinite(result))
            return def;
        return result;
    }
    function getFloat(text, def) {
        var result = parseFloat(text);
        if (!isFinite(result))
            return def;
        return result;
    }
})(SpriteText || (SpriteText = {}));
/// <reference path="../worldObject/spriteText/spriteText.ts" />
var MenuTextButton = /** @class */ (function (_super) {
    __extends(MenuTextButton, _super);
    function MenuTextButton(config) {
        var _a, _b;
        var _this = _super.call(this, config) || this;
        _this.bounds = new RectBounds(0, 0, 0, 0, _this);
        var button = _this.addModule(new Button({
            hoverTint: (_a = config.hoverColor) !== null && _a !== void 0 ? _a : 0x808080,
            clickTint: (_b = config.hoverColor) !== null && _b !== void 0 ? _b : 0x808080,
            onHover: function () {
                if (config.onHover)
                    config.onHover.apply(_this);
            },
            onJustHovered: function () {
                if (config.onJustHovered)
                    config.onJustHovered.apply(_this);
            },
            onClick: function () {
                if (config.onClick)
                    config.onClick.apply(_this);
            }
        }));
        button.baseTint = _this.tint;
        return _this;
    }
    Object.defineProperty(MenuTextButton.prototype, "tint", {
        get: function () { return this.style.color; },
        set: function (value) { this.style.color = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MenuTextButton.prototype, "enabled", {
        get: function () { var _a; return (_a = this.getModule(Button)) === null || _a === void 0 ? void 0 : _a.enabled; },
        set: function (value) {
            var button = this.getModule(Button);
            if (button)
                button.enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    MenuTextButton.prototype.update = function () {
        _super.prototype.update.call(this);
        this.setBounds();
    };
    MenuTextButton.prototype.setBounds = function () {
        var textBounds = this.getTextWorldBounds();
        this.bounds.x = textBounds.x - this.x;
        this.bounds.y = textBounds.y - this.y;
        this.bounds.width = textBounds.width;
        this.bounds.height = textBounds.height;
    };
    return MenuTextButton;
}(SpriteText));
var MenuNumericSelector = /** @class */ (function (_super) {
    __extends(MenuNumericSelector, _super);
    function MenuNumericSelector(config) {
        var _this = _super.call(this, config) || this;
        _this.barLength = config.barLength;
        _this.minValue = config.minValue;
        _this.maxValue = config.maxValue;
        _this.getValue = config.getValue;
        _this.setValue = config.setValue;
        var leftButton = _this.addChild(new MenuTextButton({
            font: _this.fontKey,
            text: "\\<",
            onClick: function () {
                global.game.playSound('click');
                var bars = _this.getFullBarsForValue(_this.getValue());
                if (bars > 0) {
                    var newValue = _this.getValueForFullBars(bars - 1);
                    _this.setValue(newValue);
                }
            }
        }));
        leftButton.style = _this.style;
        var rightButton = _this.addChild(new MenuTextButton({
            font: _this.fontKey,
            text: ">",
            onClick: function () {
                global.game.playSound('click');
                var bars = _this.getFullBarsForValue(_this.getValue());
                if (bars < _this.barLength) {
                    var newValue = _this.getValueForFullBars(bars + 1);
                    _this.setValue(newValue);
                }
            }
        }));
        rightButton.localx = (_this.barLength + 3) * _this.font.charWidth;
        rightButton.style = _this.style;
        return _this;
    }
    MenuNumericSelector.prototype.update = function () {
        _super.prototype.update.call(this);
        var fullBars = this.getFullBarsForValue(this.getValue());
        var text = "  " + "[color 0xCCCCCC]|[/color]".repeat(fullBars) + "[color 0x444444]|[/color]".repeat(this.barLength - fullBars);
        this.setText(text);
    };
    MenuNumericSelector.prototype.getFullBarsForValue = function (value) {
        var valueNormalized = M.clamp((value - this.minValue) / (this.maxValue - this.minValue), 0, 1);
        return Math.floor(valueNormalized * this.barLength);
    };
    MenuNumericSelector.prototype.getValueForFullBars = function (fullBars) {
        var fullBarsNormalized = fullBars / this.barLength;
        return this.minValue + (this.maxValue - this.minValue) * fullBarsNormalized;
    };
    return MenuNumericSelector;
}(SpriteText));
var MenuSystem = /** @class */ (function () {
    function MenuSystem(game) {
        this.game = game;
        this.menuStack = [];
    }
    Object.defineProperty(MenuSystem.prototype, "currentMenu", {
        get: function () { return _.last(this.menuStack); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MenuSystem.prototype, "inMenu", {
        get: function () { return !!this.currentMenu; },
        enumerable: false,
        configurable: true
    });
    MenuSystem.prototype.update = function () {
        if (this.inMenu) {
            this.currentMenu.update();
        }
    };
    MenuSystem.prototype.render = function (screen) {
        if (this.inMenu) {
            this.currentMenu.render(screen, 0, 0);
        }
    };
    MenuSystem.prototype.back = function () {
        if (this.inMenu)
            this.menuStack.pop();
    };
    MenuSystem.prototype.clear = function () {
        this.menuStack = [];
    };
    MenuSystem.prototype.loadMenu = function (menuFactory) {
        var instance = menuFactory();
        this.menuStack.push(instance);
    };
    return MenuSystem;
}());
var MobileScaleManager = /** @class */ (function () {
    function MobileScaleManager() {
    }
    MobileScaleManager.init = function () {
        this.scale(this.getScale());
    };
    MobileScaleManager.update = function () {
        var newScale = this.getScale();
        if (newScale !== this.currentScale) {
            this.scale(newScale);
        }
    };
    MobileScaleManager.scale = function (s) {
        Main.renderer.view.style.transform = "scale(" + s + ")";
        this.currentScale = s;
    };
    MobileScaleManager.getScale = function () {
        return Math.min(window.innerWidth / Main.getScaledWidth(), window.innerHeight / Main.getScaledHeight());
    };
    return MobileScaleManager;
}());
var MobileUtils;
(function (MobileUtils) {
    function isMobileBrowser() {
        var check = false;
        (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true; })(navigator.userAgent || navigator.vendor);
        return check;
    }
    MobileUtils.isMobileBrowser = isMobileBrowser;
    ;
})(MobileUtils || (MobileUtils = {}));
var TouchManager = /** @class */ (function () {
    function TouchManager() {
    }
    Object.defineProperty(TouchManager, "isTouching", {
        get: function () { return this.touches.length > 0; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TouchManager, "touch", {
        get: function () { return this.isTouching ? this.touches[0] : undefined; },
        enumerable: false,
        configurable: true
    });
    TouchManager.handleTouchStartEvent = function (event) {
        // TODO: handle multiple touches at some point
        if (this.isTouching)
            return;
        for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            this.touches.push(this.getTouchData(touch));
        }
        if (this.isTouching && this.onTouchDown)
            this.onTouchDown();
    };
    TouchManager.handleTouchMoveEvent = function (event) {
        var _loop_1 = function (i) {
            var touch = event.changedTouches[i];
            var index = this_1.touches.findIndex(function (td) { return td.id === touch.identifier; });
            if (index >= 0) {
                this_1.touches[index] = this_1.getTouchData(touch);
            }
        };
        var this_1 = this;
        for (var i = 0; i < event.changedTouches.length; i++) {
            _loop_1(i);
        }
    };
    TouchManager.handleTouchEndEvent = function (event) {
        var _loop_2 = function (i) {
            var touch = event.changedTouches[i];
            var index = this_2.touches.findIndex(function (td) { return td.id === touch.identifier; });
            if (index >= 0) {
                this_2.touches.splice(index, 1);
            }
        };
        var this_2 = this;
        for (var i = 0; i < event.changedTouches.length; i++) {
            _loop_2(i);
        }
        if (!this.isTouching && this.onTouchUp)
            this.onTouchUp();
    };
    TouchManager.handleTouchCancelEvent = function (event) {
        var _loop_3 = function (i) {
            var touch = event.changedTouches[i];
            var index = this_3.touches.findIndex(function (td) { return td.id === touch.identifier; });
            if (index >= 0) {
                this_3.touches.splice(index, 1);
            }
        };
        var this_3 = this;
        for (var i = 0; i < event.changedTouches.length; i++) {
            _loop_3(i);
        }
        if (!this.isTouching && this.onTouchUp)
            this.onTouchUp();
    };
    TouchManager.getTouchData = function (touch) {
        var bounds = Main.renderer.view.getBoundingClientRect();
        return {
            id: touch.identifier,
            x: M.map(touch.pageX, bounds.left, bounds.right, 0, global.gameWidth),
            y: M.map(touch.pageY, bounds.top, bounds.bottom, 0, global.gameHeight),
            radius: 10,
        };
    };
    TouchManager.touches = [];
    return TouchManager;
}());
var Persistence;
(function (Persistence) {
    Persistence.profileData = {
        profileId: '',
        totalPlayTime: 0,
        lastPlayed: 0,
    };
    Persistence.sessionData = {
        profileId: '',
        startTime: 0,
        playTime: 0,
        averageFrameRate: 0,
    };
    var registeredUpdaters = {};
    var registeredSubmitters = {};
    var sessionFrames;
    function init() {
        var now = Date.now();
        Persistence.profileData.profileId = now + "_" + new UIDGenerator().generate();
        Persistence.profileData.totalPlayTime = 0;
        var loadedData = load();
        if (loadedData) {
            for (var key in loadedData) {
                Persistence.profileData[key] = loadedData[key];
            }
        }
        Persistence.profileData.lastPlayed = now;
        Persistence.sessionData.profileId = Persistence.profileData.profileId;
        Persistence.sessionData.startTime = now;
        Persistence.sessionData.playTime = 0;
        Persistence.sessionData.averageFrameRate = 0;
        sessionFrames = 0;
    }
    Persistence.init = init;
    function update(delta) {
        Persistence.profileData.totalPlayTime += delta;
        Persistence.sessionData.playTime += delta;
        sessionFrames++;
        if (Persistence.sessionData.playTime > 0)
            Persistence.sessionData.averageFrameRate = sessionFrames / Persistence.sessionData.playTime;
    }
    Persistence.update = update;
    function submit() {
        for (var key in registeredSubmitters) {
            var value = registeredSubmitters[key].get();
            Persistence.profileData[key] = value;
            Persistence.sessionData[key] = value;
        }
        save();
    }
    Persistence.submit = submit;
    function getProfileId() {
        return Persistence.profileData.profileId;
    }
    Persistence.getProfileId = getProfileId;
    function getAverageFrameRate() {
        return Persistence.sessionData.averageFrameRate;
    }
    Persistence.getAverageFrameRate = getAverageFrameRate;
    function registerUpdater(key, initialValue) {
        var _a, _b;
        if (key in registeredUpdaters) {
            console.error("Persistence Updater '" + key + "' has already been registered");
            return registeredUpdaters[key];
        }
        var registeredUpdater = {
            update: function (updateFn) {
                Persistence.profileData[key] = updateFn(Persistence.profileData[key]);
                Persistence.sessionData[key] = updateFn(Persistence.sessionData[key]);
            },
        };
        registeredUpdaters[key] = registeredUpdater;
        Persistence.profileData[key] = (_a = Persistence.profileData[key]) !== null && _a !== void 0 ? _a : initialValue;
        Persistence.sessionData[key] = (_b = Persistence.sessionData[key]) !== null && _b !== void 0 ? _b : initialValue;
        return registeredUpdater;
    }
    Persistence.registerUpdater = registerUpdater;
    function registerSubmitter(key, get) {
        if (key in registeredSubmitters) {
            console.error("Persistence Submitter '" + key + "' has already been registered");
            return;
        }
        var registeredSubmitter = {
            get: get,
        };
        registeredSubmitters[key] = registeredSubmitter;
    }
    Persistence.registerSubmitter = registerSubmitter;
    function load() {
        try {
            var encoded = LocalStorage.getString(global.gameCodeName + "_analytics");
            return JSON.parse(St.decodeB64S(encoded));
        }
        catch (_a) {
            return undefined;
        }
    }
    function save() {
        var encoded = St.encodeB64S(JSON.stringify(Persistence.profileData));
        LocalStorage.setString(global.gameCodeName + "_analytics", encoded);
    }
})(Persistence || (Persistence = {}));
var S;
(function (S) {
    // There is no async function. Use global.script.world.runScript(scriptFunction) instead.
    function call(func) {
        return function () {
            return __generator(this, function (_a) {
                func();
                return [2 /*return*/];
            });
        };
    }
    S.call = call;
    function callAfterTime(time, func) {
        return S.chain(S.wait(time), S.call(func));
    }
    S.callAfterTime = callAfterTime;
    function chain() {
        var scriptFunctions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            scriptFunctions[_i] = arguments[_i];
        }
        return function () {
            var scriptFunctions_1, scriptFunctions_1_1, scriptFunction, e_36_1;
            var e_36, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 7]);
                        scriptFunctions_1 = __values(scriptFunctions), scriptFunctions_1_1 = scriptFunctions_1.next();
                        _b.label = 1;
                    case 1:
                        if (!!scriptFunctions_1_1.done) return [3 /*break*/, 4];
                        scriptFunction = scriptFunctions_1_1.value;
                        return [4 /*yield*/, scriptFunction];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        scriptFunctions_1_1 = scriptFunctions_1.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_36_1 = _b.sent();
                        e_36 = { error: e_36_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (scriptFunctions_1_1 && !scriptFunctions_1_1.done && (_a = scriptFunctions_1.return)) _a.call(scriptFunctions_1);
                        }
                        finally { if (e_36) throw e_36.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        };
    }
    S.chain = chain;
    function doOverTime(time, func) {
        return function () {
            var t;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        t = new Timer(OrFactory.resolve(time));
                        _a.label = 1;
                    case 1:
                        if (!!t.done) return [3 /*break*/, 3];
                        func(t.progress);
                        t.update(global.script.delta);
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        func(1);
                        return [2 /*return*/];
                }
            });
        };
    }
    S.doOverTime = doOverTime;
    /**
     * Runs a list of script functions and stops when one of them ends.
     */
    function either() {
        var scriptFunctions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            scriptFunctions[_i] = arguments[_i];
        }
        return function () {
            var scripts, scripts_1, scripts_1_1, script;
            var e_37, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        scripts = scriptFunctions.map(function (sfn) { return new Script(sfn); });
                        if (_.isEmpty(scripts))
                            return [2 /*return*/];
                        _b.label = 1;
                    case 1:
                        if (!!scripts.some(function (s) { return s.done; })) return [3 /*break*/, 4];
                        try {
                            for (scripts_1 = (e_37 = void 0, __values(scripts)), scripts_1_1 = scripts_1.next(); !scripts_1_1.done; scripts_1_1 = scripts_1.next()) {
                                script = scripts_1_1.value;
                                script.update(global.script.delta);
                            }
                        }
                        catch (e_37_1) { e_37 = { error: e_37_1 }; }
                        finally {
                            try {
                                if (scripts_1_1 && !scripts_1_1.done && (_a = scripts_1.return)) _a.call(scripts_1);
                            }
                            finally { if (e_37) throw e_37.error; }
                        }
                        if (!!scripts.some(function (s) { return s.done; })) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        };
    }
    S.either = either;
    function loopFor(count, scriptFunctionIter, yieldAfterLoop) {
        if (yieldAfterLoop === void 0) { yieldAfterLoop = false; }
        return function () {
            var i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < count)) return [3 /*break*/, 5];
                        return [4 /*yield*/, scriptFunctionIter(i)];
                    case 2:
                        _a.sent();
                        if (!yieldAfterLoop) return [3 /*break*/, 4];
                        return [4 /*yield*/];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        };
    }
    S.loopFor = loopFor;
    function loopUntil(condition, scriptFunction) {
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!condition()) return [3 /*break*/, 2];
                        return [4 /*yield*/, scriptFunction];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 0];
                    case 2: return [2 /*return*/];
                }
            });
        };
    }
    S.loopUntil = loopUntil;
    function noop() {
        return function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); };
    }
    S.noop = noop;
    function revealText(text, rate, sound) {
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        text.visibleCharCount = 0;
                        return [4 /*yield*/];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!!text.allCharactersVisible()) return [3 /*break*/, 4];
                        text.visibleCharCount++;
                        if (sound)
                            global.world.playSound(sound);
                        return [4 /*yield*/, S.wait(1 / rate)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 2];
                    case 4: return [2 /*return*/];
                }
            });
        };
    }
    S.revealText = revealText;
    function schedule() {
        var schedule = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            schedule[_i] = arguments[_i];
        }
        var fns = [];
        for (var i = 0; i < schedule.length; /* no incr */) {
            var t = schedule[i];
            var s = i + 1 < schedule.length ? schedule[i + 1] : S.noop();
            if (!_.isNumber(t)) {
                fns.push({ t: 0, s: t });
                i++;
            }
            else if (_.isNumber(s)) {
                fns.push({ t: t, s: S.noop() });
                i++;
            }
            else {
                fns.push({ t: t, s: s });
                i += 2;
            }
        }
        return S.simul.apply(S, __spread(fns.map(function (fn) { return S.chain(S.wait(fn.t), fn.s); })));
    }
    S.schedule = schedule;
    function setData(prop, value) {
        return function () {
            return __generator(this, function (_a) {
                global.script.data[prop] = value;
                return [2 /*return*/];
            });
        };
    }
    S.setData = setData;
    function simul() {
        var scriptFunctions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            scriptFunctions[_i] = arguments[_i];
        }
        return function () {
            var scripts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        scripts = scriptFunctions.map(function (sfn) { return new Script(sfn); });
                        _a.label = 1;
                    case 1:
                        if (!!_.isEmpty(scripts)) return [3 /*break*/, 4];
                        scripts = scripts.filter(function (script) {
                            script.update(global.script.delta);
                            return !script.done;
                        });
                        if (!!_.isEmpty(scripts)) return [3 /*break*/, 3];
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        };
    }
    S.simul = simul;
    function tween(duration, obj, prop, start, end, easingFunction) {
        if (easingFunction === void 0) { easingFunction = Tween.Easing.Linear; }
        return function () {
            var tween;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tween = new Tween(start, end, OrFactory.resolve(duration), easingFunction);
                        _a.label = 1;
                    case 1:
                        if (!!tween.done) return [3 /*break*/, 3];
                        tween.update(global.script.delta);
                        obj[prop] = tween.value;
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        obj[prop] = end;
                        return [2 /*return*/];
                }
            });
        };
    }
    S.tween = tween;
    function tweenPt(duration, pt, start, end, easingFunction) {
        if (easingFunction === void 0) { easingFunction = Tween.Easing.Linear; }
        var startx = start.x;
        var starty = start.y;
        var endx = end.x;
        var endy = end.y;
        return S.simul(S.tween(duration, pt, 'x', startx, endx, easingFunction), S.tween(duration, pt, 'y', starty, endy, easingFunction));
    }
    S.tweenPt = tweenPt;
    function wait(time) {
        return doOverTime(time, function (t) { return null; });
    }
    S.wait = wait;
    function waitUntil(condition) {
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!condition()) return [3 /*break*/, 2];
                        return [4 /*yield*/];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 0];
                    case 2: return [2 /*return*/];
                }
            });
        };
    }
    S.waitUntil = waitUntil;
    function yield() {
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    }
    S.yield = yield;
})(S || (S = {}));
var Script = /** @class */ (function () {
    function Script(scriptFunction, name) {
        this.iterator = this.buildIterator(scriptFunction)();
        this.name = name;
        this.data = {};
    }
    Object.defineProperty(Script.prototype, "running", {
        get: function () {
            return !this.paused && !this.done;
        },
        enumerable: false,
        configurable: true
    });
    Script.prototype.update = function (delta) {
        if (!this.running)
            return;
        global.pushScript(this);
        this.delta = delta;
        var result = this.iterator.next();
        if (result.done) {
            this.done = true;
        }
        global.popScript();
    };
    Script.prototype.finishImmediately = function (maxIters) {
        if (maxIters === void 0) { maxIters = Script.FINISH_IMMEDIATELY_MAX_ITERS; }
        for (var i = 0; i < maxIters && !this.done; i++) {
            this.update(0.1);
        }
        if (!this.done) {
            console.error('Warning: script finishImmediately exceeded max iters!', this);
            this.done = true;
        }
    };
    Script.prototype.stop = function () {
        this.done = true;
    };
    Script.prototype.buildIterator = function (scriptFunction) {
        var s = this;
        return function () {
            var iterator, result, script;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        iterator = scriptFunction();
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 8];
                        result = iterator.next();
                        if (!result.value) return [3 /*break*/, 5];
                        if (_.isArray(result.value)) {
                            result.value = S.simul.apply(S, __spread(result.value.map(function (scr) { return s.buildIterator(scr); })));
                        }
                        script = new Script(result.value);
                        _a.label = 2;
                    case 2:
                        if (!!script.done) return [3 /*break*/, 4];
                        script.update(global.script.delta);
                        if (script.done)
                            return [3 /*break*/, 4];
                        return [4 /*yield*/];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 2];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        if (!!result.done) return [3 /*break*/, 7];
                        return [4 /*yield*/];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (result.done)
                            return [3 /*break*/, 8];
                        return [3 /*break*/, 1];
                    case 8: return [2 /*return*/];
                }
            });
        };
    };
    Script.FINISH_IMMEDIATELY_MAX_ITERS = 1000000;
    return Script;
}());
(function (Script) {
    function instant(scriptFunction, maxIters) {
        new Script(scriptFunction).finishImmediately(maxIters);
    }
    Script.instant = instant;
})(Script || (Script = {}));
var ScriptManager = /** @class */ (function () {
    function ScriptManager() {
        this.activeScripts = [];
    }
    ScriptManager.prototype.update = function (delta) {
        for (var i = this.activeScripts.length - 1; i >= 0; i--) {
            this.activeScripts[i].update(delta);
            if (this.activeScripts[i].done) {
                this.activeScripts.splice(i, 1);
            }
        }
    };
    ScriptManager.prototype.reset = function () {
        this.activeScripts = [];
    };
    ScriptManager.prototype.runScript = function (script, name) {
        if (script instanceof Script) {
            if (script.done)
                return undefined;
        }
        else {
            script = new Script(script, name);
        }
        this.activeScripts.push(script);
        return script;
    };
    ScriptManager.prototype.stopScriptByName = function (name) {
        var e_38, _a;
        try {
            for (var _b = __values(this.activeScripts), _c = _b.next(); !_c.done; _c = _b.next()) {
                var script = _c.value;
                if (script.name === name)
                    script.stop();
            }
        }
        catch (e_38_1) { e_38 = { error: e_38_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_38) throw e_38.error; }
        }
    };
    return ScriptManager;
}());
var GlobalSoundManager = /** @class */ (function () {
    function GlobalSoundManager() {
        this.activeSounds = [];
        this.paused = false;
    }
    GlobalSoundManager.prototype.pause = function () {
        for (var i = this.activeSounds.length - 1; i >= 0; i--) {
            var r = this.ensureSoundDisabled(this.activeSounds[i]);
            i -= r - 1;
        }
        this.paused = true;
    };
    GlobalSoundManager.prototype.unpause = function () {
        this.paused = false;
    };
    GlobalSoundManager.prototype.preGameUpdate = function () {
        var e_39, _a;
        try {
            for (var _b = __values(this.activeSounds), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sound = _c.value;
                sound.markForDisable();
            }
        }
        catch (e_39_1) { e_39 = { error: e_39_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_39) throw e_39.error; }
        }
    };
    GlobalSoundManager.prototype.postGameUpdate = function () {
        for (var i = this.activeSounds.length - 1; i >= 0; i--) {
            var sound = this.activeSounds[i];
            if (sound.isMarkedForDisable || this.paused) {
                var r = this.ensureSoundDisabled(sound);
                i -= r - 1;
            }
        }
    };
    GlobalSoundManager.prototype.ensureSoundDisabled = function (sound) {
        sound.ensureDisabled();
        return A.removeAll(this.activeSounds, sound);
    };
    GlobalSoundManager.prototype.ensureSoundEnabled = function (sound) {
        if (this.paused)
            return;
        if (!_.contains(this.activeSounds, sound)) {
            this.activeSounds.push(sound);
        }
        sound.unmarkForDisable();
        sound.ensureEnabled();
    };
    return GlobalSoundManager;
}());
var MusicManager = /** @class */ (function () {
    function MusicManager() {
        this.musics = [];
        this.paused = false;
        this.baseVolume = 1;
        this.volumeScale = 1;
    }
    Object.defineProperty(MusicManager.prototype, "volume", {
        get: function () { return this.baseVolume * this.volumeScale; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MusicManager.prototype, "currentMusic", {
        get: function () { return _.last(this.musics); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MusicManager.prototype, "currentMusicKey", {
        get: function () { var _a; return (_a = this.currentMusic) === null || _a === void 0 ? void 0 : _a.key; },
        enumerable: false,
        configurable: true
    });
    MusicManager.prototype.update = function (delta) {
        if (this.transitionScript) {
            this.transitionScript.update(delta);
            if (this.transitionScript.done) {
                this.transitionScript = null;
            }
        }
        for (var i = this.musics.length - 1; i >= 0; i--) {
            if (!this.paused && !this.musics[i].paused) {
                this.musics[i].update(delta);
            }
            if (this.musics[i].done) {
                this.musics.splice(i, 1);
            }
        }
    };
    MusicManager.prototype.pauseMusic = function (fadeTime) {
        var _this = this;
        if (fadeTime === void 0) { fadeTime = 0; }
        if (fadeTime <= 0) {
            this.paused = true;
        }
        else {
            var startVolumes_1 = this.musics.map(function (m) { return m.volume; });
            this.transitionScript = new Script(S.chain(S.doOverTime(fadeTime, function (t) {
                for (var i = 0; i < _this.musics.length; i++) {
                    _this.musics[i].volume = startVolumes_1[i] * (1 - t);
                }
            }), S.call(function () {
                for (var i = 0; i < _this.musics.length; i++) {
                    _this.musics[i].volume = startVolumes_1[i];
                }
                _this.paused = true;
            })));
        }
    };
    MusicManager.prototype.playMusic = function (key, fadeTime) {
        var _this = this;
        if (fadeTime === void 0) { fadeTime = 0; }
        this.paused = false;
        // TODO: this really needs to be fixed
        if (this.currentMusicKey === key && !this.transitionScript) {
            var music_1 = this.currentMusic;
            var currentVolume_1 = music_1.volume;
            music_1.volume = 0;
            this.transitionScript = new Script(S.chain(S.doOverTime(fadeTime, function (t) {
                music_1.volume = t * currentVolume_1;
            })));
            return music_1;
        }
        var music = new Sound(key, this);
        music.loop = true;
        if (fadeTime <= 0) {
            this.musics = [music];
            this.transitionScript = null;
        }
        else {
            this.musics.push(music);
            music.volume = 0;
            var startVolumes_2 = this.musics.map(function (m) { return m.volume; });
            this.transitionScript = new Script(S.chain(S.doOverTime(fadeTime, function (t) {
                for (var i = 0; i < _this.musics.length - 1; i++) {
                    _this.musics[i].volume = startVolumes_2[i] * (1 - t);
                }
                music.volume = t;
            }), S.call(function () {
                _this.musics = [music];
            })));
        }
        return music;
    };
    MusicManager.prototype.stopMusic = function (fadeTime) {
        var _this = this;
        if (fadeTime === void 0) { fadeTime = 0; }
        if (fadeTime <= 0) {
            this.musics = [];
            this.transitionScript = null;
        }
        else {
            var startVolumes_3 = this.musics.map(function (m) { return m.volume; });
            this.transitionScript = new Script(S.chain(S.doOverTime(fadeTime, function (t) {
                for (var i = 0; i < _this.musics.length; i++) {
                    _this.musics[i].volume = startVolumes_3[i] * (1 - t);
                }
            }), S.call(function () {
                _this.musics = [];
            })));
        }
    };
    MusicManager.prototype.unpauseMusic = function () {
        this.paused = false;
    };
    return MusicManager;
}());
var Sound = /** @class */ (function () {
    function Sound(key, controller) {
        var asset = AssetCache.getSoundAsset(key);
        if (WebAudio.started) {
            this.webAudioSound = new WebAudioSound(asset);
        }
        else {
            this.webAudioSound = new WebAudioSoundDummy(asset);
        }
        this.webAudioSound.pause(); // Start paused to avoid playing for one frame when not updating
        this.markedForDisable = false;
        this.key = key;
        this.paused = false;
        this.pos = 0;
        this.volume = 1;
        this.speed = 1;
        this.loop = false;
        this.hanging = false;
        this.controller = controller;
    }
    Object.defineProperty(Sound.prototype, "soundManager", {
        get: function () { return global.soundManager; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "isMarkedForDisable", {
        get: function () { return this.markedForDisable; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "done", {
        get: function () { return this.webAudioSound.done; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "onDone", {
        get: function () { return this.webAudioSound.onDone; },
        set: function (value) { this.webAudioSound.onDone = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "position", {
        get: function () { return this.pos; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "duration", {
        get: function () { return this.webAudioSound.duration; },
        enumerable: false,
        configurable: true
    });
    Sound.prototype.update = function (delta) {
        this.soundManager.ensureSoundEnabled(this);
        this.pos += delta;
        if (this.hanging) {
            this.pos -= delta;
            this.webAudioSound.seek(this.loop ? M.mod(this.pos, this.duration) : this.pos);
        }
        if (WebAudio.started && this.webAudioSound instanceof WebAudioSoundDummy) {
            if (this.pos < this.duration || this.loop) {
                // Generate WebAudioSound from dummy
                this.webAudioSound = this.webAudioSound.toWebAudioSound();
            }
            this.webAudioSound.seek(this.loop ? M.mod(this.pos, this.duration) : this.pos);
        }
        this.volume = M.clamp(this.volume, 0, Sound.MAX_VOLUME);
        this.speed = M.clamp(this.speed, 0, Sound.MAX_SPEED);
        var volume = this.volume * (this.controller ? this.controller.volume : 1);
        if (this.webAudioSound.volume !== volume)
            this.webAudioSound.volume = volume;
        if (this.webAudioSound.speed !== this.speed)
            this.webAudioSound.speed = this.speed;
        if (this.webAudioSound.loop !== this.loop)
            this.webAudioSound.loop = this.loop;
    };
    Sound.prototype.markForDisable = function () {
        this.markedForDisable = true;
    };
    Sound.prototype.unmarkForDisable = function () {
        this.markedForDisable = false;
    };
    Sound.prototype.ensureDisabled = function () {
        this.webAudioSound.pause();
    };
    Sound.prototype.ensureEnabled = function () {
        this.webAudioSound.unpause();
    };
    Sound.prototype.hang = function () {
        this.hanging = true;
    };
    Sound.prototype.seek = function (position) {
        this.pos = position;
        if (this.loop) {
            this.pos = M.mod(this.pos, this.duration);
        }
        this.webAudioSound.seek(this.pos);
    };
    Sound.prototype.stop = function () {
        this.hanging = false;
        this.webAudioSound.stop();
    };
    Sound.prototype.humanize = function (percent) {
        if (percent === void 0) { percent = 0.05; }
        this.speed *= Random.float(1 - percent, 1 + percent);
    };
    Sound.prototype.setFilter = function (filter) {
        this.webAudioSound.setFilter(filter);
    };
    return Sound;
}());
(function (Sound) {
    Sound.MAX_VOLUME = 2;
    Sound.MAX_SPEED = 100;
})(Sound || (Sound = {}));
var SoundManager = /** @class */ (function () {
    function SoundManager() {
        this.sounds = [];
        this.volume = 1;
    }
    SoundManager.prototype.update = function (delta) {
        for (var i = this.sounds.length - 1; i >= 0; i--) {
            if (!this.sounds[i].paused) {
                this.sounds[i].update(delta);
            }
            if (this.sounds[i].done) {
                this.sounds.splice(i, 1);
            }
        }
    };
    SoundManager.prototype.playSound = function (key) {
        var sound = new Sound(key, this);
        this.sounds.push(sound);
        return sound;
    };
    SoundManager.prototype.getSoundsByKey = function (key) {
        return this.sounds.filter(function (sound) { return sound.key === key; });
    };
    return SoundManager;
}());
var WebAudio = /** @class */ (function () {
    function WebAudio() {
    }
    Object.defineProperty(WebAudio, "started", {
        get: function () { return this.context && this.context.state === 'running'; },
        enumerable: false,
        configurable: true
    });
    WebAudio.start = function () {
        this.context.resume();
    };
    WebAudio.initContext = function () {
        try {
            // @ts-ignore
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.context = new AudioContext();
        }
        catch (e) {
            console.error('Web Audio API is not supported in this browser. Sounds will not be able to play.');
        }
    };
    WebAudio.preloadSound = function (key, url, cb) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.onload = function () {
            WebAudio.context.decodeAudioData(request.response, function (buffer) {
                WebAudio.preloadedSounds[key] = {
                    buffer: buffer,
                    url: url,
                };
                if (cb)
                    cb();
            }, function (e) {
                console.error("Could not decode sound " + key + ":", e);
            });
        };
        request.send();
    };
    WebAudio.preloadedSounds = {};
    return WebAudio;
}());
var WebAudioSound = /** @class */ (function () {
    function WebAudioSound(asset) {
        this.asset = asset;
        this.gainNode = this.context.createGain();
        this.gainNode.connect(this.context.destination);
        this._volume = 1;
        this._speed = 1;
        this._loop = false;
        this.onDone = Utils.NOOP;
        this.start();
    }
    Object.defineProperty(WebAudioSound.prototype, "context", {
        get: function () { return WebAudio.context; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            this._volume = this.asset.volume === 0 ? value : M.clamp(value, 0, Sound.MAX_VOLUME / this.asset.volume);
            this.gainNode.gain.value = this._volume * this.asset.volume;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "speed", {
        get: function () {
            return this._speed;
        },
        set: function (value) {
            this._speed = this.asset.speed === 0 ? value : M.clamp(value, 0, Sound.MAX_SPEED / this.asset.speed);
            if (this.sourceNode)
                this.sourceNode.playbackRate.value = this._speed * this.asset.speed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "loop", {
        get: function () { return this._loop; },
        set: function (value) {
            this._loop = value;
            if (this.sourceNode)
                this.sourceNode.loop = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "duration", {
        get: function () { return this.sourceNode ? this.sourceNode.buffer.duration : 0; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "done", {
        get: function () { return this._done; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebAudioSound.prototype, "paused", {
        get: function () { return this.pausedPosition !== undefined; },
        set: function (value) { value ? this.pause() : this.unpause(); },
        enumerable: false,
        configurable: true
    });
    ;
    WebAudioSound.prototype.pause = function () {
        if (this.paused || this.done)
            return;
        this.pausedPosition = M.mod(this.context.currentTime - this.startTime, this.duration);
        this.sourceNode.onended = undefined;
        this.sourceNode.stop();
    };
    WebAudioSound.prototype.unpause = function () {
        if (!this.paused || this.done)
            return;
        this.start(this.pausedPosition);
    };
    WebAudioSound.prototype.seek = function (pos) {
        if (pos >= this.duration) {
            this.stop();
            return;
        }
        if (this.paused) {
            this.pausedPosition = pos;
        }
        else {
            this.sourceNode.onended = undefined;
            this.sourceNode.stop();
            this.start(pos);
        }
    };
    WebAudioSound.prototype.stop = function () {
        this.sourceNode.stop();
    };
    WebAudioSound.prototype.start = function (offset) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        this.sourceNode = this.context.createBufferSource();
        this.sourceNode.buffer = this.asset.buffer;
        this.sourceNode.connect(this.gainNode);
        this.sourceNode.onended = function () {
            _this._done = true;
            _this.onDone();
        };
        this.sourceNode.playbackRate.value = this._speed;
        this.sourceNode.loop = this._loop;
        this.sourceNode.start(0, offset);
        this.startTime = this.context.currentTime - offset;
        this.pausedPosition = undefined;
        this._done = false;
    };
    WebAudioSound.prototype.setFilter = function (filter) {
        this.gainNode.disconnect();
        if (this.filter) {
            this.filter.exitNode().disconnect();
        }
        if (filter) {
            this.gainNode.connect(filter.entryNode());
            filter.entryNode().connect(this.context.destination);
        }
        else {
            this.gainNode.connect(this.context.destination);
        }
        this.filter = filter;
    };
    return WebAudioSound;
}());
var WebAudioSoundDummy = /** @class */ (function () {
    function WebAudioSoundDummy(asset) {
        this.asset = asset;
        this.volume = 1;
        this.speed = 1;
        this.loop = false;
        this.onDone = Utils.NOOP;
        this.duration = asset.buffer.duration;
        this.done = false;
        this.paused = false;
    }
    WebAudioSoundDummy.prototype.pause = function () {
        this.paused = true;
    };
    WebAudioSoundDummy.prototype.unpause = function () {
        this.paused = false;
    };
    WebAudioSoundDummy.prototype.seek = function (pos) {
        if (pos >= this.duration) {
            this.stop();
            return;
        }
    };
    WebAudioSoundDummy.prototype.stop = function () {
        this.done = true;
    };
    WebAudioSoundDummy.prototype.setFilter = function (filter) {
        this.filter = filter;
    };
    WebAudioSoundDummy.prototype.toWebAudioSound = function () {
        var sound = new WebAudioSound(this.asset);
        sound.volume = this.volume;
        sound.speed = this.speed;
        sound.loop = this.loop;
        sound.onDone = this.onDone;
        sound.paused = this.paused;
        if (this.filter) {
            sound.setFilter(this.filter);
        }
        return sound;
    };
    return WebAudioSoundDummy;
}());
var AnchoredTexture = /** @class */ (function () {
    function AnchoredTexture(baseTexture, anchorX, anchorY) {
        if (anchorX === void 0) { anchorX = 0; }
        if (anchorY === void 0) { anchorY = 0; }
        this.baseTexture = baseTexture;
        this._anchorX = anchorX;
        this._anchorY = anchorY;
    }
    Object.defineProperty(AnchoredTexture.prototype, "width", {
        get: function () { return this.baseTexture.width; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnchoredTexture.prototype, "height", {
        get: function () { return this.baseTexture.height; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnchoredTexture.prototype, "anchorX", {
        get: function () { return this._anchorX; },
        set: function (v) {
            if (this.immutable) {
                console.error('Cannot set anchorX on immutable texture:', this);
                return;
            }
            this._anchorX = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnchoredTexture.prototype, "anchorY", {
        get: function () { return this._anchorY; },
        set: function (v) {
            if (this.immutable) {
                console.error('Cannot set anchorY on immutable texture:', this);
                return;
            }
            this._anchorY = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnchoredTexture.prototype, "immutable", {
        get: function () { return this.baseTexture.immutable; },
        set: function (value) { this.baseTexture.immutable = value; },
        enumerable: false,
        configurable: true
    });
    AnchoredTexture.prototype.clear = function () {
        this.baseTexture.clear();
    };
    AnchoredTexture.prototype.clone = function (source) {
        return new AnchoredTexture(this.baseTexture.clone(source), this.anchorX, this.anchorY);
    };
    AnchoredTexture.prototype.free = function () {
        this.baseTexture.free();
    };
    AnchoredTexture.prototype.getLocalBounds = function (properties) {
        var _a, _b, _c, _d, _e, _f;
        var baseBounds = this.baseTexture.getLocalBounds(properties);
        baseBounds.x += this.getAdjustmentX((_a = properties.angle) !== null && _a !== void 0 ? _a : 0, (_b = properties.scaleX) !== null && _b !== void 0 ? _b : 1, (_c = properties.scaleY) !== null && _c !== void 0 ? _c : 1);
        baseBounds.y += this.getAdjustmentY((_d = properties.angle) !== null && _d !== void 0 ? _d : 0, (_e = properties.scaleX) !== null && _e !== void 0 ? _e : 1, (_f = properties.scaleY) !== null && _f !== void 0 ? _f : 1);
        return baseBounds;
    };
    AnchoredTexture.prototype.getPixelAbsoluteARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        return this.baseTexture.getPixelAbsoluteARGB(x, y, extendMode);
    };
    AnchoredTexture.prototype.getPixelRelativeARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        return this.baseTexture.getPixelAbsoluteARGB(x + this.anchorX * this.width, y + this.anchorY * this.height, extendMode);
    };
    AnchoredTexture.prototype.getPixelsARGB = function () {
        return this.baseTexture.getPixelsARGB();
    };
    AnchoredTexture.prototype.renderTo = function (texture, properties) {
        var _a, _b, _c, _d, _e;
        if (properties === void 0) { properties = {}; }
        properties.x = (_a = properties.x) !== null && _a !== void 0 ? _a : 0;
        properties.y = (_b = properties.y) !== null && _b !== void 0 ? _b : 0;
        properties.angle = (_c = properties.angle) !== null && _c !== void 0 ? _c : 0;
        properties.scaleX = (_d = properties.scaleX) !== null && _d !== void 0 ? _d : 1;
        properties.scaleY = (_e = properties.scaleY) !== null && _e !== void 0 ? _e : 1;
        var adjustmentX = this.getAdjustmentX(properties.angle, properties.scaleX, properties.scaleY);
        var adjustmentY = this.getAdjustmentY(properties.angle, properties.scaleX, properties.scaleY);
        properties.x += adjustmentX;
        properties.y += adjustmentY;
        this.baseTexture.renderTo(texture, properties);
    };
    AnchoredTexture.prototype.renderPIXIDisplayObject = function (displayObject) {
        this.baseTexture.renderPIXIDisplayObject(displayObject);
    };
    AnchoredTexture.prototype.subdivide = function (h, v, source, anchorX, anchorY) {
        var e_40, _a;
        if (anchorX === void 0) { anchorX = 0; }
        if (anchorY === void 0) { anchorY = 0; }
        var result = this.baseTexture.subdivide(h, v, source);
        try {
            for (var result_1 = __values(result), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
                var subdivision = result_1_1.value;
                subdivision.texture = new AnchoredTexture(subdivision.texture, anchorX, anchorY);
            }
        }
        catch (e_40_1) { e_40 = { error: e_40_1 }; }
        finally {
            try {
                if (result_1_1 && !result_1_1.done && (_a = result_1.return)) _a.call(result_1);
            }
            finally { if (e_40) throw e_40.error; }
        }
        return result;
    };
    AnchoredTexture.prototype.toCanvas = function () {
        return this.baseTexture.toCanvas();
    };
    AnchoredTexture.prototype.toMask = function () {
        var mask = this.baseTexture.toMask();
        mask.offsetx = -Math.floor(this.anchorX * this.width);
        mask.offsety = -Math.floor(this.anchorY * this.height);
        return mask;
    };
    AnchoredTexture.prototype.transform = function (properties, source) {
        var transformedBaseTexture = this.baseTexture.transform(properties, source);
        return new AnchoredTexture(transformedBaseTexture, this.anchorX, this.anchorY);
    };
    AnchoredTexture.prototype.withAnchor = function (anchorX, anchorY) {
        this.anchorX = anchorX;
        this.anchorY = anchorY;
        return this;
    };
    AnchoredTexture.prototype.getAdjustmentX = function (angle, scaleX, scaleY) {
        var ax = Math.floor(this.anchorX * this.width) * scaleX;
        var ay = Math.floor(this.anchorY * this.height) * scaleY;
        var rotatedAndScaled_ax = (-ax) * M.cos(angle) - (-ay) * M.sin(angle);
        return rotatedAndScaled_ax;
    };
    AnchoredTexture.prototype.getAdjustmentY = function (angle, scaleX, scaleY) {
        var ax = Math.floor(this.anchorX * this.width) * scaleX;
        var ay = Math.floor(this.anchorY * this.height) * scaleY;
        var rotatedAndScaled_ay = (-ax) * M.sin(angle) + (-ay) * M.cos(angle);
        return rotatedAndScaled_ay;
    };
    return AnchoredTexture;
}());
var TextureCreationData;
(function (TextureCreationData) {
    TextureCreationData.TEXTURES_CREATED = {};
    TextureCreationData.TEXTURES_FREED = 0;
    function logCreateTexture(texture, source) {
        TextureCreationData.TEXTURES_CREATED[source] = (TextureCreationData.TEXTURES_CREATED[source] || 0) + 1;
    }
    TextureCreationData.logCreateTexture = logCreateTexture;
    function logFreeTexture(texture) {
        TextureCreationData.TEXTURES_FREED++;
    }
    TextureCreationData.logFreeTexture = logFreeTexture;
    function getTotalTexturesCreated() {
        var total = 0;
        for (var key in TextureCreationData.TEXTURES_CREATED) {
            total += TextureCreationData.TEXTURES_CREATED[key];
        }
        return total;
    }
    TextureCreationData.getTotalTexturesCreated = getTotalTexturesCreated;
    function getTotalTexturesCreatedAndNotFreed() {
        return getTotalTexturesCreated() - TextureCreationData.TEXTURES_FREED;
    }
    TextureCreationData.getTotalTexturesCreatedAndNotFreed = getTotalTexturesCreatedAndNotFreed;
})(TextureCreationData || (TextureCreationData = {}));
var TextureFilters;
(function (TextureFilters) {
    var Slice = /** @class */ (function (_super) {
        __extends(Slice, _super);
        function Slice(rect) {
            return _super.call(this, {
                uniforms: {
                    'float sliceX': rect.x,
                    'float sliceY': rect.y,
                    'float sliceWidth': rect.width,
                    'float sliceHeight': rect.height,
                },
                code: "\n                    if (x < sliceX || x >= sliceX + sliceWidth || y < sliceY || y >= sliceY + sliceHeight) {\n                        outp.a = 0.0;\n                    }\n                "
            }) || this;
        }
        Slice.prototype.setSlice = function (rect) {
            this.setUniforms({
                'sliceX': rect.x,
                'sliceY': rect.y,
                'sliceWidth': rect.width,
                'sliceHeight': rect.height,
            });
        };
        return Slice;
    }(TextureFilter));
    TextureFilters.Slice = Slice;
})(TextureFilters || (TextureFilters = {}));
/// <reference path="./textureCreationData.ts"/>
/// <reference path="./filter/textureFilter.ts"/>
/// <reference path="./filter/filters/slice.ts"/>
var BasicTexture = /** @class */ (function () {
    function BasicTexture(width, height, source, immutable) {
        if (immutable === void 0) { immutable = false; }
        // TODO: find the true texture bounds across devices
        // if (width > 2048 || height > 2048) {
        //     console.error(`Texture dimensions exceed bounds: (${width}, ${height}), limiting to bounds`);
        //     width = Math.min(width, 2048);
        //     height = Math.min(height, 2048);
        // }
        this.renderTextureSprite = new Texture.PIXIRenderTextureSprite(width, height);
        this.immutable = immutable;
        TextureCreationData.logCreateTexture(this, source);
    }
    Object.defineProperty(BasicTexture.prototype, "width", {
        get: function () { return this.renderTextureSprite._renderTexture.width; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasicTexture.prototype, "height", {
        get: function () { return this.renderTextureSprite._renderTexture.height; },
        enumerable: false,
        configurable: true
    });
    BasicTexture.prototype.clear = function () {
        if (this.immutable) {
            console.error('Cannot clear immutable texture!');
            return;
        }
        this.renderTextureSprite.clear();
    };
    BasicTexture.prototype.clone = function (source) {
        return this.transform({}, source);
    };
    BasicTexture.prototype.free = function () {
        this.renderTextureSprite.renderTexture.destroy(true);
        TextureCreationData.logFreeTexture(this);
    };
    BasicTexture.prototype.getLocalBounds = function (properties) {
        var _a, _b, _c;
        var scaleX = (_a = properties.scaleX) !== null && _a !== void 0 ? _a : 1;
        var scaleY = (_b = properties.scaleY) !== null && _b !== void 0 ? _b : 1;
        var angle = (_c = properties.angle) !== null && _c !== void 0 ? _c : 0;
        var width = this.width * scaleX;
        var height = this.height * scaleY;
        if (angle === 0) {
            return rect(0, 0, width, height);
        }
        var v1x = 0;
        var v1y = 0;
        var v2x = width * M.cos(angle);
        var v2y = width * M.sin(angle);
        var v3x = -height * M.sin(angle);
        var v3y = height * M.cos(angle);
        var v4x = v2x + v3x;
        var v4y = v2y + v3y;
        var minx = Math.min(v1x, v2x, v3x, v4x);
        var maxx = Math.max(v1x, v2x, v3x, v4x);
        var miny = Math.min(v1y, v2y, v3y, v4y);
        var maxy = Math.max(v1y, v2y, v3y, v4y);
        return {
            x: minx,
            y: miny,
            width: maxx - minx,
            height: maxy - miny,
        };
    };
    BasicTexture.prototype.getPixelAbsoluteARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        if (this.width === 0 || this.height === 0)
            return 0x00000000;
        var pixels = this.getPixelsARGB();
        x = Math.round(x);
        y = Math.round(y);
        if (extendMode === 'transparent') {
            if (x < 0 || x >= pixels[0].length || y < 0 || y >= pixels.length)
                return 0x00000000;
        }
        else if (extendMode === 'clamp') {
            x = M.clamp(x, 0, pixels[0].length);
            y = M.clamp(y, 0, pixels.length);
        }
        return pixels[y][x];
    };
    BasicTexture.prototype.getPixelRelativeARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        return this.getPixelAbsoluteARGB(x, y, extendMode);
    };
    BasicTexture.prototype.getPixelsARGB = function () {
        if (this.immutable && this.cachedPixelsARGB)
            return this.cachedPixelsARGB;
        var pixels = Main.renderer.plugins.extract.pixels(this.renderTextureSprite.renderTexture);
        var result = [];
        for (var y = 0; y < this.height; y++) {
            var line = [];
            for (var x = 0; x < this.width; x++) {
                var i = x + y * this.width;
                var r = pixels[4 * i + 0];
                var g = pixels[4 * i + 1];
                var b = pixels[4 * i + 2];
                var a = pixels[4 * i + 3];
                var color = (a << 24 >>> 0) + (r << 16) + (g << 8) + b;
                line.push(color);
            }
            result.push(line);
        }
        this.cachedPixelsARGB = result;
        return result;
    };
    BasicTexture.prototype.renderTo = function (texture, properties) {
        if (!texture)
            return;
        if (texture.immutable) {
            console.error('Cannot render to immutable texture!');
            return;
        }
        properties = this.setRenderTextureSpriteProperties(properties);
        var allFilters = this.setRenderTextureSpriteFilters(texture, properties);
        texture.renderPIXIDisplayObject(this.renderTextureSprite);
        this.returnTextureFilters(allFilters);
    };
    BasicTexture.prototype.renderPIXIDisplayObject = function (displayObject) {
        if (this.immutable) {
            console.error('Cannot render to immutable texture!');
            return;
        }
        global.renderer.render(displayObject, this.renderTextureSprite.renderTexture, false);
    };
    BasicTexture.prototype.subdivide = function (h, v, source) {
        if (h <= 0 || v <= 0)
            return [];
        var result = [];
        var framew = Math.floor(this.width / h);
        var frameh = Math.floor(this.height / v);
        var lastframew = this.width - (h - 1) * framew;
        var lastframeh = this.height - (v - 1) * frameh;
        for (var y = 0; y < v; y++) {
            for (var x = 0; x < h; x++) {
                var tx = x * framew;
                var ty = y * frameh;
                var tw = x === h - 1 ? lastframew : framew;
                var th = y === v - 1 ? lastframeh : frameh;
                var texture = new BasicTexture(tw, th, source, false);
                this.renderTo(texture, {
                    x: -tx,
                    y: -ty,
                });
                result.push({
                    x: tx, y: ty,
                    texture: texture
                });
            }
        }
        return result;
    };
    BasicTexture.prototype.toCanvas = function () {
        return Main.renderer.plugins.extract.canvas(this.renderTextureSprite.renderTexture);
    };
    BasicTexture.prototype.toMask = function () {
        return {
            renderTexture: this.renderTextureSprite.renderTexture,
            offsetx: 0, offsety: 0,
        };
    };
    /**
     * Returns a NEW texture which is transformed from the original.
     */
    BasicTexture.prototype.transform = function (properties, source) {
        _.defaults(properties, {
            scaleX: 1,
            scaleY: 1,
            tint: 0xFFFFFF,
            alpha: 1,
            filters: [],
        });
        var result = new BasicTexture(this.width * Math.abs(properties.scaleX), this.height * Math.abs(properties.scaleY), source, false);
        this.renderTo(result, {
            x: this.width / 2 * (Math.abs(properties.scaleX) - properties.scaleX),
            y: this.height / 2 * (Math.abs(properties.scaleY) - properties.scaleY),
            scaleX: properties.scaleX,
            scaleY: properties.scaleY,
            tint: properties.tint,
            alpha: properties.alpha,
            filters: properties.filters,
        });
        return result;
    };
    BasicTexture.prototype.getAllTextureFilters = function (properties) {
        var _this = this;
        var allFilters = [];
        if (properties.slice) {
            var sliceFilter = TextureFilter.SLICE_FILTER(properties.slice);
            var sliceRect = this.getSliceRect(properties);
            // Subtract sliceRect.xy because slice requires the shifted xy of the texture after slice
            Texture.setFilterProperties(sliceFilter, properties.x - sliceRect.x, properties.y - sliceRect.y, sliceRect.width, sliceRect.height);
            allFilters.push(sliceFilter);
        }
        if (properties.mask && properties.mask.texture) {
            var maskFilter = TextureFilters.Mask.SHARED(properties.mask.texture, 'global', properties.mask.x, properties.mask.y, properties.mask.invert);
            Texture.setFilterProperties(maskFilter, properties.x, properties.y, this.width, this.height);
            allFilters.push(maskFilter);
        }
        properties.filters.forEach(function (filter) { return filter && Texture.setFilterProperties(filter, properties.x, properties.y, _this.width * properties.scaleX, _this.height * properties.scaleY); });
        allFilters.push.apply(allFilters, __spread(properties.filters));
        return allFilters.filter(function (filter) { return filter && filter.enabled; });
    };
    BasicTexture.prototype.getSliceRect = function (properties) {
        var _a;
        return (_a = properties.slice) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: this.width, height: this.height };
    };
    BasicTexture.prototype.returnTextureFilters = function (allFilters) {
        allFilters.forEach(function (filter) { return filter.returnPixiFilter(); });
    };
    BasicTexture.prototype.setRenderTextureSpriteProperties = function (properties) {
        if (!properties)
            properties = {};
        _.defaults(properties, {
            x: 0,
            y: 0,
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            tint: 0xFFFFFF,
            alpha: 1,
            slice: undefined,
            filters: [],
            blendMode: Texture.BlendModes.NORMAL,
        });
        var sliceRect = this.getSliceRect(properties);
        // Position
        this.renderTextureSprite.x = properties.x - sliceRect.x;
        this.renderTextureSprite.y = properties.y - sliceRect.y;
        // Other values
        this.renderTextureSprite.scale.x = properties.scaleX;
        this.renderTextureSprite.scale.y = properties.scaleY;
        this.renderTextureSprite.angle = properties.angle;
        this.renderTextureSprite.tint = properties.tint;
        this.renderTextureSprite.alpha = properties.alpha;
        this.renderTextureSprite.blendMode = properties.blendMode;
        return properties;
    };
    BasicTexture.prototype.setRenderTextureSpriteFilters = function (destTexture, properties) {
        var allFilters = this.getAllTextureFilters(properties);
        allFilters.forEach(function (filter) { return filter.update(); });
        this.renderTextureSprite.filters = allFilters.map(function (filter) { return filter.borrowPixiFilter(); });
        this.renderTextureSprite.filterArea = new PIXI.Rectangle(0, 0, destTexture.width, destTexture.height);
        return allFilters;
    };
    return BasicTexture;
}());
/// <reference path="./basicTexture.ts"/>
var Draw = /** @class */ (function () {
    function Draw() {
    }
    Draw.fill = function (texture, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawRect(0, 0, texture.width, texture.height);
        this.graphics.endFill();
        texture.clear();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.eraseRect = function (texture, x, y, width, height) {
        var newTexture = texture.clone('Draw.eraseRect');
        var mask = new TextureFilters.Mask({
            type: 'local',
            mask: Texture.filledRect(width, height, 0xFFFFFF),
            offsetX: x, offsetY: y,
            invert: true,
        });
        texture.clear();
        newTexture.renderTo(texture, {
            x: 0, y: 0,
            filters: [mask],
        });
    };
    Draw.annulusSolid = function (texture, x, y, innerRadius, outerRadius, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        if (innerRadius <= 0) {
            this.circleSolid(texture, x, y, outerRadius, brush);
            return;
        }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawCircle(x, y, outerRadius);
        this.graphics.endFill();
        this.graphics.beginHole();
        this.graphics.drawCircle(x, y, innerRadius);
        this.graphics.endHole();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.circleOutline = function (texture, x, y, radius, alignment, brush) {
        if (alignment === void 0) { alignment = this.ALIGNMENT_INNER; }
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(brush.thickness, brush.color, brush.alpha, alignment);
        this.graphics.clear();
        this.graphics.beginFill(0, 0);
        this.graphics.drawCircle(x, y, radius);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.circleSolid = function (texture, x, y, radius, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawCircle(x, y, radius);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.ellipseOutline = function (texture, x, y, radiusX, radiusY, alignment, brush) {
        if (alignment === void 0) { alignment = this.ALIGNMENT_INNER; }
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(brush.thickness, brush.color, brush.alpha, alignment);
        this.graphics.clear();
        this.graphics.beginFill(0, 0);
        this.graphics.drawEllipse(x, y, radiusX, radiusY);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.ellipseSolid = function (texture, x, y, radiusX, radiusY, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawEllipse(x, y, radiusX, radiusY);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.pixel = function (texture, x, y, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        Draw.PIXEL_TEXTURE.renderTo(texture, {
            x: x, y: y,
            tint: brush.color,
            alpha: brush.alpha,
        });
    };
    Draw.line = function (texture, x1, y1, x2, y2, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(brush.thickness, brush.color, brush.alpha, this.ALIGNMENT_MIDDLE);
        this.graphics.clear();
        this.graphics.moveTo(x1, y1);
        this.graphics.lineTo(x2, y2);
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.polygonOutline = function (texture, points, alignment, brush) {
        if (alignment === void 0) { alignment = this.ALIGNMENT_INNER; }
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(brush.thickness, brush.color, brush.alpha, alignment);
        this.graphics.clear();
        this.graphics.beginFill(0, 0);
        this.graphics.drawPolygon(points.map(function (point) { return new PIXI.Point(point.x, point.y); }));
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.polygonSolid = function (texture, points, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawPolygon(points.map(function (point) { return new PIXI.Point(point.x, point.y); }));
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.rectangleOutline = function (texture, x, y, width, height, alignment, brush) {
        if (alignment === void 0) { alignment = this.ALIGNMENT_INNER; }
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(brush.thickness, brush.color, brush.alpha, alignment);
        this.graphics.clear();
        this.graphics.beginFill(0, 0);
        this.graphics.drawRect(x, y, width, height);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Draw.rectangleSolid = function (texture, x, y, width, height, brush) {
        if (brush === void 0) { brush = Draw.brush; }
        this.graphics.lineStyle(0, 0, 0);
        this.graphics.clear();
        this.graphics.beginFill(brush.color, brush.alpha);
        this.graphics.drawRect(x, y, width, height);
        this.graphics.endFill();
        texture.renderPIXIDisplayObject(this.graphics);
    };
    Object.defineProperty(Draw, "PIXEL_TEXTURE", {
        get: function () {
            if (!this._PIXEL_TEXTURE)
                this._PIXEL_TEXTURE = Texture.filledRect(1, 1, 0xFFFFFF);
            return this._PIXEL_TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Draw.brush = {
        color: 0x000000,
        alpha: 1,
        thickness: 1
    };
    Draw.graphics = new PIXI.Graphics();
    Draw.ALIGNMENT_INNER = 0;
    Draw.ALIGNMENT_MIDDLE = 0.5;
    Draw.ALIGNMENT_OUTER = 1;
    return Draw;
}());
var EmptyTexture = /** @class */ (function () {
    function EmptyTexture() {
    }
    Object.defineProperty(EmptyTexture.prototype, "width", {
        get: function () { return 0; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EmptyTexture.prototype, "height", {
        get: function () { return 0; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EmptyTexture.prototype, "immutable", {
        get: function () { return true; },
        enumerable: false,
        configurable: true
    });
    EmptyTexture.prototype.clear = function () { };
    EmptyTexture.prototype.clone = function () {
        return new EmptyTexture();
    };
    EmptyTexture.prototype.free = function () { };
    EmptyTexture.prototype.getLocalBounds = function (properties) {
        return rect(0, 0, 0, 0);
    };
    EmptyTexture.prototype.getPixelAbsoluteARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        return 0x00000000;
    };
    EmptyTexture.prototype.getPixelRelativeARGB = function (x, y, extendMode) {
        if (extendMode === void 0) { extendMode = 'transparent'; }
        return 0x00000000;
    };
    EmptyTexture.prototype.getPixelsARGB = function () {
        return [];
    };
    EmptyTexture.prototype.renderTo = function (texture, properties) {
        if (properties === void 0) { properties = {}; }
    };
    EmptyTexture.prototype.renderPIXIDisplayObject = function (displayObject) { };
    EmptyTexture.prototype.subdivide = function (h, v) {
        var result = [];
        for (var i = 0; i < h * v; i++) {
            result.push({
                texture: new EmptyTexture(),
                x: 0, y: 0,
            });
        }
        return result;
    };
    EmptyTexture.prototype.toCanvas = function () {
        return document.createElement('canvas');
    };
    EmptyTexture.prototype.toMask = function () {
        return {
            renderTexture: Utils.NOOP_RENDERTEXTURE,
            offsetx: 0, offsety: 0,
        };
    };
    EmptyTexture.prototype.transform = function (properties) {
        return new EmptyTexture();
    };
    return EmptyTexture;
}());
var Texture;
(function (Texture) {
    Texture.BlendModes = PIXI.BLEND_MODES;
})(Texture || (Texture = {}));
(function (Texture) {
    var cache_filledCircle = {};
    function filledCircle(radius, fillColor, fillAlpha) {
        if (fillAlpha === void 0) { fillAlpha = 1; }
        var key = radius + "," + fillColor + "," + fillAlpha;
        if (!cache_filledCircle[key]) {
            var result = new BasicTexture(radius * 2, radius * 2, 'Texture.filledCircle');
            Draw.circleSolid(result, radius, radius, radius, { color: fillColor, alpha: fillAlpha, thickness: 0 });
            result.immutable = true;
            cache_filledCircle[key] = result;
        }
        return cache_filledCircle[key];
    }
    Texture.filledCircle = filledCircle;
    var cache_filledRect = {};
    function filledRect(width, height, fillColor, fillAlpha) {
        if (fillAlpha === void 0) { fillAlpha = 1; }
        var key = width + "," + height + "," + fillColor + "," + fillAlpha;
        if (!cache_filledRect[key]) {
            var result = new BasicTexture(width, height, 'Texture.filledRect');
            Draw.fill(result, { color: fillColor, alpha: fillAlpha, thickness: 0 });
            result.immutable = true;
            cache_filledRect[key] = result;
        }
        return cache_filledRect[key];
    }
    Texture.filledRect = filledRect;
    function fromPixiTexture(pixiTexture) {
        var sprite = new PIXI.Sprite(pixiTexture);
        var texture = new AnchoredTexture(new BasicTexture(pixiTexture.width, pixiTexture.height, 'Texture.fromPixiTexture'));
        texture.anchorX = pixiTexture.defaultAnchor.x;
        texture.anchorY = pixiTexture.defaultAnchor.y;
        sprite.x = texture.anchorX * texture.width;
        sprite.y = texture.anchorY * texture.height;
        texture.renderPIXIDisplayObject(sprite);
        texture.immutable = true;
        return texture;
    }
    Texture.fromPixiTexture = fromPixiTexture;
    function ninepatch(sourceTexture, innerRect, targetWidth, targetHeight, tiled) {
        if (tiled === void 0) { tiled = false; }
        var result = new BasicTexture(targetWidth, targetHeight, 'Texture.ninepatch');
        var remwidth = sourceTexture.width - (innerRect.x + innerRect.width);
        var remheight = sourceTexture.height - (innerRect.y + innerRect.height);
        var innerScaleX = (targetWidth - innerRect.x - remwidth) / (innerRect.width);
        var innerScaleY = (targetHeight - innerRect.y - remheight) / (innerRect.height);
        if (tiled) {
            var countX = Math.max(1, Math.floor(innerScaleX));
            var countY = Math.max(1, Math.floor(innerScaleY));
            var pieceScaleX = innerScaleX / countX;
            var pieceScaleY = innerScaleY / countY;
            // Center
            for (var i = 0; i < countX; i++) {
                for (var j = 0; j < countY; j++) {
                    sourceTexture.renderTo(result, { x: innerRect.x + i * innerRect.width * pieceScaleX, y: innerRect.y + j * innerRect.height * pieceScaleY, scaleX: pieceScaleX, scaleY: pieceScaleY, slice: rect(pieceScaleX * innerRect.x, pieceScaleY * innerRect.y, pieceScaleX * innerRect.width, pieceScaleY * innerRect.height) });
                }
            }
            // Edges
            for (var i = 0; i < countX; i++) {
                sourceTexture.renderTo(result, { x: innerRect.x + i * innerRect.width * pieceScaleX, y: 0, scaleX: pieceScaleX, slice: rect(pieceScaleX * innerRect.x, 0, pieceScaleX * innerRect.width, innerRect.y) });
                sourceTexture.renderTo(result, { x: innerRect.x + i * innerRect.width * pieceScaleX, y: targetHeight - remheight, scaleX: pieceScaleX, slice: rect(pieceScaleX * innerRect.x, innerRect.y + innerRect.width, pieceScaleX * innerRect.width, remheight) });
            }
            for (var j = 0; j < countY; j++) {
                sourceTexture.renderTo(result, { x: 0, y: innerRect.y + j * innerRect.height * pieceScaleY, scaleY: pieceScaleY, slice: rect(0, pieceScaleY * innerRect.y, innerRect.x, pieceScaleY * innerRect.height) });
                sourceTexture.renderTo(result, { x: targetWidth - remwidth, y: innerRect.y + j * innerRect.height * pieceScaleY, scaleY: pieceScaleY, slice: rect(innerRect.x + innerRect.width, pieceScaleY * innerRect.y, remwidth, pieceScaleY * innerRect.height) });
            }
        }
        else {
            // Center
            sourceTexture.renderTo(result, { x: innerRect.x, y: innerRect.y, scaleX: innerScaleX, scaleY: innerScaleY, slice: rect(innerScaleX * innerRect.x, innerScaleY * innerRect.y, innerScaleX * innerRect.width, innerScaleY * innerRect.height) });
            // Edges
            sourceTexture.renderTo(result, { x: innerRect.x, y: 0, scaleX: innerScaleX, slice: rect(innerScaleX * innerRect.x, 0, innerScaleX * innerRect.width, innerRect.y) });
            sourceTexture.renderTo(result, { x: innerRect.x, y: targetHeight - remheight, scaleX: innerScaleX, slice: rect(innerScaleX * innerRect.x, innerRect.y + innerRect.width, innerScaleX * innerRect.width, remheight) });
            sourceTexture.renderTo(result, { x: 0, y: innerRect.y, scaleY: innerScaleY, slice: rect(0, innerScaleY * innerRect.y, innerRect.x, innerScaleY * innerRect.height) });
            sourceTexture.renderTo(result, { x: targetWidth - remwidth, y: innerRect.y, scaleY: innerScaleY, slice: rect(innerRect.x + innerRect.width, innerScaleY * innerRect.y, remwidth, innerScaleY * innerRect.height) });
        }
        // Corners
        sourceTexture.renderTo(result, { x: 0, y: 0, slice: rect(0, 0, innerRect.x, innerRect.y) });
        sourceTexture.renderTo(result, { x: targetWidth - remwidth, y: 0, slice: rect(innerRect.x + innerRect.width, 0, remwidth, innerRect.y) });
        sourceTexture.renderTo(result, { x: 0, y: targetHeight - remheight, slice: rect(0, innerRect.y + innerRect.height, innerRect.x, remheight) });
        sourceTexture.renderTo(result, { x: targetWidth - remwidth, y: targetHeight - remheight, slice: rect(innerRect.x + innerRect.width, innerRect.y + innerRect.height, remwidth, remheight) });
        return result;
    }
    Texture.ninepatch = ninepatch;
    var cache_outlineRect = {};
    function outlineRect(width, height, outlineColor, outlineAlpha, outlineThickness) {
        if (outlineAlpha === void 0) { outlineAlpha = 1; }
        if (outlineThickness === void 0) { outlineThickness = 1; }
        var key = width + "," + height + "," + outlineColor + "," + outlineAlpha + "," + outlineThickness;
        if (!cache_outlineRect[key]) {
            var result = new BasicTexture(width, height, 'Texture.outlineRect');
            Draw.rectangleOutline(result, 0, 0, width, height, Draw.ALIGNMENT_INNER, { color: outlineColor, alpha: outlineAlpha, thickness: outlineThickness });
            result.immutable = true;
            cache_outlineRect[key] = result;
        }
        return cache_outlineRect[key];
    }
    Texture.outlineRect = outlineRect;
    var cache_outlineCircle = {};
    function outlineCircle(radius, outlineColor, outlineAlpha, outlineThickness) {
        if (outlineAlpha === void 0) { outlineAlpha = 1; }
        if (outlineThickness === void 0) { outlineThickness = 1; }
        var key = radius + "," + outlineColor + "," + outlineAlpha + "," + outlineThickness;
        if (!cache_outlineCircle[key]) {
            var result = new BasicTexture(radius * 2, radius * 2, 'Texture.outlineCircle');
            Draw.circleOutline(result, radius, radius, radius, Draw.ALIGNMENT_INNER, { color: outlineColor, alpha: outlineAlpha, thickness: outlineThickness });
            result.immutable = true;
            cache_outlineCircle[key] = result;
        }
        return cache_outlineCircle[key];
    }
    Texture.outlineCircle = outlineCircle;
    function setFilterProperties(filter, posx, posy, dimx, dimy) {
        filter.setTexturePosition(posx, posy);
        filter.setTextureDimensions(dimx, dimy);
    }
    Texture.setFilterProperties = setFilterProperties;
    var PIXIRenderTextureSprite = /** @class */ (function (_super) {
        __extends(PIXIRenderTextureSprite, _super);
        function PIXIRenderTextureSprite(width, height) {
            var _this = this;
            var renderTexture = PIXI.RenderTexture.create({ width: width, height: height });
            _this = _super.call(this, renderTexture) || this;
            _this._renderTexture = renderTexture;
            return _this;
        }
        Object.defineProperty(PIXIRenderTextureSprite.prototype, "renderTexture", {
            get: function () { return this._renderTexture; },
            enumerable: false,
            configurable: true
        });
        PIXIRenderTextureSprite.prototype.clear = function () {
            global.renderer.render(Utils.NOOP_DISPLAYOBJECT, this._renderTexture, true);
        };
        PIXIRenderTextureSprite.prototype.resize = function (width, height) {
            this._renderTexture.resize(width, height);
        };
        return PIXIRenderTextureSprite;
    }(PIXI.Sprite));
    Texture.PIXIRenderTextureSprite = PIXIRenderTextureSprite;
    Texture.NONE = new EmptyTexture();
    Texture.NOOP = new BasicTexture(0, 0, 'Texture.NOOP');
    Texture.EFFECT_ONLY = new BasicTexture(0, 0, 'Texture.EFFECT_ONLY');
})(Texture || (Texture = {}));
// Unused for now
var shaderMatrixMethods = "\n    float determinant(float m) {\n        return m;\n    }\n\n    float determinant(mat2 m) {\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0]; \n    }\n\n    float determinant(mat3 m) {\n        return m[0][0] * (m[2][2]*m[1][1] - m[1][2]*m[2][1])\n            + m[0][1] * (m[1][2]*m[2][0] - m[2][2]*m[1][0])\n            + m[0][2] * (m[2][1]*m[1][0] - m[1][1]*m[2][0]);\n    }\n\n    float determinant(mat4 m) {\n        float\n            b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0],\n            b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0],\n            b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0],\n            b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1],\n            b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1],\n            b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2],\n            b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0],\n            b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0],\n            b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0],\n            b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1],\n            b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1],\n            b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    }\n\n    mat4 transpose(mat4 m) {\n        return mat4(\n            m[0][0], m[1][0], m[2][0], m[3][0],\n            m[0][1], m[1][1], m[2][1], m[3][1],\n            m[0][2], m[1][2], m[2][2], m[3][2],\n            m[0][3], m[1][3], m[2][3], m[3][3]\n        );\n    }\n\n    mat4 inverse(mat4 inp) {\n        mat4 cofactors = mat4(\n            determinant(mat3( inp[1].yzw, inp[2].yzw, inp[3].yzw)), \n            -determinant(mat3(inp[1].xzw, inp[2].xzw, inp[3].xzw)),\n            determinant(mat3( inp[1].xyw, inp[2].xyw, inp[3].xyw)),\n            -determinant(mat3(inp[1].xyz, inp[2].xyz, inp[3].xyz)),\n            \n            -determinant(mat3(inp[0].yzw, inp[2].yzw, inp[3].yzw)),\n            determinant(mat3( inp[0].xzw, inp[2].xzw, inp[3].xzw)),\n            -determinant(mat3(inp[0].xyw, inp[2].xyw, inp[3].xyw)),\n            determinant(mat3( inp[0].xyz, inp[2].xyz, inp[3].xyz)),\n            \n            determinant(mat3( inp[0].yzw, inp[1].yzw, inp[3].yzw)),\n            -determinant(mat3(inp[0].xzw, inp[1].xzw, inp[3].xzw)),\n            determinant(mat3( inp[0].xyw, inp[1].xyw, inp[3].xyw)),\n            -determinant(mat3(inp[0].xyz, inp[1].xyz, inp[3].xyz)),\n\n            -determinant(mat3(inp[0].yzw, inp[1].yzw, inp[2].yzw)),\n            determinant(mat3( inp[0].xzw, inp[1].xzw, inp[2].xzw)),\n            -determinant(mat3(inp[0].xyw, inp[1].xyw, inp[2].xyw)),\n            determinant(mat3( inp[0].xyz, inp[1].xyz, inp[2].xyz))\n        );\n        return transpose(cofactors) / determinant(inp);\n    }\n";
var TextureFilters;
(function (TextureFilters) {
    var Mask = /** @class */ (function (_super) {
        __extends(Mask, _super);
        function Mask(config) {
            var _a, _b, _c;
            var _this = _super.call(this, {
                uniforms: {
                    "sampler2D mask": undefined,
                    "float maskWidth": 0,
                    "float maskHeight": 0,
                    "float maskX": 0,
                    "float maskY": 0,
                    "bool invert": false
                },
                code: "\n                    vec2 vTextureCoordMask = vTextureCoord * inputSize.xy / vec2(maskWidth, maskHeight) - vec2(maskX, maskY) / vec2(maskWidth, maskHeight);\n                    if (vTextureCoordMask.x >= 0.0 && vTextureCoordMask.x < 1.0 && vTextureCoordMask.y >= 0.0 && vTextureCoordMask.y < 1.0) {\n                        float a = texture2D(mask, vTextureCoordMask).a;\n                        outp *= invert ? 1.0-a : a;\n                    } else {\n                        outp.a = invert ? inp.a : 0.0;\n                    }\n                "
            }) || this;
            _this.type = config.type;
            _this.offsetX = (_a = config.offsetX) !== null && _a !== void 0 ? _a : 0;
            _this.offsetY = (_b = config.offsetY) !== null && _b !== void 0 ? _b : 0;
            _this.invert = (_c = config.invert) !== null && _c !== void 0 ? _c : false;
            _this.setMask(config.mask);
            return _this;
        }
        Object.defineProperty(Mask.prototype, "invert", {
            get: function () { return this.getUniform('invert'); },
            set: function (value) { this.setUniform('invert', value); },
            enumerable: false,
            configurable: true
        });
        Mask.prototype.setMask = function (texture) {
            var mask = texture.toMask();
            this.setUniform('mask', mask.renderTexture);
            this.setUniform('maskWidth', mask.renderTexture.width);
            this.setUniform('maskHeight', mask.renderTexture.height);
            this.maskOffsetX = mask.offsetx;
            this.maskOffsetY = mask.offsety;
        };
        // Used by Texture in render
        Mask.prototype.setTexturePosition = function (posx, posy) {
            _super.prototype.setTexturePosition.call(this, posx, posy);
            this.setMaskPosition(posx, posy);
        };
        Mask.prototype.setMaskPosition = function (textureX, textureY) {
            var totalOffsetX = this.offsetX + this.maskOffsetX;
            var totalOffsetY = this.offsetY + this.maskOffsetY;
            if (this.type === 'global') {
                this.setUniform('maskX', totalOffsetX);
                this.setUniform('maskY', totalOffsetY);
            }
            else if (this.type === 'local') {
                this.setUniform('maskX', textureX + totalOffsetX);
                this.setUniform('maskY', textureY + totalOffsetY);
            }
        };
        return Mask;
    }(TextureFilter));
    TextureFilters.Mask = Mask;
    (function (Mask) {
        var _maskFilter;
        function SHARED(mask, type, offsetX, offsetY, invert) {
            if (type === void 0) { type = 'global'; }
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            if (invert === void 0) { invert = false; }
            if (!_maskFilter) {
                _maskFilter = new Mask({ mask: mask, type: type, offsetX: offsetX, offsetY: offsetY, invert: invert });
            }
            else {
                _maskFilter.setMask(mask);
                _maskFilter.type = type;
                _maskFilter.offsetX = offsetX;
                _maskFilter.offsetY = offsetY;
                _maskFilter.invert = invert;
            }
            return _maskFilter;
        }
        Mask.SHARED = SHARED;
        function getTextureMaskForWorldObject(mask, worldObject, renderX, renderY) {
            var _a;
            if (!mask || !mask.texture)
                return undefined;
            var x = 0;
            var y = 0;
            if (mask.type === 'screen') {
                x = mask.offsetx;
                y = mask.offsety;
            }
            else if (mask.type === 'local') {
                x = renderX + mask.offsetx;
                y = renderY + mask.offsety;
            }
            else if (mask.type === 'world') {
                var worldx = worldObject.world ? -Math.round(worldObject.world.camera.worldOffsetX) : 0;
                var worldy = worldObject.world ? -Math.round(worldObject.world.camera.worldOffsetY) : 0;
                x = worldx + mask.offsetx;
                y = worldy + mask.offsety;
            }
            return {
                texture: mask.texture,
                x: x, y: y,
                invert: (_a = mask.invert) !== null && _a !== void 0 ? _a : false,
            };
        }
        Mask.getTextureMaskForWorldObject = getTextureMaskForWorldObject;
        function getTextureMaskForWorld(mask) {
            var _a;
            if (!mask || !mask.texture)
                return undefined;
            return {
                texture: mask.texture,
                x: mask.offsetx, y: mask.offsety,
                invert: (_a = mask.invert) !== null && _a !== void 0 ? _a : false,
            };
        }
        Mask.getTextureMaskForWorld = getTextureMaskForWorld;
    })(Mask = TextureFilters.Mask || (TextureFilters.Mask = {}));
})(TextureFilters || (TextureFilters = {}));
var TextureFilters;
(function (TextureFilters) {
    var Tint = /** @class */ (function (_super) {
        __extends(Tint, _super);
        function Tint(tint) {
            var _this = _super.call(this, {
                uniforms: { 'vec3 tint': M.colorToVec3(tint) },
                code: "outp.rgb = inp.rgb * tint;",
            }) || this;
            _this._tint = tint;
            return _this;
        }
        Object.defineProperty(Tint.prototype, "tint", {
            get: function () { return this._tint; },
            set: function (v) {
                if (v === this._tint)
                    return;
                this._tint = v;
                this.setUniform('tint', M.colorToVec3(v));
            },
            enumerable: false,
            configurable: true
        });
        return Tint;
    }(TextureFilter));
    TextureFilters.Tint = Tint;
})(TextureFilters || (TextureFilters = {}));
var TextureFilters;
(function (TextureFilters) {
    var Warp = /** @class */ (function (_super) {
        __extends(Warp, _super);
        function Warp() {
            return _super.call(this, {
                uniforms: {
                    'float x1': 0,
                    'float y1': 0,
                    'float x2': 1,
                    'float y2': 0,
                    'float x3': 0,
                    'float y3': 1,
                    'float x4': 1,
                    'float y4': 1,
                },
                code: "\n                    float a1 = width * (x1);\n                    float b1 = width * (x2 - x1);\n                    float c1 = width * (x3 - x1);\n                    float d1 = width * (x1 + x4 - x2 - x3);\n                    float a2 = height * (y1);\n                    float b2 = height * (y2 - y1);\n                    float c2 = height * (y3 - y1);\n                    float d2 = height * (y1 + y4 - y2 - y3);\n\n                    float a = c2*d1 - c1*d2;\n                    float b = a2*d1 - a1*d2 + b1*c2 - b2*c1 + x*d2 - y*d1;\n                    float c = a2*b1 - a1*b2 + x*b2 - y*b1;\n                    float disc = b*b - 4.0*a*c;\n\n                    float py = -1.0;\n                    if ((a == 0.0 && b == 0.0) || disc < 0.0) {\n                        outp.a = 0.0;\n                    } else if (a == 0.0) {\n                        py = -c/b;\n                    } else {\n                        float pos = (-b + sqrt(disc)) / (2.0 * a);\n                        float neg = (-b - sqrt(disc)) / (2.0 * a);\n                        if (0.0 <= pos && pos <= 1.0) {\n                            py = pos;\n                        } else if (0.0 <= neg && neg <= 1.0) {\n                            py = neg; //-0.02\n                        }\n                    }\n\n                    float denom = b1 + d1*py;\n                    if (py < 0.0 || 1.0 < py || denom == 0.0) {\n                        outp.a = 0.0;\n                    } else {\n                        float px = (x - a1 - c1*py) / denom;\n                        if (px < 0.0 || 1.0 < px) { \n                            outp.a = 0.0;\n                        } else {\n                            outp = getColor(px*84.0, py*64.0);\n                        }\n                    }\n                "
            }) || this;
        }
        Warp.prototype.setVertex1 = function (x, y) {
            this.setUniform('x1', x);
            this.setUniform('y1', y);
        };
        Warp.prototype.setVertex2 = function (x, y) {
            this.setUniform('x2', x);
            this.setUniform('y2', y);
        };
        Warp.prototype.setVertex3 = function (x, y) {
            this.setUniform('x3', x);
            this.setUniform('y3', y);
        };
        Warp.prototype.setVertex4 = function (x, y) {
            this.setUniform('x4', x);
            this.setUniform('y4', y);
        };
        return Warp;
    }(TextureFilter));
    TextureFilters.Warp = Warp;
})(TextureFilters || (TextureFilters = {}));
/// <reference path="../worldObject/sprite/sprite.ts"/>
var Slide = /** @class */ (function (_super) {
    __extends(Slide, _super);
    function Slide(config) {
        var _a;
        var _this = _super.call(this, config) || this;
        var timeToLoad = (_a = config.timeToLoad) !== null && _a !== void 0 ? _a : 0;
        _this.timer = new Timer(timeToLoad);
        if (config.fadeIn) {
            _this.targetAlpha = _this.alpha;
            _this.alpha = 0;
        }
        _this.fullyLoaded = false;
        if (timeToLoad === 0) {
            _this.finishLoading();
        }
        return _this;
    }
    Slide.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateLoading();
    };
    Slide.prototype.updateLoading = function () {
        if (this.fullyLoaded)
            return;
        this.timer.update(this.delta);
        if (this.targetAlpha !== undefined) {
            this.alpha = this.targetAlpha * this.timer.progress;
        }
        if (this.timer.done) {
            this.fullyLoaded = true;
        }
    };
    Slide.prototype.finishLoading = function () {
        this.timer.finish();
        this.updateLoading();
    };
    return Slide;
}(Sprite));
var SlideManager = /** @class */ (function () {
    function SlideManager(theater) {
        this.theater = theater;
        this.slides = [];
    }
    SlideManager.prototype.addSlide = function (slide) {
        slide.layer = Theater.LAYER_SLIDES;
        World.Actions.setLayer(slide, Theater.LAYER_SLIDES);
        this.theater.addWorldObject(slide);
        this.slides.push(slide);
        return slide;
    };
    SlideManager.prototype.clearSlides = function (exceptLast) {
        if (exceptLast === void 0) { exceptLast = 0; }
        var deleteCount = this.slides.length - exceptLast;
        for (var i = 0; i < deleteCount; i++) {
            this.slides[i].removeFromWorld();
        }
        this.slides.splice(0, deleteCount);
    };
    return SlideManager;
}());
var StageManager = /** @class */ (function () {
    function StageManager(theater) {
        this.theater = theater;
        this.currentWorld = null;
        this.currentWorldAsWorldObject = null;
    }
    Object.defineProperty(StageManager.prototype, "transitioning", {
        get: function () { return !!this.transition; },
        enumerable: false,
        configurable: true
    });
    /**
     * Loads a stage immediately. If you are calling from inside your game, you probably want to call Theater.loadStage
     */
    StageManager.prototype.internalLoadStage = function (stage, transition, onTransitioned) {
        var _this = this;
        var oldWorld = this.currentWorld;
        // Remove old stuff
        if (this.currentWorld) {
            World.Actions.removeWorldObjectFromWorld(this.currentWorldAsWorldObject);
        }
        // Create new stuff
        this.currentWorldFactory = stage;
        this.currentWorld = stage();
        this.currentWorldAsWorldObject = new Theater.WorldAsWorldObject(this.currentWorld);
        this.currentWorldAsWorldObject.name = 'world';
        this.currentWorldAsWorldObject.layer = Theater.LAYER_WORLD;
        this.theater.addWorldObject(this.currentWorldAsWorldObject);
        this.theater.onStageLoad();
        this.currentWorld.update();
        var newWorld = this.currentWorld;
        this.currentWorldAsWorldObject.setActive(false);
        this.currentWorldAsWorldObject.setVisible(false);
        // this is outside the script to avoid 1-frame flicker
        this.transition = transition.withData(oldWorld, newWorld);
        this.transition.layer = Theater.LAYER_TRANSITION;
        this.theater.addWorldObject(this.transition);
        this.transition.takeWorldSnapshots();
        this.transition.start();
        this.theater.runScript(S.chain(S.waitUntil(function () { return _this.transition.done; }), S.call(function () {
            World.Actions.removeWorldObjectFromWorld(_this.transition);
            _this.transition.freeWorldSnapshots();
            _this.transition = null;
            _this.currentWorldAsWorldObject.setActive(true);
            _this.currentWorldAsWorldObject.setVisible(true);
            _this.currentWorld.onTransitioned();
            onTransitioned(_this.currentWorld);
        }))).update(this.theater.delta); // Update once in case the transition is already done (i.e. instant)
    };
    /**
     * Reloads the current stage immediately. If you are calling from inside your game, you probably want to call Theater.reloadCurrentStage
     */
    StageManager.prototype.internalReloadCurrentStage = function (transition) {
        this.internalLoadStage(this.currentWorldFactory, transition, Utils.NOOP);
    };
    return StageManager;
}());
/// <reference path="../worldObject/worldObject.ts"/>
var Transition = /** @class */ (function (_super) {
    __extends(Transition, _super);
    function Transition(config) {
        var _a, _b;
        var _this = _super.call(this) || this;
        _this.preTime = (_a = config.preTime) !== null && _a !== void 0 ? _a : 0;
        _this.postTime = (_b = config.postTime) !== null && _b !== void 0 ? _b : 0;
        _this.done = false;
        return _this;
    }
    Transition.prototype.withData = function (oldWorld, newWorld) {
        this.oldWorld = oldWorld;
        this.newWorld = newWorld;
        return this;
    };
    Transition.prototype.takeWorldSnapshots = function () {
        this.oldSnapshot = this.oldWorld ? this.oldWorld.takeSnapshot() : Texture.filledRect(global.gameWidth, global.gameHeight, global.backgroundColor).clone('Transition.takeWorldSnapshots');
        this.newSnapshot = this.newWorld.takeSnapshot();
    };
    Transition.prototype.freeWorldSnapshots = function () {
        var _a, _b;
        (_a = this.oldSnapshot) === null || _a === void 0 ? void 0 : _a.free();
        (_b = this.newSnapshot) === null || _b === void 0 ? void 0 : _b.free();
    };
    return Transition;
}(WorldObject));
/// <reference path="./transition.ts"/>
/// <reference path="../world/world.ts"/>
var Theater = /** @class */ (function (_super) {
    __extends(Theater, _super);
    function Theater(config) {
        var _this = _super.call(this, {
            layers: [
                { name: Theater.LAYER_WORLD },
                { name: Theater.LAYER_TRANSITION },
                { name: Theater.LAYER_SLIDES },
                { name: Theater.LAYER_DIALOG },
            ]
        }) || this;
        _this.loadDialogBox(config.dialogBox);
        _this.cutsceneManager = new CutsceneManager(_this);
        _this.stageManager = new StageManager(_this);
        _this.slideManager = new SlideManager(_this);
        _this.endOfFrameQueue = [];
        _this.isSkippingCutscene = false;
        _this.shouldStopSkippingCutscene = false;
        if (Debug.AUTOPLAY && config.autoPlayScript) {
            _this.runScript(config.autoPlayScript);
        }
        return _this;
    }
    Object.defineProperty(Theater.prototype, "currentWorld", {
        get: function () { return this.stageManager ? this.stageManager.currentWorld : undefined; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Theater.prototype, "isCutscenePlaying", {
        get: function () { return this.cutsceneManager ? this.cutsceneManager.isCutscenePlaying : false; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Theater.prototype, "slides", {
        get: function () { return this.slideManager ? this.slideManager.slides : []; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Theater.prototype, "canPause", {
        get: function () { var _a; return this.allowPause && ((_a = this.currentWorld) === null || _a === void 0 ? void 0 : _a.allowPause); },
        enumerable: false,
        configurable: true
    });
    Theater.prototype.update = function () {
        this.cutsceneManager.update();
        _super.prototype.update.call(this);
        while (!_.isEmpty(this.endOfFrameQueue)) {
            this.endOfFrameQueue.shift()();
        }
    };
    Theater.prototype.addSlide = function (slide) {
        return this.slideManager.addSlide(slide);
    };
    Theater.prototype.clearSlides = function (exceptLast) {
        if (exceptLast === void 0) { exceptLast = 0; }
        this.slideManager.clearSlides(exceptLast);
    };
    Theater.prototype.loadStage = function (stage, transition, onTransitioned) {
        var _this = this;
        if (transition === void 0) { transition = new Transitions.Instant(); }
        if (onTransitioned === void 0) { onTransitioned = Utils.NOOP; }
        this.runAtEndOfFrame(function () { return _this.loadStageImmediate(stage, transition, onTransitioned); });
    };
    Theater.prototype.loadStageImmediate = function (stage, transition, onTransitioned) {
        if (transition === void 0) { transition = new Transitions.Instant(); }
        if (onTransitioned === void 0) { onTransitioned = Utils.NOOP; }
        this.stageManager.internalLoadStage(stage, transition, onTransitioned);
    };
    Theater.prototype.playCutscene = function (cutscene) {
        this.cutsceneManager.playCutscene(cutscene);
    };
    Theater.prototype.playCutsceneIfNotSeen = function (cutscene) {
        this.cutsceneManager.playCutsceneIfNotSeen(cutscene);
    };
    Theater.prototype.reloadCurrentStage = function (transition) {
        var _this = this;
        if (transition === void 0) { transition = new Transitions.Instant(); }
        this.runAtEndOfFrame(function () { return _this.stageManager.internalReloadCurrentStage(transition); });
    };
    Theater.prototype.runAtEndOfFrame = function (fn) {
        this.endOfFrameQueue.push(fn);
    };
    // Rapidly update theater until cutscene is completed.
    Theater.prototype.skipCurrentCutscene = function () {
        var _this = this;
        if (this.cutsceneManager.canSkipCurrentCutscene()) {
            var currentCutscene_1 = this.cutsceneManager.current;
            var cutsceneFinished = function () { return !_this.cutsceneManager.current || _this.cutsceneManager.current !== currentCutscene_1; };
            this.shouldStopSkippingCutscene = false;
            this.isSkippingCutscene = true;
            var iters = 0;
            while (iters < Theater.SKIP_CUTSCENE_MAX_FRAMES && !cutsceneFinished() && !this.shouldStopSkippingCutscene) {
                this.update();
                iters++;
            }
            this.isSkippingCutscene = false;
            this.shouldStopSkippingCutscene = false;
            if (iters >= Theater.SKIP_CUTSCENE_MAX_FRAMES) {
                console.error('Cutscene skip exceeded max frames!');
            }
        }
    };
    Theater.prototype.onStageLoad = function () {
        this.cutsceneManager.onStageLoad();
    };
    Theater.prototype.loadDialogBox = function (factory) {
        this.dialogBox = this.addWorldObject(factory());
        this.dialogBox.setVisible(false);
        World.Actions.setLayer(this.dialogBox, Theater.LAYER_DIALOG);
    };
    Theater.LAYER_WORLD = 'world';
    Theater.LAYER_TRANSITION = 'transition';
    Theater.LAYER_SLIDES = 'slides';
    Theater.LAYER_DIALOG = 'dialog';
    Theater.SKIP_CUTSCENE_DELTA = 0.1;
    Theater.SKIP_CUTSCENE_MAX_FRAMES = 10000;
    return Theater;
}(World));
(function (Theater) {
    var WorldAsWorldObject = /** @class */ (function (_super) {
        __extends(WorldAsWorldObject, _super);
        function WorldAsWorldObject(containedWorld) {
            var _this = _super.call(this) || this;
            _this.containedWorld = containedWorld;
            _this.mask = undefined;
            _this.multiExecutionTimeScale = 1;
            _this.multiExecutionPool = 0;
            return _this;
        }
        WorldAsWorldObject.prototype.update = function () {
            _super.prototype.update.call(this);
            this.multiExecutionPool += this.multiExecutionTimeScale;
            var isNonUpdate = true;
            while (this.multiExecutionPool >= 1) {
                this.containedWorld.update();
                this.multiExecutionPool -= 1;
                isNonUpdate = false;
            }
            if (isNonUpdate) {
                this.containedWorld.nonUpdate();
            }
        };
        WorldAsWorldObject.prototype.render = function (texture, x, y) {
            var currentMask = this.containedWorld.mask;
            if (this.mask !== undefined) {
                this.containedWorld.mask = this.mask;
            }
            this.containedWorld.render(texture, x, y);
            _super.prototype.render.call(this, texture, x, y);
            this.containedWorld.mask = currentMask;
        };
        return WorldAsWorldObject;
    }(WorldObject));
    Theater.WorldAsWorldObject = WorldAsWorldObject;
})(Theater || (Theater = {}));
var Transitions;
(function (Transitions) {
    var Instant = /** @class */ (function (_super) {
        __extends(Instant, _super);
        function Instant() {
            return _super.call(this, {}) || this;
        }
        Instant.prototype.start = function () {
            this.done = true;
        };
        return Instant;
    }(Transition));
    Transitions.Instant = Instant;
    var Fade = /** @class */ (function (_super) {
        __extends(Fade, _super);
        function Fade(config) {
            var _this = _super.call(this, config) || this;
            _this.time = config.time;
            _this.newAlpha = 0;
            return _this;
        }
        Fade.prototype.start = function () {
            var _this = this;
            this.runScript(S.chain(S.wait(this.preTime), S.doOverTime(this.time, function (t) {
                _this.newAlpha = t;
            }), S.wait(this.postTime), S.call(function () { return _this.done = true; })));
        };
        Fade.prototype.render = function (texture, x, y) {
            _super.prototype.render.call(this, texture, x, y);
            this.oldSnapshot.renderTo(texture);
            this.newSnapshot.renderTo(texture, {
                alpha: this.newAlpha
            });
        };
        return Fade;
    }(Transition));
    Transitions.Fade = Fade;
    var Curtains = /** @class */ (function (_super) {
        __extends(Curtains, _super);
        function Curtains(config) {
            var _this = _super.call(this, config) || this;
            _this.inTime = config.inTime;
            _this.midTime = config.midTime;
            _this.outTime = config.outTime;
            _this.slide_t = 0;
            _this.transitioned = false;
            return _this;
        }
        Curtains.prototype.start = function () {
            var _this = this;
            this.runScript(S.chain(S.wait(this.preTime), S.doOverTime(this.inTime, function (t) { return _this.slide_t = t; }), S.wait(this.midTime), S.call(function () { return _this.transitioned = true; }), S.doOverTime(this.outTime, function (t) { return _this.slide_t = 1 - t; }), S.wait(this.postTime), S.call(function () { return _this.done = true; })));
        };
        Curtains.prototype.render = function (texture, x, y) {
            _super.prototype.render.call(this, texture, x, y);
            Draw.brush.color = 0x000000;
            Draw.brush.alpha = 1;
            if (this.transitioned) {
                this.newSnapshot.renderTo(texture);
                Draw.rectangleSolid(texture, 0, 0, this.newSnapshot.width, this.newSnapshot.height / 2 * this.slide_t);
                Draw.rectangleSolid(texture, 0, this.newSnapshot.height * (1 - 0.5 * this.slide_t), this.newSnapshot.width, this.newSnapshot.height * 0.5 * this.slide_t);
            }
            else {
                this.oldSnapshot.renderTo(texture);
                Draw.rectangleSolid(texture, 0, 0, this.oldSnapshot.width, this.oldSnapshot.height / 2 * this.slide_t);
                Draw.rectangleSolid(texture, 0, this.oldSnapshot.height * (1 - 0.5 * this.slide_t), this.oldSnapshot.width, this.oldSnapshot.height * 0.5 * this.slide_t);
            }
        };
        return Curtains;
    }(Transition));
    Transitions.Curtains = Curtains;
})(Transitions || (Transitions = {}));
var A;
(function (A) {
    A.ALPHABET_LOWERCASE = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
    A.ALPHABET_UPPERCASE = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    function batch(array, batchSize) {
        var result = A.range(Math.ceil(array.length / batchSize)).map(function (i) { return []; });
        for (var i = 0; i < array.length; i++) {
            result[Math.floor(i / batchSize)].push(array[i]);
        }
        return result;
    }
    A.batch = batch;
    function clone(array) {
        if (_.isEmpty(array))
            return [];
        return Array.from(array);
    }
    A.clone = clone;
    function clone2D(array) {
        if (_.isEmpty(array))
            return [];
        return array.map(function (line) { return clone(line); });
    }
    A.clone2D = clone2D;
    function create(count, fillFn) {
        var result = [];
        for (var i = 0; i < count; i++) {
            result.push(fillFn(i));
        }
        return result;
    }
    A.create = create;
    function emptyArray(n) {
        return filledArray(n);
    }
    A.emptyArray = emptyArray;
    function filledArray(n, fillWith) {
        var result = [];
        for (var i = 0; i < n; i++) {
            result.push(fillWith);
        }
        return result;
    }
    A.filledArray = filledArray;
    function filledArray2D(rows, cols, fillWith) {
        var result = [];
        for (var i = 0; i < rows; i++) {
            var line = [];
            for (var j = 0; j < cols; j++) {
                line.push(fillWith);
            }
            result.push(line);
        }
        return result;
    }
    A.filledArray2D = filledArray2D;
    function filterInPlace(array, predicate) {
        if (_.isEmpty(array))
            return array;
        for (var i = array.length - 1; i >= 0; i--) {
            if (!predicate(array[i], i, array)) {
                array.splice(i, 1);
            }
        }
        return array;
    }
    A.filterInPlace = filterInPlace;
    function get2DArrayDimensions(array) {
        if (_.isEmpty(array))
            return { width: 0, height: 0 };
        return { width: M.max(array, function (line) { return _.isEmpty(line) ? 0 : line.length; }), height: array.length };
    }
    A.get2DArrayDimensions = get2DArrayDimensions;
    function map2D(array, fn) {
        if (_.isEmpty(array))
            return [];
        return array.map(function (line) { return _.isEmpty(line) ? [] : line.map(fn); });
    }
    A.map2D = map2D;
    function mergeArray(array, into, key, combine) {
        var e_41, _a;
        if (combine === void 0) { combine = (function (e, into) { return e; }); }
        var result = A.clone(into);
        try {
            for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var element = array_1_1.value;
                var resultContainedKey = false;
                for (var i = 0; i < result.length; i++) {
                    if (key(element) === key(result[i])) {
                        result[i] = combine(element, result[i]);
                        resultContainedKey = true;
                        break;
                    }
                }
                if (!resultContainedKey) {
                    result.push(element);
                }
            }
        }
        catch (e_41_1) { e_41 = { error: e_41_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_41) throw e_41.error; }
        }
        return result;
    }
    A.mergeArray = mergeArray;
    /**
     * Moves an element of a list before another element of the list.
     */
    function moveBefore(list, obj, before) {
        var obji = list.indexOf(obj);
        var beforei = list.indexOf(before);
        if (obji < 0 || beforei < 0)
            return;
        if (obji === beforei - 1)
            return;
        if (obji < beforei) {
            list.splice(obji, 1);
            list.splice(beforei - 1, 0, obj);
        }
        else {
            list.splice(obji, 1);
            list.splice(beforei, 0, obj);
        }
    }
    A.moveBefore = moveBefore;
    /**
     * Moves an element of a list after another element of the list.
     */
    function moveAfter(list, obj, after) {
        var obji = list.indexOf(obj);
        var afteri = list.indexOf(after);
        if (obji < 0 || afteri < 0)
            return;
        if (obji === afteri + 1)
            return;
        if (obji < afteri) {
            list.splice(obji, 1);
            list.splice(afteri, 0, obj);
        }
        else {
            list.splice(obji, 1);
            list.splice(afteri + 1, 0, obj);
        }
    }
    A.moveAfter = moveAfter;
    function normalize(list) {
        var s = A.sum(list);
        if (s === 0)
            return list;
        for (var i = 0; i < list.length; i++) {
            list[i] /= s;
        }
        return list;
    }
    A.normalize = normalize;
    /**
     * Returns true iff the arrays contain a common element.
     */
    function overlaps(array1, array2) {
        var e_42, _a;
        if (_.isEmpty(array1) || _.isEmpty(array2))
            return false;
        try {
            for (var array1_1 = __values(array1), array1_1_1 = array1_1.next(); !array1_1_1.done; array1_1_1 = array1_1.next()) {
                var e = array1_1_1.value;
                if (_.includes(array2, e))
                    return true;
            }
        }
        catch (e_42_1) { e_42 = { error: e_42_1 }; }
        finally {
            try {
                if (array1_1_1 && !array1_1_1.done && (_a = array1_1.return)) _a.call(array1_1);
            }
            finally { if (e_42) throw e_42.error; }
        }
        return false;
    }
    A.overlaps = overlaps;
    /**
     * Pushes an object onto the array in the correct sorted order. Assumes the array is already sorted.
     * If there is a tie, uses the last possible position, similar to a normal push.
     * Returns the new length of the array.
     */
    function pushSorted(array, obj, key, reverse) {
        if (reverse === void 0) { reverse = false; }
        var r = reverse ? -1 : 1;
        var i = array.findIndex(function (e) { return r * key(obj) < r * key(e); });
        if (i < 0) {
            array.push(obj);
        }
        else {
            array.splice(i, 0, obj);
        }
        return array.length;
    }
    A.pushSorted = pushSorted;
    /**
     * An array of integers from 0 to n-1 or n to m-1, inclusive.
     */
    function range(n, m) {
        if (m === undefined) {
            m = n;
            n = 0;
        }
        return __spread(Array(m - n).keys()).map(function (i) { return i + n; });
    }
    A.range = range;
    /**
     * Removes all occurrences of a value from the array.
     * Returns the number of elements removed.
     */
    function removeAll(array, obj, startingAt) {
        if (startingAt === void 0) { startingAt = 0; }
        if (!array)
            return 0;
        var count = 0;
        for (var i = array.length - 1; i >= startingAt; i--) {
            if (array[i] === obj) {
                array.splice(i, 1);
                count++;
            }
        }
        return count;
    }
    A.removeAll = removeAll;
    function removeDuplicates(array) {
        for (var i = 0; i < array.length - 1; i++) {
            removeAll(array, array[i], i + 1);
        }
        return array;
    }
    A.removeDuplicates = removeDuplicates;
    function repeat(array, count) {
        var result = [];
        for (var i = 0; i < count; i++) {
            result.push.apply(result, __spread(array));
        }
        return result;
    }
    A.repeat = repeat;
    /**
     * Sorts in ascending order by default.
     */
    function sort(array, key, reverse) {
        if (reverse === void 0) { reverse = false; }
        var r = reverse ? -1 : 1;
        return array.sort(function (a, b) { return r * (key(a) - key(b)); });
    }
    A.sort = sort;
    /**
     * Sorts in ascending order by default.
     */
    function sorted(array, key, reverse) {
        if (reverse === void 0) { reverse = false; }
        return A.sort(A.clone(array), key, reverse);
    }
    A.sorted = sorted;
    function sum(array, key) {
        if (key === void 0) { key = (function (e) { return e; }); }
        if (_.isEmpty(array))
            return 0;
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += key(array[i]);
        }
        return result;
    }
    A.sum = sum;
    function swap(array, i, j) {
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    A.swap = swap;
})(A || (A = {}));
var Color;
(function (Color) {
    function argbToVec4(argb) {
        var a = (argb >> 24) & 255;
        var r = (argb >> 16) & 255;
        var g = (argb >> 8) & 255;
        var b = argb & 255;
        return [a / 255, r / 255, g / 255, b / 255];
    }
    Color.argbToVec4 = argbToVec4;
    function blendAlpha(bgColor, fgColor, alpha) {
        var bgColorArray = M.colorToVec3(bgColor);
        var fgColorArray = M.colorToVec3(fgColor);
        var a = M.clamp(alpha, 0, 1);
        var blendedColorArray = [
            M.lerp(bgColorArray[0], fgColorArray[0], a),
            M.lerp(bgColorArray[1], fgColorArray[1], a),
            M.lerp(bgColorArray[2], fgColorArray[2], a),
        ];
        return M.vec3ToColor(blendedColorArray);
    }
    Color.blendAlpha = blendAlpha;
    function lerpColorByLch(color1, color2, t) {
        if (color1 === color2)
            return color1;
        var vec3color1 = M.colorToVec3(color1);
        var vec3color2 = M.colorToVec3(color2);
        var chroma1 = chroma.rgb(vec3color1[0] * 255, vec3color1[1] * 255, vec3color1[2] * 255);
        var chroma2 = chroma.rgb(vec3color2[0] * 255, vec3color2[1] * 255, vec3color2[2] * 255);
        var chromaf = chroma.interpolate(chroma1, chroma2, t, 'lch');
        var rgbf = chromaf.rgb();
        return M.vec3ToColor([rgbf[0] / 255, rgbf[1] / 255, rgbf[2] / 255]);
    }
    Color.lerpColorByLch = lerpColorByLch;
    function lerpColorByRgb(color1, color2, t) {
        if (color1 === color2)
            return color1;
        var vec3color1 = M.colorToVec3(color1);
        var vec3color2 = M.colorToVec3(color2);
        var chroma1 = chroma.rgb(vec3color1[0] * 255, vec3color1[1] * 255, vec3color1[2] * 255);
        var chroma2 = chroma.rgb(vec3color2[0] * 255, vec3color2[1] * 255, vec3color2[2] * 255);
        var chromaf = chroma.interpolate(chroma1, chroma2, t, 'rgb');
        var rgbf = chromaf.rgb();
        return M.vec3ToColor([rgbf[0] / 255, rgbf[1] / 255, rgbf[2] / 255]);
    }
    Color.lerpColorByRgb = lerpColorByRgb;
    function vec4ToArgb(vec3) {
        return (Math.round(vec3[0] * 255) << 24) + (Math.round(vec3[1] * 255) << 16) + (Math.round(vec3[2] * 255) << 8) + Math.round(vec3[3] * 255);
    }
    Color.vec4ToArgb = vec4ToArgb;
})(Color || (Color = {}));
var OrFactory;
(function (OrFactory) {
    /** CANNOT RESOLVE FACTORIES OF FUNCTIONS */
    function resolve(orFactory) {
        if (_.isFunction(orFactory)) {
            return orFactory();
        }
        return orFactory;
    }
    OrFactory.resolve = resolve;
})(OrFactory || (OrFactory = {}));
var G;
(function (G) {
    function angle(p1, p2) {
        var angle = M.atan2(p2.y - p1.y, p2.x - p1.x);
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    G.angle = angle;
    function average() {
        var e_43, _a;
        var ps = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ps[_i] = arguments[_i];
        }
        if (_.isEmpty(ps)) {
            return undefined;
        }
        var sum = vec2(0, 0);
        try {
            for (var ps_1 = __values(ps), ps_1_1 = ps_1.next(); !ps_1_1.done; ps_1_1 = ps_1.next()) {
                var p = ps_1_1.value;
                sum.add(p);
            }
        }
        catch (e_43_1) { e_43 = { error: e_43_1 }; }
        finally {
            try {
                if (ps_1_1 && !ps_1_1.done && (_a = ps_1.return)) _a.call(ps_1);
            }
            finally { if (e_43) throw e_43.error; }
        }
        sum.scale(1 / ps.length);
        return sum;
    }
    G.average = average;
    function circleIntersectsSegment(cx, cy, r, lx1, ly1, lx2, ly2) {
        var dx = cx - lx1;
        var dy = cy - ly1;
        var ldx = lx2 - lx1;
        var ldy = ly2 - ly1;
        var t = (dx * ldx + dy * ldy) / (ldx * ldx + ldy * ldy);
        if (M.distanceSq(dx, dy, ldx * t, ldy * t) >= r * r - 0.00000001)
            return false;
        var tInRange = 0 < t && t < 1;
        var intersectsVertex1 = M.distanceSq(0, 0, dx, dy) < r * r;
        var intersectsVertex2 = M.distanceSq(ldx, ldy, dx, dy) < r * r;
        return tInRange || intersectsVertex1 || intersectsVertex2;
    }
    G.circleIntersectsSegment = circleIntersectsSegment;
    function distance(pt1, pt2) {
        return M.distance(pt1.x, pt1.y, pt2.x, pt2.y);
    }
    G.distance = distance;
    function distanceSq(pt1, pt2) {
        return M.distanceSq(pt1.x, pt1.y, pt2.x, pt2.y);
    }
    G.distanceSq = distanceSq;
    function distancePointToLine(px, py, lx1, ly1, lx2, ly2) {
        var dx = px - lx1;
        var dy = py - ly1;
        var ldx = lx2 - lx1;
        var ldy = ly2 - ly1;
        return Math.abs(dy * ldx - dx * ldy) / (ldx * ldx + ldy * ldy);
    }
    G.distancePointToLine = distancePointToLine;
    function dot(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }
    G.dot = dot;
    function expandRectangle(rect, amount) {
        rect.x -= amount;
        rect.y -= amount;
        rect.width += 2 * amount;
        rect.height += 2 * amount;
    }
    G.expandRectangle = expandRectangle;
    function generatePolygonVertices(cx, cy, r, n, angle) {
        if (angle === void 0) { angle = 0; }
        return A.range(n).map(function (i) { return vec2(cx + r * M.cos(angle + 360 / n * (i + 0.5)), cy + r * M.sin(angle + 360 / n * (i + 0.5))); });
    }
    G.generatePolygonVertices = generatePolygonVertices;
    function lerpPt(pt1, pt2, t) {
        return vec2(M.lerp(pt1.x, pt2.x, t), M.lerp(pt1.y, pt2.y, t));
    }
    G.lerpPt = lerpPt;
    function moveToClamp(current, to, speed, delta) {
        if (G.distance(current, to) <= speed * delta)
            current.set(to);
        current.add(vec2(to.x - current.x, to.y - current.y).withMagnitude(speed * delta));
        return current;
    }
    G.moveToClamp = moveToClamp;
    function overlapRectangles(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
    }
    G.overlapRectangles = overlapRectangles;
    function rectContainsPt(rect, pt) {
        return pt.x >= rect.x && pt.y >= rect.y && pt.x < rect.x + rect.width && pt.y < rect.y + rect.height;
    }
    G.rectContainsPt = rectContainsPt;
    function rectContainsRect(rect, contains) {
        return rect.x <= contains.x && rect.x + rect.width >= contains.x + contains.width
            && rect.y <= contains.y && rect.y + rect.height >= contains.y + contains.height;
    }
    G.rectContainsRect = rectContainsRect;
})(G || (G = {}));
var LazyValue = /** @class */ (function () {
    function LazyValue(factory) {
        this.factory = factory;
        this.value = undefined;
        this.resolved = false;
    }
    LazyValue.prototype.get = function () {
        if (!this.resolved) {
            this.value = this.factory();
            this.resolved = true;
        }
        return this.value;
    };
    LazyValue.prototype.has = function () {
        return !!this.resolved;
    };
    return LazyValue;
}());
var LazyDict = /** @class */ (function () {
    function LazyDict(factory) {
        this.factory = factory;
        this.values = {};
        this.resolvedKeys = new Set();
    }
    LazyDict.prototype.get = function (key) {
        if (!this.resolvedKeys.has(key)) {
            this.values[key] = this.factory(key);
            this.resolvedKeys.add(key);
        }
        return this.values[key];
    };
    LazyDict.prototype.has = function (key) {
        return this.resolvedKeys.has(key);
    };
    return LazyDict;
}());
var LazyDictNumber = /** @class */ (function () {
    function LazyDictNumber(factory) {
        this.factory = factory;
        this.values = {};
        this.resolvedKeys = new Set();
    }
    LazyDictNumber.prototype.get = function (key) {
        if (!this.resolvedKeys.has(key)) {
            this.values[key] = this.factory(key);
            this.resolvedKeys.add(key);
        }
        return this.values[key];
    };
    LazyDictNumber.prototype.has = function (key) {
        return this.resolvedKeys.has(key);
    };
    return LazyDictNumber;
}());
var LAZY_CACHE = {};
function lazy(key, factory) {
    if (!(key in LAZY_CACHE)) {
        LAZY_CACHE[key] = new LazyValue(factory);
    }
    return LAZY_CACHE[key].get();
}
var LocalStorage = /** @class */ (function () {
    function LocalStorage() {
    }
    LocalStorage.init = function () {
        if (this.doesLocalStorageWork()) {
            this.backend = new LocalStorageTrueBackend();
        }
        else {
            console.error('LocalStorage does not work! Using temporary in-memory storage.');
            this.backend = new LocalStorageFacadeBackend();
        }
    };
    LocalStorage.doesLocalStorageWork = function () {
        try {
            localStorage.setItem('_lsc', 'checked');
            var result = localStorage.getItem('_lsc') === 'checked';
            localStorage.removeItem('_lsc');
            return result;
        }
        catch (e) {
            console.error('Unable to get localStorage:', e);
            return false;
        }
    };
    LocalStorage.delete = function (key) {
        this.backend.delete(key);
    };
    LocalStorage.getJson = function (key) {
        return this.backend.getJson(key);
    };
    LocalStorage.getString = function (key) {
        return this.backend.getString(key);
    };
    LocalStorage.setJson = function (key, value) {
        this.backend.setJson(key, value);
    };
    LocalStorage.setString = function (key, value) {
        this.backend.setString(key, value);
    };
    return LocalStorage;
}());
var LocalStorageTrueBackend = /** @class */ (function () {
    function LocalStorageTrueBackend() {
    }
    LocalStorageTrueBackend.prototype.delete = function (key) {
        localStorage.removeItem(key);
    };
    LocalStorageTrueBackend.prototype.getJson = function (key) {
        var str = this.getString(key);
        return _.isEmpty(str) || str === 'undefined' ? undefined : JSON.parse(str);
    };
    LocalStorageTrueBackend.prototype.getString = function (key) {
        try {
            return localStorage.getItem(key);
        }
        catch (e) {
            console.error('Unable to get localStorage:', e);
        }
        return undefined;
    };
    LocalStorageTrueBackend.prototype.setJson = function (key, value) {
        this.setString(key, JSON.stringify(value));
    };
    LocalStorageTrueBackend.prototype.setString = function (key, value) {
        try {
            localStorage.setItem(key, value);
        }
        catch (e) {
            console.error('Unable to set localStorage:', e);
        }
    };
    return LocalStorageTrueBackend;
}());
var LocalStorageFacadeBackend = /** @class */ (function () {
    function LocalStorageFacadeBackend() {
        this.storage = {};
    }
    LocalStorageFacadeBackend.prototype.delete = function (key) {
        delete this.storage[key];
    };
    LocalStorageFacadeBackend.prototype.getJson = function (key) {
        var str = this.getString(key);
        return _.isEmpty(str) ? undefined : JSON.parse(str);
    };
    LocalStorageFacadeBackend.prototype.getString = function (key) {
        return key in this.storage ? this.storage[key] : undefined;
    };
    LocalStorageFacadeBackend.prototype.setJson = function (key, value) {
        this.setString(key, JSON.stringify(value));
    };
    LocalStorageFacadeBackend.prototype.setString = function (key, value) {
        this.storage[key] = value;
    };
    return LocalStorageFacadeBackend;
}());
var M;
(function (M) {
    /**
     * Computes the difference between angles, such that [from] + [diff] is
     * an equivalent angle to [to]
     */
    function angleDiff(from, to) {
        from = M.mod(from, 360);
        to = M.mod(to, 360);
        if (Math.abs(to - from) < 180)
            return to - from;
        else if (to > from)
            return to - from - 360;
        else
            return to - from + 360;
    }
    M.angleDiff = angleDiff;
    function argmax(array, key) {
        return argmin(array, function (x) { return -key(x); });
    }
    M.argmax = argmax;
    function argmin(array, key) {
        if (!array || array.length == 0)
            return null;
        var result = array[0];
        var resultValue = key(array[0]);
        for (var i = 1; i < array.length; i++) {
            var value = key(array[i]);
            if (value < resultValue) {
                result = array[i];
                resultValue = value;
            }
        }
        return result;
    }
    M.argmin = argmin;
    function axis(neg, pos) {
        return (neg ? -1 : 0) + (pos ? 1 : 0);
    }
    M.axis = axis;
    function batch(count, maxCount) {
        if (count <= maxCount) {
            return A.create(count, function (i) { return 1; });
        }
        var q = Math.floor(count / maxCount);
        var r = count % maxCount;
        return A.create(maxCount, function (i) { return i < r ? q + 1 : q; });
    }
    M.batch = batch;
    function ceilRelative(n, relativeTo) {
        return Math.ceil(n - relativeTo) + relativeTo;
    }
    M.ceilRelative = ceilRelative;
    function clamp(val, min, max) {
        return val < min ? min : (val > max ? max : val);
    }
    M.clamp = clamp;
    function colorToVec3(color) {
        var r = (color >> 16) & 255;
        var g = (color >> 8) & 255;
        var b = color & 255;
        return [r / 255, g / 255, b / 255];
    }
    M.colorToVec3 = colorToVec3;
    function degToRad(deg) {
        return Math.PI * deg / 180;
    }
    M.degToRad = degToRad;
    function distance(x1, y1, x2, y2) {
        return Math.sqrt(distanceSq(x1, y1, x2, y2));
    }
    M.distance = distance;
    function distanceSq(x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        return dx * dx + dy * dy;
    }
    M.distanceSq = distanceSq;
    function equidistantLine(middle, d, n, i) {
        return middle - d * (n - 1) / 2 + d * i;
    }
    M.equidistantLine = equidistantLine;
    function floorRelative(n, relativeTo) {
        return Math.floor(n - relativeTo) + relativeTo;
    }
    M.floorRelative = floorRelative;
    function isInt(n) {
        return /^[+-]?\d+$/.test(n);
    }
    M.isInt = isInt;
    /**
     * Calculates the height of a parabola that starts at startHeight, increases to startHeight + peakDelta, then falls to startHeight + groundDelta.
     * 0 <= t <= 1 is the percent completion of the jump.
     */
    function jumpParabola(startHeight, peakDelta, groundDelta, t) {
        var a = 2 * groundDelta - 4 * peakDelta;
        var b = 4 * peakDelta - groundDelta;
        return a * t * t + b * t + startHeight;
    }
    M.jumpParabola = jumpParabola;
    function jumpVelocityForHeight(height, gravity) {
        return Math.sqrt(2 * height * Math.abs(gravity));
    }
    M.jumpVelocityForHeight = jumpVelocityForHeight;
    function lerp(a, b, t) {
        return a * (1 - t) + b * t;
    }
    M.lerp = lerp;
    function lerpTime(a, b, speed, delta) {
        // From https://www.gamasutra.com/blogs/ScottLembcke/20180404/316046/Improved_Lerp_Smoothing.php
        return lerp(a, b, 1 - Math.pow(2, -speed * delta));
    }
    M.lerpTime = lerpTime;
    function magnitude(dx, dy) {
        return Math.sqrt(magnitudeSq(dx, dy));
    }
    M.magnitude = magnitude;
    function magnitudeSq(dx, dy) {
        return dx * dx + dy * dy;
    }
    M.magnitudeSq = magnitudeSq;
    function map(value, fromMin, fromMax, toMin, toMax) {
        var p = (value - fromMin) / (fromMax - fromMin);
        return lerp(toMin, toMax, p);
    }
    M.map = map;
    function mapClamp(value, fromMin, fromMax, toMin, toMax) {
        var clampMin = toMin <= toMax ? toMin : toMax;
        var clampMax = toMin <= toMax ? toMax : toMin;
        return clamp(map(value, fromMin, fromMax, toMin, toMax), clampMin, clampMax);
    }
    M.mapClamp = mapClamp;
    function mapTween(value, fromMin, fromMax, toMin, toMax, tweenFn) {
        var p = (value - fromMin) / (fromMax - fromMin);
        return lerp(toMin, toMax, tweenFn(p));
    }
    M.mapTween = mapTween;
    function max(array, key) {
        return -min(array, function (x) { return -key(x); });
    }
    M.max = max;
    function min(array, key) {
        if (_.isEmpty(array))
            return NaN;
        var result = key(array[0]);
        for (var i = 1; i < array.length; i++) {
            var value = key(array[i]);
            if (value < result)
                result = value;
        }
        return result;
    }
    M.min = min;
    function minPowerOf2(num) {
        return Math.pow(2, Math.ceil(Math.log2(num)));
    }
    M.minPowerOf2 = minPowerOf2;
    function mod(num, mod) {
        mod = Math.abs(mod);
        return num - Math.floor(num / mod) * mod;
    }
    M.mod = mod;
    function moveToAngleClamp(current, to, speed, delta) {
        var diff = angleDiff(current, to);
        var d = speed * delta;
        if (diff > Math.abs(d))
            return Math.min(current + d, to);
        if (diff < Math.abs(d))
            return Math.max(current - d, to);
        return current + diff;
    }
    M.moveToAngleClamp = moveToAngleClamp;
    function moveToClamp(current, to, speed, delta) {
        if (to > current)
            return Math.min(current + speed * delta, to);
        if (to < current)
            return Math.max(current - speed * delta, to);
        return current;
    }
    M.moveToClamp = moveToClamp;
    function periodic(fn, period) {
        return function (x) { return fn(mod(x, period)); };
    }
    M.periodic = periodic;
    function radToDeg(rad) {
        return 180 / Math.PI * rad;
    }
    M.radToDeg = radToDeg;
    function roundRelative(n, relativeTo) {
        return Math.round(n - relativeTo) + relativeTo;
    }
    M.roundRelative = roundRelative;
    function roundToNearest(n, unit) {
        return Math.round(n / unit) * unit;
    }
    M.roundToNearest = roundToNearest;
    function vec3ToColor(vec3) {
        return (Math.round(vec3[0] * 255) << 16) + (Math.round(vec3[1] * 255) << 8) + Math.round(vec3[2] * 255);
    }
    M.vec3ToColor = vec3ToColor;
    // Degree-based Trig
    function cos(angle) {
        return Math.cos(degToRad(angle));
    }
    M.cos = cos;
    function sin(angle) {
        return Math.sin(degToRad(angle));
    }
    M.sin = sin;
    function tan(angle) {
        return Math.tan(degToRad(angle));
    }
    M.tan = tan;
    function asin(sin) {
        return radToDeg(Math.asin(sin));
    }
    M.asin = asin;
    function acos(cos) {
        return radToDeg(Math.acos(cos));
    }
    M.acos = acos;
    function atan(tan) {
        return radToDeg(Math.atan(tan));
    }
    M.atan = atan;
    function atan2(tany, tanx) {
        return radToDeg(Math.atan2(tany, tanx));
    }
    M.atan2 = atan2;
})(M || (M = {}));
var Network;
(function (Network) {
    function httpRequest(url, data, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open(data ? "POST" : "GET", url, true);
        xhr.onload = function () {
            var _a;
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var json = JSON.parse(xhr.responseText);
                    if (!json.error && !json.message) {
                        callback(json, undefined);
                    }
                    else {
                        var error = (_a = json.error) !== null && _a !== void 0 ? _a : json.message;
                        callback(undefined, error);
                    }
                }
                else {
                    callback(undefined, xhr.statusText);
                }
            }
        };
        xhr.onerror = function () {
            callback(undefined, xhr.statusText);
        };
        xhr.send(data);
    }
    Network.httpRequest = httpRequest;
})(Network || (Network = {}));
var O;
(function (O) {
    /** Warning: make sure your object has no reference loops! */
    function deepClone(obj) {
        return deepCloneInternal(obj);
    }
    O.deepClone = deepClone;
    function deepCloneInternal(obj) {
        var e_44, _a;
        if (_.isArray(obj)) {
            if (_.isEmpty(obj))
                return [];
            var result = [];
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var el = obj_1_1.value;
                    result.push(deepCloneInternal(el));
                }
            }
            catch (e_44_1) { e_44 = { error: e_44_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_44) throw e_44.error; }
            }
            return result;
        }
        if (_.isFunction(obj))
            return obj;
        if (_.isObject(obj)) {
            if (_.isEmpty(obj))
                return {};
            var result = {};
            for (var key in obj) {
                result[key] = deepCloneInternal(obj[key]);
            }
            return result;
        }
        return obj;
    }
    function deepOverride(obj, overrides) {
        for (var key in overrides) {
            if (obj[key] && _.isArray(overrides[key])) {
                obj[key] = overrides[key];
            }
            else if (obj[key] && _.isObject(obj[key]) && _.isObject(overrides[key])) {
                deepOverride(obj[key], overrides[key]);
            }
            else {
                obj[key] = overrides[key];
            }
        }
    }
    O.deepOverride = deepOverride;
    function getClass(obj) {
        return obj.constructor;
    }
    O.getClass = getClass;
    function getPath(obj, path) {
        var e_45, _a;
        var pathParts = path.split('.');
        var current = obj;
        try {
            for (var pathParts_1 = __values(pathParts), pathParts_1_1 = pathParts_1.next(); !pathParts_1_1.done; pathParts_1_1 = pathParts_1.next()) {
                var part = pathParts_1_1.value;
                if (!current || !(part in current))
                    return undefined;
                current = current[part];
            }
        }
        catch (e_45_1) { e_45 = { error: e_45_1 }; }
        finally {
            try {
                if (pathParts_1_1 && !pathParts_1_1.done && (_a = pathParts_1.return)) _a.call(pathParts_1);
            }
            finally { if (e_45) throw e_45.error; }
        }
        return current;
    }
    O.getPath = getPath;
    function setPath(obj, path, value) {
        var e_46, _a;
        var pathParts = path.split('.');
        var lastPart = pathParts.pop();
        var current = obj;
        try {
            for (var pathParts_2 = __values(pathParts), pathParts_2_1 = pathParts_2.next(); !pathParts_2_1.done; pathParts_2_1 = pathParts_2.next()) {
                var part = pathParts_2_1.value;
                if (!current || !(part in current))
                    return;
                current = current[part];
            }
        }
        catch (e_46_1) { e_46 = { error: e_46_1 }; }
        finally {
            try {
                if (pathParts_2_1 && !pathParts_2_1.done && (_a = pathParts_2.return)) _a.call(pathParts_2);
            }
            finally { if (e_46) throw e_46.error; }
        }
        current[lastPart] = value;
    }
    O.setPath = setPath;
    function hasPath(obj, path) {
        var e_47, _a;
        var pathParts = path.split('.');
        var current = obj;
        try {
            for (var pathParts_3 = __values(pathParts), pathParts_3_1 = pathParts_3.next(); !pathParts_3_1.done; pathParts_3_1 = pathParts_3.next()) {
                var part = pathParts_3_1.value;
                if (!(part in current))
                    return false;
                current = current[part];
            }
        }
        catch (e_47_1) { e_47 = { error: e_47_1 }; }
        finally {
            try {
                if (pathParts_3_1 && !pathParts_3_1.done && (_a = pathParts_3.return)) _a.call(pathParts_3);
            }
            finally { if (e_47) throw e_47.error; }
        }
        return true;
    }
    O.hasPath = hasPath;
    function mergeObject(obj, into, combine) {
        if (combine === void 0) { combine = (function (e, into) { return e; }); }
        var result = _.clone(into);
        for (var key in obj) {
            if (result[key]) {
                result[key] = combine(obj[key], result[key]);
            }
            else {
                result[key] = obj[key];
            }
        }
        return result;
    }
    O.mergeObject = mergeObject;
    function withDefaults(obj, defaults) {
        var result = _.clone(obj);
        _.defaults(result, defaults);
        return result;
    }
    O.withDefaults = withDefaults;
    function withOverrides(obj, overrides) {
        var result = _.clone(obj);
        _.extend(result, overrides);
        return result;
    }
    O.withOverrides = withOverrides;
})(O || (O = {}));
var PageVisibility;
(function (PageVisibility) {
    PageVisibility.HIDDEN = hiddenKey(document);
    PageVisibility.VISIBILITY_CHANGE = visibilityChangeKey(document);
    function hiddenKey(document) {
        if (typeof document.hidden !== "undefined") {
            return "hidden";
        }
        else if (typeof document.msHidden !== "undefined") {
            return "msHidden";
        }
        else if (typeof document.webkitHidden !== "undefined") {
            return "webkitHidden";
        }
        console.error("Page Visibility API unsupported!");
        return undefined;
    }
    function visibilityChangeKey(document) {
        if (typeof document.hidden !== "undefined") {
            return "visibilitychange";
        }
        else if (typeof document.msHidden !== "undefined") {
            return "msvisibilitychange";
        }
        else if (typeof document.webkitHidden !== "undefined") {
            return "webkitvisibilitychange";
        }
        return undefined;
    }
})(PageVisibility || (PageVisibility = {}));
var St;
(function (St) {
    function asciiToBinary(ascii) {
        var result = "";
        for (var i = 0; i < ascii.length; i++) {
            var bin = ascii[i].charCodeAt(0).toString(2);
            result += Array(8 - bin.length + 1).join("0") + bin;
        }
        return result;
    }
    St.asciiToBinary = asciiToBinary;
    function binaryToAscii(binary) {
        var result = "";
        var arr = binary.match(/.{1,8}/g);
        for (var i = 0; i < arr.length; i++) {
            result += String.fromCharCode(parseInt(arr[i], 2));
        }
        return result;
    }
    St.binaryToAscii = binaryToAscii;
    function encodeB64S(text) {
        var binary = St.asciiToBinary(text);
        return btoa(St.binaryToAscii(binary[binary.length - 1] + binary.substring(0, binary.length - 1)));
    }
    St.encodeB64S = encodeB64S;
    function decodeB64S(text) {
        var binary = St.asciiToBinary(atob(text));
        return St.binaryToAscii(binary.substring(1) + binary[0]);
    }
    St.decodeB64S = decodeB64S;
    function isEmpty(text) {
        return !text;
    }
    St.isEmpty = isEmpty;
    function isBlank(text) {
        return isEmpty(text) || isEmpty(text.trim());
    }
    St.isBlank = isBlank;
    function padLeft(text, minLength, padString) {
        if (padString === void 0) { padString = ' '; }
        while (text.length < minLength) {
            text = padString + text;
        }
        return text;
    }
    St.padLeft = padLeft;
    function padLeftRight(text, minLength, extraPadBias, padString) {
        if (padString === void 0) { padString = ' '; }
        while (text.length < minLength - 1) {
            text = padString + text + padString;
        }
        if (text.length === minLength - 1) {
            if (extraPadBias === 'left')
                return padString + text;
            if (extraPadBias === 'right')
                return text + padString;
            if (extraPadBias === 'both')
                return padString + text + padString;
        }
        return text;
    }
    St.padLeftRight = padLeftRight;
    function padRight(text, minLength, padString) {
        if (padString === void 0) { padString = ' '; }
        while (text.length < minLength) {
            text = text + padString;
        }
        return text;
    }
    St.padRight = padRight;
    function replaceAll(str, replace, wiith) {
        if (!str)
            return "";
        return str.split(replace).join(wiith);
    }
    St.replaceAll = replaceAll;
    function splitOnWhitespace(str) {
        if (_.isEmpty(str))
            return [];
        return str.match(/\S+/g) || [];
    }
    St.splitOnWhitespace = splitOnWhitespace;
})(St || (St = {}));
var StateMachine = /** @class */ (function () {
    function StateMachine() {
        this.states = {};
    }
    StateMachine.prototype.addState = function (name, state) {
        if (name in this.states) {
            console.error("State " + name + " already exists on state machine", this);
            return;
        }
        this.states[name] = state;
    };
    StateMachine.prototype.setState = function (name) {
        var _a;
        if (this.script)
            this.script.done = true;
        var state = this.getState(name);
        if (!state)
            return;
        this.currentState = state;
        if (state.callback)
            state.callback();
        var stateScript = (_a = state.script) !== null && _a !== void 0 ? _a : S.noop();
        var sm = this;
        this.script = new Script(function () {
            var selectedTransition;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, stateScript];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/];
                    case 2:
                        _b.sent(); // Yield one more time so we don't immediately transition to next state.
                        selectedTransition = undefined;
                        _b.label = 3;
                    case 3:
                        selectedTransition = sm.getValidTransition(sm.currentState);
                        if (!!selectedTransition) return [3 /*break*/, 5];
                        return [4 /*yield*/];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        if (!selectedTransition) return [3 /*break*/, 3];
                        _b.label = 6;
                    case 6: return [4 /*yield*/, S.wait((_a = selectedTransition.delay) !== null && _a !== void 0 ? _a : 0)];
                    case 7:
                        _b.sent();
                        sm.setState(selectedTransition.toState);
                        return [2 /*return*/];
                }
            });
        });
        this.script.update(0);
    };
    StateMachine.prototype.update = function (delta) {
        var _a;
        if (this.script)
            this.script.update(delta);
        if ((_a = this.currentState) === null || _a === void 0 ? void 0 : _a.update)
            this.currentState.update();
    };
    StateMachine.prototype.getCurrentStateName = function () {
        for (var name_4 in this.states) {
            if (this.states[name_4] === this.currentState) {
                return name_4;
            }
        }
        return undefined;
    };
    StateMachine.prototype.getState = function (name) {
        if (!this.states[name]) {
            console.error("No state named " + name + " exists on state machine", this);
        }
        return this.states[name];
    };
    StateMachine.prototype.getValidTransition = function (state) {
        var e_48, _a;
        try {
            for (var _b = __values(state.transitions || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var transition = _c.value;
                if (transition.condition && !transition.condition())
                    continue;
                return transition;
            }
        }
        catch (e_48_1) { e_48 = { error: e_48_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_48) throw e_48.error; }
        }
        return undefined;
    };
    return StateMachine;
}());
var Tween = /** @class */ (function () {
    function Tween(start, end, duration, easingFunction) {
        if (easingFunction === void 0) { easingFunction = Tween.Easing.Linear; }
        this.start = start;
        this.end = end;
        this.duration = duration;
        this.easingFunction = easingFunction;
        this.timer = new Timer(duration);
    }
    Object.defineProperty(Tween.prototype, "done", {
        get: function () { return this.timer.done; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "value", {
        get: function () { return this.start + (this.end - this.start) * this.easingFunction(this.timer.progress); },
        enumerable: false,
        configurable: true
    });
    Tween.prototype.update = function (delta) {
        this.timer.update(delta);
    };
    return Tween;
}());
(function (Tween) {
    var Easing;
    (function (Easing) {
        function outFromIn(inFn) {
            return function (t) { return 1 - inFn(1 - t); };
        }
        Easing.outFromIn = outFromIn;
        function inOutFromIn(inFn) {
            return function (t) { return t <= 0.5 ? inFn(2 * t) / 2 : 1 - inFn(2 * (1 - t)) / 2; };
        }
        Easing.inOutFromIn = inOutFromIn;
        /* Easing Functions */
        Easing.Linear = function (t) { return t; };
        Easing.InPow = function (pow) { return (function (t) { return Math.pow(t, pow); }); };
        Easing.OutPow = function (pow) { return outFromIn(Easing.InPow(pow)); };
        Easing.InOutPow = function (pow) { return inOutFromIn(Easing.InPow(pow)); };
        Easing.InQuad = Easing.InPow(2);
        Easing.OutQuad = Easing.OutPow(2);
        Easing.InOutQuad = Easing.InOutPow(2);
        Easing.InCubic = Easing.InPow(3);
        Easing.OutCubic = Easing.OutPow(3);
        Easing.InOutCubic = Easing.InOutPow(3);
        Easing.InExpPow = function (pow) { return function (t) { return t * Math.pow(2, (8.25 * pow * (t - 1))); }; };
        Easing.OutExpPow = function (pow) { return outFromIn(Easing.InExpPow(pow)); };
        Easing.InOutExpPow = function (pow) { return inOutFromIn(Easing.InExpPow(pow)); };
        Easing.InExp = Easing.InExpPow(1);
        Easing.OutExp = Easing.OutExpPow(1);
        Easing.InOutExp = Easing.InOutExpPow(1);
        Easing.InBounce = function (bounceScale) { return function (t) { return (bounceScale + 1) * Math.pow(t, 3) - bounceScale * Math.pow(t, 2); }; };
        Easing.OutBounce = function (bounceScale) { return outFromIn(Easing.InBounce(bounceScale)); };
        Easing.InOutBounce = function (bounceScale) { return inOutFromIn(Easing.InBounce(bounceScale)); };
        Easing.InElastic = function (elasticity) { return function (t) {
            if (elasticity === 0)
                return t;
            if (t === 0)
                return 0;
            if (t === 1)
                return 1;
            return -Math.pow(2, (10 * t - 10) / elasticity) * M.sin((10 * t - 10.75) * 120);
        }; };
        Easing.OutElastic = function (elasticity) { return outFromIn(Easing.InElastic(elasticity)); };
        Easing.InOutElastic = function (elasticity) { return inOutFromIn(Easing.InElastic(elasticity)); };
        Easing.OscillateSine = function (cyclesPerSecond) { return (function (t) { return (1 - M.cos(t * 360 * cyclesPerSecond)) / 2; }); };
    })(Easing = Tween.Easing || (Tween.Easing = {}));
})(Tween || (Tween = {}));
var Utils;
(function (Utils) {
    Utils.NOOP = function () { return null; };
    Utils.NOOP_DISPLAYOBJECT = new PIXI.DisplayObject();
    Utils.NOOP_RENDERTEXTURE = PIXI.RenderTexture.create({ width: 0, height: 0 });
    Utils.UID = new UIDGenerator();
})(Utils || (Utils = {}));
function requireType(param) {
    return param;
}
function async(fn) {
    setTimeout(fn, 1);
}
var WebUtils;
(function (WebUtils) {
    function locationContains(sub) {
        var _a, _b;
        return ((_a = window.location.href) === null || _a === void 0 ? void 0 : _a.includes(sub)) || ((_b = document.referrer) === null || _b === void 0 ? void 0 : _b.includes(sub));
    }
    WebUtils.locationContains = locationContains;
})(WebUtils || (WebUtils = {}));
/// <reference path="../utils/o_object.ts"/>
var Camera = /** @class */ (function () {
    function Camera(config, world) {
        var _a, _b, _c, _d, _e;
        this.world = world;
        this.width = (_a = config.width) !== null && _a !== void 0 ? _a : world.width;
        this.height = (_b = config.height) !== null && _b !== void 0 ? _b : world.height;
        this.bounds = O.withDefaults((_c = config.bounds) !== null && _c !== void 0 ? _c : {}, {
            top: -Infinity,
            bottom: Infinity,
            left: -Infinity,
            right: Infinity,
        });
        this.mode = (_d = _.clone(config.mode)) !== null && _d !== void 0 ? _d : Camera.Mode.FOCUS(this.width / 2, this.height / 2);
        this.movement = (_e = _.clone(config.movement)) !== null && _e !== void 0 ? _e : Camera.Movement.SNAP();
        this.shakeIntensity = 0;
        this._shakeX = 0;
        this._shakeY = 0;
        this.waverIntensityX = 0;
        this.waverIntensityY = 0;
        this.waverSpeed = 1;
        this._waverX = 0;
        this._waverY = 0;
        this.waverPerlin = new Perlin();
        this.debugOffsetX = 0;
        this.debugOffsetY = 0;
        this.snapPosition();
    }
    Object.defineProperty(Camera.prototype, "worldOffsetX", {
        get: function () { return this.x - this.width / 2 + this._shakeX + this._waverX + this.debugOffsetX; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "worldOffsetY", {
        get: function () { return this.y - this.height / 2 + this._shakeY + this._waverY + this.debugOffsetY; },
        enumerable: false,
        configurable: true
    });
    Camera.prototype.update = function () {
        var target = this.mode.getTargetPt(this);
        this.moveTowardsPoint(target.x, target.y);
        if (this.shakeIntensity > 0) {
            var pt = Random.inCircle(this.shakeIntensity);
            this._shakeX = pt.x;
            this._shakeY = pt.y;
        }
        else {
            this._shakeX = 0;
            this._shakeY = 0;
        }
        if (this.waverIntensityX > 0 || this.waverIntensityY > 0) {
            var xf = this.waverPerlin.get(this.world.time * this.waverSpeed, -101.5);
            var yf = this.waverPerlin.get(this.world.time * this.waverSpeed, 402.7);
            this._waverX = this.waverIntensityX * xf;
            this._waverY = this.waverIntensityY * yf;
        }
        else {
            this._waverX = 0;
            this._waverY = 0;
        }
        this.clampToBounds();
        if (Debug.MOVE_CAMERA_WITH_ARROWS && global.theater && this.world === global.theater.currentWorld) {
            if (Input.isDown(Input.DEBUG_MOVE_CAMERA_LEFT))
                this.debugOffsetX -= 1;
            if (Input.isDown(Input.DEBUG_MOVE_CAMERA_RIGHT))
                this.debugOffsetX += 1;
            if (Input.isDown(Input.DEBUG_MOVE_CAMERA_UP))
                this.debugOffsetY -= 1;
            if (Input.isDown(Input.DEBUG_MOVE_CAMERA_DOWN))
                this.debugOffsetY += 1;
        }
    };
    Camera.prototype.clampToBounds = function () {
        if (this.bounds.left > -Infinity && this.x - this.width / 2 < this.bounds.left) {
            this.x = this.bounds.left + this.width / 2;
        }
        if (this.bounds.right < Infinity && this.x + this.width / 2 > this.bounds.right) {
            this.x = this.bounds.right - this.width / 2;
        }
        if (this.bounds.top > -Infinity && this.y - this.height / 2 < this.bounds.top) {
            this.y = this.bounds.top + this.height / 2;
        }
        if (this.bounds.bottom < Infinity && this.y + this.height / 2 > this.bounds.bottom) {
            this.y = this.bounds.bottom - this.height / 2;
        }
    };
    Camera.prototype.moveTowardsPoint = function (x, y) {
        var hw = this.movement.deadZoneWidth / 2;
        var hh = this.movement.deadZoneHeight / 2;
        var dx = x - this.x;
        var dy = y - this.y;
        if (Math.abs(dx) > hw) {
            var tx = Math.abs(hw / dx);
            var targetx = this.x + (1 - tx) * dx;
            if (this.movement.speed === Infinity) {
                this.x = targetx;
            }
            else {
                this.x = M.lerpTime(this.x, targetx, this.movement.speed, this.world.delta);
            }
        }
        if (Math.abs(dy) > hh) {
            var ty = Math.abs(hh / dy);
            var targety = this.y + (1 - ty) * dy;
            if (this.movement.speed === Infinity) {
                this.y = targety;
            }
            else {
                this.y = M.lerpTime(this.y, targety, this.movement.speed, this.world.delta);
            }
        }
    };
    Camera.prototype.snapPosition = function () {
        var target = this.mode.getTargetPt(this);
        this.x = target.x;
        this.y = target.y;
    };
    Camera.prototype.setMode = function (mode) {
        this.mode = mode;
    };
    Camera.prototype.setModeFocus = function (x, y) {
        this.setMode(Camera.Mode.FOCUS(x, y));
    };
    Camera.prototype.setModeFollow = function (target, offsetX, offsetY, snapToScreenBounds) {
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (snapToScreenBounds === void 0) { snapToScreenBounds = false; }
        this.setMode(Camera.Mode.FOLLOW(target, offsetX, offsetY, snapToScreenBounds));
    };
    Camera.prototype.setMovement = function (movement) {
        this.movement = movement;
    };
    Camera.prototype.setMovementSnap = function () {
        this.setMovement(Camera.Movement.SNAP());
    };
    Camera.prototype.setMovementSmooth = function (speed, deadZoneWidth, deadZoneHeight) {
        if (deadZoneWidth === void 0) { deadZoneWidth = 0; }
        if (deadZoneHeight === void 0) { deadZoneHeight = 0; }
        this.setMovement(Camera.Movement.SMOOTH(speed, deadZoneWidth, deadZoneHeight));
    };
    return Camera;
}());
(function (Camera) {
    var Mode;
    (function (Mode) {
        function FOLLOW(target, offsetX, offsetY, snapToScreenBounds) {
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            if (snapToScreenBounds === void 0) { snapToScreenBounds = false; }
            return {
                getTargetPt: function (camera) {
                    var position;
                    if (_.isString(target)) {
                        var worldObject = camera.world.select.name(target, false);
                        position = worldObject ? vec2(worldObject.x + offsetX, worldObject.y + offsetY) : vec2(camera.x, camera.y);
                    }
                    else {
                        position = vec2(target.x + offsetX, target.y + offsetY);
                    }
                    if (snapToScreenBounds) {
                        position.x = Math.floor(position.x / camera.width) * camera.width + camera.width / 2;
                        position.y = Math.floor(position.y / camera.height) * camera.height + camera.height / 2;
                    }
                    return position;
                },
            };
        }
        Mode.FOLLOW = FOLLOW;
        function FOCUS(x, y) {
            var focusPt = vec2(x, y);
            return {
                getTargetPt: function (camera) { return focusPt; },
            };
        }
        Mode.FOCUS = FOCUS;
    })(Mode = Camera.Mode || (Camera.Mode = {}));
    var Movement;
    (function (Movement) {
        function SNAP() {
            return {
                speed: Infinity,
                deadZoneWidth: 0,
                deadZoneHeight: 0,
            };
        }
        Movement.SNAP = SNAP;
        function SMOOTH(speed, deadZoneWidth, deadZoneHeight) {
            if (deadZoneWidth === void 0) { deadZoneWidth = 0; }
            if (deadZoneHeight === void 0) { deadZoneHeight = 0; }
            return {
                speed: speed,
                deadZoneWidth: deadZoneWidth,
                deadZoneHeight: deadZoneHeight,
            };
        }
        Movement.SMOOTH = SMOOTH;
    })(Movement = Camera.Movement || (Camera.Movement = {}));
})(Camera || (Camera = {}));
var Physics;
(function (Physics) {
    function resolveCollisions(world) {
        var e_49, _a, e_50, _b, e_51, _c;
        var collidingPhysicsWorldObjects = getCollidingPhysicsObjects(world);
        var physicsObjectDataCache = cachePhysicsObjectData(collidingPhysicsWorldObjects);
        var iters = 1;
        try {
            for (var collidingPhysicsWorldObjects_1 = __values(collidingPhysicsWorldObjects), collidingPhysicsWorldObjects_1_1 = collidingPhysicsWorldObjects_1.next(); !collidingPhysicsWorldObjects_1_1.done; collidingPhysicsWorldObjects_1_1 = collidingPhysicsWorldObjects_1.next()) {
                var worldObject = collidingPhysicsWorldObjects_1_1.value;
                var d = physicsObjectDataCache.dpos[worldObject.uid];
                worldObject.x -= d.x;
                worldObject.y -= d.y;
                if (d.magnitude < world.minDistanceIgnoreCollisionStepCalculation) {
                    iters = Math.max(iters, Math.ceil(d.magnitude / world.maxDistancePerCollisionStep));
                }
                worldObject.bounds.freeze();
            }
        }
        catch (e_49_1) { e_49 = { error: e_49_1 }; }
        finally {
            try {
                if (collidingPhysicsWorldObjects_1_1 && !collidingPhysicsWorldObjects_1_1.done && (_a = collidingPhysicsWorldObjects_1.return)) _a.call(collidingPhysicsWorldObjects_1);
            }
            finally { if (e_49) throw e_49.error; }
        }
        var resultCollisions = [];
        for (var iter = 0; iter < iters; iter++) {
            try {
                for (var collidingPhysicsWorldObjects_2 = (e_50 = void 0, __values(collidingPhysicsWorldObjects)), collidingPhysicsWorldObjects_2_1 = collidingPhysicsWorldObjects_2.next(); !collidingPhysicsWorldObjects_2_1.done; collidingPhysicsWorldObjects_2_1 = collidingPhysicsWorldObjects_2.next()) {
                    var worldObject = collidingPhysicsWorldObjects_2_1.value;
                    var d = physicsObjectDataCache.dpos[worldObject.uid];
                    worldObject.x += d.x / iters;
                    worldObject.y += d.y / iters;
                    worldObject.bounds.move(d.x / iters, d.y / iters);
                }
            }
            catch (e_50_1) { e_50 = { error: e_50_1 }; }
            finally {
                try {
                    if (collidingPhysicsWorldObjects_2_1 && !collidingPhysicsWorldObjects_2_1.done && (_b = collidingPhysicsWorldObjects_2.return)) _b.call(collidingPhysicsWorldObjects_2);
                }
                finally { if (e_50) throw e_50.error; }
            }
            performNormalIteration(world, resultCollisions);
        }
        for (var iter = 0; iter < world.collisionIterations - iters; iter++) {
            performNormalIteration(world, resultCollisions);
        }
        performFinalIteration(world, resultCollisions);
        // Collect any duplicate collisions for the same entities.
        var collectedCollisions = collectCollisions(resultCollisions);
        // Apply momentum transfer/callbacks
        applyCollisionEffects(collectedCollisions, world.delta);
        try {
            for (var collidingPhysicsWorldObjects_3 = __values(collidingPhysicsWorldObjects), collidingPhysicsWorldObjects_3_1 = collidingPhysicsWorldObjects_3.next(); !collidingPhysicsWorldObjects_3_1.done; collidingPhysicsWorldObjects_3_1 = collidingPhysicsWorldObjects_3.next()) {
                var worldObject = collidingPhysicsWorldObjects_3_1.value;
                worldObject.bounds.unfreeze();
            }
        }
        catch (e_51_1) { e_51 = { error: e_51_1 }; }
        finally {
            try {
                if (collidingPhysicsWorldObjects_3_1 && !collidingPhysicsWorldObjects_3_1.done && (_c = collidingPhysicsWorldObjects_3.return)) _c.call(collidingPhysicsWorldObjects_3);
            }
            finally { if (e_51) throw e_51.error; }
        }
    }
    Physics.resolveCollisions = resolveCollisions;
    function performNormalIteration(world, resultCollisions) {
        var e_52, _a;
        var collisions = getRaycastCollisions(world)
            .sort(function (a, b) { return a.collision.t - b.collision.t; });
        try {
            for (var collisions_1 = __values(collisions), collisions_1_1 = collisions_1.next(); !collisions_1_1.done; collisions_1_1 = collisions_1.next()) {
                var collision = collisions_1_1.value;
                var success = resolveCollision(world, collision);
                if (success)
                    resultCollisions.push(collision);
            }
        }
        catch (e_52_1) { e_52 = { error: e_52_1 }; }
        finally {
            try {
                if (collisions_1_1 && !collisions_1_1.done && (_a = collisions_1.return)) _a.call(collisions_1);
            }
            finally { if (e_52) throw e_52.error; }
        }
    }
    function performFinalIteration(world, resultCollisions) {
        var e_53, _a, e_54, _b;
        var collisions = getRaycastCollisions(world);
        var currentSet = new Set();
        try {
            for (var collisions_2 = __values(collisions), collisions_2_1 = collisions_2.next(); !collisions_2_1.done; collisions_2_1 = collisions_2.next()) {
                var collision = collisions_2_1.value;
                if (collision.move.isImmovable())
                    currentSet.add(collision.move);
                if (collision.from.isImmovable())
                    currentSet.add(collision.from);
            }
        }
        catch (e_53_1) { e_53 = { error: e_53_1 }; }
        finally {
            try {
                if (collisions_2_1 && !collisions_2_1.done && (_a = collisions_2.return)) _a.call(collisions_2);
            }
            finally { if (e_53) throw e_53.error; }
        }
        var doneWithCollisions = false;
        while (!doneWithCollisions) {
            doneWithCollisions = true;
            try {
                for (var collisions_3 = (e_54 = void 0, __values(collisions)), collisions_3_1 = collisions_3.next(); !collisions_3_1.done; collisions_3_1 = collisions_3.next()) {
                    var collision = collisions_3_1.value;
                    var hasMove = currentSet.has(collision.move);
                    var hasFrom = currentSet.has(collision.from);
                    if (hasMove && !hasFrom) {
                        var success = resolveCollision(world, collision, collision.move);
                        if (success)
                            resultCollisions.push(collision);
                        currentSet.add(collision.from);
                        doneWithCollisions = false;
                    }
                    if (hasFrom && !hasMove) {
                        var success = resolveCollision(world, collision, collision.from);
                        if (success)
                            resultCollisions.push(collision);
                        currentSet.add(collision.move);
                        doneWithCollisions = false;
                    }
                }
            }
            catch (e_54_1) { e_54 = { error: e_54_1 }; }
            finally {
                try {
                    if (collisions_3_1 && !collisions_3_1.done && (_b = collisions_3.return)) _b.call(collisions_3);
                }
                finally { if (e_54) throw e_54.error; }
            }
        }
    }
    // Return true iff the collision actually happened.
    function resolveCollision(world, collision, forceImmovable) {
        var raycastCollision = {
            move: collision.move,
            from: collision.from,
            collision: collision.move.bounds.getRaycastCollision(collision.move.x - collision.move.physicslastx, collision.move.y - collision.move.physicslasty, collision.from.bounds, collision.from.x - collision.from.physicslastx, collision.from.y - collision.from.physicslasty),
        };
        if (!raycastCollision.collision)
            return false;
        var displacementCollision = {
            move: raycastCollision.move,
            from: raycastCollision.from,
            collision: undefined
        };
        // Use raycast collision displacement if applicable.
        if (M.magnitude(raycastCollision.collision.displacementX, raycastCollision.collision.displacementY) <= world.useRaycastDisplacementThreshold) {
            displacementCollision.collision = {
                bounds1: raycastCollision.move.bounds,
                bounds2: raycastCollision.from.bounds,
                displacementX: raycastCollision.collision.displacementX,
                displacementY: raycastCollision.collision.displacementY,
            };
        }
        else {
            displacementCollision.collision = raycastCollision.move.bounds.getDisplacementCollision(raycastCollision.from.bounds);
        }
        if (!displacementCollision.collision)
            return false;
        applyDisplacementForCollision(displacementCollision, forceImmovable);
        return true;
    }
    function getRaycastCollisions(world) {
        var e_55, _a;
        var raycastCollisions = [];
        try {
            for (var _b = __values(world.collisions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var collision = _c.value;
                for (var imove = 0; imove < world.physicsGroups[collision.move].worldObjects.length; imove++) {
                    var fromStart = collision.move === collision.from ? imove + 1 : 0; // Don't double-count collisions between members of the same physics group.
                    for (var ifrom = fromStart; ifrom < world.physicsGroups[collision.from].worldObjects.length; ifrom++) {
                        var move = world.physicsGroups[collision.move].worldObjects[imove];
                        var from = world.physicsGroups[collision.from].worldObjects[ifrom];
                        if (move === from)
                            continue;
                        if (!G.overlapRectangles(move.bounds.getBoundingBox(), from.bounds.getBoundingBox()))
                            continue;
                        if (!move.colliding || !from.colliding)
                            continue;
                        if (!move.isCollidingWith(from) || !from.isCollidingWith(move))
                            continue;
                        var raycastCollision = move.bounds.getRaycastCollision(move.x - move.physicslastx, move.y - move.physicslasty, from.bounds, from.x - from.physicslastx, from.y - from.physicslasty);
                        if (!raycastCollision)
                            continue;
                        raycastCollisions.push({
                            move: move, from: from,
                            collision: raycastCollision,
                            callback: collision.callback,
                            momentumTransfer: collision.momentumTransfer,
                        });
                    }
                }
            }
        }
        catch (e_55_1) { e_55 = { error: e_55_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_55) throw e_55.error; }
        }
        return raycastCollisions;
    }
    function applyDisplacementForCollision(collision, forceImmovable) {
        var moveImmovable = collision.move.isImmovable() || collision.move === forceImmovable;
        var fromImmovable = collision.from.isImmovable() || collision.from === forceImmovable;
        if (moveImmovable && fromImmovable)
            return;
        if (moveImmovable) {
            collision.from.x -= collision.collision.displacementX;
            collision.from.y -= collision.collision.displacementY;
            collision.from.bounds.move(-collision.collision.displacementX, -collision.collision.displacementY);
            return;
        }
        if (fromImmovable) {
            collision.move.x += collision.collision.displacementX;
            collision.move.y += collision.collision.displacementY;
            collision.move.bounds.move(collision.collision.displacementX, collision.collision.displacementY);
            return;
        }
        var massFactor = (collision.move.mass + collision.from.mass === 0) ? 0.5 :
            collision.from.mass / (collision.move.mass + collision.from.mass);
        collision.move.x += massFactor * collision.collision.displacementX;
        collision.move.y += massFactor * collision.collision.displacementY;
        collision.move.bounds.move(massFactor * collision.collision.displacementX, massFactor * collision.collision.displacementY);
        collision.from.x -= (1 - massFactor) * collision.collision.displacementX;
        collision.from.y -= (1 - massFactor) * collision.collision.displacementY;
        collision.from.bounds.move(-(1 - massFactor) * collision.collision.displacementX, -(1 - massFactor) * collision.collision.displacementY);
    }
    function collectCollisions(collisions) {
        var e_56, _a, e_57, _b;
        var collisionGroups = [];
        try {
            for (var collisions_4 = __values(collisions), collisions_4_1 = collisions_4.next(); !collisions_4_1.done; collisions_4_1 = collisions_4.next()) {
                var collision = collisions_4_1.value;
                var collisionFoundInList = false;
                try {
                    for (var collisionGroups_1 = (e_57 = void 0, __values(collisionGroups)), collisionGroups_1_1 = collisionGroups_1.next(); !collisionGroups_1_1.done; collisionGroups_1_1 = collisionGroups_1.next()) {
                        var collisionList = collisionGroups_1_1.value;
                        if (collisionList[0].move === collision.move && collisionList[0].from === collision.from) {
                            collisionList.push(collision);
                            collisionFoundInList = true;
                            break;
                        }
                    }
                }
                catch (e_57_1) { e_57 = { error: e_57_1 }; }
                finally {
                    try {
                        if (collisionGroups_1_1 && !collisionGroups_1_1.done && (_b = collisionGroups_1.return)) _b.call(collisionGroups_1);
                    }
                    finally { if (e_57) throw e_57.error; }
                }
                if (!collisionFoundInList) {
                    collisionGroups.push([collision]);
                }
            }
        }
        catch (e_56_1) { e_56 = { error: e_56_1 }; }
        finally {
            try {
                if (collisions_4_1 && !collisions_4_1.done && (_a = collisions_4.return)) _a.call(collisions_4);
            }
            finally { if (e_56) throw e_56.error; }
        }
        return collisionGroups.map(function (collisionList) {
            return {
                move: collisionList[0].move,
                from: collisionList[0].from,
                callback: collisionList[0].callback,
                momentumTransfer: collisionList[0].momentumTransfer,
                collision: {
                    bounds1: collisionList[0].move.bounds,
                    bounds2: collisionList[0].from.bounds,
                    displacementX: A.sum(collisionList, function (collision) { return collision.collision.displacementX; }),
                    displacementY: A.sum(collisionList, function (collision) { return collision.collision.displacementY; }),
                    t: M.min(collisionList, function (collision) { return collision.collision.t; }),
                }
            };
        });
    }
    function applyCollisionEffects(collisions, delta) {
        var e_58, _a;
        try {
            for (var collisions_5 = __values(collisions), collisions_5_1 = collisions_5.next(); !collisions_5_1.done; collisions_5_1 = collisions_5.next()) {
                var collision = collisions_5_1.value;
                var moveCollisionInfo = {
                    self: {
                        obj: collision.move,
                        pre_vx: collision.move.v.x,
                        pre_vy: collision.move.v.y,
                        post_vx: collision.move.v.x,
                        post_vy: collision.move.v.y,
                    },
                    other: {
                        obj: collision.from,
                        pre_vx: collision.from.v.x,
                        pre_vy: collision.from.v.y,
                        post_vx: collision.from.v.x,
                        post_vy: collision.from.v.y,
                    }
                };
                var fromCollisionInfo = {
                    self: moveCollisionInfo.other,
                    other: moveCollisionInfo.self
                };
                applyMomentumTransferForCollision(collision, collision.momentumTransfer, delta);
                moveCollisionInfo.self.post_vx = collision.move.v.x;
                moveCollisionInfo.self.post_vy = collision.move.v.y;
                moveCollisionInfo.other.post_vx = collision.from.v.x;
                moveCollisionInfo.other.post_vy = collision.from.v.y;
                if (collision.callback)
                    collision.callback(moveCollisionInfo);
                collision.move.onCollide(moveCollisionInfo);
                collision.from.onCollide(fromCollisionInfo);
            }
        }
        catch (e_58_1) { e_58 = { error: e_58_1 }; }
        finally {
            try {
                if (collisions_5_1 && !collisions_5_1.done && (_a = collisions_5.return)) _a.call(collisions_5);
            }
            finally { if (e_58) throw e_58.error; }
        }
    }
    function applyMomentumTransferForCollision(collision, momentumTransferMode, delta) {
        if (momentumTransferMode === 'elastic') {
            if (collision.move.isImmovable() && collision.from.isImmovable())
                return;
            var d = new Vector2(collision.collision.displacementX, collision.collision.displacementY).normalized();
            var mm = collision.move.mass;
            var mf = collision.from.mass;
            if (mm + mf === 0) {
                // In case of invald masses, set both to the default 1.
                mm = 1;
                mf = 1;
            }
            var vmi_proj = G.dot(collision.move.v, d);
            var vfi_proj = G.dot(collision.from.v, d);
            var mass_factor = (collision.move.mass + collision.from.mass === 0) ? 0.5 :
                collision.from.mass / (collision.move.mass + collision.from.mass);
            var elastic_factor_m = collision.move.isImmovable() ? 0 : collision.from.isImmovable() ? 1 : mass_factor;
            var elastic_factor_f = 1 - elastic_factor_m;
            var dvmf_proj = 2 * (vfi_proj - vmi_proj) * elastic_factor_m;
            var dvff_proj = 2 * (vmi_proj - vfi_proj) * elastic_factor_f;
            collision.move.v.x += dvmf_proj * collision.move.bounce * d.x;
            collision.move.v.y += dvmf_proj * collision.move.bounce * d.y;
            collision.from.v.x += dvff_proj * collision.from.bounce * d.x;
            collision.from.v.y += dvff_proj * collision.from.bounce * d.y;
        }
        else if (momentumTransferMode === 'zero_velocity_local') {
            if (!collision.move.isImmovable()) {
                var fromvx = delta === 0 ? 0 : (collision.from.x - collision.from.physicslastx) / delta;
                var fromvy = delta === 0 ? 0 : (collision.from.y - collision.from.physicslasty) / delta;
                collision.move.v.x -= fromvx;
                collision.move.v.y -= fromvy;
                zeroVelocityAgainstDisplacement(collision.move, collision.collision.displacementX, collision.collision.displacementY);
                collision.move.v.x += fromvx;
                collision.move.v.y += fromvy;
            }
            if (!collision.from.isImmovable()) {
                var movevx = delta === 0 ? 0 : (collision.move.x - collision.move.physicslastx) / delta;
                var movevy = delta === 0 ? 0 : (collision.move.y - collision.move.physicslasty) / delta;
                collision.move.v.x -= movevx;
                collision.move.v.y -= movevy;
                zeroVelocityAgainstDisplacement(collision.from, -collision.collision.displacementX, -collision.collision.displacementY);
                collision.move.v.x += movevx;
                collision.move.v.y += movevy;
            }
        }
        else { // zero_velocity_global
            if (!collision.move.isImmovable()) {
                zeroVelocityAgainstDisplacement(collision.move, collision.collision.displacementX, collision.collision.displacementY);
            }
            if (!collision.from.isImmovable()) {
                zeroVelocityAgainstDisplacement(collision.from, -collision.collision.displacementX, -collision.collision.displacementY);
            }
        }
    }
    function zeroVelocityAgainstDisplacement(obj, dx, dy) {
        var dot = obj.v.x * dx + obj.v.y * dy;
        if (dot >= 0)
            return;
        var factor = dot / M.magnitudeSq(dx, dy);
        obj.v.x -= factor * dx;
        obj.v.y -= factor * dy;
    }
    function getCollidingPhysicsObjects(world) {
        return world.worldObjects.filter(function (worldObject) {
            if (!(worldObject instanceof PhysicsWorldObject))
                return false;
            if (!worldObject.physicsGroup)
                return false;
            if (!worldObject.isActive())
                return false;
            if (!worldObject.colliding)
                return false;
            return true;
        });
    }
    function cachePhysicsObjectData(physicsWorldObjects) {
        var e_59, _a;
        var dpos = {};
        try {
            for (var physicsWorldObjects_1 = __values(physicsWorldObjects), physicsWorldObjects_1_1 = physicsWorldObjects_1.next(); !physicsWorldObjects_1_1.done; physicsWorldObjects_1_1 = physicsWorldObjects_1.next()) {
                var worldObject = physicsWorldObjects_1_1.value;
                dpos[worldObject.uid] = vec2(worldObject.x - worldObject.physicslastx, worldObject.y - worldObject.physicslasty);
            }
        }
        catch (e_59_1) { e_59 = { error: e_59_1 }; }
        finally {
            try {
                if (physicsWorldObjects_1_1 && !physicsWorldObjects_1_1.done && (_a = physicsWorldObjects_1.return)) _a.call(physicsWorldObjects_1);
            }
            finally { if (e_59) throw e_59.error; }
        }
        return { dpos: dpos };
    }
})(Physics || (Physics = {}));
var WorldSelecter = /** @class */ (function () {
    function WorldSelecter(world) {
        this.world = world;
    }
    WorldSelecter.prototype.collidesWith = function (physicsGroup) {
        var _this = this;
        var groups = this.world.getPhysicsGroupsThatCollideWith(physicsGroup);
        return _.flatten(groups.map(function (group) { return _this.world.physicsGroups[group].worldObjects; }));
    };
    WorldSelecter.prototype.modules = function (moduleType) {
        if (!moduleType)
            return [];
        return this.world.worldObjects.map(function (obj) { return obj.getModule(moduleType); }).filter(function (m) { return m; });
    };
    WorldSelecter.prototype.name = function (name, checked) {
        if (checked === void 0) { checked = true; }
        var results = this.nameAll(name);
        if (_.isEmpty(results)) {
            if (checked)
                console.error("No object with name " + name + " exists in world:", this.world);
            return undefined;
        }
        if (results.length > 1) {
            console.error("Multiple objects with name " + name + " exist in world. Returning one of them. World:", this.world);
        }
        return results[0];
    };
    WorldSelecter.prototype.nameAll = function (name) {
        if (!name)
            return [];
        return this.world.worldObjects.filter(function (obj) { return obj.name === name; });
    };
    WorldSelecter.prototype.names = function (type) {
        var e_60, _a;
        var names = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            names[_i - 1] = arguments[_i];
        }
        var result = {};
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_5 = names_1_1.value;
                result[name_5] = this.name(name_5);
            }
        }
        catch (e_60_1) { e_60 = { error: e_60_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_60) throw e_60.error; }
        }
        return result;
    };
    WorldSelecter.prototype.overlap = function (bounds, physicsGroups) {
        var _this = this;
        var objs = physicsGroups
            ? _.flatten(Object.keys(this.world.physicsGroups)
                .filter(function (pg) { return _.contains(physicsGroups, pg); })
                .map(function (pg) { return _this.world.physicsGroups[pg].worldObjects; }))
            : this.world.select.typeAll(PhysicsWorldObject);
        if (_.isEmpty(objs))
            return [];
        return objs.filter(function (obj) { return obj.isOverlapping(bounds); });
    };
    WorldSelecter.prototype.raycast = function (x, y, dx, dy, physicsGroups) {
        var e_61, _a;
        var result = [];
        for (var physicsGroup in this.world.physicsGroups) {
            if (!_.contains(physicsGroups, physicsGroup))
                continue;
            try {
                for (var _b = (e_61 = void 0, __values(this.world.physicsGroups[physicsGroup].worldObjects)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var obj = _c.value;
                    var t = obj.bounds.raycast(x, y, dx, dy);
                    if (!isFinite(t))
                        continue;
                    result.push({ obj: obj, t: t });
                }
            }
            catch (e_61_1) { e_61 = { error: e_61_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_61) throw e_61.error; }
            }
        }
        return result.sort(function (r1, r2) { return r1.t - r2.t; });
    };
    WorldSelecter.prototype.tag = function (tag) {
        return this.world.worldObjects.filter(function (obj) { return _.contains(obj.tags, tag); });
    };
    WorldSelecter.prototype.type = function (type, checked) {
        if (checked === void 0) { checked = true; }
        var results = this.typeAll(type);
        if (_.isEmpty(results)) {
            if (checked)
                console.error("No object of type " + type.name + " exists in world:", this.world);
            return undefined;
        }
        if (results.length > 1) {
            console.error("Multiple objects of type " + type.name + " exist in world. Returning one of them. World:", this.world);
        }
        return results[0];
    };
    WorldSelecter.prototype.typeAll = function (type) {
        return this.world.worldObjects.filter(function (obj) { return obj instanceof type; });
    };
    return WorldSelecter;
}());
var CircleBounds = /** @class */ (function () {
    function CircleBounds(x, y, radius, parent) {
        this.parent = parent;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.center = new Vector2(x, y);
        this.boundingBox = new Rectangle(0, 0, 0, 0);
        this.frozen = false;
    }
    CircleBounds.prototype.clone = function () {
        return new CircleBounds(this.x, this.y, this.radius, this.parent);
    };
    CircleBounds.prototype.containsPoint = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        var center = this.getCenter();
        return M.distanceSq(center.x, center.y, x, y) <= this.radius * this.radius;
    };
    CircleBounds.prototype.freeze = function () {
        this.frozen = false;
        this.getCenter();
        this.getBoundingBox();
        this.frozen = true;
    };
    CircleBounds.prototype.getCenter = function () {
        if (!this.frozen) {
            this.center.x = (this.parent ? this.parent.x : 0) + this.x;
            this.center.y = (this.parent ? this.parent.y : 0) + this.y;
        }
        return this.center;
    };
    CircleBounds.prototype.getBoundingBox = function () {
        if (!this.frozen) {
            this.boundingBox.x = (this.parent ? this.parent.x : 0) + this.x - this.radius;
            this.boundingBox.y = (this.parent ? this.parent.y : 0) + this.y - this.radius;
            this.boundingBox.width = this.radius * 2;
            this.boundingBox.height = this.radius * 2;
        }
        return this.boundingBox;
    };
    CircleBounds.prototype.getDisplacementCollision = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.getDisplacementCollisionCircleRect(this, other);
        if (other instanceof CircleBounds)
            return Bounds.Collision.getDisplacementCollisionCircleCircle(this, other);
        if (other instanceof SlopeBounds)
            return Bounds.Collision.getDisplacementCollisionCircleSlope(this, other);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.getDisplacementCollisionCircleInvertedRect(this, other);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.getDisplacementCollisionCircleInvertedCircle(this, other);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    CircleBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        if (other instanceof RectBounds)
            return Bounds.Collision.getRaycastCollisionCircleRect(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof CircleBounds)
            return Bounds.Collision.getRaycastCollisionCircleCircle(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof SlopeBounds)
            return Bounds.Collision.getRaycastCollisionCircleSlope(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.getRaycastCollisionCircleInvertedRect(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.getRaycastCollisionCircleInvertedCircle(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    CircleBounds.prototype.isOverlapping = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.isOverlappingCircleRect(this, other);
        if (other instanceof CircleBounds)
            return Bounds.Collision.isOverlappingCircleCircle(this, other);
        if (other instanceof SlopeBounds)
            return Bounds.Collision.isOverlappingCircleSlope(this, other);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.isOverlappingCircleInvertedRect(this, other);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.isOverlappingCircleInvertedCircle(this, other);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No overlap supported between these bounds", this, other);
        return false;
    };
    CircleBounds.prototype.move = function (dx, dy) {
        var box = this.getBoundingBox();
        box.x += dx;
        box.y += dy;
        var center = this.getCenter();
        center.x += dx;
        center.y += dy;
    };
    CircleBounds.prototype.raycast = function (x, y, dx, dy) {
        var center = this.getCenter();
        var a = Math.pow(dx, 2) + Math.pow(dy, 2);
        var b = 2 * ((x - center.x) * dx + (y - center.y) * dy);
        var c = Math.pow((x - center.x), 2) + Math.pow((y - center.y), 2) - Math.pow(this.radius, 2);
        var disc = Math.pow(b, 2) - 4 * a * c;
        if (disc < 0)
            return Infinity;
        var small_t = (-b - Math.sqrt(disc)) / (2 * a);
        var large_t = (-b + Math.sqrt(disc)) / (2 * a);
        var t = small_t >= 0 ? small_t : large_t;
        if (t < 0)
            return Infinity;
        return t;
    };
    CircleBounds.prototype.unfreeze = function () {
        this.frozen = false;
    };
    return CircleBounds;
}());
var Bounds;
(function (Bounds) {
    var Collision;
    (function (Collision) {
        var OVERLAP_EPSILON = 0.000001;
        function getDisplacementCollisionCircleCircle(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            var fromPos = from.getCenter();
            var distance = M.distance(movePos.x, movePos.y, fromPos.x, fromPos.y);
            var dx = 0;
            var dy = move.radius + from.radius;
            if (distance !== 0) {
                var dradius = (move.radius + from.radius) - distance;
                dx = (movePos.x - fromPos.x) * dradius / distance;
                dy = (movePos.y - fromPos.y) * dradius / distance;
            }
            return {
                bounds1: move,
                bounds2: from,
                displacementX: dx,
                displacementY: dy,
            };
        }
        Collision.getDisplacementCollisionCircleCircle = getDisplacementCollisionCircleCircle;
        function getDisplacementCollisionCircleRect(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            var fromBox = from.getBoundingBox();
            var checkTop = movePos.y <= fromBox.top + fromBox.height / 2;
            var checkLeft = movePos.x <= fromBox.left + fromBox.width / 2;
            var displacementXs = [];
            var displacementYs = [];
            if (checkTop) {
                displacementXs.push(0);
                displacementYs.push(fromBox.top - move.radius - movePos.y);
            }
            else {
                displacementXs.push(0);
                displacementYs.push(fromBox.bottom + move.radius - movePos.y);
            }
            if (checkLeft) {
                displacementXs.push(fromBox.left - move.radius - movePos.x);
                displacementYs.push(0);
            }
            else {
                displacementXs.push(fromBox.right + move.radius - movePos.x);
                displacementYs.push(0);
            }
            if (checkTop && checkLeft) {
                if (movePos.x === fromBox.left && movePos.y === fromBox.top) {
                    displacementXs.push(-move.radius * Math.SQRT2);
                    displacementYs.push(-move.radius * Math.SQRT2);
                }
                else if (movePos.x < fromBox.left && movePos.y < fromBox.top) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.left, fromBox.top);
                    var dstd = move.radius - srcd;
                    displacementXs.push((movePos.x - fromBox.left) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.top) * dstd / srcd);
                }
                else if (movePos.x > fromBox.left && movePos.y > fromBox.top) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.left, fromBox.top);
                    var dstd = move.radius + srcd;
                    displacementXs.push((movePos.x - fromBox.left) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.top) * dstd / srcd);
                }
            }
            else if (checkTop && !checkLeft) {
                if (movePos.x === fromBox.right && movePos.y === fromBox.top) {
                    displacementXs.push(move.radius * Math.SQRT2);
                    displacementYs.push(-move.radius * Math.SQRT2);
                }
                else if (movePos.x > fromBox.right && movePos.y < fromBox.top) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.right, fromBox.top);
                    var dstd = move.radius - srcd;
                    displacementXs.push((movePos.x - fromBox.right) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.top) * dstd / srcd);
                }
                else if (movePos.x < fromBox.right && movePos.y > fromBox.top) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.right, fromBox.top);
                    var dstd = move.radius + srcd;
                    displacementXs.push((movePos.x - fromBox.right) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.top) * dstd / srcd);
                }
            }
            else if (!checkTop && !checkLeft) {
                if (movePos.x === fromBox.right && movePos.y === fromBox.bottom) {
                    displacementXs.push(move.radius * Math.SQRT2);
                    displacementYs.push(move.radius * Math.SQRT2);
                }
                else if (movePos.x > fromBox.right && movePos.y > fromBox.bottom) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.right, fromBox.bottom);
                    var dstd = move.radius - srcd;
                    displacementXs.push((movePos.x - fromBox.right) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.bottom) * dstd / srcd);
                }
                else if (movePos.x < fromBox.right && movePos.y < fromBox.bottom) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.right, fromBox.bottom);
                    var dstd = move.radius + srcd;
                    displacementXs.push((movePos.x - fromBox.right) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.bottom) * dstd / srcd);
                }
            }
            else if (!checkTop && checkLeft) {
                if (movePos.x === fromBox.left && movePos.y === fromBox.bottom) {
                    displacementXs.push(-move.radius * Math.SQRT2);
                    displacementYs.push(move.radius * Math.SQRT2);
                }
                else if (movePos.x < fromBox.left && movePos.y > fromBox.bottom) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.left, fromBox.bottom);
                    var dstd = move.radius - srcd;
                    displacementXs.push((movePos.x - fromBox.left) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.bottom) * dstd / srcd);
                }
                else if (movePos.x > fromBox.left && movePos.y < fromBox.bottom) {
                    var srcd = M.distance(movePos.x, movePos.y, fromBox.left, fromBox.bottom);
                    var dstd = move.radius + srcd;
                    displacementXs.push((movePos.x - fromBox.left) * dstd / srcd);
                    displacementYs.push((movePos.y - fromBox.bottom) * dstd / srcd);
                }
            }
            if (displacementXs.length === 0)
                return undefined;
            var i = M.argmin(A.range(displacementXs.length), function (i) { return M.magnitude(displacementXs[i], displacementYs[i]); });
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementXs[i],
                displacementY: displacementYs[i],
            };
        }
        Collision.getDisplacementCollisionCircleRect = getDisplacementCollisionCircleRect;
        function getDisplacementCollisionCircleSlope(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            var fromBox = from.getBoundingBox();
            var newXs = [];
            var newYs = [];
            // Right edge
            if (from.direction !== 'upright' && from.direction !== 'downright') {
                var t_1 = closestPointOnLine_t(movePos.x, movePos.y, fromBox.right + move.radius, fromBox.top, fromBox.right + move.radius, fromBox.bottom);
                if (0 <= t_1 && t_1 <= 1) {
                    newXs.push(fromBox.right + move.radius);
                    newYs.push(fromBox.top * (1 - t_1) + fromBox.bottom * t_1);
                }
            }
            // Left edge
            if (from.direction !== 'upleft' && from.direction !== 'downleft') {
                var t_2 = closestPointOnLine_t(movePos.x, movePos.y, fromBox.left - move.radius, fromBox.top, fromBox.left - move.radius, fromBox.bottom);
                if (0 <= t_2 && t_2 <= 1) {
                    newXs.push(fromBox.left - move.radius);
                    newYs.push(fromBox.top * (1 - t_2) + fromBox.bottom * t_2);
                }
            }
            // Top edge
            if (from.direction !== 'upleft' && from.direction !== 'upright') {
                var t_3 = closestPointOnLine_t(movePos.x, movePos.y, fromBox.left, fromBox.top - move.radius, fromBox.right, fromBox.top - move.radius);
                if (0 <= t_3 && t_3 <= 1) {
                    newXs.push(fromBox.left * (1 - t_3) + fromBox.right * t_3);
                    newYs.push(fromBox.top - move.radius);
                }
            }
            // Bottom edge
            if (from.direction !== 'downleft' && from.direction !== 'downright') {
                var t_4 = closestPointOnLine_t(movePos.x, movePos.y, fromBox.left, fromBox.bottom + move.radius, fromBox.right, fromBox.bottom + move.radius);
                if (0 <= t_4 && t_4 <= 1) {
                    newXs.push(fromBox.left * (1 - t_4) + fromBox.right * t_4);
                    newYs.push(fromBox.bottom + move.radius);
                }
            }
            // Diagonal edges
            var dfactor = move.radius / M.magnitude(fromBox.width, fromBox.height);
            var rx = fromBox.height * dfactor;
            var ry = fromBox.width * dfactor;
            var lx1, ly1, lx2, ly2;
            if (from.direction === 'upleft') {
                lx1 = fromBox.left - rx;
                ly1 = fromBox.bottom - ry;
                lx2 = fromBox.right - rx;
                ly2 = fromBox.top - ry;
            }
            else if (from.direction === 'upright') {
                lx1 = fromBox.left + rx;
                ly1 = fromBox.top - ry;
                lx2 = fromBox.right + rx;
                ly2 = fromBox.bottom - ry;
            }
            else if (from.direction === 'downleft') {
                lx1 = fromBox.left - rx;
                ly1 = fromBox.top + ry;
                lx2 = fromBox.right - rx;
                ly2 = fromBox.bottom + ry;
            }
            else {
                lx1 = fromBox.left + rx;
                ly1 = fromBox.bottom + ry;
                lx2 = fromBox.right + rx;
                ly2 = fromBox.top + ry;
            }
            var t = closestPointOnLine_t(movePos.x, movePos.y, lx1, ly1, lx2, ly2);
            if (0 <= t && t <= 1) {
                newXs.push(lx1 * (1 - t) + lx2 * t);
                newYs.push(ly1 * (1 - t) + ly2 * t);
            }
            // Vertices
            function addVertexPos(vx, vy, ldx1, ldy1, ldx2, ldy2) {
                var angle = closestPointOnCircle_angle(movePos.x, movePos.y, vx, vy);
                var newX = vx + M.cos(angle) * move.radius;
                var newY = vy + M.sin(angle) * move.radius;
                if (vectorBetweenVectors(newX - vx, newY - vy, ldx1, ldy1, ldx2, ldy2)) {
                    newXs.push(newX);
                    newYs.push(newY);
                }
            }
            if (from.direction === 'upleft') {
                addVertexPos(fromBox.right, fromBox.bottom, 1, 0, 0, 1);
                addVertexPos(fromBox.right, fromBox.top, 1, 0, -fromBox.height, -fromBox.width);
                addVertexPos(fromBox.left, fromBox.bottom, 0, 1, -fromBox.height, -fromBox.width);
            }
            else if (from.direction === 'upright') {
                addVertexPos(fromBox.left, fromBox.bottom, -1, 0, 0, 1);
                addVertexPos(fromBox.left, fromBox.top, -1, 0, fromBox.height, -fromBox.width);
                addVertexPos(fromBox.right, fromBox.bottom, 0, 1, fromBox.height, -fromBox.width);
            }
            else if (from.direction === 'downright') {
                addVertexPos(fromBox.left, fromBox.top, -1, 0, 0, -1);
                addVertexPos(fromBox.left, fromBox.bottom, -1, 0, fromBox.height, fromBox.width);
                addVertexPos(fromBox.right, fromBox.top, 0, -1, fromBox.height, fromBox.width);
            }
            else {
                addVertexPos(fromBox.right, fromBox.top, 1, 0, 0, -1);
                addVertexPos(fromBox.right, fromBox.bottom, 1, 0, -fromBox.height, fromBox.width);
                addVertexPos(fromBox.left, fromBox.top, 0, -1, -fromBox.height, fromBox.width);
            }
            if (newXs.length === 0)
                return undefined;
            var i = M.argmin(A.range(newXs.length), function (i) { return M.distanceSq(movePos.x, movePos.y, newXs[i], newYs[i]); });
            var displacementX = newXs[i] - movePos.x;
            var displacementY = newYs[i] - movePos.y;
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionCircleSlope = getDisplacementCollisionCircleSlope;
        function getDisplacementCollisionCircleInvertedRect(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            var fromBox = from.getInnerBox();
            var displacementX = 0;
            if (movePos.x - move.radius < fromBox.left)
                displacementX = fromBox.left - (movePos.x - move.radius);
            if (movePos.x + move.radius > fromBox.right)
                displacementX = fromBox.right - (movePos.x + move.radius);
            var displacementY = 0;
            if (movePos.y - move.radius < fromBox.top)
                displacementY = fromBox.top - (movePos.y - move.radius);
            if (movePos.y + move.radius > fromBox.bottom)
                displacementY = fromBox.bottom - (movePos.y + move.radius);
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionCircleInvertedRect = getDisplacementCollisionCircleInvertedRect;
        function getDisplacementCollisionCircleInvertedCircle(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            var fromPos = from.getCenter();
            var distance = M.distance(movePos.x, movePos.y, fromPos.x, fromPos.y);
            var dx = 0;
            var dy = from.radius - move.radius;
            if (distance !== 0) {
                var dradius = (from.radius - move.radius) - distance;
                dx = (movePos.x - fromPos.x) * dradius / distance;
                dy = (movePos.y - fromPos.y) * dradius / distance;
            }
            return {
                bounds1: move,
                bounds2: from,
                displacementX: dx,
                displacementY: dy,
            };
        }
        Collision.getDisplacementCollisionCircleInvertedCircle = getDisplacementCollisionCircleInvertedCircle;
        function getDisplacementCollisionRectRect(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var currentBox = move.getBoundingBox();
            var currentOtherBox = from.getBoundingBox();
            var displacementX = M.argmin([currentOtherBox.right - currentBox.left, currentOtherBox.left - currentBox.right], Math.abs);
            var displacementY = M.argmin([currentOtherBox.bottom - currentBox.top, currentOtherBox.top - currentBox.bottom], Math.abs);
            if (Math.abs(displacementX) < Math.abs(displacementY)) {
                displacementY = 0;
            }
            else {
                displacementX = 0;
            }
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionRectRect = getDisplacementCollisionRectRect;
        function getDisplacementCollisionRectSlope(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            var fromBox = from.getBoundingBox();
            var newXs = [];
            var newYs = [];
            // Left Edge + vertex
            if (from.direction === 'upright' || from.direction === 'downright'
                || (from.direction === 'upleft' && moveBox.top < fromBox.bottom && fromBox.bottom < moveBox.bottom)
                || (from.direction === 'downleft' && moveBox.top < fromBox.top && fromBox.top < moveBox.bottom)) {
                newXs.push(fromBox.left - moveBox.width);
                newYs.push(moveBox.top);
            }
            // Right Edge + vertex
            if (from.direction === 'upleft' || from.direction === 'downleft'
                || (from.direction === 'upright' && moveBox.top < fromBox.bottom && fromBox.bottom < moveBox.bottom)
                || (from.direction === 'downright' && moveBox.top < fromBox.top && fromBox.top < moveBox.bottom)) {
                newXs.push(fromBox.right);
                newYs.push(moveBox.top);
            }
            // Top Edge + vertex
            if (from.direction === 'downleft' || from.direction === 'downright'
                || (from.direction === 'upleft' && moveBox.left < fromBox.right && fromBox.right < moveBox.right)
                || (from.direction === 'upright' && moveBox.left < fromBox.left && fromBox.left < moveBox.right)) {
                newXs.push(moveBox.left);
                newYs.push(fromBox.top - moveBox.height);
            }
            // Bottom Edge + vertex
            if (from.direction === 'upleft' || from.direction === 'upright'
                || (from.direction === 'downleft' && moveBox.left < fromBox.right && fromBox.right < moveBox.right)
                || (from.direction === 'downright' && moveBox.left < fromBox.left && fromBox.left < moveBox.right)) {
                newXs.push(moveBox.left);
                newYs.push(fromBox.bottom);
            }
            var ww = fromBox.width * fromBox.width;
            var hh = fromBox.height * fromBox.height;
            var wh = fromBox.width * fromBox.height;
            // Up-left edge
            if (from.direction === 'upleft') {
                var xi = (ww * moveBox.right + hh * fromBox.left + wh * fromBox.bottom - wh * moveBox.bottom) / (ww + hh);
                var yi = fromBox.width / fromBox.height * (xi - moveBox.right) + moveBox.bottom;
                newXs.push(xi - moveBox.width);
                newYs.push(yi - moveBox.height);
            }
            // Up-right edge
            if (from.direction === 'upright') {
                var xi = (ww * moveBox.left + hh * fromBox.left - wh * fromBox.top + wh * moveBox.bottom) / (ww + hh);
                var yi = -fromBox.width / fromBox.height * (xi - moveBox.left) + moveBox.bottom;
                newXs.push(xi);
                newYs.push(yi - moveBox.height);
            }
            // Down-right edge
            if (from.direction === 'downright') {
                var xi = (ww * moveBox.left + hh * fromBox.left + wh * fromBox.bottom - wh * moveBox.top) / (ww + hh);
                var yi = fromBox.width / fromBox.height * (xi - moveBox.left) + moveBox.top;
                newXs.push(xi);
                newYs.push(yi);
            }
            // Down-left edge
            if (from.direction === 'downleft') {
                var xi = (ww * moveBox.right + hh * fromBox.left - wh * fromBox.top + wh * moveBox.top) / (ww + hh);
                var yi = -fromBox.width / fromBox.height * (xi - moveBox.right) + moveBox.top;
                newXs.push(xi - moveBox.width);
                newYs.push(yi);
            }
            if (newXs.length === 0)
                return undefined;
            var i = M.argmin(A.range(newXs.length), function (i) { return M.distanceSq(moveBox.left, moveBox.top, newXs[i], newYs[i]); });
            var displacementX = newXs[i] - moveBox.left;
            var displacementY = newYs[i] - moveBox.top;
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionRectSlope = getDisplacementCollisionRectSlope;
        function getDisplacementCollisionRectInvertedRect(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            var fromBox = from.getInnerBox();
            var displacementX = 0;
            if (moveBox.left < fromBox.left)
                displacementX = fromBox.left - moveBox.left;
            if (moveBox.right > fromBox.right)
                displacementX = fromBox.right - moveBox.right;
            var displacementY = 0;
            if (moveBox.top < fromBox.top)
                displacementY = fromBox.top - moveBox.top;
            if (moveBox.bottom > fromBox.bottom)
                displacementY = fromBox.bottom - moveBox.bottom;
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionRectInvertedRect = getDisplacementCollisionRectInvertedRect;
        function getDisplacementCollisionRectInvertedCircle(move, from) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            var fromPos = from.getCenter();
            var dx = moveBox.x + moveBox.width / 2 - fromPos.x;
            var dy = moveBox.y + moveBox.height / 2 - fromPos.y;
            var displacementX;
            var displacementY;
            if (dx === 0 && dy === 0) {
                displacementX = 0;
                displacementY = dy - from.radius;
            }
            else if (dx === 0) {
                displacementX = 0;
                displacementY = dy + Math.sign(dy) * (Math.sqrt(Math.pow(from.radius, 2) - Math.pow((move.width / 2), 2)) - move.height / 2);
            }
            else if (dy === 0) {
                displacementX = dx + Math.sign(dx) * (Math.sqrt(Math.pow(from.radius, 2) - Math.pow((move.height / 2), 2)) - move.width / 2);
                displacementY = 0;
            }
            else {
                var cornerx = moveBox.x + (dx < 0 ? 0 : moveBox.width);
                var cornery = moveBox.y + (dy < 0 ? 0 : moveBox.height);
                var cornerdx = cornerx - fromPos.x;
                var cornerdy = cornery - fromPos.y;
                var distance = M.distance(cornerdx, cornerdy, fromPos.x, fromPos.y);
                displacementX = cornerdx * from.radius / distance;
                displacementY = cornerdy * from.radius / distance;
            }
            return {
                bounds1: move,
                bounds2: from,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getDisplacementCollisionRectInvertedCircle = getDisplacementCollisionRectInvertedCircle;
        function getRaycastCollisionCircleCircle(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            movePos.x -= movedx;
            movePos.y -= movedy;
            var fromPos = from.getCenter();
            fromPos.x -= fromdx;
            fromPos.y -= fromdy;
            var t = raycastTimeCircleCircle(movePos.x - fromPos.x, movePos.y - fromPos.y, movedx - fromdx, movedy - fromdy, move.radius + from.radius);
            movePos.x += movedx;
            movePos.y += movedy;
            fromPos.x += fromdx;
            fromPos.y += fromdy;
            var result = getDisplacementCollisionCircleCircle(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionCircleCircle = getRaycastCollisionCircleCircle;
        function getRaycastCollisionCircleRect(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            movePos.x -= movedx;
            movePos.y -= movedy;
            var fromBox = from.getBoundingBox();
            fromBox.x -= fromdx;
            fromBox.y -= fromdy;
            var topleft_t = raycastTimeCircleCircle(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius);
            var topright_t = raycastTimeCircleCircle(movePos.x - fromBox.right, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius);
            var bottomright_t = raycastTimeCircleCircle(movePos.x - fromBox.right, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius);
            var bottomleft_t = raycastTimeCircleCircle(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius);
            var left_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
            var right_t = raycastTimeCircleSegment(movePos.x - fromBox.right, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
            var top_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
            var bottom_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
            var t = Math.min(topleft_t, topright_t, bottomright_t, bottomleft_t, left_t, right_t, top_t, bottom_t);
            movePos.x += movedx;
            movePos.y += movedy;
            fromBox.x += fromdx;
            fromBox.y += fromdy;
            var result = getDisplacementCollisionCircleRect(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionCircleRect = getRaycastCollisionCircleRect;
        function getRaycastCollisionCircleSlope(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            movePos.x -= movedx;
            movePos.y -= movedy;
            var fromBox = from.getBoundingBox();
            fromBox.x -= fromdx;
            fromBox.y -= fromdy;
            var topleft_t = from.direction === 'upleft' ? Infinity : raycastTimeCircleCircle(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius);
            var topright_t = from.direction === 'upright' ? Infinity : raycastTimeCircleCircle(movePos.x - fromBox.right, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius);
            var bottomright_t = from.direction === 'downright' ? Infinity : raycastTimeCircleCircle(movePos.x - fromBox.right, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius);
            var bottomleft_t = from.direction === 'downleft' ? Infinity : raycastTimeCircleCircle(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius);
            var line1_t, line2_t, line3_t;
            if (from.direction === 'upleft') {
                line1_t = raycastTimeCircleSegment(movePos.x - fromBox.right, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
                line2_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
                line3_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, -fromBox.height);
            }
            else if (from.direction === 'upright') {
                line1_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
                line2_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
                line3_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, fromBox.height);
            }
            else if (from.direction === 'downright') {
                line1_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
                line2_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
                line3_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.bottom, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, -fromBox.height);
            }
            else {
                line1_t = raycastTimeCircleSegment(movePos.x - fromBox.right, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, 0, fromBox.height);
                line2_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, 0);
                line3_t = raycastTimeCircleSegment(movePos.x - fromBox.left, movePos.y - fromBox.top, movedx - fromdx, movedy - fromdy, move.radius, fromBox.width, fromBox.height);
            }
            var t = Math.min(topleft_t, topright_t, bottomright_t, bottomleft_t, line1_t, line2_t, line3_t);
            movePos.x += movedx;
            movePos.y += movedy;
            fromBox.x += fromdx;
            fromBox.y += fromdy;
            var result = getDisplacementCollisionCircleSlope(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionCircleSlope = getRaycastCollisionCircleSlope;
        function getRaycastCollisionCircleInvertedRect(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            movePos.x -= movedx;
            movePos.y -= movedy;
            var fromBox = from.getInnerBox();
            fromBox.x -= fromdx;
            fromBox.y -= fromdy;
            var left_t = movePos.x - move.radius + movedx < fromBox.left ? (movePos.x - move.radius - fromBox.left) / (fromdx - movedx) : Infinity;
            var right_t = movePos.x + move.radius + movedx > fromBox.right ? (movePos.x + move.radius - fromBox.right) / (fromdx - movedx) : Infinity;
            var top_t = movePos.y - move.radius + movedy < fromBox.top ? (movePos.y - move.radius - fromBox.top) / (fromdy - movedy) : Infinity;
            var bottom_t = movePos.y + move.radius + movedy > fromBox.bottom ? (movePos.y + move.radius - fromBox.bottom) / (fromdy - movedy) : Infinity;
            var t = Math.min(left_t, right_t, top_t, bottom_t);
            movePos.x += movedx;
            movePos.y += movedy;
            fromBox.x += fromdx;
            fromBox.y += fromdy;
            if (!isFinite(t) && fromdx === movedx && fromdy === movedy) {
                t = 0;
            }
            if (!isFinite(t)) {
                console.error("Failed to detect time of collision between circle and inverted rect:", move.parent, { x: movePos.x, y: movePos.y, radius: move.radius }, movedx, movedy, from.parent, fromBox, fromdx, fromdy);
            }
            var result = getDisplacementCollisionCircleInvertedRect(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionCircleInvertedRect = getRaycastCollisionCircleInvertedRect;
        function getRaycastCollisionCircleInvertedCircle(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var movePos = move.getCenter();
            movePos.x -= movedx;
            movePos.y -= movedy;
            var fromPos = from.getCenter();
            fromPos.x -= fromdx;
            fromPos.y -= fromdy;
            var t = raycastTimeCircleInvertedCircle(movePos.x - fromPos.x, movePos.y - fromPos.y, movedx - fromdx, movedy - fromdy, move.radius + from.radius);
            movePos.x += movedx;
            movePos.y += movedy;
            fromPos.x += fromdx;
            fromPos.y += fromdy;
            var result = getDisplacementCollisionCircleInvertedCircle(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionCircleInvertedCircle = getRaycastCollisionCircleInvertedCircle;
        function getRaycastCollisionRectRect(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var box = move.getBoundingBox();
            box.x -= movedx;
            box.y -= movedy;
            var otherbox = from.getBoundingBox();
            otherbox.x -= fromdx;
            otherbox.y -= fromdy;
            var topbot_t = Infinity;
            var bottop_t = Infinity;
            var leftright_t = Infinity;
            var rightleft_t = Infinity;
            if (movedy !== fromdy) {
                topbot_t = (box.top - otherbox.bottom) / (fromdy - movedy);
                if (box.right + movedx * topbot_t <= otherbox.left + fromdx * topbot_t || box.left + movedx * topbot_t >= otherbox.right + fromdx * topbot_t) {
                    topbot_t = Infinity;
                }
                bottop_t = (box.bottom - otherbox.top) / (fromdy - movedy);
                if (box.right + movedx * bottop_t <= otherbox.left + fromdx * bottop_t || box.left + movedx * bottop_t >= otherbox.right + fromdx * bottop_t) {
                    bottop_t = Infinity;
                }
            }
            if (movedx !== fromdx) {
                leftright_t = (box.left - otherbox.right) / (fromdx - movedx);
                if (box.bottom + movedy * leftright_t <= otherbox.top + fromdy * leftright_t || box.top + movedy * leftright_t >= otherbox.bottom + fromdy * leftright_t) {
                    leftright_t = Infinity;
                }
                rightleft_t = (box.right - otherbox.left) / (fromdx - movedx);
                if (box.bottom + movedy * rightleft_t <= otherbox.top + fromdy * rightleft_t || box.top + movedy * rightleft_t >= otherbox.bottom + fromdy * rightleft_t) {
                    rightleft_t = Infinity;
                }
            }
            var min_t = Math.min(topbot_t, bottop_t, leftright_t, rightleft_t);
            box.x += movedx;
            box.y += movedy;
            otherbox.x += fromdx;
            otherbox.y += fromdy;
            if (min_t === Infinity)
                return undefined;
            var displacementX = 0;
            var displacementY = 0;
            if (min_t === topbot_t) {
                displacementY = otherbox.bottom - box.top;
            }
            else if (min_t === bottop_t) {
                displacementY = otherbox.top - box.bottom;
            }
            else if (min_t === leftright_t) {
                displacementX = otherbox.right - box.left;
            }
            else if (min_t === rightleft_t) {
                displacementX = otherbox.left - box.right;
            }
            if (displacementX !== 0 && displacementY !== 0) {
                console.error("Warning: rect displacement in both axes");
            }
            return {
                bounds1: move,
                bounds2: from,
                t: min_t,
                displacementX: displacementX,
                displacementY: displacementY,
            };
        }
        Collision.getRaycastCollisionRectRect = getRaycastCollisionRectRect;
        function getRaycastCollisionRectSlope(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            moveBox.x -= movedx;
            moveBox.y -= movedy;
            var fromBox = from.getBoundingBox();
            fromBox.x -= fromdx;
            fromBox.y -= fromdy;
            var left_t = Infinity;
            var right_t = Infinity;
            var top_t = Infinity;
            var bottom_t = Infinity;
            if (movedx !== fromdx) {
                left_t = (fromBox.left - moveBox.right) / (movedx - fromdx);
                if (moveBox.top + movedy * left_t >= fromBox.bottom + fromdy * left_t || fromBox.top + fromdy * left_t >= moveBox.bottom + movedy * left_t)
                    left_t = Infinity;
                if (from.direction === 'upleft' && (moveBox.top + movedy * left_t >= fromBox.bottom + fromdy * left_t || fromBox.bottom + fromdy * left_t >= moveBox.bottom + movedy * left_t))
                    left_t = Infinity;
                if (from.direction === 'downleft' && (moveBox.top + movedy * left_t >= fromBox.top + fromdy * left_t || fromBox.top + fromdy * left_t >= moveBox.bottom + movedy * left_t))
                    left_t = Infinity;
                right_t = (fromBox.right - moveBox.left) / (movedx - fromdx);
                if (moveBox.top + movedy * right_t >= fromBox.bottom + fromdy * right_t || fromBox.top + fromdy * right_t >= moveBox.bottom + movedy * right_t)
                    right_t = Infinity;
                if (from.direction === 'upright' && (moveBox.top + movedy * right_t >= fromBox.bottom + fromdy * right_t || fromBox.bottom + fromdy * right_t >= moveBox.bottom + movedy * right_t))
                    right_t = Infinity;
                if (from.direction === 'downright' && (moveBox.top + movedy * right_t >= fromBox.top + fromdy * right_t || fromBox.top + fromdy * right_t >= moveBox.bottom + movedy * right_t))
                    right_t = Infinity;
            }
            if (movedy !== fromdy) {
                top_t = (fromBox.top - moveBox.bottom) / (movedy - fromdy);
                if (moveBox.left + movedx * top_t >= fromBox.right + fromdx * top_t || fromBox.left + fromdx * top_t >= moveBox.right + movedx * top_t)
                    top_t = Infinity;
                if (from.direction === 'upleft' && (moveBox.left + movedx * top_t >= fromBox.right + fromdx * top_t || fromBox.right + fromdx * top_t >= moveBox.right + movedx * top_t))
                    top_t = Infinity;
                if (from.direction === 'upright' && (moveBox.left + movedx * top_t >= fromBox.left + fromdx * top_t || fromBox.left + fromdx * top_t >= moveBox.right + movedx * top_t))
                    top_t = Infinity;
                bottom_t = (fromBox.bottom - moveBox.top) / (movedy - fromdy);
                if (moveBox.left + movedx * bottom_t >= fromBox.right + fromdx * bottom_t || fromBox.left + fromdx * bottom_t >= moveBox.right + movedx * bottom_t)
                    bottom_t = Infinity;
                if (from.direction === 'downleft' && (moveBox.left + movedx * bottom_t >= fromBox.right + fromdx * bottom_t || fromBox.right + fromdx * bottom_t >= moveBox.right + movedx * bottom_t))
                    bottom_t = Infinity;
                if (from.direction === 'downright' && (moveBox.left + movedx * bottom_t >= fromBox.left + fromdx * bottom_t || fromBox.left + fromdx * bottom_t >= moveBox.right + movedx * bottom_t))
                    bottom_t = Infinity;
            }
            var topleft_t = from.direction !== 'upleft' ? Infinity : raycastTimePointSegment(moveBox.right - fromBox.left, moveBox.bottom - fromBox.bottom, movedx - fromdx, movedy - fromdy, fromBox.width, -fromBox.height);
            var topright_t = from.direction !== 'upright' ? Infinity : raycastTimePointSegment(moveBox.left - fromBox.left, moveBox.bottom - fromBox.top, movedx - fromdx, movedy - fromdy, fromBox.width, fromBox.height);
            var bottomleft_t = from.direction !== 'downleft' ? Infinity : raycastTimePointSegment(moveBox.right - fromBox.left, moveBox.top - fromBox.top, movedx - fromdx, movedy - fromdy, fromBox.width, fromBox.height);
            var bottomright_t = from.direction !== 'downright' ? Infinity : raycastTimePointSegment(moveBox.left - fromBox.left, moveBox.top - fromBox.bottom, movedx - fromdx, movedy - fromdy, fromBox.width, -fromBox.height);
            moveBox.x += movedx;
            moveBox.y += movedy;
            fromBox.x += fromdx;
            fromBox.y += fromdy;
            var t = Math.min(left_t, right_t, top_t, bottom_t, topleft_t, topright_t, bottomleft_t, bottomright_t);
            if (!isFinite(t))
                return undefined;
            var ww = fromBox.width * fromBox.width;
            var hh = fromBox.height * fromBox.height;
            var wh = fromBox.width * fromBox.height;
            var newX, newY;
            if (t === left_t) {
                newX = fromBox.left - moveBox.width;
                newY = moveBox.top;
            }
            else if (t === right_t) {
                newX = fromBox.right;
                newY = moveBox.top;
            }
            else if (t === top_t) {
                newX = moveBox.left;
                newY = fromBox.top - moveBox.height;
            }
            else if (t === bottom_t) {
                newX = moveBox.left;
                newY = fromBox.bottom;
            }
            else if (t === topleft_t) {
                var xi = (ww * moveBox.right + hh * fromBox.left + wh * fromBox.bottom - wh * moveBox.bottom) / (ww + hh);
                var yi = fromBox.width / fromBox.height * (xi - moveBox.right) + moveBox.bottom;
                newX = xi - moveBox.width;
                newY = yi - moveBox.height;
            }
            else if (t === topright_t) {
                var xi = (ww * moveBox.left + hh * fromBox.left - wh * fromBox.top + wh * moveBox.bottom) / (ww + hh);
                var yi = -fromBox.width / fromBox.height * (xi - moveBox.left) + moveBox.bottom;
                newX = xi;
                newY = yi - moveBox.height;
            }
            else if (t === bottomright_t) {
                var xi = (ww * moveBox.left + hh * fromBox.left + wh * fromBox.bottom - wh * moveBox.top) / (ww + hh);
                var yi = fromBox.width / fromBox.height * (xi - moveBox.left) + moveBox.top;
                newX = xi;
                newY = yi;
            }
            else {
                var xi = (ww * moveBox.right + hh * fromBox.left - wh * fromBox.top + wh * moveBox.top) / (ww + hh);
                var yi = -fromBox.width / fromBox.height * (xi - moveBox.right) + moveBox.top;
                newX = xi - moveBox.width;
                newY = yi;
            }
            return {
                bounds1: move,
                bounds2: from,
                t: t,
                displacementX: newX - moveBox.left,
                displacementY: newY - moveBox.top
            };
        }
        Collision.getRaycastCollisionRectSlope = getRaycastCollisionRectSlope;
        function getRaycastCollisionRectInvertedRect(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            moveBox.x -= movedx;
            moveBox.y -= movedy;
            var fromBox = from.getInnerBox();
            fromBox.x -= fromdx;
            fromBox.y -= fromdy;
            var left_t = moveBox.left + movedx < fromBox.left ? (moveBox.left - fromBox.left) / (fromdx - movedx) : Infinity;
            var right_t = moveBox.right + movedx > fromBox.right ? (moveBox.right - fromBox.right) / (fromdx - movedx) : Infinity;
            var top_t = moveBox.top + movedy < fromBox.top ? (moveBox.top - fromBox.top) / (fromdy - movedy) : Infinity;
            var bottom_t = moveBox.bottom + movedy > fromBox.bottom ? (moveBox.bottom - fromBox.bottom) / (fromdy - movedy) : Infinity;
            var t = Math.min(left_t, right_t, top_t, bottom_t);
            moveBox.x += movedx;
            moveBox.y += movedy;
            fromBox.x += fromdx;
            fromBox.y += fromdy;
            if (!isFinite(t) && fromdx === movedx && fromdy === movedy) {
                t = 0;
            }
            if (!isFinite(t)) {
                console.error("Failed to detect time of collision between rect and inverted rect:", move.parent, moveBox, movedx, movedy, from.parent, fromBox, fromdx, fromdy);
            }
            var result = getDisplacementCollisionRectInvertedRect(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionRectInvertedRect = getRaycastCollisionRectInvertedRect;
        function getRaycastCollisionRectInvertedCircle(move, movedx, movedy, from, fromdx, fromdy) {
            if (!move.isOverlapping(from))
                return undefined;
            var moveBox = move.getBoundingBox();
            moveBox.x -= movedx;
            moveBox.y -= movedy;
            var fromPos = from.getCenter();
            fromPos.x -= fromdx;
            fromPos.y -= fromdy;
            var dx = moveBox.x + moveBox.width / 2 - fromPos.x;
            var dy = moveBox.y + moveBox.height / 2 - fromPos.y;
            var cornerx = moveBox.x + (dx < 0 ? 0 : moveBox.width);
            var cornery = moveBox.y + (dy < 0 ? 0 : moveBox.height);
            var t = raycastTimeCircleCircle(cornerx - fromPos.x, cornery - fromPos.y, movedx - fromdx, movedy - fromdy, from.radius);
            moveBox.x += movedx;
            moveBox.y += movedy;
            fromPos.x += fromdx;
            fromPos.y += fromdy;
            var result = getDisplacementCollisionRectInvertedCircle(move, from);
            result.t = t;
            return result;
        }
        Collision.getRaycastCollisionRectInvertedCircle = getRaycastCollisionRectInvertedCircle;
        function isOverlappingCircleCircle(move, from) {
            var movePosition = move.getCenter();
            var fromPosition = from.getCenter();
            return M.distance(movePosition.x, movePosition.y, fromPosition.x, fromPosition.y) < move.radius + from.radius - OVERLAP_EPSILON;
        }
        Collision.isOverlappingCircleCircle = isOverlappingCircleCircle;
        function isOverlappingCircleRect(move, from) {
            var movePosition = move.getCenter();
            var fromBox = from.getBoundingBox();
            // Tall rect
            if (fromBox.left < movePosition.x && movePosition.x < fromBox.right && fromBox.top - move.radius < movePosition.y && movePosition.y < fromBox.bottom + move.radius) {
                return true;
            }
            // Long rect
            if (fromBox.left - move.radius < movePosition.x && movePosition.x < fromBox.right + move.radius && fromBox.top < movePosition.y && movePosition.y < fromBox.bottom) {
                return true;
            }
            // Vertices
            if (M.distanceSq(movePosition.x, movePosition.y, fromBox.left, fromBox.top) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(movePosition.x, movePosition.y, fromBox.left, fromBox.bottom) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(movePosition.x, movePosition.y, fromBox.right, fromBox.bottom) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(movePosition.x, movePosition.y, fromBox.right, fromBox.top) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            return false;
        }
        Collision.isOverlappingCircleRect = isOverlappingCircleRect;
        function isOverlappingCircleSlope(move, from) {
            var movePos = move.getCenter();
            var fromBox = from.getBoundingBox();
            var centerInBox = fromBox.contains(movePos.x, movePos.y);
            var centerInSlope = (from.direction === 'upright' && movePos.y > fromBox.height / fromBox.width * (movePos.x - fromBox.left) + fromBox.top)
                || (from.direction === 'upleft' && movePos.y > -fromBox.height / fromBox.width * (movePos.x - fromBox.left) + fromBox.bottom)
                || (from.direction === 'downleft' && movePos.y < fromBox.height / fromBox.width * (movePos.x - fromBox.left) + fromBox.top)
                || (from.direction === 'downright' && movePos.y < -fromBox.height / fromBox.width * (movePos.x - fromBox.left) + fromBox.bottom);
            if (centerInBox && centerInSlope) {
                return true;
            }
            // Top edge
            if (from.direction !== 'upleft' && from.direction !== 'upright' && fromBox.left < movePos.x && movePos.x < fromBox.right && fromBox.top - move.radius < movePos.y && movePos.y <= fromBox.top) {
                return true;
            }
            // Bottom edge
            if (from.direction !== 'downleft' && from.direction !== 'downright' && fromBox.left < movePos.x && movePos.x < fromBox.right && fromBox.bottom <= movePos.y && movePos.y < fromBox.bottom + move.radius) {
                return true;
            }
            // Left edge
            if (from.direction !== 'upleft' && from.direction !== 'downleft' && fromBox.left - move.radius < movePos.x && movePos.x <= fromBox.left && fromBox.top < movePos.y && movePos.y < fromBox.bottom) {
                return true;
            }
            // Right edge
            if (from.direction !== 'upright' && from.direction !== 'downright' && fromBox.right <= movePos.x && movePos.x < fromBox.right + move.radius && fromBox.top < movePos.y && movePos.y < fromBox.bottom) {
                return true;
            }
            // Top-left vertex
            if (from.direction !== 'upleft' && M.distanceSq(movePos.x, movePos.y, fromBox.left, fromBox.top) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            // Top-right vertex
            if (from.direction !== 'upright' && M.distanceSq(movePos.x, movePos.y, fromBox.right, fromBox.top) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            // Bottom-right vertex
            if (from.direction !== 'downright' && M.distanceSq(movePos.x, movePos.y, fromBox.right, fromBox.bottom) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            // Bottom-left vertex
            if (from.direction !== 'downleft' && M.distanceSq(movePos.x, movePos.y, fromBox.left, fromBox.bottom) < move.radius * move.radius - OVERLAP_EPSILON) {
                return true;
            }
            // sloped edge /
            if (from.direction !== 'upright' && from.direction !== 'downleft' && G.circleIntersectsSegment(movePos.x, movePos.y, move.radius, fromBox.left, fromBox.bottom, fromBox.right, fromBox.top)) {
                return true;
            }
            // sloped edge \
            if (from.direction !== 'upleft' && from.direction !== 'downright' && G.circleIntersectsSegment(movePos.x, movePos.y, move.radius, fromBox.left, fromBox.top, fromBox.right, fromBox.bottom)) {
                return true;
            }
            return false;
        }
        Collision.isOverlappingCircleSlope = isOverlappingCircleSlope;
        function isOverlappingCircleInvertedRect(move, from) {
            var movePos = move.getCenter();
            var fromBox = from.getInnerBox();
            if (movePos.x - move.radius < fromBox.left)
                return true;
            if (movePos.x + move.radius > fromBox.right)
                return true;
            if (movePos.y - move.radius < fromBox.top)
                return true;
            if (movePos.y + move.radius > fromBox.bottom)
                return true;
            return false;
        }
        Collision.isOverlappingCircleInvertedRect = isOverlappingCircleInvertedRect;
        function isOverlappingCircleInvertedCircle(move, from) {
            var movePosition = move.getCenter();
            var fromPosition = from.getCenter();
            return M.distance(movePosition.x, movePosition.y, fromPosition.x, fromPosition.y) > from.radius - move.radius + OVERLAP_EPSILON;
        }
        Collision.isOverlappingCircleInvertedCircle = isOverlappingCircleInvertedCircle;
        function isOverlappingRectRect(move, from) {
            return G.overlapRectangles(move.getBoundingBox(), from.getBoundingBox());
        }
        Collision.isOverlappingRectRect = isOverlappingRectRect;
        function isOverlappingRectSlope(move, from) {
            var moveBox = move.getBoundingBox();
            var fromBox = from.getBoundingBox();
            if (!G.overlapRectangles(moveBox, fromBox))
                return false;
            if (from.direction === 'upleft' && moveBox.bottom <= -fromBox.height / fromBox.width * (moveBox.right - fromBox.left) + fromBox.bottom)
                return false;
            if (from.direction === 'upright' && moveBox.bottom <= fromBox.height / fromBox.width * (moveBox.left - fromBox.left) + fromBox.top)
                return false;
            if (from.direction === 'downright' && moveBox.top >= -fromBox.height / fromBox.width * (moveBox.left - fromBox.left) + fromBox.bottom)
                return false;
            if (from.direction === 'downleft' && moveBox.top >= fromBox.height / fromBox.width * (moveBox.right - fromBox.left) + fromBox.top)
                return false;
            return true;
        }
        Collision.isOverlappingRectSlope = isOverlappingRectSlope;
        function isOverlappingRectInvertedRect(move, from) {
            var moveBox = move.getBoundingBox();
            var fromBox = from.getInnerBox();
            if (moveBox.left < fromBox.left)
                return true;
            if (moveBox.right > fromBox.right)
                return true;
            if (moveBox.top < fromBox.top)
                return true;
            if (moveBox.bottom > fromBox.bottom)
                return true;
            return false;
        }
        Collision.isOverlappingRectInvertedRect = isOverlappingRectInvertedRect;
        function isOverlappingRectInvertedCircle(move, from) {
            var moveBox = move.getBoundingBox();
            var fromPos = from.getCenter();
            // Vertices
            if (M.distanceSq(moveBox.left, moveBox.top, fromPos.x, fromPos.y) > from.radius * from.radius + OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(moveBox.right, moveBox.top, fromPos.x, fromPos.y) > from.radius * from.radius + OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(moveBox.left, moveBox.bottom, fromPos.x, fromPos.y) > from.radius * from.radius + OVERLAP_EPSILON) {
                return true;
            }
            if (M.distanceSq(moveBox.right, moveBox.bottom, fromPos.x, fromPos.y) > from.radius * from.radius + OVERLAP_EPSILON) {
                return true;
            }
            return false;
        }
        Collision.isOverlappingRectInvertedCircle = isOverlappingRectInvertedCircle;
        function invertDisplacementCollision(collision) {
            if (collision) {
                var temp = collision.bounds1;
                collision.bounds1 = collision.bounds2;
                collision.bounds2 = temp;
                collision.displacementX *= -1;
                collision.displacementY *= -1;
            }
            return collision;
        }
        Collision.invertDisplacementCollision = invertDisplacementCollision;
        function invertRaycastCollision(collision) {
            if (collision) {
                var temp = collision.bounds1;
                collision.bounds1 = collision.bounds2;
                collision.bounds2 = temp;
                collision.displacementX *= -1;
                collision.displacementY *= -1;
            }
            return collision;
        }
        Collision.invertRaycastCollision = invertRaycastCollision;
        function closestPointOnCircle_angle(px, py, cx, cy) {
            var dx = px - cx;
            var dy = py - cy;
            return M.atan2(dy, dx);
        }
        function closestPointOnLine_t(px, py, lx1, ly1, lx2, ly2) {
            var dx = px - lx1;
            var dy = py - ly1;
            var ldx = lx2 - lx1;
            var ldy = ly2 - ly1;
            var t = (dx * ldx + dy * ldy) / (ldx * ldx + ldy * ldy);
            return t;
        }
        function raycastTimeCircleCircle(dx, dy, ddx, ddy, R) {
            var a = ddx * ddx + ddy * ddy;
            var b = 2 * dx * ddx + 2 * dy * ddy;
            var c = dx * dx + dy * dy - R * R;
            var disc = b * b - 4 * a * c;
            if (disc < 0)
                return Infinity;
            return (-b - Math.sqrt(disc)) / (2 * a);
        }
        function raycastTimeCircleInvertedCircle(dx, dy, ddx, ddy, R) {
            var a = ddx * ddx + ddy * ddy;
            var b = 2 * dx * ddx + 2 * dy * ddy;
            var c = dx * dx + dy * dy - R * R;
            var disc = b * b - 4 * a * c;
            if (disc < 0)
                return Infinity;
            return (-b + Math.sqrt(disc)) / (2 * a);
        }
        function raycastTimeCircleSegment(dx, dy, ddx, ddy, r, linedx, linedy) {
            var L = M.magnitude(linedx, linedy);
            var denom = linedx * ddy - linedy * ddx;
            var t1 = (r * L + linedy * dx - linedx * dy) / denom;
            var t2 = (-r * L + linedy * dx - linedx * dy) / denom;
            var t = Math.min(t1, t2);
            var newx = dx + ddx * t;
            var newy = dy + ddy * t;
            var comp = linedx * newx + linedy * newy;
            if (comp < 0 || L * L < comp)
                return Infinity;
            return t;
        }
        function raycastTimePointSegment(dpx, dpy, ddx, ddy, linedx, linedy) {
            var t = (linedy * dpx - linedx * dpy) / (linedx * ddy - linedy * ddx);
            var s = linedx !== 0 ? (dpx + ddx * t) / linedx : (dpy + ddy * t) / linedy;
            if (s < 0 || 1 < s)
                return Infinity;
            return t;
        }
        function vectorBetweenVectors(vx, vy, x1, y1, x2, y2) {
            var cross1xV = x1 * vy - y1 * vx;
            var cross1x2 = x1 * y2 - y1 * x2;
            var cross2xV = x2 * vy - y2 * vx;
            var cross2x1 = x2 * y1 - y2 * x1;
            return cross1xV * cross1x2 >= 0 && cross2xV * cross2x1 >= 0;
        }
    })(Collision = Bounds.Collision || (Bounds.Collision = {}));
})(Bounds || (Bounds = {}));
var InvertedCircleBounds = /** @class */ (function () {
    function InvertedCircleBounds(x, y, radius, parent) {
        this.parent = parent;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.center = new Vector2(x, y);
        // Big numbers because I don't trust Infinity :)
        this.boundingBox = new Rectangle(-1000000, -1000000, 2000000, 2000000);
        this.frozen = false;
    }
    InvertedCircleBounds.prototype.clone = function () {
        return new InvertedCircleBounds(this.x, this.y, this.radius, this.parent);
    };
    InvertedCircleBounds.prototype.containsPoint = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        var center = this.getCenter();
        return M.distanceSq(center.x, center.y, x, y) > this.radius * this.radius;
    };
    InvertedCircleBounds.prototype.freeze = function () {
        this.frozen = false;
        this.getCenter();
        this.getBoundingBox();
        this.frozen = true;
    };
    InvertedCircleBounds.prototype.getCenter = function () {
        if (!this.frozen) {
            this.center.x = (this.parent ? this.parent.x : 0) + this.x;
            this.center.y = (this.parent ? this.parent.y : 0) + this.y;
        }
        return this.center;
    };
    InvertedCircleBounds.prototype.getBoundingBox = function () {
        return this.boundingBox;
    };
    InvertedCircleBounds.prototype.getDisplacementCollision = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionRectInvertedCircle(other, this));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionCircleInvertedCircle(other, this));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    InvertedCircleBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionRectInvertedCircle(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionCircleInvertedCircle(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    InvertedCircleBounds.prototype.isOverlapping = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.isOverlappingRectInvertedCircle(other, this);
        if (other instanceof CircleBounds)
            return Bounds.Collision.isOverlappingCircleInvertedCircle(other, this);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No overlap supported between these bounds", this, other);
        return false;
    };
    InvertedCircleBounds.prototype.move = function (dx, dy) {
        var box = this.getBoundingBox();
        box.x += dx;
        box.y += dy;
        var center = this.getCenter();
        center.x += dx;
        center.y += dy;
    };
    InvertedCircleBounds.prototype.raycast = function (x, y, dx, dy) {
        var center = this.getCenter();
        if (dx === 0 && dy === 0) {
            return Math.pow((x - center.x), 2) + Math.pow((y - center.y), 2) <= Math.pow(this.radius, 2) ? Infinity : 0;
        }
        var a = Math.pow(dx, 2) + Math.pow(dy, 2);
        var b = 2 * ((x - center.x) * dx + (y - center.y) * dy);
        var c = Math.pow((x - center.x), 2) + Math.pow((y - center.y), 2) - Math.pow(this.radius, 2);
        var disc = Math.pow(b, 2) - 4 * a * c;
        if (disc < 0)
            return Infinity;
        var small_t = (-b - Math.sqrt(disc)) / (2 * a);
        var large_t = (-b + Math.sqrt(disc)) / (2 * a);
        var t = large_t;
        if (t < 0)
            return Infinity;
        return t;
    };
    InvertedCircleBounds.prototype.unfreeze = function () {
        this.frozen = false;
    };
    return InvertedCircleBounds;
}());
var InvertedRectBounds = /** @class */ (function () {
    function InvertedRectBounds(x, y, width, height, parent) {
        this.parent = parent;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        // Big numbers because I don't trust Infinity :)
        this.boundingBox = new Rectangle(-1000000, -1000000, 2000000, 2000000);
        this.innerBox = new Rectangle(0, 0, 0, 0);
        this.frozen = false;
    }
    InvertedRectBounds.prototype.clone = function () {
        return new InvertedRectBounds(this.x, this.y, this.width, this.height, this.parent);
    };
    InvertedRectBounds.prototype.containsPoint = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        return !this.getInnerBox().contains(x, y);
    };
    InvertedRectBounds.prototype.freeze = function () {
        this.frozen = false;
        this.getInnerBox();
        this.getBoundingBox();
        this.frozen = true;
    };
    InvertedRectBounds.prototype.getBoundingBox = function () {
        return this.boundingBox;
    };
    InvertedRectBounds.prototype.getInnerBox = function () {
        if (!this.frozen) {
            this.innerBox.x = (this.parent ? this.parent.x : 0) + this.x;
            this.innerBox.y = (this.parent ? this.parent.y : 0) + this.y;
            this.innerBox.width = this.width;
            this.innerBox.height = this.height;
        }
        return this.innerBox;
    };
    InvertedRectBounds.prototype.getDisplacementCollision = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionRectInvertedRect(other, this));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionCircleInvertedRect(other, this));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    InvertedRectBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionRectInvertedRect(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionCircleInvertedRect(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    InvertedRectBounds.prototype.isOverlapping = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.isOverlappingRectInvertedRect(other, this);
        if (other instanceof CircleBounds)
            return Bounds.Collision.isOverlappingCircleInvertedRect(other, this);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No overlap supported between these bounds", this, other);
        return false;
    };
    InvertedRectBounds.prototype.move = function (dx, dy) {
        var box = this.getBoundingBox();
        box.x += dx;
        box.y += dy;
        var ibox = this.getInnerBox();
        ibox.x += dx;
        ibox.y += dy;
    };
    InvertedRectBounds.prototype.raycast = function (x, y, dx, dy) {
        var box = this.getInnerBox();
        if (dx === 0 && dy === 0) {
            return box.contains(x, y) ? Infinity : 0;
        }
        var left_t = dx < 0 && x >= box.left ? (box.left - x) / dx : Infinity;
        var right_t = dx > 0 && x <= box.right ? (box.right - x) / dx : Infinity;
        var top_t = dy < 0 && y >= box.top ? (box.top - y) / dy : Infinity;
        var bottom_t = dy > 0 && y <= box.bottom ? (box.bottom - y) / dy : Infinity;
        var t = Math.min(left_t, right_t, top_t, bottom_t);
        return t;
    };
    InvertedRectBounds.prototype.unfreeze = function () {
        this.frozen = false;
    };
    return InvertedRectBounds;
}());
var NullBounds = /** @class */ (function () {
    function NullBounds(parent) {
        this.parent = parent;
        this.x = 0;
        this.y = 0;
        this.boundingBox = new Rectangle(Infinity, Infinity, 0, 0);
    }
    NullBounds.prototype.clone = function () {
        return new NullBounds();
    };
    NullBounds.prototype.containsPoint = function (x, y) {
        return false;
    };
    NullBounds.prototype.freeze = function () {
        // Noop
    };
    NullBounds.prototype.getBoundingBox = function () {
        return this.boundingBox;
    };
    NullBounds.prototype.getDisplacementCollision = function (other) {
        return undefined;
    };
    NullBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        return undefined;
    };
    NullBounds.prototype.isOverlapping = function (other) {
        return false;
    };
    NullBounds.prototype.move = function (dx, dy) {
        // Noop
    };
    NullBounds.prototype.raycast = function (x, y, dx, dy) {
        return Infinity;
    };
    NullBounds.prototype.unfreeze = function () {
        // Noop
    };
    return NullBounds;
}());
var PhysicsUtils = /** @class */ (function () {
    function PhysicsUtils() {
    }
    PhysicsUtils.applyFriction = function (v, fx, fy, delta) {
        if (v.x > 0)
            v.x = Math.max(v.x - fx * delta, 0);
        if (v.x < 0)
            v.x = Math.min(v.x + fx * delta, 0);
        if (v.y > 0)
            v.y = Math.max(v.y - fy * delta, 0);
        if (v.y < 0)
            v.y = Math.min(v.y + fy * delta, 0);
    };
    PhysicsUtils.applyFriction1d = function (v, f, delta) {
        if (v > 0)
            return Math.max(v - f * delta, 0);
        if (v < 0)
            return Math.min(v + f * delta, 0);
        return 0;
    };
    PhysicsUtils.inverseLinear = function (v, G) {
        var mag = v.magnitude;
        if (mag === 0)
            return v;
        v.setMagnitude(G / mag);
        return v;
    };
    PhysicsUtils.inverseSquare = function (v, G) {
        var magSq = v.magnitudeSq;
        if (magSq === 0)
            return v;
        v.setMagnitude(G / magSq);
        return v;
    };
    PhysicsUtils.smartAccelerate = function (v, ax, ay, delta, maxSpeed) {
        var oldMagnitude = v.magnitude;
        v.x += ax * delta;
        v.y += ay * delta;
        if (v.magnitude > maxSpeed) {
            v.clampMagnitude(oldMagnitude);
        }
    };
    PhysicsUtils.smartAccelerate1d = function (v, a, delta, maxSpeed) {
        v += a * delta;
        if (Math.abs(v) > maxSpeed) {
            v = Math.sign(v) * maxSpeed;
        }
        return v;
    };
    return PhysicsUtils;
}());
var RectBounds = /** @class */ (function () {
    function RectBounds(x, y, width, height, parent) {
        this.parent = parent;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.boundingBox = new Rectangle(0, 0, 0, 0);
        this.frozen = false;
    }
    RectBounds.prototype.clone = function () {
        return new RectBounds(this.x, this.y, this.width, this.height, this.parent);
    };
    RectBounds.prototype.containsPoint = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        return this.getBoundingBox().contains(x, y);
    };
    RectBounds.prototype.freeze = function () {
        this.frozen = false;
        this.getBoundingBox();
        this.frozen = true;
    };
    RectBounds.prototype.getBoundingBox = function () {
        if (!this.frozen) {
            this.boundingBox.x = (this.parent ? this.parent.x : 0) + this.x;
            this.boundingBox.y = (this.parent ? this.parent.y : 0) + this.y;
            this.boundingBox.width = this.width;
            this.boundingBox.height = this.height;
        }
        return this.boundingBox;
    };
    RectBounds.prototype.getDisplacementCollision = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.getDisplacementCollisionRectRect(this, other);
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionCircleRect(other, this));
        if (other instanceof SlopeBounds)
            return Bounds.Collision.getDisplacementCollisionRectSlope(this, other);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.getDisplacementCollisionRectInvertedRect(this, other);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.getDisplacementCollisionRectInvertedCircle(this, other);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    RectBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        if (other instanceof RectBounds)
            return Bounds.Collision.getRaycastCollisionRectRect(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionCircleRect(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof SlopeBounds)
            return Bounds.Collision.getRaycastCollisionRectSlope(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.getRaycastCollisionRectInvertedRect(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.getRaycastCollisionRectInvertedCircle(this, dx, dy, other, otherdx, otherdy);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    RectBounds.prototype.isOverlapping = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.isOverlappingRectRect(this, other);
        if (other instanceof CircleBounds)
            return Bounds.Collision.isOverlappingCircleRect(other, this);
        if (other instanceof SlopeBounds)
            return Bounds.Collision.isOverlappingRectSlope(this, other);
        if (other instanceof InvertedRectBounds)
            return Bounds.Collision.isOverlappingRectInvertedRect(this, other);
        if (other instanceof InvertedCircleBounds)
            return Bounds.Collision.isOverlappingRectInvertedCircle(this, other);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No overlap supported between these bounds", this, other);
        return false;
    };
    RectBounds.prototype.move = function (dx, dy) {
        var box = this.getBoundingBox();
        box.x += dx;
        box.y += dy;
    };
    RectBounds.prototype.raycast = function (x, y, dx, dy) {
        var box = this.getBoundingBox();
        var top_t = Infinity;
        var bottom_t = Infinity;
        var left_t = Infinity;
        var right_t = Infinity;
        if (dy !== 0) {
            top_t = (box.top - y) / dy;
            if (x + dx * top_t < box.left || x + dx * top_t > box.right)
                top_t = Infinity;
            bottom_t = (box.bottom - y) / dy;
            if (x + dx * bottom_t < box.left || x + dx * bottom_t > box.right)
                bottom_t = Infinity;
        }
        if (dx !== 0) {
            left_t = (box.left - x) / dx;
            if (y + dy * left_t < box.top || y + dy * left_t > box.bottom)
                left_t = Infinity;
            right_t = (box.right - x) / dx;
            if (y + dy * right_t < box.top || y + dy * right_t > box.bottom)
                right_t = Infinity;
        }
        var horiz_small_t = Math.min(left_t, right_t);
        var horiz_large_t = Math.max(left_t, right_t);
        var horiz_t = horiz_small_t >= 0 ? horiz_small_t : horiz_large_t;
        var vert_small_t = Math.min(top_t, bottom_t);
        var vert_large_t = Math.max(top_t, bottom_t);
        var vert_t = vert_small_t >= 0 ? vert_small_t : vert_large_t;
        var small_t = Math.min(horiz_t, vert_t);
        var large_t = Math.max(horiz_t, vert_t);
        var t = small_t >= 0 ? small_t : large_t;
        if (t < 0)
            return Infinity;
        return t;
    };
    RectBounds.prototype.unfreeze = function () {
        this.frozen = false;
    };
    return RectBounds;
}());
var SlopeBounds = /** @class */ (function () {
    function SlopeBounds(x, y, width, height, direction, parent) {
        this.parent = parent;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.direction = direction;
        this.boundingBox = new Rectangle(0, 0, 0, 0);
        this.frozen = false;
    }
    SlopeBounds.prototype.clone = function () {
        return new SlopeBounds(this.x, this.y, this.width, this.height, this.direction, this.parent);
    };
    SlopeBounds.prototype.containsPoint = function (x, y) {
        if (!_.isNumber(x)) {
            y = x.y;
            x = x.x;
        }
        var box = this.getBoundingBox();
        if (!box.contains(x, y))
            return false;
        if (this.direction === 'upleft' && y - box.bottom < (x - box.left) * (-box.height / box.width))
            return false;
        if (this.direction === 'downright' && y - box.bottom > (x - box.left) * (-box.height / box.width))
            return false;
        if (this.direction === 'upright' && y - box.top < (x - box.left) * (box.height / box.width))
            return false;
        if (this.direction === 'downleft' && y - box.top > (x - box.left) * (box.height / box.width))
            return false;
        return true;
    };
    SlopeBounds.prototype.freeze = function () {
        this.frozen = false;
        this.getBoundingBox();
        this.frozen = true;
    };
    SlopeBounds.prototype.getBoundingBox = function () {
        if (!this.frozen) {
            this.boundingBox.x = (this.parent ? this.parent.x : 0) + this.x;
            this.boundingBox.y = (this.parent ? this.parent.y : 0) + this.y;
            this.boundingBox.width = this.width;
            this.boundingBox.height = this.height;
        }
        return this.boundingBox;
    };
    SlopeBounds.prototype.getDisplacementCollision = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionRectSlope(other, this));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertDisplacementCollision(Bounds.Collision.getDisplacementCollisionCircleSlope(other, this));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    SlopeBounds.prototype.getRaycastCollision = function (dx, dy, other, otherdx, otherdy) {
        if (other instanceof RectBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionRectSlope(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof CircleBounds)
            return Bounds.Collision.invertRaycastCollision(Bounds.Collision.getRaycastCollisionCircleSlope(other, otherdx, otherdy, this, dx, dy));
        if (other instanceof NullBounds)
            return undefined;
        console.error("No collision supported between these bounds", this, other);
        return undefined;
    };
    SlopeBounds.prototype.isOverlapping = function (other) {
        if (other instanceof RectBounds)
            return Bounds.Collision.isOverlappingRectSlope(other, this);
        if (other instanceof CircleBounds)
            return Bounds.Collision.isOverlappingCircleSlope(other, this);
        if (other instanceof NullBounds)
            return undefined;
        console.error("No overlap supported between these bounds", this, other);
        return false;
    };
    SlopeBounds.prototype.move = function (dx, dy) {
        var box = this.getBoundingBox();
        box.x += dx;
        box.y += dy;
    };
    SlopeBounds.prototype.raycast = function (x, y, dx, dy) {
        var box = this.getBoundingBox();
        var top_t = Infinity;
        var bottom_t = Infinity;
        var left_t = Infinity;
        var right_t = Infinity;
        var slash_t = Infinity;
        var backslash_t = Infinity;
        if (dy !== 0) {
            top_t = (box.top - y) / dy;
            if (x + dx * top_t < box.left || x + dx * top_t > box.right)
                top_t = Infinity;
            bottom_t = (box.bottom - y) / dy;
            if (x + dx * bottom_t < box.left || x + dx * bottom_t > box.right)
                bottom_t = Infinity;
        }
        if (dx !== 0) {
            left_t = (box.left - x) / dx;
            if (y + dy * left_t < box.top || y + dy * left_t > box.bottom)
                left_t = Infinity;
            right_t = (box.right - x) / dx;
            if (y + dy * right_t < box.top || y + dy * right_t > box.bottom)
                right_t = Infinity;
        }
        if (dx * box.height + dy * box.width !== 0) {
            slash_t = ((box.left - x) * box.height + (box.bottom - y) * box.width) / (dx * box.height + dy * box.width);
            if (x + dx * slash_t < box.left || x + dx * slash_t > box.right)
                slash_t = Infinity;
        }
        if (dx * box.height - dy * box.width !== 0) {
            backslash_t = ((box.left - x) * box.height - (box.top - y) * box.width) / (dx * box.height - dy * box.width);
            if (x + dx * backslash_t < box.left || x + dx * backslash_t > box.right)
                backslash_t = Infinity;
        }
        var t1, t2, t3;
        if (this.direction === 'upleft') {
            t1 = right_t;
            t2 = bottom_t;
            t3 = slash_t;
        }
        else if (this.direction === 'upright') {
            t1 = left_t;
            t2 = bottom_t;
            t3 = backslash_t;
        }
        else if (this.direction === 'downright') {
            t1 = left_t;
            t2 = top_t;
            t3 = slash_t;
        }
        else {
            t1 = right_t;
            t2 = top_t;
            t3 = backslash_t;
        }
        var small_t12 = Math.min(t1, t2);
        var large_t12 = Math.max(t1, t2);
        var t12 = small_t12 >= 0 ? small_t12 : large_t12;
        var small_t = Math.min(t12, t3);
        var large_t = Math.max(t12, t3);
        var t = small_t >= 0 ? small_t : large_t;
        if (t < 0)
            return Infinity;
        return t;
    };
    SlopeBounds.prototype.unfreeze = function () {
        this.frozen = false;
    };
    return SlopeBounds;
}());
/// <reference path="../texture/filter/textureFilter.ts" />
var Effects = /** @class */ (function () {
    function Effects(config) {
        if (config === void 0) { config = {}; }
        this.effects = [undefined, undefined, undefined, undefined];
        this.pre = { filters: [] };
        this.post = { filters: [] };
        this.updateFromConfig(config);
    }
    Object.defineProperty(Effects.prototype, "silhouette", {
        get: function () {
            if (!this.effects[Effects.SILHOUETTE_I]) {
                this.effects[Effects.SILHOUETTE_I] = new Effects.Filters.Silhouette(0x000000, 1);
                this.effects[Effects.SILHOUETTE_I].enabled = false;
            }
            return this.effects[Effects.SILHOUETTE_I];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effects.prototype, "outline", {
        get: function () {
            if (!this.effects[Effects.OUTLINE_I]) {
                this.effects[Effects.OUTLINE_I] = new Effects.Filters.Outline(0x000000, 1);
                this.effects[Effects.OUTLINE_I].enabled = false;
            }
            return this.effects[Effects.OUTLINE_I];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effects.prototype, "invertColors", {
        get: function () {
            if (!this.effects[Effects.INVERT_COLORS_I]) {
                this.effects[Effects.INVERT_COLORS_I] = new Effects.Filters.InvertColors();
                this.effects[Effects.INVERT_COLORS_I].enabled = false;
            }
            return this.effects[Effects.INVERT_COLORS_I];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effects.prototype, "glitch", {
        get: function () {
            if (!this.effects[Effects.GLITCH_I]) {
                this.effects[Effects.GLITCH_I] = new Effects.Filters.Glitch(2, 1, 2);
                this.effects[Effects.GLITCH_I].enabled = false;
            }
            return this.effects[Effects.GLITCH_I];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effects.prototype, "addSilhouette", {
        get: function () {
            this.silhouette.enabled = true;
            return this.silhouette;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Effects.prototype, "addOutline", {
        get: function () {
            this.outline.enabled = true;
            return this.outline;
        },
        enumerable: false,
        configurable: true
    });
    Effects.prototype.getFilterList = function () {
        return this.pre.filters.concat(this.effects).concat(this.post.filters);
    };
    Effects.prototype.hasEffects = function () {
        if (this.effects.some(function (effect) { return effect && effect.enabled; }))
            return true;
        if (this.pre.filters.some(function (filter) { return filter && filter.enabled; }))
            return true;
        if (this.post.filters.some(function (filter) { return filter && filter.enabled; }))
            return true;
        return false;
    };
    Effects.prototype.updateEffects = function (delta) {
        var e_62, _a, e_63, _b;
        if (this.effects[Effects.SILHOUETTE_I])
            this.effects[Effects.SILHOUETTE_I].updateTime(delta);
        if (this.effects[Effects.OUTLINE_I])
            this.effects[Effects.OUTLINE_I].updateTime(delta);
        if (this.effects[Effects.INVERT_COLORS_I])
            this.effects[Effects.INVERT_COLORS_I].updateTime(delta);
        if (this.effects[Effects.GLITCH_I])
            this.effects[Effects.GLITCH_I].updateTime(delta);
        try {
            for (var _c = __values(this.pre.filters), _d = _c.next(); !_d.done; _d = _c.next()) {
                var filter = _d.value;
                filter.updateTime(delta);
            }
        }
        catch (e_62_1) { e_62 = { error: e_62_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_62) throw e_62.error; }
        }
        try {
            for (var _e = __values(this.post.filters), _f = _e.next(); !_f.done; _f = _e.next()) {
                var filter = _f.value;
                filter.updateTime(delta);
            }
        }
        catch (e_63_1) { e_63 = { error: e_63_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_63) throw e_63.error; }
        }
    };
    Effects.prototype.updateFromConfig = function (config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!config)
            return;
        if (config.pre) {
            this.pre.filters = (_a = config.pre.filters) !== null && _a !== void 0 ? _a : [];
        }
        if (config.silhouette) {
            this.silhouette.color = (_b = config.silhouette.color) !== null && _b !== void 0 ? _b : 0x000000;
            this.silhouette.alpha = (_c = config.silhouette.alpha) !== null && _c !== void 0 ? _c : 1;
            this.silhouette.amount = (_d = config.silhouette.amount) !== null && _d !== void 0 ? _d : 1;
            this.silhouette.enabled = (_e = config.silhouette.enabled) !== null && _e !== void 0 ? _e : true;
        }
        if (config.outline) {
            this.outline.color = (_f = config.outline.color) !== null && _f !== void 0 ? _f : 0x000000;
            this.outline.alpha = (_g = config.outline.alpha) !== null && _g !== void 0 ? _g : 1;
            this.outline.enabled = (_h = config.outline.enabled) !== null && _h !== void 0 ? _h : true;
        }
        if (config.invertColors) {
            this.invertColors.enabled = (_j = config.invertColors.enabled) !== null && _j !== void 0 ? _j : true;
        }
        if (config.glitch) {
            this.glitch.strength = (_k = config.glitch.strength) !== null && _k !== void 0 ? _k : 2;
            this.glitch.speed = (_l = config.glitch.speed) !== null && _l !== void 0 ? _l : 1;
            this.glitch.spread = (_m = config.glitch.spread) !== null && _m !== void 0 ? _m : 2;
            this.glitch.enabled = (_o = config.glitch.enabled) !== null && _o !== void 0 ? _o : true;
        }
        if (config.post) {
            this.post.filters = (_p = config.post.filters) !== null && _p !== void 0 ? _p : [];
        }
    };
    Effects.SILHOUETTE_I = 0;
    Effects.OUTLINE_I = 1;
    Effects.INVERT_COLORS_I = 2;
    Effects.GLITCH_I = 3;
    return Effects;
}());
(function (Effects) {
    var Filters;
    (function (Filters) {
        var Silhouette = /** @class */ (function (_super) {
            __extends(Silhouette, _super);
            function Silhouette(color, alpha) {
                var _this = _super.call(this, {
                    uniforms: {
                        "vec3 color": M.colorToVec3(0x000000),
                        "float alpha": 1.0,
                        "float amount": 1.0
                    },
                    code: "\n                        if (inp.a > 0.0) {\n                            outp = inp * (1.0 - amount) + vec4(color, alpha) * amount;\n                        }\n                    "
                }) || this;
                _this.color = color;
                _this.alpha = alpha;
                return _this;
            }
            Object.defineProperty(Silhouette.prototype, "color", {
                get: function () { return M.vec3ToColor(this.getUniform('color')); },
                set: function (value) { this.setUniform('color', M.colorToVec3(value)); },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Silhouette.prototype, "alpha", {
                get: function () { return this.getUniform('alpha'); },
                set: function (value) { this.setUniform('alpha', value); },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Silhouette.prototype, "amount", {
                get: function () { return this.getUniform('amount'); },
                set: function (value) { this.setUniform('amount', value); },
                enumerable: false,
                configurable: true
            });
            Silhouette.prototype.enable = function (color, alpha, amount) {
                this.color = color;
                this.alpha = alpha;
                this.amount = amount;
                this.enabled = true;
            };
            return Silhouette;
        }(TextureFilter));
        Filters.Silhouette = Silhouette;
        var Outline = /** @class */ (function (_super) {
            __extends(Outline, _super);
            function Outline(color, alpha) {
                var _this = _super.call(this, {
                    uniforms: {
                        "vec3 color": M.colorToVec3(0x000000),
                        "float alpha": 1.0
                    },
                    code: "\n                        if (inp.a == 0.0 && (getColor(x-1.0, y).a > 0.0 || getColor(x+1.0, y).a > 0.0 || getColor(x, y-1.0).a > 0.0 || getColor(x, y+1.0).a > 0.0)) {\n                            outp = vec4(color, alpha);\n                        }\n                    "
                }) || this;
                _this.color = color;
                _this.alpha = alpha;
                return _this;
            }
            Object.defineProperty(Outline.prototype, "color", {
                get: function () { return M.vec3ToColor(this.getUniform('color')); },
                set: function (value) { this.setUniform('color', M.colorToVec3(value)); },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Outline.prototype, "alpha", {
                get: function () { return this.getUniform('alpha'); },
                set: function (value) { this.setUniform('alpha', value); },
                enumerable: false,
                configurable: true
            });
            Outline.prototype.enable = function (color, alpha) {
                this.color = color;
                this.alpha = alpha;
                this.enabled = true;
            };
            return Outline;
        }(TextureFilter));
        Filters.Outline = Outline;
        var InvertColors = /** @class */ (function (_super) {
            __extends(InvertColors, _super);
            function InvertColors() {
                return _super.call(this, {
                    code: "\n                        outp.r = 1.0 - inp.r;\n                        outp.g = 1.0 - inp.g;\n                        outp.b = 1.0 - inp.b;\n                    "
                }) || this;
            }
            InvertColors.prototype.enable = function () {
                this.enabled = true;
            };
            return InvertColors;
        }(TextureFilter));
        Filters.InvertColors = InvertColors;
        var Glitch = /** @class */ (function (_super) {
            __extends(Glitch, _super);
            /**
             * @param strength - the amplitude of the offset
             * @param speed - the speed at which the offset cycles
             * @param spread - the average length of the bands
             */
            function Glitch(strength, speed, spread) {
                var _this = _super.call(this, {
                    uniforms: { 'float strength': strength, 'float speed': speed, 'float spread': spread },
                    code: "\n                        float tt = floor(5.4 + t * speed);\n                        float yy = floor(y / spread) * spread;\n                        float offset = pnoise(0.0, yy*1.1, tt*5.1) * strength;\n                        outp = getColor(x + offset, y);\n                    "
                }) || this;
                _this._strength = strength;
                _this._speed = speed;
                _this._spread = spread;
                return _this;
            }
            Object.defineProperty(Glitch.prototype, "strength", {
                get: function () { return this._strength; },
                set: function (value) {
                    this._strength = value;
                    this.setUniform('strength', value);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Glitch.prototype, "speed", {
                get: function () { return this._speed; },
                set: function (value) {
                    this._speed = value;
                    this.setUniform('speed', value);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Glitch.prototype, "spread", {
                get: function () { return this._spread; },
                set: function (value) {
                    this._spread = value;
                    this.setUniform('spread', value);
                },
                enumerable: false,
                configurable: true
            });
            Glitch.prototype.enable = function (strength, speed, spread) {
                this.strength = strength;
                this.speed = speed;
                this.spread = spread;
                this.enabled = true;
            };
            return Glitch;
        }(TextureFilter));
        Filters.Glitch = Glitch;
    })(Filters = Effects.Filters || (Effects.Filters = {}));
})(Effects || (Effects = {}));
var ActionBehavior = /** @class */ (function () {
    function ActionBehavior(startAction, startWait) {
        this.controller = new Controller();
        this.stateMachine = new StateMachine();
        this.actions = {};
        this.addAction(ActionBehavior.START_ACTION, {
            wait: startWait,
            nextAction: startAction,
        });
    }
    Object.defineProperty(ActionBehavior.prototype, "currentAction", {
        get: function () { return this.actions[this.currentActionName]; },
        enumerable: false,
        configurable: true
    });
    ActionBehavior.prototype.update = function (delta) {
        this.stateMachine.update(delta);
        if (!this.currentAction) {
            this.stateMachine.setState(ActionBehavior.START_ACTION);
        }
    };
    ActionBehavior.prototype.addAction = function (name, action) {
        var b = this;
        if (action.wait) {
            var waitActionName = "wait_after_" + name;
            this.addAction(name, {
                script: action.script,
                interrupt: action.interrupt,
                nextAction: waitActionName,
            });
            this.addAction(waitActionName, {
                script: function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, S.wait(action.wait)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                },
                nextAction: action.nextAction,
            });
            return;
        }
        this.stateMachine.addState(name, {
            script: function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!action.script) return [3 /*break*/, 2];
                            return [4 /*yield*/, action.script];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [4 /*yield*/];
                        case 3:
                            _a.sent(); // Yield once before doing the next action to let final controller inputs go through.
                            b.doAction(b.getNextAction(action.nextAction));
                            return [2 /*return*/];
                    }
                });
            }
        });
        this.actions[name] = action;
    };
    ActionBehavior.prototype.interrupt = function (action) {
        if (!this.currentAction)
            return;
        if (action && action !== this.currentActionName)
            return;
        if (!this.canInterrupt(this.currentAction.interrupt))
            return;
        var interruptAction = this.getInterruptAction(this.currentAction);
        this.doAction(interruptAction);
    };
    ActionBehavior.prototype.doAction = function (name) {
        this.controller.reset();
        this.currentActionName = name;
        this.stateMachine.setState(name);
    };
    ActionBehavior.prototype.canInterrupt = function (interrupt) {
        return !!interrupt;
    };
    ActionBehavior.prototype.getNextAction = function (nextAction) {
        if (_.isString(nextAction))
            return nextAction;
        return nextAction.call(this);
    };
    ActionBehavior.prototype.getInterruptAction = function (action) {
        if (_.isString(action.interrupt))
            return action.interrupt;
        return this.getNextAction(action.nextAction);
    };
    ActionBehavior.START_ACTION = 'start';
    return ActionBehavior;
}());
var Controller = /** @class */ (function () {
    function Controller() {
        this.moveDirection = vec2(0, 0);
        this.aimDirection = vec2(0, 0);
        this.keys = {};
    }
    Object.defineProperty(Controller.prototype, "left", {
        get: function () { return this.keys.left; },
        set: function (value) { this.keys.left = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "right", {
        get: function () { return this.keys.right; },
        set: function (value) { this.keys.right = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "up", {
        get: function () { return this.keys.up; },
        set: function (value) { this.keys.up = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "down", {
        get: function () { return this.keys.down; },
        set: function (value) { this.keys.down = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "jump", {
        get: function () { return this.keys.jump; },
        set: function (value) { this.keys.jump = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "attack", {
        get: function () { return this.keys.attack; },
        set: function (value) { this.keys.attack = value; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "interact", {
        get: function () { return this.keys.interact; },
        set: function (value) { this.keys.interact = value; },
        enumerable: false,
        configurable: true
    });
    Controller.prototype.updateFromBehavior = function (behavior) {
        if (behavior instanceof NullBehavior)
            return;
        this.moveDirection.x = behavior.controller.moveDirection.x;
        this.moveDirection.y = behavior.controller.moveDirection.y;
        this.aimDirection.x = behavior.controller.aimDirection.x;
        this.aimDirection.y = behavior.controller.aimDirection.y;
        for (var key in behavior.controller.keys) {
            this.keys[key] = behavior.controller.keys[key];
        }
    };
    Controller.prototype.reset = function () {
        this.moveDirection.x = 0;
        this.moveDirection.y = 0;
        this.aimDirection.x = 0;
        this.aimDirection.y = 0;
        for (var key in this.keys) {
            this.keys[key] = false;
        }
    };
    return Controller;
}());
/// <reference path="../controller/controller.ts" />
var ControllerBehavior = /** @class */ (function () {
    function ControllerBehavior(update) {
        this.controller = new Controller();
        this.updateCallback = update;
    }
    ControllerBehavior.prototype.update = function (delta) {
        this.controller.reset();
        this.updateCallback();
    };
    ControllerBehavior.prototype.interrupt = function () { };
    return ControllerBehavior;
}());
var NullBehavior = /** @class */ (function () {
    function NullBehavior() {
        this.controller = new Controller();
    }
    NullBehavior.prototype.update = function (delta) { };
    NullBehavior.prototype.interrupt = function () { };
    return NullBehavior;
}());
var Module = /** @class */ (function () {
    function Module(type) {
        this.type = type;
    }
    Object.defineProperty(Module.prototype, "worldObject", {
        get: function () { return this._worldObject; },
        enumerable: false,
        configurable: true
    });
    Module.prototype.init = function (worldObject) {
        if (!(worldObject instanceof this.type)) {
            console.error("Tried to add Module<" + this.type.name + "> to a world object of incompatible type:", worldObject);
            return;
        }
        this._worldObject = worldObject;
    };
    Module.prototype.update = function () { };
    Module.prototype.render = function (texture, x, y) { };
    Module.prototype.remove = function () {
        A.removeAll(this.worldObject.modules, this);
    };
    return Module;
}());
/// <reference path="./module.ts" />
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _this = _super.call(this, WorldObject) || this;
        _this.lastHovered = false;
        _this.lastClickedDown = false;
        _this.clickedDown = false;
        _this.onClick = (_a = config.onClick) !== null && _a !== void 0 ? _a : Utils.NOOP;
        _this.onHover = (_b = config.onHover) !== null && _b !== void 0 ? _b : Utils.NOOP;
        _this.onJustHovered = (_c = config.onJustHovered) !== null && _c !== void 0 ? _c : Utils.NOOP;
        _this.onUnhover = (_d = config.onUnhover) !== null && _d !== void 0 ? _d : Utils.NOOP;
        _this.onJustUnhovered = (_e = config.onJustUnhovered) !== null && _e !== void 0 ? _e : Utils.NOOP;
        _this.onClickedDown = (_f = config.onClickedDown) !== null && _f !== void 0 ? _f : Utils.NOOP;
        _this.onJustClickedDown = (_g = config.onJustClickedDown) !== null && _g !== void 0 ? _g : Utils.NOOP;
        _this.canHover = (_h = config.canHover) !== null && _h !== void 0 ? _h : (function () { return true; });
        _this.hoverTint = config.hoverTint;
        _this.clickTint = config.clickTint;
        _this.baseTint = config.baseTint;
        _this.priority = (_j = config.priority) !== null && _j !== void 0 ? _j : 0;
        _this.enabled = (_k = config.enabled) !== null && _k !== void 0 ? _k : true;
        return _this;
    }
    Object.defineProperty(Button.prototype, "worldObject", {
        get: function () { return this._worldObject; },
        enumerable: false,
        configurable: true
    });
    Button.prototype.init = function (worldObject) {
        _super.prototype.init.call(this, worldObject);
        if (this.baseTint === undefined) {
            this.baseTint = this.worldObject.tint;
        }
    };
    Button.prototype.update = function () {
        _super.prototype.update.call(this);
        var hovered = this.isHovered();
        if (hovered && Input.justDown(Input.GAME_SELECT)) {
            this.clickedDown = true;
        }
        if (Input.justUp(Input.GAME_SELECT)) {
            if (hovered && this.clickedDown) {
                this.click();
            }
            this.clickedDown = false;
        }
        if (hovered) {
            if (this.clickedDown) {
                if (this.clickTint !== undefined)
                    this.worldObject.tint = this.clickTint;
            }
            else {
                if (this.hoverTint !== undefined)
                    this.worldObject.tint = this.hoverTint;
            }
        }
        else {
            if (this.baseTint !== undefined)
                this.worldObject.tint = this.baseTint;
        }
        if (hovered) {
            this.onHover();
            if (!this.lastHovered) {
                this.onJustHovered();
            }
            if (this.clickedDown) {
                this.onClickedDown();
                if (!this.lastClickedDown) {
                    this.onJustClickedDown();
                }
            }
        }
        else {
            this.onUnhover();
            if (this.lastHovered) {
                this.onJustUnhovered();
            }
        }
        this.lastHovered = hovered;
        this.lastClickedDown = this.clickedDown;
    };
    Button.prototype.click = function () {
        this.onClick();
    };
    Button.prototype.isHovered = function () {
        if (!this.enabled)
            return false;
        if (!this.canHover())
            return false;
        if (!this.isOverlappingMouse())
            return false;
        var mouseBounds = this.worldObject.world.getWorldMouseBounds();
        return Button.getClosestButton(mouseBounds, this.worldObject.world) === this;
    };
    Button.prototype.isOverlappingMouse = function () {
        var mouseBounds = this.worldObject.world.getWorldMouseBounds();
        return this.worldObject.bounds.isOverlapping(mouseBounds);
    };
    return Button;
}(Module));
(function (Button) {
    function getClosestButton(targetBounds, world) {
        var buttons = world.select.modules(Button).filter(function (button) { return button.worldObject.isActive() && button.enabled && button.worldObject.bounds.isOverlapping(targetBounds) && button.canHover(); });
        if (_.isEmpty(buttons)) {
            return undefined;
        }
        buttons.sort(function (b1, b2) {
            if (b1.priority !== b2.priority)
                return b2.priority - b1.priority;
            var b1dist = distanceTo(targetBounds.x, targetBounds.y, b1.worldObject.bounds.getBoundingBox());
            var b2dist = distanceTo(targetBounds.x, targetBounds.y, b2.worldObject.bounds.getBoundingBox());
            return b1dist - b2dist;
        });
        return buttons[0];
    }
    Button.getClosestButton = getClosestButton;
    function distanceTo(x, y, rect) {
        if (G.rectContainsPt(rect, vec2(x, y)))
            return 0;
        if (rect.x <= x && x <= rect.x + rect.width) {
            return Math.min(Math.abs(rect.y - y), Math.abs(rect.y + rect.height - y));
        }
        if (rect.y <= y && y <= rect.y + rect.height) {
            return Math.min(Math.abs(rect.x - x), Math.abs(rect.x + rect.width - x));
        }
        return Math.min(M.distance(x, y, rect.x, rect.y), M.distance(x, y, rect.x + rect.width, rect.y), M.distance(x, y, rect.x, rect.y + rect.height), M.distance(x, y, rect.x + rect.width, rect.y + rect.height));
    }
})(Button || (Button = {}));
var PuffSystem = /** @class */ (function (_super) {
    __extends(PuffSystem, _super);
    function PuffSystem(config) {
        var _this = _super.call(this, config) || this;
        _this.puffs = [];
        return _this;
    }
    PuffSystem.prototype.update = function () {
        _super.prototype.update.call(this);
        for (var i = this.puffs.length - 1; i >= 0; i--) {
            var puff = this.puffs[i];
            puff.x += puff.vx * this.delta;
            puff.y += puff.vy * this.delta;
            puff.t += this.delta;
            if (this.puffs[i].t > this.puffs[i].maxLife) {
                this.puffs.splice(i, 1);
            }
        }
    };
    PuffSystem.prototype.render = function (texture, x, y) {
        var e_64, _a;
        try {
            for (var _b = __values(this.puffs), _c = _b.next(); !_c.done; _c = _b.next()) {
                var puff = _c.value;
                var progress = puff.t / puff.maxLife;
                var radius = M.lerp(puff.initialRadius, puff.finalRadius, progress);
                var color = Color.lerpColorByLch(puff.initialColor, puff.finalColor, progress);
                var alpha = M.lerp(puff.initialAlpha, puff.finalAlpha, progress);
                Draw.brush.color = color;
                Draw.brush.alpha = alpha;
                Draw.circleSolid(texture, x - this.x + puff.x, y - this.y + puff.y, radius);
            }
        }
        catch (e_64_1) { e_64 = { error: e_64_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_64) throw e_64.error; }
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    PuffSystem.prototype.addPuff = function (config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.puffs.push({
            x: this.x + ((_b = (_a = config.p) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0),
            y: this.y + ((_d = (_c = config.p) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0),
            vx: config.v.x,
            vy: config.v.y,
            t: 0,
            maxLife: config.maxLife,
            initialRadius: config.radius,
            finalRadius: (_e = config.finalRadius) !== null && _e !== void 0 ? _e : config.radius,
            initialColor: config.color,
            finalColor: (_f = config.finalColor) !== null && _f !== void 0 ? _f : config.color,
            initialAlpha: (_g = config.alpha) !== null && _g !== void 0 ? _g : 1,
            finalAlpha: (_j = (_h = config.finalAlpha) !== null && _h !== void 0 ? _h : config.alpha) !== null && _j !== void 0 ? _j : 1,
        });
    };
    return PuffSystem;
}(WorldObject));
/// <reference path="./puffSystem.ts" />
var BurstPuffSystem = /** @class */ (function (_super) {
    __extends(BurstPuffSystem, _super);
    function BurstPuffSystem(config) {
        var _a;
        var _this = _super.call(this, config) || this;
        _this.deleteOnComplete = (_a = config.deleteOnComplete) !== null && _a !== void 0 ? _a : true;
        for (var i = 0; i < config.puffCount; i++) {
            _this.addPuff(config.puffConfigFactory());
        }
        return _this;
    }
    BurstPuffSystem.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.deleteOnComplete && _.isEmpty(this.puffs)) {
            this.kill();
        }
    };
    return BurstPuffSystem;
}(PuffSystem));
/// <reference path="./puffSystem.ts" />
var ContinuousPuffSystem = /** @class */ (function (_super) {
    __extends(ContinuousPuffSystem, _super);
    function ContinuousPuffSystem(config) {
        var _a, _b;
        var _this = _super.call(this, config) || this;
        _this.enabled = (_a = config.startEnabled) !== null && _a !== void 0 ? _a : true;
        var puffTimer = new Timer(1 / config.puffRate, function () {
            if (_this.enabled) {
                _this.addPuff(config.puffConfigFactory());
            }
        }, Infinity);
        _this.addTimer(new Timer((_b = config.startDelay) !== null && _b !== void 0 ? _b : 0, function () { return _this.addTimer(puffTimer); }));
        return _this;
    }
    return ContinuousPuffSystem;
}(PuffSystem));
var AnimationManager = /** @class */ (function () {
    function AnimationManager(sprite) {
        this.sprite = sprite;
        this.animations = {};
        this.speed = 1;
        this.currentFrame = null;
        this.currentFrameTime = 0;
    }
    AnimationManager.prototype.update = function (delta) {
        if (this.currentFrame) {
            this.currentFrameTime += delta * this.speed;
            while (this.currentFrame && this.currentFrameTime >= this.currentFrame.duration) {
                this.currentFrameTime -= this.currentFrame.duration;
                this.setCurrentFrame(this.currentFrame.nextFrameRef, false, true);
            }
        }
    };
    AnimationManager.prototype.addAnimation = function (name, frames) {
        if (this.animations[name]) {
            console.error("Cannot add animation '" + name + "' to sprite", this.sprite, "since it already exists");
            return;
        }
        this.animations[name] = _.defaults(frames, {
            duration: 0,
            forceRequired: false,
        });
    };
    Object.defineProperty(AnimationManager.prototype, "forceRequired", {
        get: function () {
            return this.currentFrame && this.currentFrame.forceRequired;
        },
        enumerable: false,
        configurable: true
    });
    AnimationManager.prototype.getCurrentAnimationName = function () {
        for (var name_6 in this.animations) {
            if (_.contains(this.animations[name_6], this.currentFrame)) {
                return name_6;
            }
        }
        return null;
    };
    AnimationManager.prototype.getCurrentFrame = function () {
        return this.currentFrame;
    };
    AnimationManager.prototype.getFrameByRef = function (ref) {
        var parts = ref.split('/');
        if (parts.length != 2) {
            console.error("Cannot get frame '" + ref + "' on sprite", this.sprite, "as it does not fit the form '[animation]/[frame]'");
            return null;
        }
        var animation = this.animations[parts[0]];
        if (!animation) {
            console.error("Cannot get frame '" + ref + "' on sprite", this.sprite, "as animation '" + parts[0] + "' does not exist");
            return null;
        }
        var frame = parseInt(parts[1]);
        if (!isFinite(frame) || frame < 0 || frame >= animation.length) {
            console.error("Cannot get frame '" + ref + "' on sprite", this.sprite, "as animation '" + parts[0] + " does not have frame '" + parts[1] + "'");
            return null;
        }
        return animation[frame];
    };
    AnimationManager.prototype.hasAnimation = function (name) {
        return !!this.animations[name];
    };
    AnimationManager.prototype.isAnimationEmpty = function (name) {
        return _.isEmpty(this.animations[name]);
    };
    Object.defineProperty(AnimationManager.prototype, "isPlaying", {
        get: function () {
            return !!this.currentFrame;
        },
        enumerable: false,
        configurable: true
    });
    AnimationManager.prototype.playAnimation = function (name, force) {
        var _a;
        if (force === void 0) { force = false; }
        if (!force && (this.forceRequired || ((_a = this.getCurrentAnimationName()) === null || _a === void 0 ? void 0 : _a.startsWith(name)))) {
            return;
        }
        if (this.hasAnimation(name) && this.isAnimationEmpty(name)) {
            this.setCurrentFrame(null, true, force);
            return;
        }
        this.setCurrentFrame(name + "/0", true, force);
    };
    AnimationManager.prototype.setCurrentFrame = function (frameRef, resetFrameTime, force) {
        if (resetFrameTime === void 0) { resetFrameTime = true; }
        if (force === void 0) { force = false; }
        if (this.forceRequired && !force) {
            return;
        }
        // Reset frame time.
        if (resetFrameTime) {
            this.currentFrameTime = 0;
        }
        if (!frameRef) {
            this.currentFrame = null;
            return;
        }
        var frame = this.getFrameByRef(frameRef);
        if (!frame) {
            console.error('No animation frame found:', frameRef);
            return;
        }
        this.currentFrame = frame;
        // Set sprite properties from the frame.
        if (this.currentFrame.texture) {
            this.sprite.setTexture(this.currentFrame.texture);
        }
        // Call the callback
        if (this.currentFrame.callback) {
            this.currentFrame.callback();
        }
    };
    AnimationManager.prototype.stop = function () {
        this.setCurrentFrame(null, true, true);
    };
    return AnimationManager;
}());
/// <reference path="../../utils/a_array.ts" />
var Animations = /** @class */ (function () {
    function Animations() {
    }
    Animations.emptyList = function () {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        if (_.isEmpty(names))
            return [];
        return names.map(function (name) { return { name: name, frames: [] }; });
    };
    Animations.fromSingleTexture = function (config) {
        var _a;
        var result = {
            name: config.name,
            frames: [{
                    duration: (_a = config.duration) !== null && _a !== void 0 ? _a : Infinity,
                    texture: config.texture,
                    forceRequired: config.oneOff,
                }],
        };
        if (config.override) {
            result.frames[0] = this.overrideFrame(result.frames[0], config.override);
        }
        return result;
    };
    Animations.fromTextureList = function (config) {
        _.defaults(config, {
            count: 1,
        });
        if (config.count < 0 || !isFinite(config.count)) {
            config.nextFrameRef = config.name + "/0";
            config.count = 1;
        }
        var frameDuration = 1 / config.frameRate;
        var textures = A.repeat(config.textures, config.count);
        var result = {
            name: config.name,
            frames: [],
        };
        if (_.isEmpty(textures)) {
            return result;
        }
        var texturePrefix = !config.textureRoot ? "" : config.textureRoot + "/";
        for (var i = 0; i < textures.length; i++) {
            var animationFrame = {
                duration: frameDuration,
                texture: (_.isString(textures[i]) || _.isNumber(textures[i])) ? "" + texturePrefix + textures[i] : textures[i],
                nextFrameRef: config.name + "/" + (i + 1),
                forceRequired: config.oneOff,
            };
            result.frames.push(animationFrame);
        }
        result.frames[result.frames.length - 1].nextFrameRef = config.nextFrameRef;
        if (config.overrides) {
            for (var key in config.overrides) {
                var frame = key;
                result.frames[frame] = this.overrideFrame(result.frames[frame], config.overrides[key]);
            }
        }
        return result;
    };
    Animations.overrideFrame = function (frame, override) {
        return O.withOverrides(frame, override);
    };
    return Animations;
}());
var SpriteTextConverter;
(function (SpriteTextConverter) {
    function textToCharListWithWordWrap(text, font, maxWidth) {
        if (!text)
            return [];
        var result = [[]];
        var word = [];
        var nextCharPosition = new Vector2(0, 0);
        var tagStack = [];
        var current = { part: 0 };
        for (var i = 0; i < text.length; i++) {
            if (text[i] === ' ') {
                pushWord(word, result, nextCharPosition, font, maxWidth, current);
                nextCharPosition.x += font.spaceWidth;
            }
            else if (text[i] === '\n') {
                pushWord(word, result, nextCharPosition, font, maxWidth, current);
                nextCharPosition.x = 0;
                nextCharPosition.y += getNewLineHeightDiff(nextCharPosition.y, SpriteText.getHeightOfCharList(_.flatten(result)), font.newlineHeight);
                result.push([]);
            }
            else if (text[i] === '[') {
                var closingBracketIndex = text.indexOf(']', i);
                if (closingBracketIndex < i + 1) {
                    console.error("Text '" + text + "' has an unclosed tag bracket.");
                    continue;
                }
                var parts = parseTag(text.substring(i + 1, closingBracketIndex));
                if (parts[0].startsWith('/')) {
                    if (!_.isEmpty(tagStack)) {
                        tagStack.pop();
                    }
                }
                else {
                    var tag = parts.shift();
                    tagStack.push({ tag: tag, params: parts });
                }
                current.part++;
                i = closingBracketIndex;
            }
            else if (text[i] === '<') {
                var closingBracketIndex = text.indexOf('>', i);
                if (closingBracketIndex < i + 1) {
                    console.error("Text '" + text + "' has an unclosed custom character bracket.");
                    continue;
                }
                var char = createCharacter(font, text.substring(i + 1, closingBracketIndex), nextCharPosition.x, nextCharPosition.y, current.part, tagStack);
                word.push(char);
                nextCharPosition.x += char.width;
                i = closingBracketIndex;
            }
            else {
                if (text[i] === '\\' && i < text.length - 1)
                    i++;
                var char = createCharacter(font, text[i], nextCharPosition.x, nextCharPosition.y, current.part, tagStack);
                word.push(char);
                nextCharPosition.x += char.width;
            }
        }
        pushWord(word, result, nextCharPosition, font, maxWidth, current);
        return result;
    }
    SpriteTextConverter.textToCharListWithWordWrap = textToCharListWithWordWrap;
    function createCharacter(font, char, x, y, part, tagData) {
        var charWidth;
        var charHeight;
        if (char === ' ') {
            charWidth = font.spaceWidth;
            charHeight = font.charHeight;
        }
        else {
            var charTexture = AssetCache.getTexture(font.charTextures[char]);
            if (!font.charTextures[char] || !charTexture) {
                console.error("Font does not have character '" + char + "':", font);
                char = 'missing';
                charTexture = AssetCache.getTexture(font.charTextures[char]);
            }
            charWidth = charTexture.width;
            charHeight = charTexture.height;
        }
        var character = new SpriteText.Character();
        character.char = char;
        character.x = x;
        character.y = y;
        character.width = charWidth;
        character.height = charHeight;
        character.part = part;
        character.tagData = A.clone(tagData);
        return character;
    }
    function parseTag(tag) {
        var result = St.splitOnWhitespace(tag);
        if (_.isEmpty(result)) {
            console.error("Tag " + tag + " must have the tag part specified.");
            return [SpriteText.NOOP_TAG];
        }
        return result;
    }
    function pushWord(word, resultLines, position, font, maxWidth, current) {
        var e_65, _a;
        if (_.isEmpty(word))
            return;
        var lastChar = _.last(word);
        if (maxWidth > 0 && lastChar.right > maxWidth) {
            var diffx = -word[0].x;
            var diffy = getNewLineHeightDiff(word[0].y, SpriteText.getHeightOfCharList(_.flatten(resultLines)), font.newlineHeight);
            try {
                for (var word_1 = __values(word), word_1_1 = word_1.next(); !word_1_1.done; word_1_1 = word_1.next()) {
                    var char = word_1_1.value;
                    char.x += diffx;
                    char.y += diffy;
                    char.part++;
                }
            }
            catch (e_65_1) { e_65 = { error: e_65_1 }; }
            finally {
                try {
                    if (word_1_1 && !word_1_1.done && (_a = word_1.return)) _a.call(word_1);
                }
                finally { if (e_65) throw e_65.error; }
            }
            position.x += diffx;
            position.y += diffy;
            current.part++;
            resultLines.push([]);
        }
        while (word.length > 0) {
            _.last(resultLines).push(word.shift());
        }
    }
    function getNewLineHeightDiff(lastLineY, heightOfCharList, fontNewLineHeight) {
        return Math.max(heightOfCharList - lastLineY, fontNewLineHeight);
    }
    function getStaticTexturesForCharList(chars, visibleChars) {
        var bounds = {};
        var partToTagData = {};
        for (var i = 0; i < visibleChars; i++) {
            var char = chars[i];
            if (char.part in bounds) {
                bounds[char.part].left = Math.min(bounds[char.part].left, char.left);
                bounds[char.part].top = Math.min(bounds[char.part].top, char.top);
                bounds[char.part].right = Math.max(bounds[char.part].right, char.right);
                bounds[char.part].bottom = Math.max(bounds[char.part].bottom, char.bottom);
            }
            else {
                bounds[char.part] = { left: char.left, top: char.top, right: char.right, bottom: char.bottom };
            }
            partToTagData[char.part] = char.tagData;
        }
        var textures = {};
        for (var part in bounds) {
            var texture = SpriteTextConverter.cache_staticTextures.borrow(bounds[part].right - bounds[part].left, bounds[part].bottom - bounds[part].top);
            texture.clear();
            textures[part] = {
                x: bounds[part].left,
                y: bounds[part].top,
                texture: texture,
                tagData: partToTagData[part],
            };
        }
        return textures;
    }
    SpriteTextConverter.getStaticTexturesForCharList = getStaticTexturesForCharList;
    function returnStaticTextures(textures) {
        if (!textures)
            return;
        for (var part in textures) {
            SpriteTextConverter.cache_staticTextures.return(textures[part].texture.width, textures[part].texture.height, textures[part].texture);
        }
    }
    SpriteTextConverter.returnStaticTextures = returnStaticTextures;
    SpriteTextConverter.cache_staticTextures = new DualKeyPool(function (w, h) {
        return new BasicTexture(w, h, 'SpriteTextConverter.getStaticTexturesForCharList', false);
    }, function (w, h) { return w + "," + h; });
})(SpriteTextConverter || (SpriteTextConverter = {}));
var Tilemap = /** @class */ (function (_super) {
    __extends(Tilemap, _super);
    function Tilemap(config) {
        var _a, _b, _c;
        var _this = _super.call(this, config) || this;
        _this.tilemap = Tilemap.cloneTilemap(_.isString(config.tilemap) ? AssetCache.getTilemap(config.tilemap) : config.tilemap);
        _this.scrubTilemapEntities(config.entities);
        _this.setTilemapLayer((_a = config.tilemapLayer) !== null && _a !== void 0 ? _a : 0);
        _this.tileset = AssetCache.getTileset(config.tileset);
        _this.zMap = (_b = config.zMap) !== null && _b !== void 0 ? _b : {};
        _this.animation = config.animation;
        _this.collisionOnly = (_c = config.collisionOnly) !== null && _c !== void 0 ? _c : false;
        _this.createTilemap();
        _this.dirty = false;
        _this.debugDrawBounds = false;
        return _this;
    }
    Object.defineProperty(Tilemap.prototype, "currentTilemapLayer", {
        get: function () { return this.tilemap.layers[this.tilemapLayer]; },
        enumerable: false,
        configurable: true
    });
    Tilemap.prototype.update = function () {
        if (this.dirty) {
            this.createTilemap();
            this.dirty = false;
        }
    };
    Tilemap.prototype.getTile = function (x, y) {
        return this.currentTilemapLayer.tiles[y][x];
    };
    Tilemap.prototype.setTile = function (x, y, tile) {
        this.currentTilemapLayer.tiles[y][x] = O.deepClone(tile);
        this.dirty = true;
    };
    Object.defineProperty(Tilemap.prototype, "width", {
        get: function () {
            return this.widthInTiles * this.tileset.tileWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tilemap.prototype, "height", {
        get: function () {
            return this.heightInTiles * this.tileset.tileHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tilemap.prototype, "widthInTiles", {
        get: function () {
            return this.tilemap.layers[this.tilemapLayer].tiles[0].length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tilemap.prototype, "heightInTiles", {
        get: function () {
            return this.tilemap.layers[this.tilemapLayer].tiles.length;
        },
        enumerable: false,
        configurable: true
    });
    Tilemap.prototype.createCollisionBoxes = function () {
        var e_66, _a;
        World.Actions.removeWorldObjectsFromWorld(this.collisionBoxes);
        this.collisionBoxes = [];
        var collisionRects = Tilemap.getCollisionRects(this.currentTilemapLayer, this.tileset);
        Tilemap.optimizeCollisionRects(collisionRects); // Not optimizing entire array first to save some cycles.
        Tilemap.optimizeCollisionRects(collisionRects, Tilemap.OPTIMIZE_ALL);
        try {
            for (var collisionRects_1 = __values(collisionRects), collisionRects_1_1 = collisionRects_1.next(); !collisionRects_1_1.done; collisionRects_1_1 = collisionRects_1.next()) {
                var rect_3 = collisionRects_1_1.value;
                var box = this.addChild(new PhysicsWorldObject({
                    bounds: new RectBounds(rect_3.x, rect_3.y, rect_3.width, rect_3.height),
                    copyFromParent: ['layer', 'physicsGroup'],
                    immovable: true,
                    simulating: false,
                }));
                box.debugDrawBounds = this.debugDrawBounds;
                this.collisionBoxes.push(box);
            }
        }
        catch (e_66_1) { e_66 = { error: e_66_1 }; }
        finally {
            try {
                if (collisionRects_1_1 && !collisionRects_1_1.done && (_a = collisionRects_1.return)) _a.call(collisionRects_1);
            }
            finally { if (e_66) throw e_66.error; }
        }
    };
    Tilemap.prototype.createTilemap = function () {
        if (!this.collisionOnly) {
            this.drawRenderTexture();
        }
        this.createCollisionBoxes();
    };
    Tilemap.prototype.drawRenderTexture = function () {
        this.clearZTextures();
        var zTileIndices = Tilemap.createZTileIndicies(this.currentTilemapLayer, this.zMap);
        var zTextures = this.createZTextures(zTileIndices);
        for (var y = 0; y < this.currentTilemapLayer.tiles.length; y++) {
            for (var x = 0; x < this.currentTilemapLayer.tiles[y].length; x++) {
                var zValue = Tilemap.getZValue(zTileIndices, y, x);
                if (!zTextures[zValue])
                    continue;
                this.drawTile(this.currentTilemapLayer.tiles[y][x], x - zTextures[zValue].tileBounds.left, y - zTextures[zValue].tileBounds.top, zTextures[zValue].frames);
            }
        }
    };
    Tilemap.prototype.drawTile = function (tile, tileX, tileY, renderTextures) {
        if (!tile || tile.index < 0)
            return;
        for (var i = 0; i < renderTextures.length; i++) {
            var textureKeyIndex = this.animation ? i * this.animation.tilesPerFrame + tile.index : tile.index;
            var textureKey = this.tileset.tiles[textureKeyIndex];
            var texture = AssetCache.getTexture(textureKey);
            texture.renderTo(renderTextures[i], {
                x: (tileX + 0.5) * this.tileset.tileWidth,
                y: (tileY + 0.5) * this.tileset.tileHeight,
                angle: tile.angle,
                scaleX: tile.flipX ? -1 : 1,
            });
        }
    };
    Tilemap.prototype.setTilemapLayer = function (tilemapLayer) {
        if (_.isNumber(tilemapLayer)) {
            this.tilemapLayer = tilemapLayer;
            return;
        }
        var layerIndex = this.tilemap.layers.findIndex(function (layer) { return layer.name === tilemapLayer; });
        if (layerIndex >= 0) {
            this.tilemapLayer = layerIndex;
            return;
        }
        console.error("Could not find layer '" + tilemapLayer + "' in tilemap", this);
        this.tilemapLayer = 0;
    };
    Tilemap.prototype.createZTextures = function (zTileIndices) {
        var texturesByZ = Tilemap.createEmptyZTextures(zTileIndices, this.tileset, this.animation);
        for (var zValue in texturesByZ) {
            var zHeight = texturesByZ[zValue].zHeight * this.tileset.tileHeight;
            var zTexture = this.addChild(new Sprite());
            zTexture.x = this.x + texturesByZ[zValue].bounds.x;
            zTexture.y = this.y + texturesByZ[zValue].bounds.y + zHeight;
            zTexture.copyFromParent.push('layer');
            zTexture.offsetY = -zHeight;
            zTexture.setTexture(this.animation ? undefined : texturesByZ[zValue].frames[0]);
            if (this.animation) {
                zTexture.addAnimation(Animations.fromTextureList({ name: 'play', textures: texturesByZ[zValue].frames, frameRate: this.animation.frameRate, count: -1 }));
                zTexture.playAnimation('play');
            }
            this.zTextures.push(zTexture);
        }
        return texturesByZ;
    };
    Tilemap.prototype.clearZTextures = function () {
        World.Actions.removeWorldObjectsFromWorld(this.zTextures);
        this.zTextures = [];
    };
    Tilemap.prototype.scrubTilemapEntities = function (entities) {
        if (_.isEmpty(entities))
            return;
        for (var layer = 0; layer < this.tilemap.layers.length; layer++) {
            for (var y = 0; y < this.tilemap.layers[layer].tiles.length; y++) {
                for (var x = 0; x < this.tilemap.layers[layer].tiles[y].length; x++) {
                    if (this.tilemap.layers[layer].tiles[y][x].index in entities) {
                        this.tilemap.layers[layer].tiles[y][x].index = -1;
                    }
                }
            }
        }
    };
    return Tilemap;
}(WorldObject));
(function (Tilemap) {
    function cloneTilemap(tilemap) {
        var result = {
            layers: [],
        };
        for (var i = 0; i < tilemap.layers.length; i++) {
            result.layers.push(O.deepClone(tilemap.layers[i]));
        }
        return result;
    }
    Tilemap.cloneTilemap = cloneTilemap;
    function createZTileIndicies(layer, zMap) {
        var zTileIndices = getInitialZTileIndicies(layer, zMap);
        fillZTileIndicies(zTileIndices);
        return zTileIndices;
    }
    Tilemap.createZTileIndicies = createZTileIndicies;
    function createEmptyZTextures(zTileIndices, tileset, animation) {
        var zTextureSlots = {};
        for (var y = 0; y < zTileIndices.length; y++) {
            for (var x = 0; x < zTileIndices[y].length; x++) {
                if (isFinite(zTileIndices[y][x])) {
                    var zValue = getZValue(zTileIndices, y, x);
                    if (!zTextureSlots[zValue])
                        zTextureSlots[zValue] = {
                            frames: null,
                            bounds: { x: 0, y: 0, width: 0, height: 0 },
                            tileBounds: { left: Infinity, right: -Infinity, top: Infinity, bottom: -Infinity },
                            zHeight: -Infinity,
                        };
                    if (x < zTextureSlots[zValue].tileBounds.left)
                        zTextureSlots[zValue].tileBounds.left = x;
                    if (x > zTextureSlots[zValue].tileBounds.right)
                        zTextureSlots[zValue].tileBounds.right = x;
                    if (y < zTextureSlots[zValue].tileBounds.top)
                        zTextureSlots[zValue].tileBounds.top = y;
                    if (y > zTextureSlots[zValue].tileBounds.bottom)
                        zTextureSlots[zValue].tileBounds.bottom = y;
                    if (zTileIndices[y][x] > zTextureSlots[zValue].zHeight)
                        zTextureSlots[zValue].zHeight = zTileIndices[y][x];
                }
            }
        }
        var _loop_4 = function (zValue) {
            zTextureSlots[zValue].bounds.x = zTextureSlots[zValue].tileBounds.left * tileset.tileWidth;
            zTextureSlots[zValue].bounds.y = zTextureSlots[zValue].tileBounds.top * tileset.tileHeight;
            zTextureSlots[zValue].bounds.width = (zTextureSlots[zValue].tileBounds.right - zTextureSlots[zValue].tileBounds.left + 1) * tileset.tileWidth;
            zTextureSlots[zValue].bounds.height = (zTextureSlots[zValue].tileBounds.bottom - zTextureSlots[zValue].tileBounds.top + 1) * tileset.tileHeight;
            var numFrames = animation ? animation.frames : 1;
            zTextureSlots[zValue].frames = A.range(numFrames).map(function (i) { return new BasicTexture(zTextureSlots[zValue].bounds.width, zTextureSlots[zValue].bounds.height, 'Tilemap.createEmptyZTextures'); });
        };
        for (var zValue in zTextureSlots) {
            _loop_4(zValue);
        }
        return zTextureSlots;
    }
    Tilemap.createEmptyZTextures = createEmptyZTextures;
    function getCollisionRects(tilemapLayer, tileset) {
        if (_.isEmpty(tileset.collisionIndices))
            return [];
        var result = [];
        for (var y = 0; y < tilemapLayer.tiles.length; y++) {
            for (var x = 0; x < tilemapLayer.tiles[y].length; x++) {
                var tile = tilemapLayer.tiles[y][x];
                if (_.contains(tileset.collisionIndices, tile.index)) {
                    var rect_4 = {
                        x: x * tileset.tileWidth,
                        y: y * tileset.tileHeight,
                        width: tileset.tileWidth,
                        height: tileset.tileHeight
                    };
                    result.push(rect_4);
                }
            }
        }
        return result;
    }
    Tilemap.getCollisionRects = getCollisionRects;
    function getZValue(zTileIndices, y, x) {
        return y + zTileIndices[y][x];
    }
    Tilemap.getZValue = getZValue;
    function lookupZMapValue(tile, zMap) {
        return zMap[tile.index];
    }
    Tilemap.lookupZMapValue = lookupZMapValue;
    function optimizeCollisionRects(rects, all) {
        if (all === void 0) { all = !Tilemap.OPTIMIZE_ALL; }
        var i = 0;
        while (i < rects.length) {
            var j = i + 1;
            while (j < rects.length) {
                var combined = combineRects(rects[j], rects[i]);
                if (combined) {
                    rects.splice(j, 1);
                }
                else if (all) {
                    j++;
                }
                else {
                    break;
                }
            }
            i++;
        }
    }
    Tilemap.optimizeCollisionRects = optimizeCollisionRects;
    Tilemap.OPTIMIZE_ALL = true;
    function combineRects(rect, into) {
        if (G.rectContainsRect(into, rect))
            return true;
        if (G.rectContainsRect(rect, into)) {
            into.x = rect.x;
            into.y = rect.y;
            into.width = rect.width;
            into.height = rect.height;
            return true;
        }
        if (rect.x == into.x && rect.width == into.width) {
            if (rect.y <= into.y + into.height && rect.y + rect.height >= into.y) {
                var newY = Math.min(rect.y, into.y);
                var newH = Math.max(rect.y + rect.height, into.y + into.height) - newY;
                into.y = newY;
                into.height = newH;
                return true;
            }
        }
        if (rect.y == into.y && rect.height == into.height) {
            if (rect.x <= into.x + into.width && rect.x + rect.width >= into.x) {
                var newX = Math.min(rect.x, into.x);
                var newW = Math.max(rect.x + rect.width, into.x + into.width) - newX;
                into.x = newX;
                into.width = newW;
                return true;
            }
        }
        return false;
    }
    function getInitialZTileIndicies(layer, zMap) {
        var zTileIndices = A.filledArray2D(layer.tiles.length, layer.tiles[0].length, undefined);
        if (_.isEmpty(zMap)) {
            for (var x = 0; x < layer.tiles[0].length; x++) {
                zTileIndices[0][x] = 0;
            }
            return zTileIndices;
        }
        for (var y = 0; y < layer.tiles.length; y++) {
            for (var x = 0; x < layer.tiles[y].length; x++) {
                var tile = layer.tiles[y][x];
                zTileIndices[y][x] = tile.index === -1 ? -Infinity : lookupZMapValue(tile, zMap);
            }
        }
        return zTileIndices;
    }
    function fillZTileIndicies(zTileIndices) {
        for (var y = 1; y < zTileIndices.length; y++) {
            for (var x = 0; x < zTileIndices[y].length; x++) {
                if (zTileIndices[y][x] === undefined && isFinite(zTileIndices[y - 1][x])) {
                    zTileIndices[y][x] = zTileIndices[y - 1][x] - 1;
                }
            }
        }
        for (var y = zTileIndices.length - 2; y >= 0; y--) {
            for (var x = 0; x < zTileIndices[y].length; x++) {
                if (zTileIndices[y][x] === undefined && isFinite(zTileIndices[y + 1][x])) {
                    zTileIndices[y][x] = zTileIndices[y + 1][x] + 1;
                }
            }
        }
        for (var y = 0; y < zTileIndices.length; y++) {
            for (var x = 0; x < zTileIndices[y].length; x++) {
                if (zTileIndices[y][x] === undefined) {
                    zTileIndices[y][x] = 0;
                }
            }
        }
    }
})(Tilemap || (Tilemap = {}));
/// <reference path="./tilemap.ts" />
var SmartTilemap;
(function (SmartTilemap) {
    function sortedRules(rules) {
        return A.sort(rules, function (rule) { return getPatternSpecificity(rule.pattern); }, true);
    }
    SmartTilemap.sortedRules = sortedRules;
    function getSmartTilemap(tilemap, config) {
        if (_.isString(tilemap)) {
            tilemap = AssetCache.getTilemap(tilemap);
            if (!tilemap)
                return undefined;
        }
        return {
            layers: tilemap.layers.map(function (layer) { return getSmartTilemapLayer(layer, config); }),
        };
    }
    SmartTilemap.getSmartTilemap = getSmartTilemap;
    function getSmartTilemapLayer(tilemapLayer, config) {
        var tiles = [];
        for (var y = 0; y < tilemapLayer.tiles.length; y++) {
            var line = [];
            for (var x = 0; x < tilemapLayer.tiles[y].length; x++) {
                line.push(getSmartTile(tilemapLayer, x, y, config));
            }
            tiles.push(line);
        }
        return {
            name: tilemapLayer.name,
            tiles: tiles,
        };
    }
    SmartTilemap.getSmartTilemapLayer = getSmartTilemapLayer;
    function getSmartTile(tilemap, x, y, config) {
        var e_67, _a;
        try {
            for (var _b = __values(config.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rule = _c.value;
                if (matchTilePattern(tilemap, x, y, config, rule.pattern)) {
                    return _.isNumber(rule.tile) ? { index: rule.tile, angle: 0, flipX: false } : rule.tile;
                }
            }
        }
        catch (e_67_1) { e_67 = { error: e_67_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_67) throw e_67.error; }
        }
        return tilemap[y][x];
    }
    function matchTilePattern(tilemap, x, y, config, pattern) {
        return matchTilePatternTile(pattern.tile, getTileIndex(tilemap, x, y, config))
            && matchTilePatternTile(pattern.above, getTileIndex(tilemap, x, y - 1, config))
            && matchTilePatternTile(pattern.below, getTileIndex(tilemap, x, y + 1, config))
            && matchTilePatternTile(pattern.left, getTileIndex(tilemap, x - 1, y, config))
            && matchTilePatternTile(pattern.right, getTileIndex(tilemap, x + 1, y, config))
            && matchTilePatternTile(pattern.aboveLeft, getTileIndex(tilemap, x - 1, y - 1, config))
            && matchTilePatternTile(pattern.aboveRight, getTileIndex(tilemap, x + 1, y - 1, config))
            && matchTilePatternTile(pattern.belowLeft, getTileIndex(tilemap, x - 1, y + 1, config))
            && matchTilePatternTile(pattern.belowRight, getTileIndex(tilemap, x + 1, y + 1, config));
    }
    function matchTilePatternTile(patternTile, tileIndex) {
        if (patternTile === undefined)
            return true;
        if (_.isNumber(patternTile))
            return patternTile === tileIndex;
        if (patternTile.type === 'is')
            return patternTile.index === tileIndex;
        if (patternTile.type === 'not')
            return patternTile.index !== tileIndex;
        return false;
    }
    function getPatternSpecificity(pattern) {
        return getPatternTileSpecificity(pattern.tile)
            + getPatternTileSpecificity(pattern.above)
            + getPatternTileSpecificity(pattern.below)
            + getPatternTileSpecificity(pattern.left)
            + getPatternTileSpecificity(pattern.right)
            + getPatternTileSpecificity(pattern.aboveLeft)
            + getPatternTileSpecificity(pattern.aboveRight)
            + getPatternTileSpecificity(pattern.belowLeft)
            + getPatternTileSpecificity(pattern.belowRight);
    }
    function getPatternTileSpecificity(patternTile) {
        if (patternTile === undefined)
            return 0;
        return 1;
    }
    function getTileIndex(tilemapLayer, x, y, config) {
        if (0 <= y && y < tilemapLayer.tiles.length && 0 <= x && x < tilemapLayer.tiles[y].length) {
            if (tilemapLayer.tiles[y][x].index >= 0) {
                return tilemapLayer.tiles[y][x].index;
            }
            if (!config.emptyRule || config.emptyRule.type === 'noop') {
                return tilemapLayer.tiles[y][x].index;
            }
            if (config.emptyRule.type === 'constant') {
                return config.emptyRule.index;
            }
        }
        if (config.outsideRule.type === 'constant') {
            return config.outsideRule.index;
        }
        if (config.outsideRule.type === 'extend') {
            var nearesty = M.clamp(y, 0, tilemapLayer.tiles.length - 1);
            var nearestx = M.clamp(x, 0, tilemapLayer.tiles[nearesty].length - 1);
            return tilemapLayer.tiles[nearesty][nearestx].index;
        }
        return -1;
    }
})(SmartTilemap || (SmartTilemap = {}));
var TilemapEntities = /** @class */ (function () {
    function TilemapEntities() {
    }
    TilemapEntities.getEntities = function (config) {
        var _a, _b;
        var tilemap = _.isString(config.tilemap) ? AssetCache.getTilemap(config.tilemap) : config.tilemap;
        var tilemapLayer = config.tilemapLayer;
        var tileset = AssetCache.getTileset(config.tileset);
        var entities = config.entities;
        var offsetX = (_a = config.offsetX) !== null && _a !== void 0 ? _a : 0;
        var offsetY = (_b = config.offsetY) !== null && _b !== void 0 ? _b : 0;
        var layer = tilemap.layers[tilemapLayer];
        var result = [];
        for (var y = 0; y < layer.tiles.length; y++) {
            for (var x = 0; x < layer.tiles[y].length; x++) {
                var tile = layer.tiles[y][x];
                if (!entities[tile.index])
                    continue;
                var entity = entities[tile.index](offsetX + x * tileset.tileWidth, offsetY + y * tileset.tileHeight, tile);
                result.push(entity);
            }
        }
        return result;
    };
    return TilemapEntities;
}());
/**
 *  To add a new ability, simply add an entry to this map and
 *  trigger the ability with Ball.queueAbilities.
 */
var ABILITIES = {
    'onBallEnterBattle': { params: function (ball) { return null; }, manual: false, battle: true },
    'onBallDie': { params: function (ball) { return null; }, manual: false, battle: true },
    'onBallJoin': { params: function (ball) { return null; }, manual: false, battle: true },
    'onBallShootProjectile': { params: function (ball, hitCount) { return null; }, manual: false, battle: true },
    'onBallTakeDamage': { params: function (ball, damage) { return null; }, manual: false, battle: true },
    'onBuy': { params: function () { return null; }, manual: false, battle: false },
    'onCollideWithBallPreDamage': { params: function (ball) { return null; }, manual: false, battle: true },
    'onCollideWithEnemyPostDamage': { params: function (enemy, damage) { return null; }, manual: false, battle: true },
    'onDeath': { params: function (killedBy) { return null; }, manual: false, battle: true },
    'onEnterBattle': { params: function () { return null; }, manual: false, battle: true },
    'onEquip': { params: function () { return null; }, manual: false, battle: false },
    'onKill': { params: function (killed) { return null; }, manual: false, battle: true },
    'onLevelUp': { params: function () { return null; }, manual: false, battle: false },
    'onLevelDown': { params: function () { return null; }, manual: false, battle: false },
    'onPlay': { params: function () { return null; }, manual: false, battle: false },
    'onPreBattle': { params: function () { return null; }, manual: true, battle: true },
    'onRestock': { params: function () { return null; }, manual: false, battle: false },
    'onSell': { params: function () { return null; }, manual: false, battle: false },
    'onStartShop': { params: function () { return null; }, manual: false, battle: false },
    'onSurviveBattle': { params: function () { return null; }, manual: false, battle: false },
    'onTakeDamage': { params: function (damage) { return null; }, manual: false, battle: true },
    'onTakeLeechDamage': { params: function (damage) { return null; }, manual: false, battle: true },
    'update': { params: function () { return null; }, manual: false, battle: true },
};
var ABILITY_ORDERING = [
    { sourceClass1: 'equipment', sourceType1: 27, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 116, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: 32 },
    { sourceClass1: 'ball', sourceType1: 142, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: 32 },
    { sourceClass1: 'ball', sourceType1: 32, condition: '<', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'ball', sourceType1: 32, condition: '>', teamRelation: 'ally', sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'equipment', sourceType1: 10, condition: '>', teamRelation: 'enemy', sourceClass2: 'equipment', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 22, condition: '>', teamRelation: 'enemy', sourceClass2: 'equipment', sourceType2: undefined },
    { sourceClass1: 'equipment', sourceType1: 30, condition: '>', teamRelation: undefined, sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 116, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 142, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 124, condition: '>', teamRelation: 'enemy', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 49, condition: '>', teamRelation: 'ally', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 102, condition: '>', teamRelation: 'enemy', sourceClass2: 'ball', sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 140, condition: '<', teamRelation: 'ally', sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'equipment', sourceType1: 32, condition: '<', teamRelation: 'ally', sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'equipment', sourceType1: 15, condition: '<', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 33, condition: '<', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 40, condition: '<', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 40, condition: '<', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'ball', sourceType1: 123, condition: '<', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'ball', sourceType1: 32, condition: '>', teamRelation: 'enemy', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'ball', sourceType1: 140, condition: '<', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'ball', sourceType1: 140, condition: '>', teamRelation: 'enemy', sourceClass2: 'equipment', sourceType2: 39 },
    { sourceClass1: 'equipment', sourceType1: 37, condition: '<', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'equipment', sourceType1: 8, condition: '>', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 101, condition: '>', teamRelation: undefined, sourceClass2: undefined, sourceType2: undefined },
    { sourceClass1: 'ball', sourceType1: 25, condition: '>', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 20 },
    { sourceClass1: 'ball', sourceType1: 136, condition: '>', teamRelation: 'ally', sourceClass2: 'equipment', sourceType2: 20 },
];
var MANUAL_ABILITIES_SAME_TIME_BALLS = [
    14,
    22,
    40,
    43,
    102,
    116,
    123,
    124,
    142,
];
var MANUAL_ABILITIES_SAME_TIME_EQUIPMENT = [
    10,
    15,
    27,
    30,
    32,
    37,
];
var AbilitySet = /** @class */ (function () {
    function AbilitySet() {
        this.abilities = {};
    }
    AbilitySet.prototype.addAbility = function (type, abilityFunction, nullifyable) {
        if (nullifyable === void 0) { nullifyable = true; }
        if (!(type in this.abilities)) {
            this.abilities[type] = [];
        }
        this.abilities[type].push({
            abilityFunction: abilityFunction,
            nullifyable: nullifyable,
        });
    };
    AbilitySet.prototype.cancelAbilities = function (source) {
        if (!source.mainWorld) {
            console.error('cancelAbilities source has no mainWorld:', source);
            return;
        }
        var abilitySystem = source.mainWorld.select.type(AbilitySystem);
        if (!abilitySystem)
            return;
        abilitySystem.cancelAbilities(source);
    };
    AbilitySet.prototype.hasAbility = function (abilityType) {
        return abilityType in this.abilities;
    };
    AbilitySet.prototype.queueAbilities = function (abilityType, source, nullified, abilityParams) {
        var e_68, _a;
        if (!this.hasAbility(abilityType))
            return;
        if (!source.mainWorld) {
            console.error('queueAbilities source has no mainWorld:', abilityType, source);
            return;
        }
        var abilitySystem = source.mainWorld.select.type(AbilitySystem);
        if (!abilitySystem)
            return;
        var ballSource = source instanceof Ball ? source : source.getParent();
        if (!ballSource) {
            console.error('No ballSource found for ability:', abilityType, source);
            return;
        }
        try {
            for (var _b = __values(this.abilities[abilityType]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var abilityConfig = _c.value;
                abilitySystem.queueAbility(source, ballSource, abilityType, abilityConfig, nullified, abilityParams);
            }
        }
        catch (e_68_1) { e_68 = { error: e_68_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_68) throw e_68.error; }
        }
    };
    return AbilitySet;
}());
var AbilitySystem = /** @class */ (function (_super) {
    __extends(AbilitySystem, _super);
    function AbilitySystem() {
        var _this = _super.call(this) || this;
        _this.queuedAbilities = [];
        return _this;
    }
    AbilitySystem.prototype.activateAbilities = function () {
        this.consistentizeQueuedAbilities();
        while (!_.isEmpty(this.queuedAbilities)) {
            var nextIndex = this.queuedAbilities.findIndex(function (ability) { return !ABILITIES[ability.abilityType].manual; });
            if (nextIndex < 0)
                return;
            var nextAbility = this.queuedAbilities.splice(nextIndex, 1)[0];
            //if (nextAbility.abilityType !== 'update') console.log('activating:', nextAbility.abilityType, nextAbility);
            nextAbility.abilityFunction.apply(nextAbility, __spread([nextAbility.ballSource, this.world], nextAbility.abilityParams));
            nextAbility.ballSource.noteAbilityActivated(nextAbility.abilityType);
        }
    };
    AbilitySystem.prototype.activateNextManualAbilities = function () {
        var e_69, _a;
        var nextIndex = this.queuedAbilities.findIndex(function (ability) { return ABILITIES[ability.abilityType].manual; });
        if (nextIndex < 0)
            return [];
        var nextAbilities = [this.queuedAbilities.splice(nextIndex, 1)[0]];
        var sameTimeForBalls = nextAbilities[0].sourceClass === 'ball' && _.contains(MANUAL_ABILITIES_SAME_TIME_BALLS, nextAbilities[0].sourceType);
        var sameTimeForEquipment = nextAbilities[0].sourceClass === 'equipment' && _.contains(MANUAL_ABILITIES_SAME_TIME_EQUIPMENT, nextAbilities[0].sourceType);
        if (sameTimeForBalls || sameTimeForEquipment) {
            for (var i = nextIndex; i < this.queuedAbilities.length; i++) {
                if (this.queuedAbilities[i].abilityType === nextAbilities[0].abilityType && this.queuedAbilities[i].sourceClass === nextAbilities[0].sourceClass && this.queuedAbilities[i].sourceType === nextAbilities[0].sourceType) {
                    nextAbilities.push(this.queuedAbilities.splice(i, 1)[0]);
                    i--;
                }
            }
        }
        try {
            //console.log('activating next:', nextAbilities[0].abilityType, nextAbilities);
            for (var nextAbilities_1 = __values(nextAbilities), nextAbilities_1_1 = nextAbilities_1.next(); !nextAbilities_1_1.done; nextAbilities_1_1 = nextAbilities_1.next()) {
                var nextAbility = nextAbilities_1_1.value;
                nextAbility.abilityFunction.apply(nextAbility, __spread([nextAbility.ballSource, this.world], nextAbility.abilityParams));
                nextAbility.ballSource.noteAbilityActivated(nextAbility.abilityType);
            }
        }
        catch (e_69_1) { e_69 = { error: e_69_1 }; }
        finally {
            try {
                if (nextAbilities_1_1 && !nextAbilities_1_1.done && (_a = nextAbilities_1.return)) _a.call(nextAbilities_1);
            }
            finally { if (e_69) throw e_69.error; }
        }
        return nextAbilities;
    };
    AbilitySystem.prototype.cancelAbilities = function (source) {
        A.filterInPlace(this.queuedAbilities, function (queuedAbility) {
            return queuedAbility.source !== source;
        });
    };
    AbilitySystem.prototype.consistentizeQueuedAbilities = function () {
        var e_70, _a;
        this.queuedAbilities.sort(function (a, b) {
            if (a.sourceClass === 'ball' && b.sourceClass === 'equipment')
                return -1;
            if (a.sourceClass === 'equipment' && b.sourceClass === 'ball')
                return 1;
            return a.sourceType - b.sourceType;
        });
        var oldQueuedAbilities = this.queuedAbilities;
        this.queuedAbilities = [];
        try {
            for (var oldQueuedAbilities_1 = __values(oldQueuedAbilities), oldQueuedAbilities_1_1 = oldQueuedAbilities_1.next(); !oldQueuedAbilities_1_1.done; oldQueuedAbilities_1_1 = oldQueuedAbilities_1.next()) {
                var ability = oldQueuedAbilities_1_1.value;
                this.pushAbility(ability);
            }
        }
        catch (e_70_1) { e_70 = { error: e_70_1 }; }
        finally {
            try {
                if (oldQueuedAbilities_1_1 && !oldQueuedAbilities_1_1.done && (_a = oldQueuedAbilities_1.return)) _a.call(oldQueuedAbilities_1);
            }
            finally { if (e_70) throw e_70.error; }
        }
    };
    AbilitySystem.prototype.hasManualAbilitiesQueued = function () {
        return this.queuedAbilities.find(function (ability) { return ABILITIES[ability.abilityType].manual; });
    };
    AbilitySystem.prototype.purgeDeadPreBattleAbilities = function () {
        A.filterInPlace(this.queuedAbilities, function (ability) {
            if (ability.abilityType !== 'onPreBattle')
                return true;
            if (!ability.source.world)
                return false;
            return true;
        });
    };
    AbilitySystem.prototype.queueAbility = function (source, ballSource, abilityType, abilityConfig, nullified, abilityParams) {
        if (nullified && abilityConfig.nullifyable) {
            if (source instanceof Ball)
                source.noteAbilityActivated(abilityType);
            return;
        }
        this.pushAbility({
            sourceClass: source instanceof Ball ? 'ball' : 'equipment',
            sourceType: source instanceof Ball ? source.properties.type : source.equipmentType,
            source: source,
            ballSource: ballSource,
            abilityType: abilityType,
            abilityFunction: abilityConfig.abilityFunction,
            abilityParams: abilityParams,
        });
    };
    AbilitySystem.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        this.activateAbilities();
    };
    AbilitySystem.prototype.reset = function () {
        this.queuedAbilities = [];
    };
    AbilitySystem.prototype.pushAbility = function (newAbility) {
        var e_71, _a;
        for (var i = 0; i < this.queuedAbilities.length; i++) {
            var queuedAbility = this.queuedAbilities[i];
            try {
                for (var ABILITY_ORDERING_1 = (e_71 = void 0, __values(ABILITY_ORDERING)), ABILITY_ORDERING_1_1 = ABILITY_ORDERING_1.next(); !ABILITY_ORDERING_1_1.done; ABILITY_ORDERING_1_1 = ABILITY_ORDERING_1.next()) {
                    var ordering = ABILITY_ORDERING_1_1.value;
                    if (this.abilityMatchesOrdering(newAbility, queuedAbility, ordering)) {
                        if (ordering.condition === '>') {
                            this.queuedAbilities.splice(i, 0, newAbility);
                            return;
                        }
                        else if (ordering.condition === '<') {
                            break;
                        }
                    }
                    else if (this.abilityMatchesOrdering(queuedAbility, newAbility, ordering)) {
                        if (ordering.condition === '<') {
                            this.queuedAbilities.splice(i, 0, newAbility);
                            return;
                        }
                        else if (ordering.condition === '>') {
                            break;
                        }
                    }
                }
            }
            catch (e_71_1) { e_71 = { error: e_71_1 }; }
            finally {
                try {
                    if (ABILITY_ORDERING_1_1 && !ABILITY_ORDERING_1_1.done && (_a = ABILITY_ORDERING_1.return)) _a.call(ABILITY_ORDERING_1);
                }
                finally { if (e_71) throw e_71.error; }
            }
            // New ability does not go in this position
        }
        // New ability did not cmp with any queued ability, push it to the end
        this.queuedAbilities.push(newAbility);
    };
    AbilitySystem.prototype.abilityMatchesOrdering = function (ability1, ability2, ordering) {
        if (ordering.sourceClass1 !== undefined && ability1.sourceClass !== ordering.sourceClass1)
            return false;
        if (ordering.sourceType1 !== undefined && ability1.sourceType !== ordering.sourceType1)
            return false;
        if (ordering.sourceClass2 !== undefined && ability2.sourceClass !== ordering.sourceClass2)
            return false;
        if (ordering.sourceType2 !== undefined && ability2.sourceType !== ordering.sourceType2)
            return false;
        if (ordering.teamRelation === 'ally' && ability1.ballSource.team !== ability2.ballSource.team)
            return false;
        if (ordering.teamRelation === 'enemy' && ability1.ballSource.team === ability2.ballSource.team)
            return false;
        return true;
    };
    return AbilitySystem;
}(WorldObject));
var AbilityCooldown = /** @class */ (function () {
    function AbilityCooldown(cooldown, uses) {
        var _this = this;
        this.currentUses = uses;
        this.maxUses = uses;
        this.timer = new Timer(cooldown, function () { return _this.currentUses = M.clamp(_this.currentUses + 1, 0, _this.maxUses); }, Infinity);
    }
    AbilityCooldown.prototype.update = function (delta) {
        if (this.currentUses < this.maxUses) {
            this.timer.update(delta);
        }
    };
    AbilityCooldown.prototype.consumeUse = function () {
        if (this.currentUses <= 0)
            return false;
        this.currentUses--;
        return true;
    };
    return AbilityCooldown;
}());
var AchievementRewardInfoBox = /** @class */ (function (_super) {
    __extends(AchievementRewardInfoBox, _super);
    function AchievementRewardInfoBox(onlyOperateInBounds) {
        var _this = _super.call(this, {
            useGlobalTime: true,
        }) || this;
        _this.text = _this.addChild(new SpriteText({
            anchor: Vector2.CENTER,
            justify: 'center',
            copyFromParent: ['layer'],
        }));
        _this.floatTimer = new Timer(0.25, function () { return _this.setVisible(true); });
        _this.onlyOperateInBounds = onlyOperateInBounds;
        return _this;
    }
    AchievementRewardInfoBox.prototype.update = function () {
        var e_72, _a;
        var _b;
        _super.prototype.update.call(this);
        var mousePos = this.world.getWorldMousePosition();
        var rewards = this.world.select.tag('reward');
        var selectedReward = rewards.find(function (reward) { return reward.bounds.containsPoint(mousePos); });
        try {
            // Yes, basic highlighting here...
            for (var rewards_1 = __values(rewards), rewards_1_1 = rewards_1.next(); !rewards_1_1.done; rewards_1_1 = rewards_1.next()) {
                var reward = rewards_1_1.value;
                if (reward === selectedReward) {
                    reward.effects.outline.color = 0xFFFF00;
                    reward.effects.outline.enabled = true;
                }
                else {
                    reward.effects.outline.enabled = false;
                }
            }
        }
        catch (e_72_1) { e_72 = { error: e_72_1 }; }
        finally {
            try {
                if (rewards_1_1 && !rewards_1_1.done && (_a = rewards_1.return)) _a.call(rewards_1);
            }
            finally { if (e_72) throw e_72.error; }
        }
        var inBounds = !selectedReward || G.overlapRectangles(this.onlyOperateInBounds, selectedReward.getVisibleScreenBounds());
        if (selectedReward && inBounds) {
            var text = '??????';
            if (selectedReward.hasTag('secret')) {
                text = (_b = selectedReward.data.desc) !== null && _b !== void 0 ? _b : 'Secret Achievement :)';
            }
            this.text.setText(text);
            var width = this.text.getTextWidth() + 2 * AchievementRewardInfoBox.PADDING.x - 1;
            var height = this.text.getTextHeight() + 2 * AchievementRewardInfoBox.PADDING.y;
            this.setTexture(InfoBox.getTextureForSize(width, height));
            var extraMove = IS_MOBILE ? 20 : 0;
            this.x = mousePos.x + width / 2 + extraMove;
            this.y = mousePos.y + height / 2 + extraMove;
            this.floatTimer.update(this.delta);
        }
        else {
            this.setVisible(false);
            this.floatTimer.reset();
        }
    };
    AchievementRewardInfoBox.PADDING = vec2(8, 4);
    return AchievementRewardInfoBox;
}(Sprite));
var ACHIEVEMENTS = {
    'PlayFiveGames': requireType({
        description: 'Play 5 games',
        rewardIconBase: 'achievements/playfivegames',
        rewardObjectFactory: function () { return getRewardItem(14); },
        completeProgress: 5,
        secret: false,
    }),
    'WinGame': requireType({
        description: 'Win your first game',
        rewardIconBase: 'achievements/wingame',
        rewardObjectFactory: function () { return getRewardBall(25); },
        completeProgress: 1,
        secret: false,
    }),
    'StrongBall': requireType({
        description: 'Have a ball with at least [r]15<sword>[/r] [g]15<heart>[/g]',
        rewardIconBase: 'achievements/strongball',
        rewardObjectFactory: function () { return getRewardBall(24); },
        completeProgress: 1,
        secret: false,
    }),
    'RoundsInARow': requireType({
        description: 'Win 3 rounds in a row',
        rewardIconBase: 'achievements/roundsinarow',
        rewardObjectFactory: function () { return getRewardItem(17); },
        completeProgress: 3,
        secret: false,
    }),
    'HaveTwentyGold': requireType({
        description: 'Have at least 20 gold at once',
        rewardIconBase: 'achievements/havetwentygold',
        rewardObjectFactory: function () { return getRewardItem(20); },
        completeProgress: 20,
        secret: false,
    }),
    'ReachRoundTwelve': requireType({
        description: 'Reach Round 12',
        rewardIconBase: 'achievements/reachroundtwelve',
        rewardObjectFactory: function () { return getRewardBall(34); },
        completeProgress: 12,
        secret: false,
    }),
    'PlayHundredRounds': requireType({
        description: 'Play 100 rounds',
        rewardIconBase: 'achievements/playhundredrounds',
        rewardObjectFactory: function () { return getRewardItem(24); },
        completeProgress: 100,
        secret: false,
    }),
    'WinFiftyRounds': requireType({
        description: 'Win 50 rounds',
        rewardIconBase: 'achievements/winfiftyrounds',
        rewardObjectFactory: function () { return getRewardItem(23); },
        completeProgress: 50,
        secret: false,
    }),
    'VictoryWithTwoBalls': requireType({
        description: 'Win the final round with <lte>3 balls',
        rewardIconBase: 'achievements/victorywithtwoballs',
        rewardObjectFactory: function () { return getRewardBall(32); },
        completeProgress: 1,
        secret: false,
    }),
    'MakeFiveHundredPurchases': requireType({
        description: 'Make 500 shop purchases',
        rewardIconBase: 'achievements/makefivehundredpurchases',
        rewardObjectFactory: function () { return getRewardBall(35); },
        completeProgress: 500,
        secret: false,
    }),
    'CatEarsOnSquad': requireType({
        description: 'Equip cat ears on all five balls',
        rewardIconBase: 'achievements/catearsonsquad',
        rewardObjectFactory: function () { return getRewardBall(28, -3, 3); },
        completeProgress: 1,
        secret: false,
    }),
    'WinInTenMinutes': requireType({
        description: 'Win a game in 15 minutes or less',
        rewardIconBase: 'achievements/winintenminutes',
        rewardObjectFactory: function () { return getRewardItem(21); },
        completeProgress: 1,
        secret: false,
    }),
    'StrongSquad': requireType({
        description: 'Have all five balls with at least [r]7<sword>[/r] [g]7<heart>[/g]',
        rewardIconBase: 'achievements/strongsquad',
        rewardObjectFactory: function () { return getRewardItem(15); },
        completeProgress: 1,
        secret: false,
    }),
    'WinWithoutEquipment': requireType({
        description: 'Win a game without buying equipment',
        rewardIconBase: 'achievements/winwithoutequipment',
        rewardObjectFactory: function () { return getRewardBall(30); },
        completeProgress: 1,
        secret: false,
    }),
    'WinWithoutFreezing': requireType({
        description: 'Win a game without freezing anything\\ ',
        rewardIconBase: 'achievements/winwithoutfreezing',
        rewardObjectFactory: function () { return getRewardBall(39); },
        completeProgress: 1,
        secret: false,
    }),
    'DealDamage': requireType({
        description: 'Deal 1000 total damage',
        rewardIconBase: 'achievements/dealdamage',
        rewardObjectFactory: function () { return getRewardBall(43); },
        completeProgress: 1000,
        secret: false,
    }),
    'DefeatCrownedSquads': requireType({
        description: 'Defeat a\n[gold][offsetx -3]<crown>[/offsetx][/gold]Crowned squad',
        rewardIconBase: 'achievements/defeatcrownedsquads',
        rewardObjectFactory: function () { return getRewardItem(27); },
        completeProgress: 1,
        secret: false,
    }),
    'MidLevelBall': requireType({
        description: 'Have a ball at 4[gold]<star>[/gold] or greater',
        rewardIconBase: 'achievements/midlevelball',
        rewardObjectFactory: function () { return getRewardBall(49); },
        completeProgress: 1,
        secret: false,
    }),
    'HealHp': requireType({
        description: 'Heal a total of [g]100<heart>[/g]',
        rewardIconBase: 'achievements/healhp',
        rewardObjectFactory: function () { return getRewardBall(127); },
        completeProgress: 100,
        secret: false,
    }),
    'BallGoBrrr': requireType({
        description: 'Make a ball go at 250% speed',
        rewardIconBase: 'achievements/ballgobrrr',
        rewardObjectFactory: function () { return getRewardBall(110); },
        completeProgress: 250,
        secret: false,
    }),
    'SameBall': requireType({
        description: 'Win a round with 3 of the same ball',
        rewardIconBase: 'achievements/sameball',
        rewardObjectFactory: function () { return getRewardBall(116); },
        completeProgress: 1,
        secret: false,
    }),
    'SellCoin': requireType({
        description: 'Sell a Coin for 10 gold',
        rewardIconBase: 'achievements/sellcoin',
        rewardObjectFactory: function () { return getRewardItem(46); },
        completeProgress: 1,
        secret: false,
    }),
    'WinDaily': requireType({
        description: 'Win a Daily game',
        rewardIconBase: 'achievements/windaily',
        rewardObjectFactory: function () { return getRewardBall(139); },
        completeProgress: 1,
        secret: false,
    }),
    'DealBurnDamage': requireType({
        description: 'Burn enemies for 200 total damage',
        rewardIconBase: 'achievements/dealburndamage',
        rewardObjectFactory: function () { return getRewardBall(138); },
        completeProgress: 200,
        secret: false,
    }),
    'ShootProjectiles': requireType({
        description: 'Shoot 250 projectiles',
        rewardIconBase: 'achievements/shootprojectiles',
        rewardObjectFactory: function () { return getRewardItem(52); },
        completeProgress: 250,
        secret: false,
    }),
    'FiveRemainingBalls': requireType({
        description: 'Win a round with at least 5 balls left\\ ',
        rewardIconBase: 'achievements/fiveremainingballs',
        rewardObjectFactory: function () { return getRewardBall(137); },
        completeProgress: 1,
        secret: false,
    }),
    'CompleteBallmanacEntries': requireType({
        description: 'Win 20 entries in the Ballmanac',
        rewardIconBase: 'achievements/completeballmanacentries',
        rewardObjectFactory: function () { return getRewardBall(140); },
        completeProgress: 20,
        secret: false,
    }),
    'KillBeforeBattle': requireType({
        description: 'Kill an enemy before the battle starts',
        rewardIconBase: 'achievements/killbeforebattle',
        rewardObjectFactory: function () { return getRewardItem(55); },
        completeProgress: 1,
        secret: false,
    }),
    'KillEnemiesInRound': requireType({
        description: 'Kill 3 enemies with a single ball',
        rewardIconBase: 'achievements/killenemiesinround',
        rewardObjectFactory: function () { return getRewardBall(143); },
        completeProgress: 3,
        secret: false,
    }),
    'WinWeekly': requireType({
        description: 'Win a Weekly Shuffle game',
        rewardIconBase: 'achievements/winweekly',
        rewardObjectFactory: function () { return getRewardBall(52); },
        completeProgress: 1,
        secret: false,
    }),
    'ArgPart1': requireType({
        description: 'Break the game',
        rewardIconBase: 'achievements/argpart1',
        rewardObjectFactory: function () { return getRewardBall(42); },
        completeProgress: 1,
        secret: true,
    }),
    'B': requireType({
        description: 'Free the virus',
        rewardIconBase: 'achievements/b',
        rewardObjectFactory: function () {
            var r = getRewardSprite('achievements/b/1', '[m]_... . _ ._[/m]');
            r.effects.post.filters.push(new Effects.Filters.Glitch(4, 2, 4));
            return r;
        },
        completeProgress: 1,
        secret: true,
    }),
    'C': requireType({
        description: 'Beat the game',
        rewardIconBase: 'achievements/c',
        rewardObjectFactory: function () { return getRewardSprite('achievements/c/1', '[m]._ _[/m] / [m]_ .... .[/m] / [m]. _. _..[/m]\n[m]___ .._.[/m] / [m]_ .... .[/m]\n[m].__ ___ ._. ._.. _..[/m]'); },
        completeProgress: 1,
        secret: true,
    }),
    'CompleteTheBallmanac': requireType({
        description: 'Complete the Ballmanac',
        rewardIconBase: 'achievements/completetheballmanac',
        rewardObjectFactory: function () { return getRewardSprite('achievements/completetheballmanac/1', 'You did it!!!'); },
        completeProgress: 1,
        secret: true,
    }),
    'TimeOut': requireType({
        description: 'Time out',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'WinWithoutLosing': requireType({
        description: 'Win a game without losing a round',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'ReallyStrongBall': requireType({
        description: 'Have a ball with at least [r]50<sword>[/r] [g]50<heart>[/g]',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'HighLevelBall': requireType({
        description: 'Have a ball at 6[gold]<star>[/gold] or greater',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'DefeatLectvs': requireType({
        description: 'Defeat lectvs in Matchmaking',
        rewardIconBase: 'achievements/defeatlectvs',
        rewardObjectFactory: function () { return getRewardSprite('achievements/defeatlectvs/1', 'The developer of\nAuto Balls!'); },
        completeProgress: 1,
        secret: true,
    }),
    'DefeatMaterwelons': requireType({
        description: 'Defeat Materwelons in Matchmaking',
        rewardIconBase: 'achievements/defeatmaterwelons',
        rewardObjectFactory: function () { return getRewardSprite('achievements/defeatmaterwelons/1', 'The Community Bash Versus\nMode tournament winner!'); },
        completeProgress: 1,
        secret: true,
    }),
    'Useless': requireType({
        description: 'Useless! >:(',
        rewardIconBase: 'achievements/useless',
        rewardObjectFactory: function () { return getRewardSprite('achievements/useless/1', "Your Crown was replaced\nwith a useless ball..."); },
        completeProgress: 1,
        secret: true,
    }),
    'TonsOfBalls': requireType({
        description: 'Have 25 balls in battle at once',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'OneBall': requireType({
        description: 'Win the final round with one ball',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'CompleteVictoryLap': requireType({
        description: 'Complete a Victory Lap',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'CompleteTwoVictoryLaps': requireType({
        description: 'Complete 2 Victory Laps in one game',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'NoRestocks': requireType({
        description: 'Win a game without restocking the shop',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'NoLevelUp': requireType({
        description: 'Win a game without leveling up',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'NoSell': requireType({
        description: 'Win a game without selling',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'NoItems': requireType({
        description: 'Win a game without buying an item',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'DrawsInARow': requireType({
        description: 'Draw 3 rounds in a row',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 3,
        secret: true,
    }),
    'WinWithGlitchedBall': requireType({
        description: 'Win a game with the ?/? Glitched Ball',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'WinVSGame': requireType({
        description: 'Win a Versus Mode game',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'WinChallengeMode': requireType({
        description: 'Win a Challenge Mode game',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'WinBirthdayMode': requireType({
        description: 'Happy Birthday\nAuto Balls!',
        rewardIconBase: 'achievements/birthday',
        rewardObjectFactory: function () { return getRewardSprite('achievements/birthday/1', 'Happy Birthday!!'); },
        completeProgress: 1,
        secret: true,
    }),
    'PeaceWasNeverAnOption': requireType({
        description: 'Peace was never an option',
        rewardIconBase: 'achievements/peacewasneveranoption',
        rewardObjectFactory: function () { return getRewardSprite('achievements/peacewasneveranoption/1', "Win a game with Dove\nin your squad"); },
        completeProgress: 1,
        secret: true,
    }),
    'NoBallsDied': requireType({
        description: 'Win a round without losing a ball',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'WinFast': requireType({
        description: 'Win a round in 3 seconds',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'GetRevenge': requireType({
        description: 'Revenge!',
        rewardIconBase: 'achievements/getrevenge',
        rewardObjectFactory: function () { return getRewardSprite('achievements/getrevenge/1', "Win a round against a\nplayer who beat you in\nthe same game"); },
        completeProgress: 1,
        secret: true,
    }),
    'NumberOne': requireType({
        description: 'You Are Number One!',
        rewardIconBase: 'achievements/numberone',
        rewardObjectFactory: function () { return getRewardSprite('achievements/numberone/1', 'Place first overall\nin a Daily'); },
        completeProgress: 1,
        secret: true,
    }),
    'SellBall50': requireType({
        description: 'Sell a ball for 50 gold',
        rewardIconBase: 'achievements/secret',
        rewardObjectFactory: function () { return getRewardSprite('achievements/secret/1'); },
        completeProgress: 1,
        secret: true,
    }),
    'BugSquad': requireType({
        description: 'Bug your entire squad',
        rewardIconBase: 'achievements/bugsquad',
        rewardObjectFactory: function () { return getRewardSprite('achievements/bugsquad/1'); },
        completeProgress: 1,
        secret: true,
    }),
};
var ACHIEVEMENTS_PROGRESS = {};
setNewAchievementsProgress();
function setNewAchievementsProgress() {
    ACHIEVEMENTS_PROGRESS = {};
    for (var ach in ACHIEVEMENTS) {
        ACHIEVEMENTS_PROGRESS[ach] = 0;
    }
}
function updateAchievementProgress(achievement, update) {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    if (!(achievement in ACHIEVEMENTS))
        return;
    ACHIEVEMENTS_PROGRESS[achievement] = update(ACHIEVEMENTS_PROGRESS[achievement]);
    saveAchievementsProgress();
}
function grantAchievement(achievement) {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    if (!(achievement in ACHIEVEMENTS))
        return;
    if (hasCompletedAchievement(achievement))
        return;
    ACHIEVEMENTS_PROGRESS[achievement] = ACHIEVEMENTS[achievement].completeProgress;
    saveAchievementsProgress();
}
function hasCompletedAchievement(achievement) {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    return ACHIEVEMENTS_PROGRESS[achievement] >= ACHIEVEMENTS[achievement].completeProgress;
}
function getAchievementsCompleteCount() {
    var completeCount = 0;
    var secretCompleteCount = 0;
    for (var ach in ACHIEVEMENTS) {
        if (hasCompletedAchievement(ach)) {
            if (ACHIEVEMENTS[ach].secret)
                secretCompleteCount++;
            else
                completeCount++;
        }
    }
    return { completeCount: completeCount, secretCompleteCount: secretCompleteCount };
}
function getAchievementsCount() {
    var count = Object.keys(ACHIEVEMENTS).filter(function (ach) { return !ACHIEVEMENTS[ach].secret; }).length;
    var secretCount = Object.keys(ACHIEVEMENTS).filter(function (ach) { return ACHIEVEMENTS[ach].secret; }).length;
    return { count: count, secretCount: secretCount };
}
function clearAchievements() {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    for (var achievement in ACHIEVEMENTS) {
        ACHIEVEMENTS_PROGRESS[achievement] = 0;
    }
    saveAchievementsProgress();
}
function unlockAllAchievements(includeSecret) {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    for (var achievement in ACHIEVEMENTS) {
        if (ACHIEVEMENTS[achievement].secret && !includeSecret)
            continue;
        ACHIEVEMENTS_PROGRESS[achievement] = Math.max(ACHIEVEMENTS_PROGRESS[achievement], ACHIEVEMENTS[achievement].completeProgress);
    }
    saveAchievementsProgress();
}
function saveAchievementsProgress() {
    LocalStorage.setString(global.gameCodeName + "_ach", btoa(JSON.stringify(ACHIEVEMENTS_PROGRESS)));
}
function loadAchievementsProgress() {
    if (!ACHIEVEMENTS_PROGRESS)
        setNewAchievementsProgress();
    var achString = LocalStorage.getString(global.gameCodeName + "_ach");
    if (!achString)
        return;
    var achivementsProgress = JSON.parse(atob(achString));
    mergeAchievementsProgresses(achivementsProgress, ACHIEVEMENTS_PROGRESS);
}
function mergeAchievementsProgressAndSave(progress) {
    mergeAchievementsProgresses(progress, ACHIEVEMENTS_PROGRESS);
    saveAchievementsProgress();
}
function mergeAchievementsProgresses(progress, into) {
    if (!progress || !_.isObject(progress) || Object.keys(progress).some(function (ach) { return !_.isNumber(progress[ach]); })) {
        return;
    }
    for (var ach in progress) {
        if (!_.isNumber(progress[ach]))
            continue;
        var currentProgress = into[ach] || 0;
        into[ach] = Math.max(currentProgress, progress[ach]);
    }
}
function getRewardBall(type, x, y) {
    if (x === void 0) { x = 0; }
    if (y === void 0) { y = 0; }
    var ball = squadBallToWorldBall({
        x: x, y: y,
        properties: {
            type: type,
            health: 1,
            damage: 1,
            equipment: -1,
            level: 1,
            metadata: {},
        }
    }, undefined, -1, 'friend');
    ball.hideAllStats();
    ball.layer = World.DEFAULT_LAYER;
    ball.physicsGroup = undefined;
    ball.isInShop = true;
    return ball;
}
function getRewardItem(type) {
    var item = itemTypeToBallItem(type, 0, 0);
    item.layer = World.DEFAULT_LAYER;
    return item;
}
function getRewardSprite(texture, desc) {
    return new Sprite({
        texture: texture,
        layer: World.DEFAULT_LAYER,
        bounds: new CircleBounds(0, 0, 10),
        tags: ['reward', 'secret'],
        data: { desc: desc },
    });
}
function updateInGameUpdateAchievements(world) {
    if (!youArePlaying(world))
        return;
    var friendlyBalls = world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend' && !ball.isInShop; });
    if (friendlyBalls.some(function (ball) { return ball.dmg >= 15 && ball.hp >= 15; }) && !hasCompletedAchievement('StrongBall')) {
        updateAchievementProgress('StrongBall', function (p) { return 1; });
    }
    if (friendlyBalls.some(function (ball) { return ball.dmg >= 50 && ball.hp >= 50; }) && !hasCompletedAchievement('ReallyStrongBall')) {
        updateAchievementProgress('ReallyStrongBall', function (p) { return 1; });
    }
    if (GAME_DATA.gold && isFinite(GAME_DATA.gold)) {
        updateAchievementProgress('HaveTwentyGold', function (p) { return Math.max(p, GAME_DATA.gold); });
    }
    if (friendlyBalls.filter(function (ball) { return ball.equipment && ball.equipment instanceof Equipments.CatEars; }).length >= 5 && !hasCompletedAchievement('CatEarsOnSquad')) {
        updateAchievementProgress('CatEarsOnSquad', function (p) { return 1; });
    }
    if (friendlyBalls.filter(function (ball) { return ball.dmg >= 7 && ball.hp >= 7; }).length >= 5 && !hasCompletedAchievement('StrongSquad')) {
        updateAchievementProgress('StrongSquad', function (p) { return 1; });
    }
    if (friendlyBalls.some(function (ball) { return ball.level >= 5; }) && !hasCompletedAchievement('MidLevelBall')) {
        updateAchievementProgress('MidLevelBall', function (p) { return 1; });
    }
    if (friendlyBalls.some(function (ball) { return ball.level >= 7; }) && !hasCompletedAchievement('HighLevelBall')) {
        updateAchievementProgress('HighLevelBall', function (p) { return 1; });
    }
    if (friendlyBalls.length >= 25 && !hasCompletedAchievement('TonsOfBalls')) {
        updateAchievementProgress('TonsOfBalls', function (p) { return 1; });
    }
    var maxEnemiesKilled = M.max(friendlyBalls, function (ball) { return ball.timesKilledEnemy; });
    if (maxEnemiesKilled && isFinite(maxEnemiesKilled))
        updateAchievementProgress('KillEnemiesInRound', function (p) { return Math.max(p, maxEnemiesKilled); });
    var maxMaxSpeed = M.max(friendlyBalls, function (ball) { return ball.getBoostMaxSpeedMultiplier(); });
    if (maxMaxSpeed && isFinite(maxMaxSpeed))
        updateAchievementProgress('BallGoBrrr', function (p) { return Math.max(p, 100 * maxMaxSpeed); });
    var almanacEntriesCompleted = getAlmanacEntriesCompleted();
    if (almanacEntriesCompleted && isFinite(almanacEntriesCompleted)) {
        updateAchievementProgress('CompleteBallmanacEntries', function (p) { return Math.max(p, getAlmanacEntriesCompleted()); });
    }
    if (isAlmanacComplete()) {
        updateAchievementProgress('CompleteTheBallmanac', function (p) { return 1; });
    }
}
ACHIEVEMENTS.C.description = "Play the sequel";
var ShopActions;
(function (ShopActions) {
    function buyBall(ball) {
        if (ball.frozen) {
            ball.world.playSound('unfreeze');
            ball.unfreeze();
        }
        GAME_DATA.gold -= ball.getShopCost();
        GAME_DATA.squad.balls.push({
            x: ball.x,
            y: ball.y,
            properties: ball.properties,
        });
        ball.squad = GAME_DATA.squad;
        ball.squadIndexReference = GAME_DATA.squad.balls.length - 1;
        ball.isInShop = false;
        ball.addTag(Tags.PURCHASED_THIS_SHOP_PHASE);
        ball.removeShine();
        ball.removeFromParentKeepWorldPosition();
        ball.world.playSound('buyball');
        ball.queueAbilities('onBuy');
        updateAchievementProgress('MakeFiveHundredPurchases', function (p) { return p + 1; });
        if (GAME_DATA.round === 1 && GAME_MODE === 'mm' && !DAILY && !IS_MOBILE && ball instanceof Balls.Zombie) {
            GAME_DATA.argTrigger.zombie = true;
        }
        if (ball.properties.type === 127) {
            GAME_DATA.hasPurchasedDove = true;
        }
    }
    ShopActions.buyBall = buyBall;
    function levelUpBall(ball, withBall) {
        var e_73, _a;
        if (ball.squadIndexReference < 0 || ball.squadIndexReference >= GAME_DATA.squad.balls.length) {
            console.error('Invalid ball squad index for level up:', ball.squadIndexReference);
            return;
        }
        if (withBall.squadIndexReference < 0 || withBall.squadIndexReference >= GAME_DATA.squad.balls.length) {
            console.error('Invalid withBall squad index for level up:', withBall.squadIndexReference);
            return;
        }
        var rootSquadIndex = withBall.squadIndexReference;
        var balls = ball.world.select.typeAll(Ball);
        try {
            for (var balls_1 = __values(balls), balls_1_1 = balls_1.next(); !balls_1_1.done; balls_1_1 = balls_1.next()) {
                var b = balls_1_1.value;
                if (b.squadIndexReference > rootSquadIndex)
                    b.squadIndexReference--;
            }
        }
        catch (e_73_1) { e_73 = { error: e_73_1 }; }
        finally {
            try {
                if (balls_1_1 && !balls_1_1.done && (_a = balls_1.return)) _a.call(balls_1);
            }
            finally { if (e_73) throw e_73.error; }
        }
        GAME_DATA.squad.balls.splice(rootSquadIndex, 1);
        withBall.kill();
        ball.levelUp(withBall.properties);
        GAME_DATA.hasLeveledUp = true;
    }
    ShopActions.levelUpBall = levelUpBall;
    function sellBall(ball) {
        if (ball.squadIndexReference < 0 || ball.squadIndexReference >= GAME_DATA.squad.balls.length) {
            console.error('Invalid ball squad index for sell:', ball.squadIndexReference);
            return;
        }
        removeBallFromSquad(ball);
        ball.world.addWorldObject(newPuff(ball.x, ball.y, Battle.Layers.ui, 'medium'));
        ball.world.playSound('sellball');
        GAME_DATA.hasSold = true;
        if (ball instanceof Balls.Coin && ball.getSellValue() >= 10) {
            updateAchievementProgress('SellCoin', function (p) { return p + 1; });
        }
        if (ball.getSellValue() >= 50) {
            updateAchievementProgress('SellBall50', function (p) { return p + 1; });
        }
        GAME_DATA.gold += ball.getSellValue();
        ball.properties.metadata.extraSellValue = 0;
        ball.queueAbilities('onSell');
        ball.kill();
    }
    ShopActions.sellBall = sellBall;
    function removeBallFromSquad(ball) {
        var e_74, _a;
        if (ball.squadIndexReference < 0 || ball.squadIndexReference >= GAME_DATA.squad.balls.length) {
            console.error('Invalid ball squad index for removal:', ball.squadIndexReference);
            return;
        }
        var rootSquadIndex = ball.squadIndexReference;
        var balls = ball.world.select.typeAll(Ball);
        try {
            for (var balls_2 = __values(balls), balls_2_1 = balls_2.next(); !balls_2_1.done; balls_2_1 = balls_2.next()) {
                var b = balls_2_1.value;
                if (b.squadIndexReference > rootSquadIndex)
                    b.squadIndexReference--;
            }
        }
        catch (e_74_1) { e_74 = { error: e_74_1 }; }
        finally {
            try {
                if (balls_2_1 && !balls_2_1.done && (_a = balls_2.return)) _a.call(balls_2);
            }
            finally { if (e_74) throw e_74.error; }
        }
        GAME_DATA.squad.balls.splice(rootSquadIndex, 1);
    }
    ShopActions.removeBallFromSquad = removeBallFromSquad;
    function buyBallItem(item, targetBall) {
        if (item.frozen) {
            item.world.playSound('unfreeze');
            item.unfreeze();
        }
        var cost = item.getShopCost();
        GAME_DATA.gold -= cost;
        targetBall.useItem(item);
        item.addTag(Tags.PURCHASED_THIS_SHOP_PHASE);
        item.world.playSound('buyball');
        item.kill();
        if (item.getType() === 'Equipment' && cost > 0) {
            GAME_DATA.hasBoughtEquipment = true;
            GAME_DATA.hasBoughtItem = true;
        }
        if (item.getType() === 'Item') {
            addItemTypeForAlmanacWin(item.type);
            GAME_DATA.hasBoughtItem = true;
        }
        updateAchievementProgress('MakeFiveHundredPurchases', function (p) { return p + 1; });
    }
    ShopActions.buyBallItem = buyBallItem;
})(ShopActions || (ShopActions = {}));
var AddBlueFilter = /** @class */ (function (_super) {
    __extends(AddBlueFilter, _super);
    function AddBlueFilter(amount) {
        var _this = _super.call(this, {
            uniforms: { 'float amount': amount },
            code: "\n                outp.rgb = inp.rgb + amount * vec3(0.0, 0.2, 0.4);\n            "
        }) || this;
        _this._amount = amount;
        return _this;
    }
    Object.defineProperty(AddBlueFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (v) {
            if (this._amount === v)
                return;
            this._amount = v;
            this.setUniform('amount', M.clamp(v, 0, Infinity));
        },
        enumerable: false,
        configurable: true
    });
    return AddBlueFilter;
}(TextureFilter));
var ALMANAC_ENTRIES = {
    balls: {},
    items: {},
};
var ALMANAC_EXCLUDED_BALLS = [
    0,
    20,
    31,
    41,
    77,
    142,
];
var ALMANAC_EXCLUDED_ITEMS = [
    16,
    25,
    32,
    38,
    39,
];
function getAlmanacDisplayedBallTypes(pack, weekly) {
    var ballTypeList = getAllBallTypesForPack(pack, weekly).filter(function (type) {
        if (_.contains(ALMANAC_EXCLUDED_BALLS, type))
            return false;
        if (type === 42 && !isBallTypeUnlocked(42))
            return false; // Glitched Ball
        return true;
    });
    A.sort(ballTypeList, function (type) { return TYPE_TO_BALL_TYPE_DEF[type].tier; });
    return ballTypeList;
}
function getAlmanacDisplayedItemTypes() {
    var itemTypeList = Object.keys(TYPE_TO_ITEM_TYPE_DEF).map(function (type) { return parseInt(type); }).filter(function (type) {
        if (_.contains(ALMANAC_EXCLUDED_ITEMS, type))
            return false;
        return true;
    });
    A.sort(itemTypeList, function (type) { return TYPE_TO_ITEM_TYPE_DEF[type].tier; });
    return itemTypeList;
}
function clearAlmanacEntries() {
    ALMANAC_ENTRIES = {
        balls: {},
        items: {},
    };
    saveAlmanacEntries();
}
function seeAllAlmanacEntries() {
    for (var type in TYPE_TO_BALL_TYPE_DEF) {
        seeAlmanacBall(type);
    }
    for (var type in TYPE_TO_ITEM_TYPE_DEF) {
        seeAlmanacItem(type);
    }
}
function winAllAlmanacEntries() {
    for (var type in TYPE_TO_BALL_TYPE_DEF) {
        addAlmanacBallWin(type);
    }
    for (var type in TYPE_TO_ITEM_TYPE_DEF) {
        addAlmanacItemWin(type);
    }
}
function restoreCompleteAlmanac() {
    for (var type in TYPE_TO_BALL_TYPE_DEF) {
        if (getAlmanacBallEntry(type).wins > 0)
            continue;
        addAlmanacBallWin(type);
    }
    for (var type in TYPE_TO_ITEM_TYPE_DEF) {
        if (getAlmanacItemEntry(type).wins > 0)
            continue;
        addAlmanacItemWin(type);
    }
    updateAchievementProgress('CompleteTheBallmanac', function (p) { return 1; });
    saveSeenAlmanacComplete(true);
}
function setAllAlmanacEntriesRandom() {
    clearAlmanacEntries();
    var weights = [0.2, 0.4, 0.25, 0.1, 0.05];
    for (var type in TYPE_TO_BALL_TYPE_DEF) {
        var entry = getAlmanacBallEntry(type);
        entry.wins = Random.elementWeighted([-1, 0, 1, 2, 3], weights);
    }
    for (var type in TYPE_TO_ITEM_TYPE_DEF) {
        var entry = getAlmanacItemEntry(type);
        entry.wins = Random.elementWeighted([-1, 0, 1, 2, 3], weights);
    }
    saveAlmanacEntries();
}
function getAlmanacBallEntry(ballType, from) {
    if (from === void 0) { from = ALMANAC_ENTRIES; }
    if (!(ballType in from.balls)) {
        from.balls[ballType] = {
            wins: -1,
        };
    }
    return from.balls[ballType];
}
function getAlmanacItemEntry(itemType, from) {
    if (from === void 0) { from = ALMANAC_ENTRIES; }
    if (!(itemType in from.items)) {
        from.items[itemType] = {
            wins: -1,
        };
    }
    return from.items[itemType];
}
function seeAlmanacBall(ballType) {
    var entry = getAlmanacBallEntry(ballType);
    if (entry.wins < 0)
        entry.wins = 0;
    saveAlmanacEntries();
}
function seeAlmanacItem(itemType) {
    var entry = getAlmanacItemEntry(itemType);
    if (entry.wins < 0)
        entry.wins = 0;
    saveAlmanacEntries();
}
function hasSeenAlmanacBall(ballType) {
    return getAlmanacBallEntry(ballType).wins >= 0;
}
function hasSeenAlmanacItem(itemType) {
    return getAlmanacItemEntry(itemType).wins >= 0;
}
function addAlmanacBallWin(ballType) {
    seeAlmanacBall(ballType);
    getAlmanacBallEntry(ballType).wins++;
    saveAlmanacEntries();
}
function addAlmanacItemWin(itemType) {
    seeAlmanacItem(itemType);
    getAlmanacItemEntry(itemType).wins++;
    saveAlmanacEntries();
}
function getAlmanacBallWinCount(ballType) {
    var entry = getAlmanacBallEntry(ballType);
    return entry.wins >= 0 ? entry.wins : 0;
}
function getAlmanacItemWinCount(itemType) {
    var entry = getAlmanacItemEntry(itemType);
    return entry.wins >= 0 ? entry.wins : 0;
}
function getAlmanacEntriesCompleted() {
    var e_75, _a;
    var count = 0;
    try {
        for (var OFFICIAL_PACKS_1 = __values(OFFICIAL_PACKS), OFFICIAL_PACKS_1_1 = OFFICIAL_PACKS_1.next(); !OFFICIAL_PACKS_1_1.done; OFFICIAL_PACKS_1_1 = OFFICIAL_PACKS_1.next()) {
            var pack = OFFICIAL_PACKS_1_1.value;
            var ballTypes = getAlmanacDisplayedBallTypes(pack, undefined);
            var completedBallTypes = ballTypes.filter(function (type) { return getAlmanacBallWinCount(type) > 0; });
            count += completedBallTypes.length;
        }
    }
    catch (e_75_1) { e_75 = { error: e_75_1 }; }
    finally {
        try {
            if (OFFICIAL_PACKS_1_1 && !OFFICIAL_PACKS_1_1.done && (_a = OFFICIAL_PACKS_1.return)) _a.call(OFFICIAL_PACKS_1);
        }
        finally { if (e_75) throw e_75.error; }
    }
    var itemTypes = getAlmanacDisplayedItemTypes();
    var completedItemTypes = itemTypes.filter(function (type) { return getAlmanacItemWinCount(type) > 0; });
    count += completedItemTypes.length;
    return count;
}
function getAlmanacBallCompletionPercent(pack, weekly) {
    var ballTypes = getAlmanacDisplayedBallTypes(pack, weekly);
    var completedBallTypes = ballTypes.filter(function (type) { return getAlmanacBallWinCount(type) > 0; });
    return completedBallTypes.length / ballTypes.length;
}
function getAlmanacItemCompletionPercent() {
    var itemTypes = getAlmanacDisplayedItemTypes();
    var completedItemTypes = itemTypes.filter(function (type) { return getAlmanacItemWinCount(type) > 0; });
    return completedItemTypes.length / itemTypes.length;
}
function getAlmanacTotalCompletionPercent() {
    var e_76, _a, e_77, _b;
    var classicBallTypes = getAlmanacDisplayedBallTypes('classic', undefined);
    var communityBallTypes = getAlmanacDisplayedBallTypes('community', undefined);
    var itemTypes = getAlmanacDisplayedItemTypes();
    var seen = 0;
    var won = 0;
    var total = 0;
    try {
        for (var _c = __values(__spread(classicBallTypes, communityBallTypes)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var type = _d.value;
            if (hasSeenAlmanacBall(type))
                seen++;
            if (getAlmanacBallWinCount(type) > 0)
                won++;
            total++;
        }
    }
    catch (e_76_1) { e_76 = { error: e_76_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_76) throw e_76.error; }
    }
    try {
        for (var itemTypes_1 = __values(itemTypes), itemTypes_1_1 = itemTypes_1.next(); !itemTypes_1_1.done; itemTypes_1_1 = itemTypes_1.next()) {
            var type = itemTypes_1_1.value;
            if (hasSeenAlmanacItem(type))
                seen++;
            if (getAlmanacItemWinCount(type) > 0)
                won++;
            total++;
        }
    }
    catch (e_77_1) { e_77 = { error: e_77_1 }; }
    finally {
        try {
            if (itemTypes_1_1 && !itemTypes_1_1.done && (_b = itemTypes_1.return)) _b.call(itemTypes_1);
        }
        finally { if (e_77) throw e_77.error; }
    }
    return { seen: seen / total, won: won / total };
}
function isAlmanacComplete() {
    return getAlmanacTotalCompletionPercent().won >= 1;
}
function saveAlmanacEntries() {
    LocalStorage.setString(global.gameCodeName + "_almanac", btoa(JSON.stringify(ALMANAC_ENTRIES)));
}
function loadAlmanacEntries() {
    var almanacString = LocalStorage.getString(global.gameCodeName + "_almanac");
    if (!almanacString)
        return;
    var almanacEntries = JSON.parse(atob(almanacString));
    mergeAlmanacEntrieses(almanacEntries, ALMANAC_ENTRIES);
}
function mergeAlmanacEntriesAndSave(almanacEntries) {
    mergeAlmanacEntrieses(almanacEntries, ALMANAC_ENTRIES);
    saveAlmanacEntries();
}
function mergeAlmanacEntrieses(almanacEntries, into) {
    if (!almanacEntries || !_.isObject(almanacEntries) || !_.isObject(almanacEntries.balls) || !_.isObject(almanacEntries.items)) {
        return;
    }
    for (var type in almanacEntries.balls) {
        if (!_.isObject(almanacEntries.balls[type]) || !_.isNumber(almanacEntries.balls[type].wins))
            continue;
        var entry = getAlmanacBallEntry(type, into);
        entry.wins = Math.max(entry.wins, almanacEntries.balls[type].wins);
    }
    for (var type in almanacEntries.items) {
        if (!_.isObject(almanacEntries.items[type]) || !_.isNumber(almanacEntries.items[type].wins))
            continue;
        var entry = getAlmanacItemEntry(type, into);
        entry.wins = Math.max(entry.wins, almanacEntries.items[type].wins);
    }
}
function updateAlmanacEntriesSeen(world) {
    var e_78, _a, e_79, _b, e_80, _c;
    if (!youArePlaying(world))
        return;
    var balls = world.select.typeAll(Ball);
    try {
        for (var balls_3 = __values(balls), balls_3_1 = balls_3.next(); !balls_3_1.done; balls_3_1 = balls_3.next()) {
            var ball = balls_3_1.value;
            seeAlmanacBall(ball.properties.type);
        }
    }
    catch (e_78_1) { e_78 = { error: e_78_1 }; }
    finally {
        try {
            if (balls_3_1 && !balls_3_1.done && (_a = balls_3.return)) _a.call(balls_3);
        }
        finally { if (e_78) throw e_78.error; }
    }
    var items = world.select.typeAll(BallItem);
    try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            seeAlmanacItem(item.type);
        }
    }
    catch (e_79_1) { e_79 = { error: e_79_1 }; }
    finally {
        try {
            if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
        }
        finally { if (e_79) throw e_79.error; }
    }
    var equipments = world.select.typeAll(Equipment);
    try {
        for (var equipments_1 = __values(equipments), equipments_1_1 = equipments_1.next(); !equipments_1_1.done; equipments_1_1 = equipments_1.next()) {
            var equipment = equipments_1_1.value;
            seeAlmanacItem(getItemTypeForEquipmentType(equipment.equipmentType));
        }
    }
    catch (e_80_1) { e_80 = { error: e_80_1 }; }
    finally {
        try {
            if (equipments_1_1 && !equipments_1_1.done && (_c = equipments_1.return)) _c.call(equipments_1);
        }
        finally { if (e_80) throw e_80.error; }
    }
}
var API;
(function (API) {
    API.VISIBLE_CORE_VERSION = 1;
    API.VISIBLE_MAJOR_VERSION = 4;
    API.VISIBLE_MINOR_VERSION = 2;
    API.VERSION = 29;
    API.BREAKING_VERSIONS = [24, 25, 26, 29]; // Versions which include non-backward compatible changes, e.g. new balls, tier change
    API.BETA = false;
    API.B = 2000;
    API.ERROR_NO_SQUAD_RECEIVED = "No squad received";
    function getFormattedVersion() {
        return API.VISIBLE_CORE_VERSION + "." + API.VISIBLE_MAJOR_VERSION + "." + API.VISIBLE_MINOR_VERSION;
    }
    API.getFormattedVersion = getFormattedVersion;
    function cmpFormattedVersions(version1, version2) {
        var split1 = version1.split('.');
        var _a = __read(split1.map(function (s) { return parseInt(s); }), 3), coreVersion1 = _a[0], majorVersion1 = _a[1], minorVersion1 = _a[2];
        var split2 = version2.split('.');
        var _b = __read(split2.map(function (s) { return parseInt(s); }), 3), coreVersion2 = _b[0], majorVersion2 = _b[1], minorVersion2 = _b[2];
        if (coreVersion1 < coreVersion2)
            return -1;
        if (coreVersion1 > coreVersion2)
            return 1;
        if (majorVersion1 < majorVersion2)
            return -1;
        if (majorVersion1 > majorVersion2)
            return 1;
        if (minorVersion1 < minorVersion2)
            return -1;
        if (minorVersion1 > minorVersion2)
            return 1;
        return 0;
    }
    API.cmpFormattedVersions = cmpFormattedVersions;
    /* API */
    "modded_remove_from";
    API.submitsquad = throttledFunction("submitsquad", 5000, function (callback, player, round, squad, gameId, profileId, lap, offlineCount, arena, packs, apiVersion, dailyDay, week) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submitsquad&player=" + player + "&round=" + round + "&squad=" + encodeURIComponent(St.encodeB64S(JSON.stringify(squad))) + "&version=" + apiVersion + "&gameId=" + gameId + "&profileId=" + profileId + "&lap=" + lap + "&offlineCount=" + offlineCount + "&arena=" + arena + "&packs=" + packs.join(',') + "&beta=" + API.BETA + "&dailyDay=" + dailyDay + "&week=" + week, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    "modded_remove_to";
    API.getsquad = throttledFunction("getsquad", 3000, function (callback, player, round, allowProfane, bannedBallTypes, lap, arena, packs, week) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=getsquad&player=" + player + "&round=" + round + "&allowProfane=" + allowProfane + "&version=" + API.VERSION + "&bannedBallTypes=" + bannedBallTypes.join(',') + "&lap=" + lap + "&onlyWinningSquads=" + CHALLENGE_MODE_ENABLED + "&arena=" + arena + "&packs=" + packs.join(',') + "&beta=" + API.BETA + "&week=" + week, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['squad']) {
                callback(undefined, API.ERROR_NO_SQUAD_RECEIVED);
            }
            else {
                callback({ squad: responseJson['squad'], version: responseJson['version'], gameResult: responseJson['gameResult'], arena: responseJson['arena'] }, undefined);
            }
        });
    });
    API.getsquadforgame = throttledFunction("getsquadforgame", 500, function (callback, gameid, round) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=getsquadforgame&gameid=" + gameid + "&round=" + round, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['squad']) {
                callback(undefined, API.ERROR_NO_SQUAD_RECEIVED);
            }
            else {
                callback({ squad: responseJson['squad'], version: responseJson['version'], gameResult: responseJson['gameResult'], arena: responseJson['arena'] }, undefined);
            }
        });
    });
    API.share = throttledFunction("share", 5000, function (callback, player, gameId, round, result, imageData) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=share&player=" + player + "&gameId=" + gameId + "&round=" + round + "&result=" + result + "&version=" + API.VERSION, imageData, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['url']) {
                callback(undefined, "No url received");
            }
            else {
                callback(responseJson['url'], undefined);
            }
        });
    });
    "modded_remove_from";
    API.submitgameresults = throttledFunction("submitgameresults", 5000, function (callback, gameId, roundResults, gameResult, profileId, packs) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submitgameresults&gameId=" + gameId + "&roundResults=" + encodeURIComponent(JSON.stringify(roundResults)) + "&gameResult=" + gameResult + "&version=" + API.VERSION + "&profileId=" + profileId + "&packs=" + packs.join(',') + "&beta=" + API.BETA, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    "modded_remove_to";
    API.getliveversion = throttledFunction("getliveversion", 1000, function (callback) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=getliveversion", null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['versions']) {
                callback(undefined, "No versions received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    API.createvsgame = throttledFunction("createvsgame", 5000, function (callback, player, lives, allowedBallTypes, allowedItemTypes, frameTime, profileId, startRound, startGameGold, startRoundGold, maxSquadSize, timeLimit, speedCap, arena, hostPacks, nonhostPacks) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=createvsgame&player=" + player + "&version=" + API.VERSION + "&lives=" + lives + "&allowedBallTypes=" + allowedBallTypes.join(',') + "&allowedItemTypes=" + allowedItemTypes.join(',') + "&frameTime=" + frameTime + "&profileId=" + profileId + "&startRound=" + startRound + "&startGameGold=" + startGameGold + "&startRoundGold=" + startRoundGold + "&maxSquadSize=" + maxSquadSize + "&timeLimit=" + timeLimit + "&speedCap=" + speedCap + "&arena=" + arena + "&hostPacks=" + hostPacks.join(',') + "&nonhostPacks=" + nonhostPacks.join(','), null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['gameid']) {
                callback(undefined, "No gameid received");
            }
            else {
                callback(responseJson['gameid'], undefined);
            }
        });
    });
    API.joinvsgame = throttledFunction("joinvsgame", 1000, function (callback, gameid, player, allowedBallTypes, allowedItemTypes, frameTime, profileId) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=joinvsgame&gameid=" + gameid + "&player=" + player + "&version=" + API.VERSION + "&allowedBallTypes=" + allowedBallTypes.join(',') + "&allowedItemTypes=" + allowedItemTypes.join(',') + "&frameTime=" + frameTime + "&profileId=" + profileId, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    API.getvsgame = throttledFunction("getvsgame", 1000, function (callback, gameid, player, spectate, getLastSquads, profileId) {
        httpRequestWithFallback(CONTINUOUS_LAMBDA_URL, FALLBACK_CONTINUOUS_LAMBDA_URL, "?operation=getvsgame&gameid=" + gameid + "&player=" + player + "&spectate=" + spectate + "&getLastSquads=" + getLastSquads + "&profileId=" + profileId + "&version=" + API.VERSION, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['game']) {
                callback(undefined, "No game received");
            }
            else {
                callback(responseJson['game'], undefined);
            }
        });
    });
    API.submitvssquad = throttledFunction("submitvssquad", 1500, function (callback, gameid, player, round, squad, profileId) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submitvssquad&gameid=" + gameid + "&player=" + player + "&round=" + round + "&squad=" + encodeURIComponent(St.encodeB64S(JSON.stringify(squad))) + "&version=" + API.VERSION + "&profileId=" + profileId, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    API.submitvsgameresult = throttledFunction("submitvsgameresult", 1500, function (callback, gameid, player, round, hostresult, hostprotected, nonhostprotected, profileId) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submitvsgameresult&gameid=" + gameid + "&player=" + player + "&round=" + round + "&hostresult=" + hostresult + "&hostprotected=" + hostprotected + "&nonhostprotected=" + nonhostprotected + "&version=" + API.VERSION + "&profileId=" + profileId, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    "modded_remove_from";
    API.submiterror = throttledFunction("submiterror", 5000, function (callback, profileId, err) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submiterror&profileId=" + profileId + "&version=" + API.VERSION + "&error=" + encodeURIComponent(err), null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    "modded_remove_to";
    "modded_remove_from";
    API.createsave = throttledFunction("createsave", 10000, function (callback, saveData, player, profileId) {
        httpRequestWithFallback(SAVES_LAMBDA_URL, FALLBACK_SAVES_LAMBDA_URL, "?operation=createsave&game=" + global.gameCodeName + "&playerId=" + player + "&profileId=" + profileId + "&version=" + API.VERSION, saveData, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['id'] || !responseJson['saveTime']) {
                callback(undefined, "No save id or saveTime received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    API.save = throttledFunction("save", 1000, function (callback, id, saveData, player, profileId) {
        httpRequestWithFallback(SAVES_LAMBDA_URL, FALLBACK_SAVES_LAMBDA_URL, "?operation=save&game=" + global.gameCodeName + "&id=" + id + "&playerId=" + player + "&profileId=" + profileId + "&version=" + API.VERSION, saveData, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['saveTime']) {
                callback(undefined, "No save time received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    API.getsave = throttledFunction("getsave", 0, function (callback, id, profileId) {
        httpRequestWithFallback(SAVES_LAMBDA_URL, FALLBACK_SAVES_LAMBDA_URL, "?operation=getsave&game=" + global.gameCodeName + "&id=" + id + "&profileId=" + profileId + "&version=" + API.VERSION, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson['saveData'] || !responseJson['saveTime']) {
                callback(undefined, "No saveData received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    "modded_remove_to";
    "modded_remove_from";
    API.getdaily = throttledFunction("getdaily", 800, function (callback, relativeDay, profileId, playerId, allowProfane) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=getdaily&relativeDay=" + relativeDay + "&profileId=" + profileId + "&playerId=" + playerId + "&allowProfane=" + allowProfane, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson) {
                callback(undefined, "No daily received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    API.submitdailyresults = throttledFunction("submitdailyresults", 5000, function (callback, day, player, profileId, playerId, gameId, wins, health, rounds, time, squad) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=submitdailyresults&day=" + day + "&player=" + player + "&profileId=" + profileId + "&playerId=" + playerId + "&gameId=" + gameId + "&wins=" + wins + "&health=" + health + "&rounds=" + rounds + "&time=" + time + "&squad=" + encodeURIComponent(St.encodeB64S(JSON.stringify(squad))) + "&version=" + API.VERSION, null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson || !responseJson.result) {
                callback(undefined, "submitdaily response not received");
            }
            else {
                callback(undefined, undefined);
            }
        });
    });
    API.startdaily = throttledFunction("startdaily", 5000, function (callback, day, profileId, playerId, player) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=startdaily&day=" + day + "&profileId=" + profileId + "&playerId=" + playerId + "&player=" + player, null, function (responseJson, err) {
            callback(undefined, err);
        });
    });
    "modded_remove_to";
    API.getweekly = throttledFunction("getweekly", 500, function (callback) {
        httpRequestWithFallback(LAMBDA_URL, FALLBACK_LAMBDA_URL, "?operation=getweekly", null, function (responseJson, err) {
            if (err) {
                callback(undefined, err);
            }
            else if (!responseJson) {
                callback(undefined, "No weekly received");
            }
            else {
                callback(responseJson, undefined);
            }
        });
    });
    var LAMBDA_URL = 'https://wtqurfsgwd.execute-api.us-east-2.amazonaws.com/default/autoballs';
    var CONTINUOUS_LAMBDA_URL = 'https://0wgyeeqc32.execute-api.us-east-2.amazonaws.com/default/autoballs-continuous';
    "modded_remove_from";
    var SAVES_LAMBDA_URL = 'https://ldqgz93mrh.execute-api.us-east-2.amazonaws.com/default/saves';
    "modded_remove_to";
    var FALLBACK_LAMBDA_URL = 'https://fp52xkawjg.execute-api.us-east-2.amazonaws.com/default/undefined';
    var FALLBACK_CONTINUOUS_LAMBDA_URL = 'https://5ftlkjp3rc.execute-api.us-east-2.amazonaws.com/default/undefined';
    "modded_remove_from";
    var FALLBACK_SAVES_LAMBDA_URL = 'https://62zs1zaui2.execute-api.us-east-2.amazonaws.com/default/saves-fallback';
    "modded_remove_to";
    function httpRequestWithFallback(baseUrl, fallbackUrl, restOfUrl, data, callback) {
        Network.httpRequest("" + baseUrl + restOfUrl, data, function (responseJson, err) {
            if (!responseJson && err === '') {
                Network.httpRequest("" + fallbackUrl + restOfUrl, data, callback);
            }
            else {
                callback(responseJson, err);
            }
        });
    }
    function throttledFunction(fnName, maxTimeMs, fn) {
        var lastTime = 0;
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            var time = Date.now();
            if (lastTime > 0 && time - lastTime < maxTimeMs) {
                params[0](undefined, "Throttled: " + fnName);
                return;
            }
            lastTime = time;
            /// @ts-ignore
            fn.apply(void 0, __spread(params));
        };
    }
})(API || (API = {}));
console.log("Auto Balls v" + API.getFormattedVersion() + (API.BETA ? ' BETA' : '') + " (API version " + API.VERSION + ")");
var ArenaBdayShadeFilter = /** @class */ (function (_super) {
    __extends(ArenaBdayShadeFilter, _super);
    function ArenaBdayShadeFilter() {
        var _this = _super.call(this, {
            uniforms: { 'float amount': 0 },
            code: "\n                float dx = x - width * 0.5;\n                float dy = y - height * 0.5;\n                float distance = sqrt(dx*dx + dy*dy);\n\n                float angle = atan(dy, dx) + distance * 0.01 - t * 0.2;\n\n                float radius = amount * (60.0 + 10.0 * pnoise(4.0 * cos(angle), 4.0 * sin(angle), 0.8));\n                float p = clamp(map(distance, 0.0, radius, 0.9, 0.0), 0.0, 0.9);\n\n                outp.rgb = lerp(outp.rgb, vec3(0.0, 0.0, 0.0), p);\n            "
        }) || this;
        _this._amount = 0;
        return _this;
    }
    Object.defineProperty(ArenaBdayShadeFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (v) {
            if (this._amount === v)
                return;
            this._amount = v;
            this.setUniform('amount', M.clamp(v, 0, Infinity));
        },
        enumerable: false,
        configurable: true
    });
    return ArenaBdayShadeFilter;
}(TextureFilter));
var ArenaFirstFilter = /** @class */ (function (_super) {
    __extends(ArenaFirstFilter, _super);
    function ArenaFirstFilter() {
        return _super.call(this, {
            code: "\n                if (x > 8.0 && x < width-9.0 && y > 8.0 && y < height-9.0 && inp.a > 0.0) {\n\n                    bool topLeft = convolute44(x, y, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0)\n                                || convolute44(x, y, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0)\n                                || convolute44(x, y, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);\n\n                    bool topRight = convolute44(x-3.0, y, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0)\n                                 || convolute44(x-3.0, y, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0)\n                                 || convolute44(x-3.0, y, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\n                    bool bottomLeft = convolute44(x, y-3.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)\n                                   || convolute44(x, y-3.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0)\n                                   || convolute44(x, y-3.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n                    bool bottomRight = convolute44(x-3.0, y-3.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)\n                                    || convolute44(x-3.0, y-3.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)\n                                    || convolute44(x-3.0, y-3.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n                    if (getColor(x-1.0, y).a > 0.0 && getColor(x+1.0, y).a > 0.0 && getColor(x, y-1.0).a > 0.0 && getColor(x, y+1.0).a > 0.0\n                            && (getColor(x-2.0, y).a == 0.0 || getColor(x+2.0, y).a == 0.0 || getColor(x, y-2.0).a == 0.0 || getColor(x, y+2.0).a == 0.0)) {\n                        outp.rgb = vec3(1.0, 1.0, 1.0);\n                    }\n\n                    if (topLeft || topRight || bottomLeft || bottomRight) {\n                        outp.rgb = vec3(1.0, 1.0, 1.0);\n                    }\n                }\n            "
        }) || this;
    }
    ArenaFirstFilter.load = function () {
        Texture.EFFECT_ONLY.renderTo(new BasicTexture(1, 1, 'ArenaFirstFilter.load'), { filters: [new ArenaFirstFilter()] });
    };
    return ArenaFirstFilter;
}(TextureFilter));
var ArenaShrink = /** @class */ (function (_super) {
    __extends(ArenaShrink, _super);
    function ArenaShrink() {
        var _this = _super.call(this, {
            layer: Battle.Layers.walls,
            physicsGroup: Battle.Layers.walls,
            immovable: true,
        }) || this;
        _this.maxPadX = 66;
        _this.maxPadY = 50;
        _this.bounds = _this.invertedBounds = new InvertedRectBounds(0, 0, global.gameWidth, global.gameHeight);
        return _this;
    }
    ArenaShrink.prototype.update = function () {
        _super.prototype.update.call(this);
        var p = 0;
        var battleTimer = this.world.select.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 45, 0, 1);
        }
        this.invertedBounds.x = M.lerp(0, this.maxPadX, p);
        this.invertedBounds.y = M.lerp(0, this.maxPadY, p);
        this.invertedBounds.width = M.lerp(global.gameWidth, global.gameWidth - 2 * this.maxPadX, p);
        this.invertedBounds.height = M.lerp(global.gameHeight, global.gameHeight - 2 * this.maxPadY, p);
    };
    ArenaShrink.prototype.render = function (texture, x, y) {
        var box = this.invertedBounds.getInnerBox();
        Draw.brush.color = 0x000000;
        Draw.brush.alpha = 1;
        Draw.rectangleSolid(texture, x, y, global.gameWidth, box.top);
        Draw.rectangleSolid(texture, x, y, box.left, global.gameHeight);
        Draw.rectangleSolid(texture, x + box.right, y, global.gameWidth - box.right, global.gameHeight);
        Draw.rectangleSolid(texture, x, y + box.bottom, global.gameWidth, global.gameHeight - box.bottom);
        _super.prototype.render.call(this, texture, x, y);
    };
    return ArenaShrink;
}(PhysicsWorldObject));
var ArenaShrinkBday = /** @class */ (function (_super) {
    __extends(ArenaShrinkBday, _super);
    function ArenaShrinkBday() {
        var _this = _super.call(this) || this;
        _this.playedBoom = false;
        _this.blackHole = _this.addChild(new CenterBlackHole(global.gameWidth / 2, global.gameHeight / 2, 0));
        return _this;
    }
    ArenaShrinkBday.prototype.update = function () {
        _super.prototype.update.call(this);
        var p = 0;
        var battleTimer = this.world.select.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 31, 0, 1);
            this.blackHole.gravityFactor = p <= 0 ? 0 : M.mapClamp(battleTimer.battleTime, 30, 45, 1, 2);
        }
        if (!this.playedBoom && p > 0.5) {
            this.world.playSound('dioboom');
            this.playedBoom = true;
        }
        var bg = this.world.select.name(Arenas.BG_NAME, false);
        if (bg) {
            var amountMod = M.lerp(0.95, 1, Tween.Easing.OscillateSine(2)(this.life.time));
            var bulgeFilter = bg.effects.post.filters.find(function (f) { return f instanceof BulgeFilter; });
            if (bulgeFilter) {
                bulgeFilter.bulgeAmount = M.lerp(0, 0.4 * amountMod, Tween.Easing.InOutElastic(1)(p));
            }
            var shadeFilter = bg.effects.post.filters.find(function (f) { return f instanceof ArenaBdayShadeFilter; });
            if (shadeFilter) {
                shadeFilter.amount = M.lerp(0, 1 * amountMod, Tween.Easing.InOutElastic(1)(p));
            }
        }
    };
    return ArenaShrinkBday;
}(WorldObject));
var ArenaShrinkFactory = /** @class */ (function (_super) {
    __extends(ArenaShrinkFactory, _super);
    function ArenaShrinkFactory(factoryPipeController, hourHand, minuteHand) {
        var _this = _super.call(this) || this;
        _this.factoryPipeController = factoryPipeController;
        _this.hourHand = hourHand;
        _this.minuteHand = minuteHand;
        return _this;
    }
    ArenaShrinkFactory.prototype.update = function () {
        _super.prototype.update.call(this);
        var p = 0;
        var battleTimer = this.world.select.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 45, 0, 1);
        }
        this.factoryPipeController.arenaShrinkFactor = p;
        this.hourHand.vangle = ArenaShrinkFactory.INITIAL_VANGLE_HOUR * M.lerp(1, 20, p);
        this.minuteHand.vangle = ArenaShrinkFactory.INITIAL_VANGLE_MINUTE * M.lerp(1, 8, p);
    };
    ArenaShrinkFactory.INITIAL_VANGLE_HOUR = 30;
    ArenaShrinkFactory.INITIAL_VANGLE_MINUTE = 30 * 12;
    return ArenaShrinkFactory;
}(PhysicsWorldObject));
var ArenaShrinkGravity = /** @class */ (function (_super) {
    __extends(ArenaShrinkGravity, _super);
    function ArenaShrinkGravity(ceiling) {
        var _this = _super.call(this) || this;
        _this.maxY = 146;
        _this.ceiling = ceiling;
        _this.updateCeilingPosition();
        return _this;
    }
    ArenaShrinkGravity.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateCeilingPosition();
    };
    ArenaShrinkGravity.prototype.updateCeilingPosition = function () {
        var _a, _b;
        var p = 0;
        var battleTimer = (_b = (_a = this.world) === null || _a === void 0 ? void 0 : _a.select) === null || _b === void 0 ? void 0 : _b.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 45, 0, 1);
        }
        this.ceiling.y = M.lerp(0, this.maxY, p);
    };
    return ArenaShrinkGravity;
}(PhysicsWorldObject));
var ArenaShrinkIce = /** @class */ (function (_super) {
    __extends(ArenaShrinkIce, _super);
    function ArenaShrinkIce() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.speedMultiplier = 1;
        _this.iceFansMultiplier = 1;
        return _this;
    }
    ArenaShrinkIce.prototype.update = function () {
        _super.prototype.update.call(this);
        var p = 0;
        var battleTimer = this.world.select.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 45, 0, 1);
        }
        this.speedMultiplier = M.lerp(1, 4, p);
        this.iceFansMultiplier = M.lerp(1, 6, p);
    };
    return ArenaShrinkIce;
}(PhysicsWorldObject));
var ArenaShrinkSpace = /** @class */ (function (_super) {
    __extends(ArenaShrinkSpace, _super);
    function ArenaShrinkSpace(centerBlackHole, blackHole) {
        var _this = _super.call(this) || this;
        _this.centerBlackHole = centerBlackHole;
        _this.blackHole = blackHole;
        return _this;
    }
    ArenaShrinkSpace.prototype.update = function () {
        _super.prototype.update.call(this);
        var p = 0;
        var battleTimer = this.world.select.type(BattleTimer, false);
        if (battleTimer) {
            p = M.mapClamp(battleTimer.battleTimeForArenaShrink, 30, 45, 0, 1);
        }
        this.centerBlackHole.gravityFactor = M.lerp(ArenaShrinkSpace.BASE_GRAVITY_FACTOR, 2, p);
        this.blackHole.scale = M.lerp(ArenaShrinkSpace.BASE_BLACK_HOLE_SCALE, 1, p);
    };
    ArenaShrinkSpace.BASE_GRAVITY_FACTOR = 0.5;
    ArenaShrinkSpace.BASE_BLACK_HOLE_SCALE = 0.5;
    return ArenaShrinkSpace;
}(PhysicsWorldObject));
var Arenas;
(function (Arenas) {
    Arenas.PARENT_NAME = 'arenaParent';
    Arenas.BG_NAME = 'arenaBg';
    Arenas.ARENA_FIRST = 'first';
    Arenas.ARENA_BDAY = 'bday';
    Arenas.ARENA_SPACE = 'space';
    Arenas.ARENA_FACTORY = 'factory';
    Arenas.ARENA_ICE = 'ice';
    Arenas.ARENA_GRAVITY = 'gravity';
    Arenas.ARENAS = [Arenas.ARENA_FIRST, Arenas.ARENA_BDAY, Arenas.ARENA_SPACE, Arenas.ARENA_FACTORY, Arenas.ARENA_ICE, Arenas.ARENA_GRAVITY];
    function BASE() {
        var _a;
        var world = new World({
            backgroundColor: 0x000000,
            camera: {
                mode: Camera.Mode.FOCUS(global.gameWidth / 2, global.gameHeight / 2),
                movement: Camera.Movement.SNAP()
            },
            layers: [
                { name: Battle.Layers.bg },
                { name: Battle.Layers.ground },
                { name: Battle.Layers.onground },
                { name: Battle.Layers.walls },
                { name: Battle.Layers.balls },
                { name: Battle.Layers.fx },
                { name: Battle.Layers.fg },
                { name: Battle.Layers.playernames },
                { name: Battle.Layers.ui },
                { name: Battle.Layers.drag },
                { name: Battle.Layers.infobox },
                { name: Battle.Layers.warning },
            ],
            physicsGroups: (_a = {},
                _a[Battle.PhysicsGroups.walls] = {},
                _a[Battle.PhysicsGroups.balls] = {},
                _a[Battle.PhysicsGroups.balls_ethereal] = {},
                _a[Battle.PhysicsGroups.droppables] = {},
                _a),
            collisions: [
                { move: Battle.PhysicsGroups.balls, from: Battle.PhysicsGroups.walls, momentumTransfer: 'elastic' },
                { move: Battle.PhysicsGroups.balls_ethereal, from: Battle.PhysicsGroups.walls, momentumTransfer: 'elastic' },
                { move: Battle.PhysicsGroups.balls, from: Battle.PhysicsGroups.balls, momentumTransfer: 'elastic', callback: Ball.handleCollision },
                { move: Battle.PhysicsGroups.droppables, from: Battle.PhysicsGroups.walls, momentumTransfer: 'elastic' },
            ],
            collisionIterations: 4,
            // TODO: why does this work?
            useRaycastDisplacementThreshold: Infinity,
            maxDistancePerCollisionStep: 16,
            minDistanceIgnoreCollisionStepCalculation: 400,
            globalSoundHumanizePercent: 0.1,
        });
        world.addWorldObject(new Sprite({
            texture: Texture.filledRect(world.width, world.height, 0xFFFFFF),
            layer: Battle.Layers.bg,
        }));
        // Walls
        world.addWorldObject(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(0, 0, world.width, world.height),
            immovable: true,
        }));
        // Flow
        world.addWorldObject(new FlowHolder(Flow.GET_FIXED_FLOW_TEXTURE()));
        // Non-Update
        world.nonUpdateCallback = function () {
            var _a, _b;
            (_a = this.select.type(BallHighlighter, false)) === null || _a === void 0 ? void 0 : _a.update();
            (_b = this.select.type(InfoBox, false)) === null || _b === void 0 ? void 0 : _b.update();
        };
        return world;
    }
    Arenas.BASE = BASE;
    function CLEAR_OLD_ARENA(world) {
        var _a;
        (_a = world.select.name(Arenas.PARENT_NAME, false)) === null || _a === void 0 ? void 0 : _a.removeFromWorld();
        world.data.arenaName = undefined;
        world.data.onBattleStart = undefined;
        A.filterInPlace(world.getLayerByName(Battle.Layers.walls).effects.post.filters, function (filter) { return !(filter instanceof ArenaFirstFilter); });
        A.filterInPlace(world.getLayerByName(Battle.Layers.ground).effects.post.filters, function (filter) { return !(filter instanceof BulgeFilter) && !(filter instanceof AddBlueFilter); });
    }
    function NEW_ARENA_PARENT(world) {
        return world.addWorldObject(new WorldObject({
            name: Arenas.PARENT_NAME,
        }));
    }
    function SET_FOR_ARENA(world, arena) {
        if (arena === Arenas.ARENA_BDAY) {
            SET_BDAY(world);
        }
        else if (arena === Arenas.ARENA_SPACE) {
            SET_SPACE(world);
        }
        else if (arena === Arenas.ARENA_ICE) {
            SET_ICE(world);
        }
        else if (arena === Arenas.ARENA_GRAVITY) {
            SET_GRAVITY(world);
        }
        else if (arena === Arenas.ARENA_FACTORY) {
            SET_FACTORY(world);
        }
        else {
            SET_FIRST(world);
        }
    }
    Arenas.SET_FOR_ARENA = SET_FOR_ARENA;
    function SET_FIRST(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_FIRST;
        // BG
        arenaParent.addChild(new Sprite({
            name: Arenas.BG_NAME,
            texture: world.select.type(FlowHolder).flowTexture,
            effects: { post: { filters: [new FlowFilter(0.05)] } },
            alpha: 0.55,
            layer: Battle.Layers.ground,
        }));
        // Collision
        arenaParent.addChild(new ArenaShrink());
        arenaParent.addChild(Parts.circle(world.width / 2, world.height / 2, 30));
        var borderThickness = 16;
        world.addWorldObject(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(borderThickness, borderThickness, world.width - 2 * borderThickness, world.height - 2 * borderThickness),
            immovable: true,
        }));
        var trapWidth = 132;
        var trapHeight = 32;
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, 0, trapWidth, trapWidth - trapHeight * 2, trapHeight));
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, world.height - trapHeight, trapWidth - trapHeight * 2, trapWidth, trapHeight));
        // Decoration
        arenaParent.addChild(new Sprite({
            texture: 'arena1_walls',
            layer: Battle.Layers.walls,
        }));
        arenaParent.addChild(new Sprite({
            x: world.width / 2, y: world.height / 2,
            texture: 'centerblades',
            layer: Battle.Layers.walls,
            vangle: 720,
        }));
        world.getLayerByName(Battle.Layers.walls).effects.post.filters.push(new ArenaFirstFilter());
    }
    function SET_BDAY(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_BDAY;
        // BG
        arenaParent.addChild(new Sprite({
            name: Arenas.BG_NAME,
            texture: 'arena_bday_bg',
            layer: Battle.Layers.ground,
            effects: { post: { filters: [new FlipbookFilter(1, 0.2, 60, 2), new BulgeFilter(0), new ArenaBdayShadeFilter()] } },
        }));
        // Collision
        arenaParent.addChild(new ArenaShrinkBday());
        var borderThickness = 16;
        arenaParent.addChild(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(borderThickness, borderThickness, world.width - 2 * borderThickness, world.height - 2 * borderThickness),
            immovable: true,
        }));
        var trapWidth = 132;
        var trapHeight = 32;
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, 0, trapWidth, trapWidth - trapHeight * 2, trapHeight));
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, world.height - trapHeight, trapWidth - trapHeight * 2, trapWidth, trapHeight));
        // Decoration
        arenaParent.addChild(new Sprite({
            x: -10, y: -10,
            texture: 'arena_bday_walls',
            layer: Battle.Layers.fg,
            effects: { post: { filters: [new FlipbookFilter(2, 0.1, 120, 1.5)] } },
        }));
        arenaParent.addChild(new Sprite({
            x: -10, y: -10,
            texture: 'arena_bday_deco',
            layer: Battle.Layers.fg,
            effects: { pre: { filters: [new FlipbookFilter(1, 1, 2, 1.5)] }, outline: {} },
        }));
        if (!IS_MOBILE)
            arenaParent.addChild(new BdayBallTrail());
    }
    function SET_SPACE(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_SPACE;
        arenaParent.addChildren(lciDocumentToWorldObjects('arena_space'));
        // Collision
        arenaParent.addChild(new PhysicsWorldObject({
            x: world.width / 2, y: world.height / 2,
            layer: Battle.Layers.walls,
            physicsGroup: Battle.PhysicsGroups.walls,
            immovable: true,
            bounds: new InvertedCircleBounds(0, 0, 112),
        }));
        var centerBlackHole = arenaParent.addChild(new CenterBlackHole(global.gameWidth / 2, global.gameHeight / 2, 0));
        centerBlackHole.updateCallback = function () {
            if (getBattleState(this.world) === Ball.States.BATTLE) {
                this.gravityFactor = M.moveToClamp(this.gravityFactor, ArenaShrinkSpace.BASE_GRAVITY_FACTOR, ArenaShrinkSpace.BASE_GRAVITY_FACTOR, this.delta);
            }
        };
        var blackHole = world.select.name('blackhole');
        blackHole.scale = ArenaShrinkSpace.BASE_BLACK_HOLE_SCALE;
        blackHole.vangle = 30;
        arenaParent.addChild(new ArenaShrinkSpace(centerBlackHole, blackHole));
        var perlin = new Perlin();
        var starAlphaMin = -0.5;
        var starAlphaMax = 1.5;
        var starAlphaSpeed = 0.5;
        world.select.name('stars1').updateCallback = function () {
            this.alpha = M.map(perlin.get(this.life.time * starAlphaSpeed, 5.5), -1, 1, starAlphaMin, starAlphaMax);
        };
        world.select.name('stars2').updateCallback = function () {
            this.alpha = M.map(-perlin.get(this.life.time * starAlphaSpeed, 5.5), -1, 1, starAlphaMin, starAlphaMax);
        };
        var bf = new BulgeFilter(0, 0.6);
        world.getLayerByName(Battle.Layers.ground).effects.post.filters.push(bf);
        world.select.name(Arenas.BG_NAME).updateCallback = function () {
            bf.bulgeAmount = M.map(perlin.get(this.life.time * 2), -1, 1, 0, 0.2);
        };
    }
    function SET_ICE(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_ICE;
        // BG
        arenaParent.addChild(new Sprite({
            name: Arenas.BG_NAME,
            texture: world.select.type(FlowHolder).flowTexture,
            effects: { post: { filters: [new FlowFilter(0.05, 0)] } },
            alpha: 0.55,
            layer: Battle.Layers.ground,
        }));
        arenaParent.addChildren(lciDocumentToWorldObjects('arena_ice'));
        // Collision
        arenaParent.addChild(Parts.circle(world.width / 2, world.height / 2, 30));
        var borderThickness = 16;
        arenaParent.addChild(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(borderThickness, borderThickness, world.width - 2 * borderThickness, world.height - 2 * borderThickness),
            immovable: true,
        }));
        var trapWidth = 132;
        var trapHeight = 32;
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, 0, trapWidth, trapWidth - trapHeight * 2, trapHeight));
        arenaParent.addChild(Parts.trapezoidV(world.width / 2 - trapWidth / 2, world.height - trapHeight, trapWidth - trapHeight * 2, trapWidth, trapHeight));
        var arenaShrinkIce = arenaParent.addChild(new ArenaShrinkIce());
        // Decoration
        arenaParent.addChild(new Sprite({
            texture: 'arena1_walls',
            layer: Battle.Layers.walls,
        }));
        arenaParent.addChild(new Sprite({
            x: world.width / 2, y: world.height / 2,
            texture: 'centerblades',
            layer: Battle.Layers.walls,
            update: function () {
                var falloff = 16;
                this.timeScale = arenaShrinkIce.iceFansMultiplier;
                this.angle = 30 + 10 * M.periodic(function (x) { return (x < 1 ? x : 1 - (x - 1) / falloff); }, 1 + falloff)(this.life.time * 30);
            },
        }));
        world.getLayerByName(Battle.Layers.ground).effects.post.filters.push(new AddBlueFilter(0.8));
        world.getLayerByName(Battle.Layers.walls).effects.post.filters.push(new ArenaFirstFilter());
    }
    function SET_GRAVITY(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_GRAVITY;
        world.data.onBattleStart = function () {
            var e_81, _a;
            try {
                for (var _b = __values(world.select.typeAll(Ball)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var ball = _c.value;
                    ball.v.y += 1;
                }
            }
            catch (e_81_1) { e_81 = { error: e_81_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_81) throw e_81.error; }
            }
        };
        // Collision
        var borderThickness = 16;
        arenaParent.addChild(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(borderThickness, 0, world.width - 2 * borderThickness, world.height),
            immovable: true,
        }));
        arenaParent.addChild(new Trampoline(80, 153, false));
        arenaParent.addChild(new Trampoline(240, 153, true));
        arenaParent.addChildren(lciDocumentToWorldObjects('arena_gravity'));
        var ceiling = world.select.name('ceiling');
        arenaParent.addChild(new ArenaShrinkGravity(ceiling));
    }
    function SET_FACTORY(world) {
        CLEAR_OLD_ARENA(world);
        var arenaParent = NEW_ARENA_PARENT(world);
        world.data.arenaName = Arenas.ARENA_FACTORY;
        arenaParent.addChildren(lciDocumentToWorldObjects('arena_factory'));
        world.select.name('wires').effects.post.filters.push(new FlowFilterFactory());
        // Collision
        arenaParent.addChild(Parts.circle(world.width / 2, world.height / 2, 30));
        var borderThickness = 16;
        world.addWorldObject(new PhysicsWorldObject({
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(borderThickness, borderThickness, world.width - 2 * borderThickness, world.height - 2 * borderThickness),
            immovable: true,
        }));
        var trapWidth = 32;
        var trapHeight = 132;
        arenaParent.addChild(Parts.trapezoidH(0, world.height / 2 - trapHeight / 2, trapHeight, trapHeight - trapWidth * 2, trapWidth));
        arenaParent.addChild(Parts.trapezoidH(world.width - trapWidth, world.height / 2 - trapHeight / 2, trapHeight - trapWidth * 2, trapHeight, trapWidth));
        var hourHand = world.select.name('hourhand');
        var minuteHand = world.select.name('minutehand');
        hourHand.vangle = ArenaShrinkFactory.INITIAL_VANGLE_HOUR;
        minuteHand.vangle = ArenaShrinkFactory.INITIAL_VANGLE_MINUTE;
        var topPipe = arenaParent.addChild(new FactoryPipe(world.width / 2, 0, false));
        var bottomPipe = arenaParent.addChild(new FactoryPipe(world.width / 2, world.height, true));
        var factoryPipeController = arenaParent.addChild(new FactoryPipeController(topPipe, bottomPipe));
        arenaParent.addChild(new ArenaShrinkFactory(factoryPipeController, hourHand, minuteHand));
    }
    function translateCoordinate(v, fromArena, toArena) {
        v = vec2(v);
        if (fromArena === toArena)
            return v;
        if (!_.contains(Arenas.ARENAS, fromArena) || !_.contains(Arenas.ARENAS, toArena))
            return v;
        if (fromArena === Arenas.ARENA_ICE && toArena === Arenas.ARENA_FIRST)
            return v;
        if (fromArena === Arenas.ARENA_FIRST && toArena === Arenas.ARENA_ICE)
            return v;
        var polar = v.subtract(160, 120).toPolar();
        var fromPolarization = getArenaPolarizationForAngle(fromArena, polar.angle);
        var toPolarization = getArenaPolarizationForAngle(toArena, polar.angle);
        polar.radius = M.map(polar.radius, fromPolarization.near, fromPolarization.far, toPolarization.near, toPolarization.far);
        return polar.toCartesian().add(160, 120);
    }
    Arenas.translateCoordinate = translateCoordinate;
    var ARENA_POLARIZATION_FOOTPRINTS = {};
    function loadArenaPolarizationFootprints() {
        var e_82, _a;
        try {
            for (var ARENAS_1 = __values(Arenas.ARENAS), ARENAS_1_1 = ARENAS_1.next(); !ARENAS_1_1.done; ARENAS_1_1 = ARENAS_1.next()) {
                var arena = ARENAS_1_1.value;
                if (arena in ARENA_POLARIZATION_FOOTPRINTS)
                    continue;
                var world = BASE();
                SET_FOR_ARENA(world, arena);
                var hasCenter = world.select.overlap(new RectBounds(world.width / 2 - 1, world.height / 2 - 1, 2, 2), [Battle.PhysicsGroups.walls]).length > 0;
                var result = [];
                for (var angle = 0; angle < 360; angle++) {
                    var walls = world.select.raycast(world.width / 2, world.height / 2, M.cos(angle), M.sin(angle), [Battle.PhysicsGroups.walls]);
                    if (hasCenter) {
                        result.push({ near: walls[0].t, far: walls[1].t });
                    }
                    else {
                        result.push({ near: 0, far: walls[0].t });
                    }
                }
                ARENA_POLARIZATION_FOOTPRINTS[arena] = result;
            }
        }
        catch (e_82_1) { e_82 = { error: e_82_1 }; }
        finally {
            try {
                if (ARENAS_1_1 && !ARENAS_1_1.done && (_a = ARENAS_1.return)) _a.call(ARENAS_1);
            }
            finally { if (e_82) throw e_82.error; }
        }
    }
    Arenas.loadArenaPolarizationFootprints = loadArenaPolarizationFootprints;
    function getArenaPolarizationForAngle(arena, angle) {
        angle = M.mod(angle, 360);
        var i = Math.floor(angle);
        var j = Math.ceil(angle);
        return {
            near: angle === i ? ARENA_POLARIZATION_FOOTPRINTS[arena][i % 360].near
                : M.map(angle, i, j, ARENA_POLARIZATION_FOOTPRINTS[arena][i % 360].near, ARENA_POLARIZATION_FOOTPRINTS[arena][j % 360].near),
            far: angle === i ? ARENA_POLARIZATION_FOOTPRINTS[arena][i % 360].far
                : M.map(angle, i, j, ARENA_POLARIZATION_FOOTPRINTS[arena][i % 360].far, ARENA_POLARIZATION_FOOTPRINTS[arena][j % 360].far),
        };
    }
    Arenas.getArenaPolarizationForAngle = getArenaPolarizationForAngle;
})(Arenas || (Arenas = {}));
var Assets;
(function (Assets) {
    Assets.textures = {
        'blank': {},
        // Debug
        'debug': {},
        // Level
        'arena1_walls': {},
        'centerblades': { anchor: Vector2.CENTER },
        'arena_bday_walls': {},
        'arena_bday_bg': {},
        'arena_bday_deco': {},
        'arena_space': { url: 'arena_space.lci' },
        'arena_ice': { url: 'arena_ice.lci' },
        'arena_gravity': { url: 'arena_gravity.lci' },
        'trampoline': {
            anchor: Vector2.TOP_CENTER,
            spritesheet: { frameWidth: 160, frameHeight: 87 },
        },
        'arena_factory': { url: 'arena_factory.lci' },
        'factorypipe': { anchor: Vector2.TOP_CENTER },
        // FX
        'aura': { anchor: Vector2.CENTER },
        'buffsigns': {
            anchor: Vector2.CENTER,
            frames: {
                'buff+': { rect: rect(0, 0, 7, 7) },
                'buff-': { rect: rect(7, 0, 7, 7) },
            }
        },
        'buffbeams': { anchor: Vector2.CENTER },
        'necromancerbeams': { anchor: Vector2.CENTER },
        'spike': { anchor: Vector2.CENTER },
        'sap': { anchor: Vector2.CENTER },
        'clawslash': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 28, frameHeight: 28 },
        },
        'buffcat': { anchor: Vector2.CENTER },
        'psychiceye': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 20, frameHeight: 14 },
        },
        'medkit': { anchor: Vector2.CENTER },
        'medkitdmg': { anchor: Vector2.CENTER },
        'voodoo': { anchor: Vector2.CENTER },
        'vampring': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 56, frameHeight: 56 },
        },
        'cue': { anchor: Vector2.CENTER_LEFT },
        'reduce': { anchor: Vector2.CENTER },
        'boomerbullet': { anchor: Vector2.CENTER },
        'nullified': { anchor: Vector2.CENTER },
        'landmine': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 10, frameHeight: 10 },
        },
        'scrapbullet': { anchor: Vector2.CENTER },
        'ghost': { anchor: Vector2.CENTER },
        'crosshair': { anchor: Vector2.CENTER },
        'speedflame': { anchor: Vector2.CENTER },
        // Balls
        'balls': {
            anchor: vec2(0.5, 0.25),
            frames: {
                'balls/8ball': { rect: rect(0, 0, 16, 32) },
                'balls/assassin': { rect: rect(16, 0, 16, 32) },
                'balls/ballofice': { rect: rect(32, 0, 16, 32) },
                'balls/ballofyarn': { rect: rect(48, 0, 16, 32) },
                'balls/biogrenade': { rect: rect(64, 0, 8, 16) },
                'balls/booster': { rect: rect(80, 0, 16, 32) },
                'balls/buffer': { rect: rect(96, 0, 16, 32) },
                'balls/coin': { rect: rect(112, 0, 16, 32) },
                'balls/commando': { rect: rect(0, 32, 16, 32) },
                'balls/crown': { rect: rect(16, 32, 16, 32) },
                'balls/crusher': { rect: rect(32, 32, 16, 32) },
                'balls/crystalball': { rect: rect(48, 32, 16, 32) },
                'balls/cueball': { rect: rect(64, 32, 16, 32) },
                'balls/deathstar': { rect: rect(80, 32, 32, 64) },
                'balls/gacha': { rect: rect(112, 32, 16, 32) },
                'balls/gladiator': { rect: rect(0, 64, 16, 32) },
                'balls/greencrystalball': { rect: rect(16, 64, 16, 32) },
                'balls/grenade': { rect: rect(32, 64, 16, 32) },
                'balls/healer': { rect: rect(48, 64, 16, 32) },
                'balls/leech': { rect: rect(64, 64, 16, 32) },
                'balls/martyr': { rect: rect(112, 64, 16, 32) },
                'balls/mechanic': { rect: rect(0, 96, 16, 32) },
                'balls/medic': { rect: rect(16, 96, 16, 32) },
                'balls/mercenary': { rect: rect(32, 96, 16, 32) },
                'balls/necromancer': { rect: rect(48, 96, 16, 32) },
                'balls/ninja': { rect: rect(64, 96, 16, 32) },
                'balls/normal': { rect: rect(80, 96, 16, 32) },
                'balls/pickleball': { rect: rect(96, 96, 16, 32) },
                'balls/pokeball': { rect: rect(112, 96, 16, 32) },
                'balls/powerball': { rect: rect(0, 128, 16, 32) },
                'balls/psychic': { rect: rect(16, 128, 16, 32) },
                'balls/recycler': { rect: rect(32, 128, 16, 32) },
                'balls/redcrystalball': { rect: rect(48, 128, 16, 32) },
                'balls/sapper': { rect: rect(64, 128, 16, 32) },
                'balls/skeleton': { rect: rect(80, 128, 16, 32) },
                'balls/sniper': { rect: rect(96, 128, 16, 32) },
                'balls/snowball': { rect: rect(112, 128, 16, 32) },
                'balls/spiker': { rect: rect(0, 160, 16, 32) },
                'balls/splinter': { rect: rect(16, 160, 16, 32) },
                'balls/split': { rect: rect(32, 160, 16, 32) },
                'balls/splitspawn': { rect: rect(48, 160, 8, 16) },
                'balls/thief': { rect: rect(64, 160, 16, 32) },
                'balls/trainer': { rect: rect(80, 160, 16, 32) },
                'balls/turret': { rect: rect(96, 160, 16, 32) },
                'balls/vagrant': { rect: rect(112, 160, 16, 32) },
                'balls/vampire': { rect: rect(0, 192, 16, 32) },
                'balls/vanguard': { rect: rect(16, 192, 16, 32) },
                'balls/voodooball': { rect: rect(32, 192, 16, 32) },
                'balls/wobby1': { rect: rect(48, 192, 16, 32) },
                'balls/wobby2': { rect: rect(64, 192, 16, 32) },
                'balls/wobby3': { rect: rect(80, 192, 16, 32) },
                'balls/wobby4': { rect: rect(96, 192, 16, 32) },
                'balls/zombie': { rect: rect(112, 192, 16, 32) },
                'balls/bank': { rect: rect(0, 224, 16, 32) },
                'balls/butterball': { rect: rect(16, 224, 16, 32) },
                'balls/reducer': { rect: rect(32, 224, 16, 32) },
                'balls/matryoshkaxl': { rect: rect(128, 0, 32, 64) },
                'balls/matryoshkal': { rect: rect(160, 0, 22, 44) },
                'balls/matryoshkam': { rect: rect(182, 0, 16, 32) },
                'balls/matryoshkas': { rect: rect(198, 0, 12, 24) },
                'balls/matryoshkaxs': { rect: rect(210, 0, 8, 16) },
                'balls/sleeper': { rect: rect(48, 224, 16, 32) },
                'balls/angel': { rect: rect(64, 224, 16, 32) },
                'balls/devil': { rect: rect(80, 224, 16, 32) },
                'balls/blackhole': { rect: rect(96, 224, 16, 32) },
                'balls/boomer': { rect: rect(112, 224, 16, 32) },
                'balls/zoomer': { rect: rect(224, 0, 16, 32) },
                'balls/guardian': { rect: rect(240, 0, 16, 32) },
                'balls/fragmenter': { rect: rect(192, 32, 16, 32) },
                'balls/watcher': { rect: rect(208, 32, 16, 32) },
                'balls/stinger': { rect: rect(224, 32, 16, 32) },
                'balls/wizard': { rect: rect(240, 32, 16, 32) },
                'balls/scavenger': { rect: rect(128, 64, 16, 32) },
                'balls/medkit': { rect: rect(144, 64, 16, 32) },
                'balls/cheel': { rect: rect(160, 64, 16, 32) },
                'balls/mimic': { rect: rect(176, 64, 16, 32) },
                'balls/fireball': { rect: rect(192, 64, 16, 32) },
                'balls/phoenix': { rect: rect(208, 64, 16, 32) },
                'balls/impostor': { rect: rect(224, 64, 16, 32) },
                'balls/miner': { rect: rect(240, 64, 16, 32) },
                'balls/hitman': { rect: rect(128, 96, 16, 32) },
                'balls/nullifier': { rect: rect(144, 96, 16, 32) },
                'balls/seed': { rect: rect(160, 96, 16, 32) },
                'balls/pinata': { rect: rect(176, 96, 16, 32) },
                'balls/questionball': { rect: rect(192, 96, 16, 32) },
                'balls/questionballspent': { rect: rect(208, 96, 16, 32) },
                'balls/dove': { rect: rect(224, 96, 16, 32) },
                'balls/watermelon': { rect: rect(240, 96, 16, 32) },
                'balls/grave': { rect: rect(128, 128, 16, 32) },
                'balls/scrapcannon': { rect: rect(144, 128, 16, 32) },
                'balls/haunt': { rect: rect(160, 128, 16, 32) },
                'balls/firefighter': { rect: rect(176, 128, 16, 32) },
                'balls/battery': { rect: rect(192, 128, 16, 32) },
                'balls/oldcrystalball': { rect: rect(208, 128, 16, 32) },
                'balls/neocrystalball': { rect: rect(224, 128, 16, 32) },
                'balls/dolly': { rect: rect(240, 128, 16, 32) },
                'balls/burner': { rect: rect(128, 160, 16, 32) },
                'balls/goldcrystalball': { rect: rect(144, 160, 16, 32) },
                'balls/alchemist': { rect: rect(160, 160, 16, 32) },
                'balls/seeker': { rect: rect(176, 160, 16, 32) },
                'balls/greatermimic': { rect: rect(192, 160, 16, 32) },
                'balls/toxin': { rect: rect(208, 160, 16, 32) },
                'balls/bowlingball': { rect: rect(224, 160, 16, 32) },
                'balls/stopper': { rect: rect(240, 160, 16, 32) },
                'balls/cannon': { rect: rect(128, 192, 22, 44) },
                'balls/cannonball': { rect: rect(160, 192, 16, 32) },
            }
        },
        'grenadehandle': { anchor: Vector2.CENTER },
        'turretgunbase': { anchor: Vector2.CENTER },
        'turretgunbarrel': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 22, frameHeight: 6 },
        },
        'biogrenadehandle': { anchor: Vector2.CENTER },
        'ballofyarntail': { anchor: Vector2.CENTER },
        'angelhalo': { anchor: Vector2.CENTER },
        'devilhorns': { anchor: Vector2.CENTER },
        'blackholecurl': { anchor: Vector2.CENTER },
        'blackholeoverlay': { anchor: Vector2.CENTER },
        'boomergun': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 20, frameHeight: 28 },
        },
        'wizardhat': { anchor: Vector2.CENTER },
        'stingerspike': { anchor: Vector2.CENTER },
        'phoenixashes': { anchor: Vector2.CENTER },
        'impostor_vent': {
            anchor: vec2(36 / 48, 13 / 32),
            spritesheet: { frameWidth: 48, frameHeight: 32 },
        },
        'scrapgunbase': { anchor: Vector2.CENTER },
        'scrapgunbarrel': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 8 },
        },
        'neocrystalballoverlay': { anchor: Vector2.CENTER },
        'cannongunbase': { anchor: Vector2.CENTER },
        'cannongunbarrel': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 40, frameHeight: 16 },
        },
        'mimictextures': {
            anchor: vec2(0.5, 0.25),
            frames: {
                'mimictextures/scrapcannon': { rect: rect(0, 0, 16, 32) },
                'mimictextures/turret': { rect: rect(16, 0, 16, 32) },
                'mimictextures/boomer': { rect: rect(32, 0, 16, 32) },
                'mimictextures/cannon': { rect: rect(48, 0, 22, 44) },
            }
        },
        // Ball Items
        'items': {
            anchor: Vector2.CENTER,
            frames: {
                'items/armorplating': { rect: rect(0, 0, 16, 16) },
                'items/bounty': { rect: rect(16, 0, 16, 16) },
                'items/rejuvenator': { rect: rect(32, 0, 16, 16) },
                'items/catears': { rect: rect(0, 16, 16, 16) },
                'items/magnet': { rect: rect(16, 16, 16, 16) },
                'items/guns': { rect: rect(32, 16, 16, 16) },
                'items/claws': { rect: rect(0, 32, 16, 16) },
                'items/polarityinverter': { rect: rect(16, 32, 16, 16) },
                'items/polarityinverterfan': { rect: rect(32, 32, 16, 16) },
                'items/clout': { rect: rect(0, 48, 16, 16) },
                'items/ballsharpener1': { rect: rect(16, 48, 16, 16) },
                'items/protectionbubble': { rect: rect(32, 48, 16, 16) },
                'items/hotpickle': { rect: rect(0, 64, 16, 16) },
                'items/pickle': { rect: rect(16, 64, 16, 16) },
                'items/starcatcher': { rect: rect(32, 64, 16, 16) },
                'items/polisher1': { rect: rect(0, 80, 16, 16) },
                'items/toxicfungus': { rect: rect(16, 80, 16, 16) },
                'items/redcube': { rect: rect(32, 80, 16, 16) },
                'items/shield': { rect: rect(0, 96, 16, 16) },
                'items/silencer': { rect: rect(16, 96, 16, 16) },
                'items/greencube': { rect: rect(32, 96, 16, 16) },
                'items/skullcharm': { rect: rect(0, 112, 16, 16) },
                'items/voodoopin': { rect: rect(16, 112, 16, 16) },
                'items/collectiblecoin': { rect: rect(32, 112, 16, 16) },
                'items/medkit': { rect: rect(0, 128, 16, 16) },
                'items/participationtrophy': { rect: rect(16, 128, 16, 16) },
                'items/cursedeye': { rect: rect(32, 128, 16, 16) },
                'items/timebomboff': { rect: rect(0, 144, 16, 16) },
                'items/timebomb': { rect: rect(16, 144, 16, 16) },
                'items/huntersmark': { rect: rect(32, 144, 16, 16) },
                'items/unstablecatalyst': { rect: rect(56, 0, 24, 24) },
                'items/scribbledmap': { rect: rect(80, 0, 24, 24) },
                'items/bestfriend': { rect: rect(104, 0, 24, 24) },
                'items/consolationprize': { rect: rect(56, 24, 24, 24) },
                'items/smokebomb': { rect: rect(80, 24, 24, 24) },
                'items/hyperdriver': { rect: rect(104, 24, 24, 24) },
                'items/orbitingpotato': { rect: rect(56, 48, 24, 24) },
                'items/spinach': { rect: rect(80, 48, 24, 24) },
                'items/overcharger': { rect: rect(104, 48, 24, 24) },
                'items/ballsharpener': { rect: rect(56, 72, 24, 24) },
                'items/supernova': { rect: rect(80, 72, 24, 24) },
                'items/polisher': { rect: rect(104, 72, 24, 24) },
                'items/bandaid': { rect: rect(56, 96, 24, 24) },
                'items/thiefmask': { rect: rect(80, 96, 24, 24) },
                'items/retroglasses': { rect: rect(104, 96, 24, 24) },
                'items/birthdaycake': { rect: rect(56, 120, 24, 24) },
                'items/mitosis': { rect: rect(80, 120, 24, 24) },
                'items/vipticket': { rect: rect(104, 120, 24, 24) },
                'items/mocha': { rect: rect(80, 144, 24, 24) },
                'items/thebug': { rect: rect(104, 144, 24, 24) },
                'items/gift': { rect: rect(128, 0, 24, 24) },
                'items/jetpack': { rect: rect(128, 24, 24, 24) },
                'items/contagion': { rect: rect(128, 48, 24, 24) },
                'items/moleculardisassembler': { rect: rect(128, 72, 24, 24) },
                'items/curseddoll': { rect: rect(128, 96, 24, 24) },
                'items/joker': { rect: rect(128, 120, 24, 24) },
                'items/curry': { rect: rect(128, 144, 24, 24) },
            }
        },
        // Equipments
        'equipments/orbiting': {
            anchor: Vector2.CENTER,
            frames: {
                'equipments/bestfriend': { rect: rect(0, 0, 12, 12) },
                'equipments/bandaid': { rect: rect(12, 0, 12, 12) },
                'equipments/bounty': { rect: rect(24, 0, 12, 12) },
                'equipments/claws': { rect: rect(36, 0, 12, 12) },
                'equipments/hyperdriver': { rect: rect(48, 0, 12, 12) },
                'equipments/magnet': { rect: rect(60, 0, 12, 12) },
                'equipments/rejuvenator': { rect: rect(72, 0, 12, 12) },
                'equipments/polarityinverter': { rect: rect(0, 12, 12, 12) },
                'equipments/polarityinverterfan': { rect: rect(12, 12, 12, 12) },
                'equipments/shield': { rect: rect(24, 12, 12, 12) },
                'equipments/silencer': { rect: rect(36, 12, 12, 12) },
                'equipments/skullcharm': { rect: rect(48, 12, 12, 12) },
                'equipments/smokebomb': { rect: rect(60, 12, 12, 12) },
                'equipments/toxicfungus': { rect: rect(72, 12, 12, 12) },
                'equipments/unstablecatalyst': { rect: rect(0, 24, 12, 12) },
                'equipments/vipticket': { rect: rect(12, 24, 12, 12) },
                'equipments/thiefmask': { rect: rect(24, 24, 12, 12) },
                'equipments/spore': { rect: rect(36, 24, 12, 12) },
                'equipments/medkit': { rect: rect(48, 24, 12, 12) },
                'equipments/mitosis': { rect: rect(60, 24, 12, 12) },
                'equipments/starcatcher': { rect: rect(72, 24, 12, 12) },
                'equipments/infection': { rect: rect(0, 36, 12, 12) },
                'equipments/redcube': { rect: rect(12, 36, 12, 12) },
                'equipments/greencube': { rect: rect(24, 36, 12, 12) },
                'equipments/curseddoll': { rect: rect(36, 36, 12, 12) },
                'equipments/cursedeye': { rect: rect(48, 36, 12, 12) },
                'equipments/joker': { rect: rect(60, 36, 12, 12) },
                'equipments/timebomb': { rect: rect(72, 36, 12, 12) },
                'equipments/huntersmark': { rect: rect(0, 48, 12, 12) },
                'equipments/curry': { rect: rect(12, 48, 12, 12) },
                'equipments/thebug': { rect: rect(24, 48, 12, 12) },
                'equipments/mocha': { rect: rect(36, 48, 12, 12) },
            }
        },
        'equipments/catears': { anchor: Vector2.CENTER },
        'equipments/gun': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 48, frameHeight: 48 },
        },
        'equipments/retroglasses': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 14, frameHeight: 8 },
        },
        'equipments/orbitingpotato': { anchor: Vector2.CENTER },
        'equipments/voodoopin': { anchor: Vector2.CENTER },
        'equipments/voodoopin_shoot': { anchor: Vector2.CENTER },
        'equipments/thief_hand': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 20, frameHeight: 14 },
        },
        'equipments/thruster': {
            anchor: vec2(2 / 12, 7 / 24),
            spritesheet: { frameWidth: 12, frameHeight: 24 },
        },
        'equipments/star_catcher': { anchor: vec2(14 / 20, 7 / 14) },
        // UI
        'dialogbox': { anchor: Vector2.CENTER },
        'dialogbox_name': { anchor: Vector2.CENTER },
        'slider': { anchor: Vector2.CENTER },
        'sliderbar': { anchor: Vector2.CENTER },
        'preppanel': { url: 'preppanel.lci' },
        'gear': { anchor: Vector2.CENTER },
        'gearsmall': { anchor: Vector2.CENTER },
        'infobox_9p': {},
        'dmgbox': { anchor: Vector2.CENTER },
        'hpbox': { anchor: Vector2.CENTER },
        'star': { anchor: Vector2.CENTER },
        'crown': { anchor: Vector2.CENTER },
        'pause': { anchor: Vector2.CENTER },
        'fastforward': { anchor: Vector2.CENTER },
        'countdown': {
            anchor: Vector2.CENTER,
            frames: {
                'countdown/3': { rect: rect(0, 0, 48, 80) },
                'countdown/2': { rect: rect(48, 0, 48, 80) },
                'countdown/1': { rect: rect(96, 0, 48, 80) },
                'countdown/0': { rect: rect(144, 0, 336, 80) },
            }
        },
        'achievementrewardbox': { anchor: Vector2.CENTER },
        'argpart1box': { anchor: Vector2.CENTER },
        'achievementscrollbar': {},
        'patchnotesscrollbar': {},
        'scrollbarhandle': {},
        'twitterlogosmall': { anchor: Vector2.CENTER },
        'imagelogosmall': { anchor: Vector2.CENTER },
        'freeze8': { anchor: Vector2.CENTER },
        'freeze16': { anchor: Vector2.CENTER },
        'vshearts': {},
        'vignette': {},
        'strategy': {},
        'checkmark': { anchor: Vector2.CENTER },
        'keyboardkey': { anchor: Vector2.CENTER },
        'keyboardkeybackspace': { anchor: Vector2.CENTER },
        'keyboardkeyshift': { anchor: Vector2.CENTER },
        'keyboardkeyspace': { anchor: Vector2.CENTER },
        'keyboardkeyenter': { anchor: Vector2.CENTER },
        'noballs': { anchor: Vector2.TOP },
        'bdayemojis': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 44, frameHeight: 44 },
        },
        'almanacentrybox': { anchor: Vector2.CENTER },
        'almanacscrollbar': {},
        'almanacmystery': { anchor: Vector2.CENTER },
        'lectvslogo': { anchor: Vector2.CENTER },
        'almanacicon': {
            anchor: Vector2.CENTER,
            frames: {
                'almanacicon/open': { rect: rect(0, 0, 24, 20) },
                'almanacicon/closed': { rect: rect(24, 0, 24, 20) },
            }
        },
        'dailyscrollbar': {},
        'dailyicons': {
            anchor: Vector2.CENTER,
            frames: {
                'dailyicons/pack/classic': { rect: rect(0, 0, 16, 16) },
                'dailyicons/pack/community': { rect: rect(16, 0, 16, 16) },
                'dailyicons/pack/all': { rect: rect(32, 0, 16, 16) },
                'dailyicons/pack/weekly': { rect: rect(48, 0, 16, 16) },
                'dailyicons/arena/first': { rect: rect(0, 16, 16, 16) },
                'dailyicons/arena/ice': { rect: rect(16, 16, 16, 16) },
                'dailyicons/arena/space': { rect: rect(32, 16, 16, 16) },
                'dailyicons/arena/factory': { rect: rect(48, 16, 16, 16) },
                'dailyicons/arena/gravity': { rect: rect(64, 16, 16, 16) },
                'dailyicons/arena/bday': { rect: rect(80, 16, 16, 16) },
                'dailyicons/modifier/nospeedcap': { rect: rect(0, 32, 16, 16) },
                'dailyicons/modifier/extradmg': { rect: rect(16, 32, 16, 16) },
                'dailyicons/modifier/extrahp': { rect: rect(32, 32, 16, 16) },
                'dailyicons/modifier/extrastars': { rect: rect(48, 32, 16, 16) },
                'dailyicons/modifier/lessgold': { rect: rect(64, 32, 16, 16) },
                'dailyicons/modifier/moregold': { rect: rect(80, 32, 16, 16) },
                'dailyicons/modifier/preequipped': { rect: rect(96, 32, 16, 16) },
                'dailyicons/modifier/sameballsstocked': { rect: rect(112, 32, 16, 16) },
                'dailyicons/modifier/birthday': { rect: rect(128, 32, 16, 16) },
                'dailyicons/modifier/unknown': { rect: rect(144, 32, 16, 16) },
                'dailyicons/modifier/packclash': { rect: rect(0, 48, 16, 16) },
                'dailyicons/modifier/sharedhp': { rect: rect(16, 48, 16, 16) },
                'dailyicons/modifier/spores': { rect: rect(32, 48, 16, 16) },
                'dailyicons/modifier/lesssell': { rect: rect(48, 48, 16, 16) },
                'dailyicons/modifier/moresell': { rect: rect(64, 48, 16, 16) },
                'dailyicons/modifier/challengemode': { rect: rect(80, 48, 16, 16) },
                'dailyicons/modifier/noitems': { rect: rect(96, 48, 16, 16) },
                'dailyicons/modifier/moreballs': { rect: rect(112, 48, 16, 16) },
                'dailyicons/modifier/slowcollisions': { rect: rect(128, 48, 16, 16) },
                'dailyicons/modifier/ballsexplode': { rect: rect(144, 48, 16, 16) },
                'dailyicons/modifier/earlyshrink': { rect: rect(0, 64, 16, 16) },
                'dailyicons/modifier/pickles': { rect: rect(16, 64, 16, 16) },
                'dailyicons/modifier/onlyintier': { rect: rect(32, 64, 16, 16) },
                'dailyicons/modifier/lesssquadsize': { rect: rect(48, 64, 16, 16) },
                'dailyicons/modifier/moresquadsize': { rect: rect(64, 64, 16, 16) },
                'dailyicons/modifier/lessrestockcost': { rect: rect(80, 64, 16, 16) },
                'dailyicons/modifier/morerestockcost': { rect: rect(96, 64, 16, 16) },
                'dailyicons/modifier/wallshurt': { rect: rect(112, 64, 16, 16) },
                'dailyicons/modifier/wallsbounce': { rect: rect(128, 64, 16, 16) },
            }
        },
        'infoicon': { anchor: Vector2.CENTER },
        // Achievements
        'achievements/playfivegames': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/wingame': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/strongball': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/roundsinarow': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/havetwentygold': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/reachroundtwelve': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 36, frameHeight: 36 },
        },
        'achievements/playhundredrounds': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/winfiftyrounds': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/victorywithtwoballs': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/makefivehundredpurchases': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/catearsonsquad': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        'achievements/winintenminutes': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/strongsquad': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/winwithoutequipment': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/winwithoutfreezing': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/dealdamage': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/defeatcrownedsquads': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/midlevelball': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/healhp': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/ballgobrrr': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/sameball': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/sellcoin': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/windaily': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/dealburndamage': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/shootprojectiles': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/fiveremainingballs': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/completeballmanacentries': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/killbeforebattle': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/killenemiesinround': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/winweekly': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/argpart1': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/b': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/c': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/secret': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/peacewasneveranoption': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 72, frameHeight: 24 },
        },
        'achievements/birthday': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 20, frameHeight: 20 },
        },
        'achievements/getrevenge': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        'achievements/defeatlectvs': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        'achievements/defeatmaterwelons': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        'achievements/useless': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/completetheballmanac': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'achievements/numberone': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        'achievements/bugsquad': {
            anchor: Vector2.CENTER,
            spritesheet: { frameWidth: 32, frameHeight: 32 },
        },
        // Menu
        'mainmenu': { url: 'mainmenu.lci' },
        'playmenu': { url: 'playmenu.lci' },
        'packmenu': { url: 'packmenu.lci' },
        'vsmodemenu': { url: 'vsmodemenu.lci' },
        'vssettingsmenu': { url: 'vssettingsmenu.lci' },
        'optionsmenu': { url: 'optionsmenu.lci' },
        'cloudsavemenu': { url: 'cloudsavemenu.lci' },
        'credits/1': { url: 'credits/1.lci' },
        'credits/2': { url: 'credits/2.lci' },
        'credits/3': { url: 'credits/3.lci' },
        'achievementsmenu': { url: 'achievementsmenu.lci' },
        'patchnotesmenu': { url: 'patchnotesmenu.lci' },
        'almanacmenu': { url: 'almanacmenu.lci' },
        'dailymenu': { url: 'dailymenu.lci' },
        'dailyinfomenu': { url: 'dailyinfomenu.lci' },
        'tutorial1': { url: 'tutorial/1.lci' },
        'tutorial2': { url: 'tutorial/2.lci' },
        //'tutorial3': { url: 'tutorial/3.lci' },
        'bugged': { url: 'bugged.lci' },
        'trailer/title': { url: 'trailer/title.lci' },
        'trailer/build': { url: 'trailer/build.lci' },
        'trailer/battle': { url: 'trailer/battle.lci' },
        'trailer/playfree': { url: 'trailer/playfree.lci' },
        // ARG
        'arg/lobby': { url: 'arg/lobby.lci' },
        'arg/room1': { url: 'arg/room1.lci' },
        'arg/room2': { url: 'arg/room2.lci' },
        'arg/room3': { url: 'arg/room3.lci' },
        'arg/hall': { url: 'arg/hall.lci' },
        'arg/end': { url: 'arg/end.lci' },
        'arg/keypad': { url: 'arg/keypad.lci' },
        'arg/conference': { url: 'arg/conference.lci' },
        'arg/restricted': { url: 'arg/restricted.lci' },
        'arg/area1': { url: 'arg/area1.lci' },
        'arg/area2': { url: 'arg/area2.lci' },
        'arg/area3': { url: 'arg/area3.lci' },
        'arg/area4': { url: 'arg/area4.lci' },
        'arg/area5': { url: 'arg/area5.lci' },
        'arg/hallbeta': { url: 'arg/hallbeta.lci' },
        'arg/lab': { url: 'arg/lab.lci' },
        'arg/bec': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'arg/chester': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'arg/guardian': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 28, frameHeight: 44 },
        },
        'arg/wolf': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 24, frameHeight: 24 },
        },
        'arg/doctor': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 26, frameHeight: 38 },
        },
        'arg/scientist1': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 52, frameHeight: 54 },
        },
        'arg/scientist2': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 52, frameHeight: 54 },
        },
        'arg/scientist3': {
            anchor: Vector2.BOTTOM,
            spritesheet: { frameWidth: 44, frameHeight: 44 },
        },
        'arg/key': { anchor: Vector2.BOTTOM },
        'arg/box': { anchor: Vector2.BOTTOM },
        'arg/button': { anchor: Vector2.BOTTOM, spritesheet: { frameWidth: 12, frameHeight: 12 } },
        'arg/lasergen': { anchor: Vector2.BOTTOM, frames: {
                'arg/lasergen/up': { rect: rect(0, 0, 13, 19) },
                'arg/lasergen/down': { rect: rect(13, 0, 13, 19) },
            } },
        'arg/laserrec': { anchor: vec2(0.5, 17 / 20), frames: {
                'arg/laserrec/down/off': { rect: rect(0, 0, 13, 20) },
                'arg/laserrec/down/on': { rect: rect(13, 0, 13, 20) },
                'arg/laserrec/up/off': { rect: rect(26, 0, 13, 20) },
                'arg/laserrec/up/on': { rect: rect(39, 0, 13, 20) },
            } },
        'arg/gatev': { anchor: Vector2.BOTTOM, spritesheet: { frameWidth: 32, frameHeight: 20 } },
        'arg/gateh': { anchor: Vector2.BOTTOM, spritesheet: { frameWidth: 7, frameHeight: 46 } },
        'arg/autoballs': { anchor: Vector2.BOTTOM, spritesheet: { frameWidth: 20, frameHeight: 20 } },
        'arg/cabinet': { anchor: Vector2.CENTER, frames: {
                'arg/cabinet/closed': { rect: rect(0, 0, 32, 68) },
                'arg/cabinet/open': { rect: rect(32, 0, 32, 68) },
            } },
        'arg/qr_intro': { anchor: Vector2.CENTER },
        'arg/overlay': { url: 'arg/overlay.lci' },
        'arg/desktop': { url: 'arg/desktop.lci' },
        'arg/sabtitle': { url: 'arg/sabtitle.lci' },
        'arg/sabgame': { url: 'arg/sabgame.lci' },
        'arg/ball': { anchor: Vector2.CENTER, spritesheet: { frameWidth: 14, frameHeight: 14 } },
        'arg/ffgame': { url: 'arg/ffgame.lci' },
        'arg/hook': { anchor: vec2(0.5, 128 / 132) },
        'arg/softwareerror': { anchor: Vector2.CENTER },
        'arg/fish': { anchor: Vector2.CENTER },
        'arg/fishdead': { anchor: Vector2.CENTER },
        'arg/login': { url: 'arg/login.lci' },
        'arg/phiportrait': { anchor: Vector2.CENTER },
        'arg/sessionlocked': { anchor: Vector2.CENTER },
        'arg/kayportraits': {
            anchor: Vector2.CENTER,
            frames: {
                'arg/kayportraits/default': { rect: rect(0, 0, 80, 80) },
                'arg/kayportraits/smug': { rect: rect(80, 0, 80, 80) },
                'arg/kayportraits/cheek': { rect: rect(160, 0, 80, 80) },
                'arg/kayportraits/eyeroll': { rect: rect(240, 0, 80, 80) },
                'arg/kayportraits/nervous': { rect: rect(320, 0, 80, 80) },
                'arg/kayportraits/frown': { rect: rect(400, 0, 80, 80) },
                'arg/kayportraits/blank': { rect: rect(480, 0, 80, 80) },
                'arg/kayportraits/skeptical': { rect: rect(560, 0, 80, 80) },
                'arg/kayportraits/thinkingl': { rect: rect(640, 0, 80, 80) },
                'arg/kayportraits/thinkingr': { rect: rect(720, 0, 80, 80) },
            }
        },
        // Font
        'deluxe16_extras': { spritesheet: { frameWidth: 8, frameHeight: 15 } },
        'deluxe16_touch': { spritesheet: { frameWidth: 16, frameHeight: 18 } },
        'smallnumbers_extras': { spritesheet: { frameWidth: 4, frameHeight: 6 } },
    };
    Assets.sounds = {
        // Debug
        'debug': {},
        // Menu
        'click': {},
        'menublip': {},
        'typename': {},
        'kay': {},
        'achievement': { volume: 1 },
        'wob': { url: 'blem.aac', volume: 1.5 },
        'yay': { volume: 1 },
        // General
        'shake': {},
        'shake2': { volume: 0.5 },
        'win': { volume: 0.5 },
        'lose': { volume: 0.5 },
        'draw': { volume: 0.5 },
        'countdown': {},
        'countdownfight': {},
        'pause': { volume: 0.7 },
        'unpause': { volume: 0.7 },
        'speedup': { volume: 1 },
        'impact': { volume: 1 },
        'sweep': { volume: 1 },
        'glitch': { volume: 1.5 },
        'pluckreverb': { volume: 1 },
        'ballcount': { volume: 1 },
        'ballcountreverb': { volume: 1 },
        'bookopen': { volume: 1 },
        'bookclose': { volume: 1 },
        // Shop
        'play': {},
        'sellball': {},
        'buyball': { volume: 0.6 },
        'pickupball': {},
        'putdownball': {},
        'error': {},
        'zapequip': { volume: 0.3 },
        'freeze': { volume: 1.5 },
        'unfreeze': { volume: 1 },
        'disintegrate': { volume: 0.7 },
        'charge': { volume: 0.3 },
        'windowserror': { volume: 1 },
        // Battle
        'ballhit': { volume: 0.2 },
        'hitwall': {},
        'balldie': { volume: 0.3 },
        'levelup': { volume: 0.5 },
        'implode': { volume: 0.5 },
        'buff': { volume: 0.3 },
        'shoot': { volume: 0.5 },
        'eqbreak': { volume: 0.7 },
        'spike': { volume: 0.4 },
        'steal': { volume: 1.3 },
        'zap': { volume: 0.5 },
        'cloak': { volume: 2 },
        'wub': { volume: 1, speed: 1 },
        'medkitout': {},
        'medkitheal': { volume: 0.5 },
        'medkitgrab': { volume: 0.5 },
        'diocharge': { volume: 0.7 },
        'dioboom': { volume: 0.7 },
        'cuehit': { volume: 1.5 },
        'reduce': { volume: 0.8 },
        'fireignite': { volume: 0.4 },
        'fire': { volume: 1.3 },
        'shaker': { volume: 0.7 },
        'beep': { volume: 0.5 },
        'beepbeep': { volume: 0.5 },
        'chain': { volume: 1.4 },
        'popper': { volume: 1 },
        'confetti': { volume: 1 },
        'trampoline': { volume: 1 },
        'dispenser': { volume: 2 },
        'rocket': { volume: 1 },
        'pew': { volume: 0.5 },
        'swoosh': { volume: 0.7 },
        'puff': { volume: 1 },
        'mariocoin': { volume: 0.25 },
        'splash': { volume: 0.6 },
        'scrap': { volume: 0.5 },
        'spook': { volume: 0.7 },
        'whisper': { volume: 1 },
        'stab': { volume: 0.7 },
        'slosh': { volume: 1.3 },
        'shootcannon': { volume: 0.7 },
        'stopboom': { volume: 0.7 },
        // ARG
        'arg/arg': {},
        'arg/walk': { volume: 0.7 },
        'arg/box_slide': { volume: 0.5 },
        'arg/pressureplate': { volume: 0.7 },
        'arg/laser': { volume: 0.5 },
        'arg/laser_start': { volume: 0.5 },
        'arg/securitydoor': {},
        'arg/lasergate': { volume: 0.5 },
        'arg/glitch_dialog': { volume: 0.8 },
        'arg/glitch_screen': { volume: 0.8 },
        'arg/reach': {},
        'arg/scene': {},
        'arg/bip': {},
        'arg/spark': {},
        'arg/tear': {},
        'arg/glitch_short': { volume: 0.8 },
        'arg/glitch_short_low': { volume: 0.8 },
        'arg/echo': { volume: 1 },
        'arg/pickup': { volume: 0.7 },
        'arg/unlock': { volume: 0.7 },
        'arg/riser': { volume: 0.5 },
        'arg/sight': { volume: 0.8 },
        'arg/glass': { volume: 1 },
        'arg/static': { volume: 1 },
        'arg/shot': { volume: 1.5 },
        'arg/softimpact': { volume: 2 },
        'arg/click': { volume: 1 },
        'arg/sabhurt': { volume: 0.7 },
        'arg/sabwall': { volume: 1 },
        'arg/sabpickup': { volume: 1.2 },
        'arg/sabputdown': { volume: 1.2 },
        'arg/sabselect': { volume: 1.2 },
        'arg/sabwin': { volume: 0.7 },
        'arg/sablose': { volume: 0.7 },
        'arg/sabintro1': { volume: 0.6 },
        'arg/sabintro2': { volume: 0.6 },
        'arg/sabintro3': { volume: 0.6 },
        'arg/sessionlocked': { volume: 1 },
        'arg/bubbles': {},
        'arg/tvstatic': { volume: 1 },
        // Dialog
        'dialogstart': { url: 'click.aac', volume: 0.5 },
        'dialogspeak': {},
        // Music
        'music/title': {},
        'music/shop': {},
        'music/shop2': { volume: 0.7 },
        'music/battle': {},
        'music/battle2': {},
        'arg/music_light': { volume: 0.7 },
        'arg/atmosphere': { volume: 0.7 },
        'arg/booms': { volume: 0.5 },
        'arg/computer': { volume: 1 },
        'arg/sabtitle': { volume: 0.6 },
        'arg/sabshop': { volume: 0.6 },
        'arg/sabbattle': { volume: 0.6 },
        'arg/ff': { url: 'arg/ff.wav', volume: 0.6 },
    };
    Assets.tilesets = {};
    Assets.pyxelTilemaps = {};
    Assets.fonts = {
        'deluxe16': {
            charWidth: 8,
            charHeight: 15,
            spaceWidth: 8,
            newlineHeight: 15,
            customCharacters: {
                'coin': 'deluxe16_extras/0',
                'heart': 'deluxe16_extras/1',
                'trophy': 'deluxe16_extras/2',
                'sword': 'deluxe16_extras/3',
                'lmb': 'deluxe16_extras/4',
                'rmb': 'deluxe16_extras/5',
                'star': 'deluxe16_extras/6',
                'etick': 'deluxe16_extras/7',
                'lte': 'deluxe16_extras/8',
                'clock': 'deluxe16_extras/9',
                'bullet': 'deluxe16_extras/10',
                'g1': 'deluxe16_extras/11',
                'g2': 'deluxe16_extras/12',
                'g3': 'deluxe16_extras/13',
                'g4': 'deluxe16_extras/14',
                'g5': 'deluxe16_extras/15',
                'crown': 'deluxe16_extras/16',
                'ntick': 'deluxe16_extras/17',
                'dove1': 'deluxe16_extras/18',
                'dove2': 'deluxe16_extras/19',
                'touch_hold': 'deluxe16_touch/0',
                'touch_drag': 'deluxe16_touch/1',
                'touch_tap': 'deluxe16_touch/2',
                'touch_hold_t': 'deluxe16_touch/3',
                'touch_drag_t': 'deluxe16_touch/4',
                'touch_tap_t': 'deluxe16_touch/5',
            }
        },
        'smallnumbers': {
            charWidth: 4,
            charHeight: 6,
            spaceWidth: 4,
            newlineHeight: 6,
            customCharacters: {
                'coin': 'smallnumbers_extras/0',
                'crownl': 'smallnumbers_extras/1',
                'crownr': 'smallnumbers_extras/2',
                'crown2l': 'smallnumbers_extras/3',
                'crown2r': 'smallnumbers_extras/4',
            }
        },
        'starnumbers': {
            charWidth: 8,
            charHeight: 8,
            spaceWidth: 8,
            newlineHeight: 8,
        },
    };
    Assets.customResources = {
        'blurfilter': {
            load: function () { return BlurFilter.load(); },
        },
        'arenafirstfilter': {
            load: function () { return ArenaFirstFilter.load(); },
        },
        'contagionfilter': {
            load: function () { return Equipments.Contagion.loadFilter(); },
        },
        'disintegratorfilter': {
            load: function () { return BallItems.MolecularDisassembler.loadFilter(); },
        },
    };
    Assets.spriteTextTags = {
        'dg': function () { return ({
            color: 0x007F0E,
        }); },
        'pg': function () { return ({
            color: 0x00BB00,
        }); },
        'gold': function () { return ({
            color: 0xFFD800,
        }); },
        'dgold': function () { return ({
            color: 0xE0BB00,
        }); },
        'purp': function () { return ({
            color: 0xB200FF,
        }); },
        'dr': function () { return ({
            color: 0xAA0000,
        }); },
        'rb': function () { return ({
            color: 0x0A27CC,
        }); },
        'fb': function () { return ({
            color: 0x44FFFF,
        }); },
        'pb': function () { return ({
            color: 0x22BBBB,
        }); },
        'lb': function () { return ({
            color: 0x00FFFF,
        }); },
        'w': function () { return ({
            color: 0xFFFFFF,
        }); },
        'grey': function () { return ({
            color: 0x444444,
        }); },
        'achx': function () { return ({
            offsetX: -1,
        }); },
        'verx': function () { return ({
            offsetX: 2,
        }); },
        'minorverx': function () { return ({
            offsetX: -1,
        }); },
        'glitched': function (params) {
            var _a, _b;
            return ({
                filters: [new Effects.Filters.Glitch(parseInt((_a = params[0]) !== null && _a !== void 0 ? _a : '2'), parseInt((_b = params[1]) !== null && _b !== void 0 ? _b : '4'), 2)],
            });
        },
        'tr': function (params) { return ({
            alpha: 0.1,
        }); },
        'm': function (params) { return ({
            offsetY: -3,
        }); },
    };
})(Assets || (Assets = {}));
var BallFreezer = /** @class */ (function (_super) {
    __extends(BallFreezer, _super);
    function BallFreezer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.movingTime = 0;
        return _this;
    }
    BallFreezer.prototype.update = function () {
        _super.prototype.update.call(this);
        if (IS_MOBILE) {
            this.updateFreezeMobile();
        }
        else {
            this.updateFreezePc();
        }
    };
    BallFreezer.prototype.updateFreezePc = function () {
        if (Input.justDown('rightclick')) {
            var mousePos_1 = this.world.getWorldMousePosition();
            var balls = this.world.select.typeAll(Ball);
            var ballItems = this.world.select.typeAll(BallItem);
            var hoveredBall = balls.find(function (ball) { return ball.bounds.containsPoint(mousePos_1); });
            if (!hoveredBall)
                hoveredBall = ballItems.find(function (item) { return item.bounds.containsPoint(mousePos_1); });
            if (this.canFreezeOrUnfreezeThing(hoveredBall)) {
                this.freezeOrUnfreezeThing(hoveredBall);
            }
        }
    };
    BallFreezer.prototype.updateFreezeMobile = function () {
        var ballMover = this.world.select.type(BallMover);
        if (!ballMover) {
            this.currentMovingThing = undefined;
            return;
        }
        var nextMovingThing = ballMover.movingThing;
        if (nextMovingThing === this.currentMovingThing) {
            this.movingTime += this.delta;
            return;
        }
        if (this.currentMovingThing === undefined || nextMovingThing !== undefined) {
            this.currentMovingThing = nextMovingThing;
            this.movingTime = 0;
            return;
        }
        if (this.movingTime < 0.25 && ballMover.lastMovedMovedDistance < 10 && this.currentMovingThing.world && this.currentMovingThing.isInShop && !this.currentMovingThing.hasTag(Tags.PURCHASED_THIS_SHOP_PHASE)) {
            if (this.canFreezeOrUnfreezeThing(this.currentMovingThing)) {
                this.freezeOrUnfreezeThing(this.currentMovingThing);
            }
        }
        this.currentMovingThing = undefined;
    };
    BallFreezer.prototype.canFreezeOrUnfreezeThing = function (thing) {
        return thing && (thing instanceof BallItem || thing.isInShop);
    };
    BallFreezer.prototype.freezeOrUnfreezeThing = function (thing) {
        if (thing.frozen) {
            this.world.playSound('unfreeze');
            thing.unfreeze();
        }
        else if (thing.canFreeze) {
            this.world.playSound('freeze');
            thing.freeze(false);
            GAME_DATA.hasFrozen = true;
        }
        else {
            this.world.playSound('error', { humanized: false });
            this.world.addWorldObject(new BallMoverError(thing.x, thing.y, 'CANNOT\nFREEZE'));
        }
    };
    return BallFreezer;
}(WorldObject));
var BallHighlighter = /** @class */ (function (_super) {
    __extends(BallHighlighter, _super);
    function BallHighlighter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.enabled = true;
        _this.mouseBounds = new CircleBounds(0, 0, 0);
        return _this;
    }
    BallHighlighter.prototype.update = function () {
        var e_83, _a, e_84, _b;
        _super.prototype.update.call(this);
        var mousePos = this.world.getWorldMousePosition();
        this.mouseBounds.x = mousePos.x;
        this.mouseBounds.y = mousePos.y;
        this.mouseBounds.radius = Input.mouseRadius;
        var ballMover = this.world.select.type(BallMover, false);
        var movingThing = ballMover === null || ballMover === void 0 ? void 0 : ballMover.movingThing;
        if (movingThing) {
            movingThing.changeHighlight(true, 0xBBBB00, movingThing.defaultOutlineAlpha);
        }
        var balls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== movingThing; });
        var ballItems = this.world.select.typeAll(BallItem).filter(function (item) { return item !== movingThing; });
        var hoveredBall = this.getHoveredBall(balls, ballMover);
        try {
            for (var balls_4 = __values(balls), balls_4_1 = balls_4.next(); !balls_4_1.done; balls_4_1 = balls_4.next()) {
                var ball = balls_4_1.value;
                if (ball === hoveredBall) {
                    ball.changeHighlight(this.enabled || ball.isInShop, this.enabled ? 0xFFFF00 : ball.defaultOutline, ball.defaultOutlineAlpha);
                    if (!ball.isInShop && GAME_MODE === 'mm') { // Don't do this in VS mode because the fixed delta screws up ordering for some balls like Scrap Cannon
                        World.Actions.moveWorldObjectToFront(ball);
                    }
                    ball.orderBallComponents();
                }
                else if (ball !== movingThing) {
                    ball.changeHighlight(ball.isInShop, ball.defaultOutline, ball.defaultOutlineAlpha);
                }
            }
        }
        catch (e_83_1) { e_83 = { error: e_83_1 }; }
        finally {
            try {
                if (balls_4_1 && !balls_4_1.done && (_a = balls_4.return)) _a.call(balls_4);
            }
            finally { if (e_83) throw e_83.error; }
        }
        var hoveredItem = this.getHoveredItem(ballItems);
        try {
            for (var ballItems_1 = __values(ballItems), ballItems_1_1 = ballItems_1.next(); !ballItems_1_1.done; ballItems_1_1 = ballItems_1.next()) {
                var item = ballItems_1_1.value;
                if (item === hoveredItem) {
                    item.changeHighlight(true, 0xFFFF00, item.defaultOutlineAlpha);
                }
                else if (item !== movingThing) {
                    item.changeHighlight(true, item.defaultOutline, item.defaultOutlineAlpha);
                }
            }
        }
        catch (e_84_1) { e_84 = { error: e_84_1 }; }
        finally {
            try {
                if (ballItems_1_1 && !ballItems_1_1.done && (_b = ballItems_1.return)) _b.call(ballItems_1);
            }
            finally { if (e_84) throw e_84.error; }
        }
    };
    BallHighlighter.prototype.onRemove = function () {
        var e_85, _a;
        _super.prototype.onRemove.call(this);
        var balls = this.world.select.typeAll(Ball);
        try {
            for (var balls_5 = __values(balls), balls_5_1 = balls_5.next(); !balls_5_1.done; balls_5_1 = balls_5.next()) {
                var ball = balls_5_1.value;
                ball.changeHighlight(ball.isInShop, ball.defaultOutline, ball.defaultOutlineAlpha);
            }
        }
        catch (e_85_1) { e_85 = { error: e_85_1 }; }
        finally {
            try {
                if (balls_5_1 && !balls_5_1.done && (_a = balls_5.return)) _a.call(balls_5);
            }
            finally { if (e_85) throw e_85.error; }
        }
    };
    BallHighlighter.prototype.getHoveredBall = function (balls, ballMover) {
        var _this = this;
        var movingThing = ballMover === null || ballMover === void 0 ? void 0 : ballMover.movingThing;
        if (movingThing) {
            return ballMover.getBallForApplication(movingThing);
        }
        var validBalls = balls.filter(function (ball) { return ball.bounds.isOverlapping(_this.mouseBounds); });
        return M.argmin(validBalls, function (ball) { return G.distance(ball, _this.mouseBounds); });
    };
    BallHighlighter.prototype.getHoveredItem = function (items) {
        var _this = this;
        var validItems = items.filter(function (item) { return item.bounds.isOverlapping(_this.mouseBounds); });
        return M.argmin(validItems, function (ball) { return G.distance(ball, _this.mouseBounds); });
    };
    return BallHighlighter;
}(WorldObject));
var BallLimiter = /** @class */ (function (_super) {
    __extends(BallLimiter, _super);
    function BallLimiter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.BALL_LIMIT_PER_TEAM = 25;
        return _this;
    }
    BallLimiter.prototype.postUpdate = function () {
        var e_86, _a;
        _super.prototype.postUpdate.call(this);
        var balls = this.world.select.typeAll(Ball);
        var ballsPerTeam = { 'friend': 0, 'enemy': 0 };
        try {
            for (var balls_6 = __values(balls), balls_6_1 = balls_6.next(); !balls_6_1.done; balls_6_1 = balls_6.next()) {
                var ball = balls_6_1.value;
                if (ballsPerTeam[ball.team] > this.BALL_LIMIT_PER_TEAM) {
                    this.world.addWorldObject(newPuff(ball.x, ball.y, Battle.Layers.fx, 'medium'));
                    ball.kill();
                }
                ballsPerTeam[ball.team]++;
            }
        }
        catch (e_86_1) { e_86 = { error: e_86_1 }; }
        finally {
            try {
                if (balls_6_1 && !balls_6_1.done && (_a = balls_6.return)) _a.call(balls_6);
            }
            finally { if (e_86) throw e_86.error; }
        }
    };
    return BallLimiter;
}(WorldObject));
var BallMover = /** @class */ (function (_super) {
    __extends(BallMover, _super);
    function BallMover() {
        var _this = _super.call(this) || this;
        _this.movedDistance = 0;
        _this.lastMovedMovedDistance = 0;
        _this.hasMovedFast = false;
        _this.mouseStartPos = vec2(0, 0);
        _this.movingThingStartPos = vec2(0, 0);
        _this.dragOffset = vec2(0, 0);
        _this.hoverText = _this.addChild(new SpriteText({
            text: "REPLACE",
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.drag,
            visible: false,
        }));
        return _this;
    }
    BallMover.prototype.update = function () {
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        if (Input.justDown('click') && !this.isClicked()) {
            var balls = this.world.select.typeAll(Ball);
            var ballItems = this.world.select.typeAll(BallItem);
            var hoveredBall = M.argmin(balls.filter(function (ball) { return ball.bounds.isOverlapping(mouseBounds); }), function (ball) { return G.distance(ball, mouseBounds); });
            if (!hoveredBall)
                hoveredBall = M.argmin(ballItems.filter(function (item) { return item.bounds.isOverlapping(mouseBounds); }), function (item) { return G.distance(item, mouseBounds); });
            if (hoveredBall) {
                this.world.playSound('pickupball');
                this.movingThing = hoveredBall;
                this.movingThing.colliding = false;
                this.movingThing.layer = Battle.Layers.drag;
                this.movingThingStartPos.set(this.movingThing);
                this.mouseStartPos.set(mouseBounds);
                this.dragOffset.set(mouseBounds.x - this.movingThing.x, mouseBounds.y - this.movingThing.y);
                this.movedDistance = 0;
                this.lastMovedMovedDistance = 0;
                this.hasMovedFast = false;
                this.movingThing.onPickUp();
            }
        }
        if (Input.isUp('click') && this.isClicked()) {
            this.unclick();
        }
        if (this.movingThing) {
            if (IS_MOBILE) {
                this.movedDistance = Math.max(this.movedDistance, G.distance(mouseBounds, this.mouseStartPos));
                if (this.movingThing.isInShop && this.movingThing.x < 180) {
                    this.movedDistance = Infinity;
                }
                if (this.hasMovedAwayFromStartPos()) {
                    this.movingThing.x = mouseBounds.x - this.dragOffset.x;
                    this.movingThing.y = mouseBounds.y - this.dragOffset.y;
                    if (getBigDragging()) {
                        var radius = this.movingThing instanceof Ball ? this.movingThing.physicalRadius : 8;
                        this.movingThing.setMoveScale(radius === 0 ? 2 : 16 / radius);
                        this.movingThing.alpha = 0.5;
                    }
                }
                if (!this.hasMovedFast && this.world.getWorldMouseSpeed() > 800) {
                    this.hasMovedFast = true;
                }
            }
            else {
                this.movingThing.x = mouseBounds.x - this.dragOffset.x;
                this.movingThing.y = mouseBounds.y - this.dragOffset.y;
            }
            this.lastMovedMovedDistance = this.movedDistance;
        }
        if (this.isAboutToSellBall() && this.movingThing instanceof Ball) {
            this.hoverText.x = this.movingThing.x;
            this.hoverText.y = this.movingThing.y - (IS_MOBILE ? 24 : 12);
            this.hoverText.setText("SELL <coin>" + this.movingThing.getSellValue());
            this.hoverText.style.color = Color.lerpColorByLch(0xFFD800, 0xFFFFFF, Tween.Easing.OscillateSine(2)(this.life.time));
            this.hoverText.setVisible(true);
            World.Actions.orderWorldObjectAfter(this.hoverText, this.movingThing.stars);
        }
        else if (this.isAboutToReplaceItem()) {
            this.hoverText.x = this.movingThing.x;
            this.hoverText.y = this.movingThing.y - (IS_MOBILE ? 24 : 12);
            this.hoverText.setText("REPLACE");
            this.hoverText.style.color = Color.lerpColorByLch(0xFF0000, 0xFFFFFF, Tween.Easing.OscillateSine(2)(this.life.time));
            this.hoverText.setVisible(true);
            World.Actions.orderWorldObjectAfter(this.hoverText, this.movingThing);
        }
        else {
            this.hoverText.setVisible(false);
        }
    };
    BallMover.prototype.unclick = function () {
        if (!this.isClicked())
            return;
        this.world.playSound('putdownball');
        this.movingThing.colliding = true;
        this.movingThing.layer = Battle.Layers.balls;
        this.movingThing.changeHighlight(false);
        this.movingThing.setMoveScale(1);
        this.movingThing.alpha = 1;
        if (this.movingThing instanceof BallItem) {
            var targetBall = this.getValidItemBall(this.movingThing);
            var itemMoveError = this.getItemMoveError(this.movingThing, targetBall);
            if (itemMoveError !== null) {
                if (!St.isBlank(itemMoveError)) {
                    this.world.playSound('error', { humanized: false });
                    this.world.addWorldObject(new BallMoverError(this.movingThing.x, this.movingThing.y, itemMoveError));
                }
                this.movingThing.teleport(this.movingThingStartPos);
                this.movingThing.colliding = false;
                this.movingThing.layer = Battle.Layers.ui;
            }
            else {
                ShopActions.buyBallItem(this.movingThing, targetBall);
            }
        }
        else {
            var ballMoveError = this.getBallMoveError(this.movingThing);
            if (ballMoveError !== null) {
                if (!St.isBlank(ballMoveError)) {
                    this.world.playSound('error', { humanized: false });
                    this.world.addWorldObject(new BallMoverError(this.movingThing.x, this.movingThing.y, ballMoveError));
                }
                this.movingThing.teleport(this.movingThingStartPos);
                if (this.movingThing.isInShop) {
                    this.movingThing.colliding = false;
                    this.movingThing.layer = Battle.Layers.ui;
                }
            }
            else if (this.isAboutToSellBall()) {
                this.movingThing.colliding = false;
                ShopActions.sellBall(this.movingThing);
            }
            else {
                var levelUpBall = this.getClosestBallForLevelUp(this.movingThing);
                if (this.movingThing.isInShop) {
                    ShopActions.buyBall(this.movingThing);
                    if (!levelUpBall)
                        this.movingThing.joinTeam();
                }
                if (levelUpBall) {
                    ShopActions.levelUpBall(levelUpBall, this.movingThing);
                    this.movingThing.colliding = false;
                }
            }
        }
        this.movingThing.onPutDown();
        this.movingThing = undefined;
        this.movedDistance = 0;
        this.hasMovedFast = false;
    };
    BallMover.prototype.onRemove = function () {
        _super.prototype.onRemove.call(this);
        this.unclick();
    };
    BallMover.prototype.getBallForApplication = function (movingThing) {
        if (!movingThing)
            return undefined;
        if (movingThing instanceof Ball)
            return this.getClosestBallForLevelUp(movingThing);
        return this.getValidItemBall(movingThing);
    };
    BallMover.prototype.hasMovedAwayFromStartPos = function () {
        return this.movedDistance > 4;
    };
    BallMover.prototype.isClicked = function () {
        return !!this.movingThing;
    };
    BallMover.prototype.getBallMoveError = function (movingBall) {
        if (G.rectContainsPt(BallMover.SELL_BOUNDS, movingBall)) {
            if (movingBall.isInShop || movingBall.isBeingDisintegrated)
                return "";
            else
                return null;
        }
        if (movingBall.x + movingBall.radius > this.world.width / 2)
            return "";
        var levelUpBall = this.getClosestBallForLevelUp(movingBall);
        if (levelUpBall) {
            if (levelUpBall.properties.type !== movingBall.properties.type)
                return "WRONG\nTYPE";
            if (levelUpBall.level !== movingBall.level)
                return "WRONG\nLEVEL";
        }
        if (movingBall.isInShop) {
            if (GAME_DATA.gold < movingBall.getShopCost())
                return "BROKE";
            if (levelUpBall)
                return null;
            if (GAME_DATA.squad.balls.length >= GET_MAX_SQUAD_SIZE())
                return "FULL";
        }
        if (!movingBall.isPurchasable())
            return "";
        return null;
    };
    BallMover.prototype.getItemMoveError = function (movingItem, targetBall) {
        if (!targetBall)
            return "";
        if (GAME_DATA.gold < movingItem.getShopCost())
            return "BROKE";
        if (!movingItem.canApplyToBall(targetBall))
            return "CANNOT APPLY";
        if (!movingItem.isPurchasable())
            return "";
        return null;
    };
    BallMover.prototype.getClosestBallForLevelUp = function (withBall) {
        var balls = this.world.select.typeAll(Ball)
            .filter(function (ball) { return ball !== withBall
            && ball.squadIndexReference >= 0
            && ball.team === 'friend'
            && !ball.isBeingDisintegrated
            && ball.applyBounds.containsPoint(withBall); });
        return M.argmin(balls, function (ball) { return G.distance(ball, withBall); });
    };
    BallMover.prototype.getValidItemBall = function (withItem) {
        var balls = this.world.select.typeAll(Ball)
            .filter(function (ball) { return ball.team === 'friend'
            && !ball.isBeingDisintegrated
            && ball.applyBounds.containsPoint(withItem); });
        return M.argmin(balls, function (ball) { return G.distance(ball, withItem); });
    };
    BallMover.prototype.isAboutToReplaceItem = function () {
        if (!this.movingThing)
            return false;
        if (!(this.movingThing instanceof BallItem))
            return false;
        var targetBall = this.getValidItemBall(this.movingThing);
        return targetBall && this.movingThing.isAboutToReplace(targetBall);
    };
    BallMover.prototype.isAboutToSellBall = function () {
        if (!this.movingThing)
            return false;
        if (!(this.movingThing instanceof Ball))
            return false;
        return !this.movingThing.isInShop && G.rectContainsPt(BallMover.SELL_BOUNDS, this.movingThing);
    };
    BallMover.SELL_BOUNDS = rect(175, 186, 42, 42);
    return BallMover;
}(WorldObject));
var ballTextureCache = {};
function getBallTextures(base) {
    if (base in ballTextureCache)
        return ballTextureCache[base];
    var baseTexture = AssetCache.getTexture(base);
    if (!baseTexture)
        return [];
    var ballRollFilter = new BallRollFilter();
    var textures = [];
    for (var i = 0; i < 20; i++) {
        ballRollFilter.angle = 2 * Math.PI / 20 * i;
        textures.push(baseTexture.transform({ filters: [ballRollFilter] }, 'getBallTextures'));
    }
    ballTextureCache[base] = textures;
    return textures;
}
var BallRollFilter = /** @class */ (function (_super) {
    __extends(BallRollFilter, _super);
    function BallRollFilter() {
        var _this = _super.call(this, {
            uniforms: { 'float angle': 0 },
            code: "\n                if (0.0 <= y && y <= height) {\n                    float pixel = angle / TWOPI * height;\n                    outp = getColor(x, mod(y + pixel, height));\n                }\n            "
        }) || this;
        _this._angle = 0;
        return _this;
    }
    Object.defineProperty(BallRollFilter.prototype, "angle", {
        get: function () { return this._angle; },
        set: function (value) {
            if (this._angle !== value)
                this.setUniform('angle', value);
            this._angle = value;
        },
        enumerable: false,
        configurable: true
    });
    return BallRollFilter;
}(TextureFilter));
var BallTeamColorFilter = /** @class */ (function (_super) {
    __extends(BallTeamColorFilter, _super);
    function BallTeamColorFilter(color) {
        return _super.call(this, {
            uniforms: { 'vec3 color': M.colorToVec3(color) },
            code: "\n                vec3 normalColor = vec3(1.0, 1.0, 1.0) * 128.0 / 255.0;\n                if (abs(outp.r - normalColor.r) <= 0.016 && abs(outp.g - normalColor.g) <= 0.016 && abs(outp.b - normalColor.b) <= 0.016) {\n                    outp.rgb = color;\n                }\n\n                vec3 darkColor = vec3(1.0, 1.0, 1.0) * 64.0 / 255.0;\n                if (abs(outp.r - darkColor.r) <= 0.016 && abs(outp.g - darkColor.g) <= 0.016 && abs(outp.b - darkColor.b) <= 0.016) {\n                    outp.rgb = mix(color, vec3(0.0, 0.0, 0.0), 0.5);\n                }\n\n                vec3 lightColor = vec3(1.0, 1.0, 1.0) * 191.0 / 255.0;\n                if (abs(outp.r - lightColor.r) <= 0.016 && abs(outp.g - lightColor.g) <= 0.016 && abs(outp.b - lightColor.b) <= 0.016) {\n                    outp.rgb = mix(color, vec3(1.0, 1.0, 1.0), 0.5);\n                }\n            "
        }) || this;
    }
    BallTeamColorFilter.prototype.setColor = function (color) {
        this.setUniform('color', M.colorToVec3(color));
    };
    return BallTeamColorFilter;
}(TextureFilter));
var Battle;
(function (Battle) {
    Battle.Layers = {
        bg: 'bg',
        ground: 'ground',
        onground: 'onground',
        walls: 'walls',
        balls: 'balls',
        fx: 'fx',
        fg: 'fg',
        playernames: 'playernames',
        ui: 'ui',
        drag: 'drag',
        infobox: 'infobox',
        warning: 'warning',
    };
    Battle.PhysicsGroups = {
        walls: 'walls',
        balls: 'balls',
        balls_ethereal: 'balls_ethereal',
        droppables: 'droppables',
    };
})(Battle || (Battle = {}));
var BattleSpeedController = /** @class */ (function (_super) {
    __extends(BattleSpeedController, _super);
    function BattleSpeedController() {
        var _this = _super.call(this, {
            useGlobalTime: true,
        }) || this;
        _this.paused = false;
        _this.speed = 1;
        _this.enabled = true;
        _this.endOfGame = false;
        _this.touchTime = 0;
        _this.producedTimescale = 1;
        return _this;
    }
    BattleSpeedController.prototype.update = function () {
        var _a;
        _super.prototype.update.call(this);
        var world = (_a = global.theater.currentWorld) !== null && _a !== void 0 ? _a : this.world;
        if (this.enabled) {
            if (IS_MOBILE) {
                this.updateSpeedMobile(world);
            }
            else {
                this.updateSpeedPc(world);
            }
            var targetSpeed = this.paused ? 0 : this.speed;
            this.producedTimescale = M.lerpTime(this.producedTimescale, targetSpeed, 10, global.game.delta);
        }
    };
    BattleSpeedController.prototype.getProducedTimescale = function () {
        if (this.enabled)
            return this.producedTimescale;
        return 1;
    };
    BattleSpeedController.prototype.reset = function () {
        this.paused = false;
        this.speed = 1;
        this.producedTimescale = 1;
        this.enabled = false;
    };
    BattleSpeedController.prototype.canControl = function (world) {
        if (!world)
            return false;
        if (world.select.modules(Button).some(function (button) { return button.isHovered(); }))
            return false;
        return true;
    };
    BattleSpeedController.prototype.updateSpeedPc = function (world) {
        if (!this.canControl(world))
            return;
        if (Input.justDown('pausebattle')) {
            this.pause(world);
        }
        if (Input.justDown('speedupbattle')) {
            this.speedUp();
        }
    };
    BattleSpeedController.prototype.updateSpeedMobile = function (world) {
        if (!this.canControl(world))
            return;
        if (Input.isDown('lmb')) {
            var lastTouchTime = this.touchTime;
            this.touchTime += this.delta;
            var infoBox = world.select.type(InfoBox, false);
            var infoBoxTriggering = infoBox === null || infoBox === void 0 ? void 0 : infoBox.isTriggering;
            var speedUpRate = 3;
            if ((getBattleState(world) === Ball.States.BATTLE || !infoBoxTriggering) && !this.paused && this.touchTime > 1 / speedUpRate && Math.floor(lastTouchTime * speedUpRate) !== Math.floor(this.touchTime * speedUpRate)) {
                this.speedUp();
            }
            return;
        }
        if (this.touchTime === 0)
            return;
        if (this.touchTime < 0.33) {
            this.pause(world);
            this.touchTime = 0;
            return;
        }
        this.touchTime = 0;
    };
    BattleSpeedController.prototype.pause = function (world) {
        this.paused = !this.paused;
        this.speed = 1;
        if (this.paused) {
            world.select.typeAll(Ball).forEach(function (ball) { return ball.showAllStats(); });
            global.game.musicManager.pauseMusic();
            global.theater.playSound('pause', { humanized: false });
        }
        else {
            if (getBattleState(world) === Ball.States.BATTLE) {
                world.select.typeAll(Ball).forEach(function (ball) { return ball.hideAllStats(); });
            }
            global.game.musicManager.unpauseMusic();
            global.theater.playSound('unpause', { humanized: false });
        }
        this.flashSprite('pause');
    };
    BattleSpeedController.prototype.speedUp = function () {
        this.paused = false;
        if (this.speed < 4) {
            this.speed++;
            this.flashSprite('fastforward');
            global.game.musicManager.unpauseMusic();
            global.theater.playSound('speedup', { humanized: false });
        }
    };
    BattleSpeedController.prototype.flashSprite = function (texture) {
        global.theater.addWorldObject(new Sprite({
            x: global.gameWidth / 2, y: global.gameHeight / 2,
            texture: texture,
            layer: Theater.LAYER_SLIDES,
            life: 0.5,
            update: function () {
                this.alpha = 1 - this.life.progress;
            },
        }));
    };
    return BattleSpeedController;
}(WorldObject));
var BattleTimer = /** @class */ (function (_super) {
    __extends(BattleTimer, _super);
    function BattleTimer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BattleTimer.prototype, "battleTime", {
        get: function () { return this.life.time; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BattleTimer.prototype, "battleTimeForArenaShrink", {
        get: function () { return getModifierArenaShrinkStartTime() + this.battleTime * getModifierArenaShrinkTimeScale(); },
        enumerable: false,
        configurable: true
    });
    return BattleTimer;
}(WorldObject));
var BdayBallTrail = /** @class */ (function (_super) {
    __extends(BdayBallTrail, _super);
    function BdayBallTrail() {
        var _this = _super.call(this, {
            texture: new BasicTexture(global.gameWidth, global.gameHeight, 'BdayBallTrail.texture'),
            layer: Battle.Layers.onground,
            effects: { post: { filters: [new BdayBallTrail.RenderFilter()] } },
        }) || this;
        _this.filter = new BdayBallTrail.ConstantAlphaFilter();
        _this.oldTexture = new BasicTexture(global.gameWidth, global.gameHeight, 'BdayBallTrail.oldTexture');
        return _this;
    }
    BdayBallTrail.prototype.update = function () {
        var e_87, _a;
        _super.prototype.update.call(this);
        this.filter.delta = this.delta;
        this.oldTexture.clear();
        this.getTexture().renderTo(this.oldTexture, { filters: [this.filter] });
        var newTexture = this.oldTexture;
        this.oldTexture = this.getTexture();
        this.setTexture(newTexture);
        var balls = this.world.select.typeAll(Ball).filter(function (ball) { return ball.state === 'battle'; });
        try {
            for (var balls_7 = __values(balls), balls_7_1 = balls_7.next(); !balls_7_1.done; balls_7_1 = balls_7.next()) {
                var ball = balls_7_1.value;
                Draw.brush.color = 0x89700D;
                Draw.brush.alpha = 1;
                Draw.circleSolid(newTexture, ball.x, ball.y, ball.physicalRadius * Random.float(0.25, 0.5));
            }
        }
        catch (e_87_1) { e_87 = { error: e_87_1 }; }
        finally {
            try {
                if (balls_7_1 && !balls_7_1.done && (_a = balls_7.return)) _a.call(balls_7);
            }
            finally { if (e_87) throw e_87.error; }
        }
        this.setTexture(newTexture);
    };
    return BdayBallTrail;
}(Sprite));
(function (BdayBallTrail) {
    var ConstantAlphaFilter = /** @class */ (function (_super) {
        __extends(ConstantAlphaFilter, _super);
        function ConstantAlphaFilter() {
            return _super.call(this, {
                uniforms: { 'float delta': 0 },
                code: "\n                    float speed = 2.0;\n                    outp.a = max(0.0, inp.a - speed*delta * map(inp.a, 1.0, 0.0, 0.5, 1.0));\n                "
            }) || this;
        }
        Object.defineProperty(ConstantAlphaFilter.prototype, "delta", {
            set: function (v) {
                this.setUniform('delta', v);
            },
            enumerable: false,
            configurable: true
        });
        return ConstantAlphaFilter;
    }(TextureFilter));
    BdayBallTrail.ConstantAlphaFilter = ConstantAlphaFilter;
    var RenderFilter = /** @class */ (function (_super) {
        __extends(RenderFilter, _super);
        function RenderFilter() {
            return _super.call(this, {
                uniforms: { 'vec3 baseColor': M.colorToVec3(0x896E00), 'vec3 topColor': M.colorToVec3(0xA08310), 'vec3 bottomColor': M.colorToVec3(0xFFE14F) },
                code: "\n                    if (inp.a > 0.0) {\n                        if (getColor(x, y-1.0).a == 0.0) {\n                            outp.rgb = topColor;\n                            outp.a = 0.5;\n                        } else if (getColor(x, y+1.0).a == 0.0) {\n                            outp.rgb = bottomColor;\n                            outp.a = 0.5;\n                        } else {\n                            outp.rgb = baseColor;\n                            outp.a = 0.5;\n                        }\n                    }\n                "
            }) || this;
        }
        return RenderFilter;
    }(TextureFilter));
    BdayBallTrail.RenderFilter = RenderFilter;
})(BdayBallTrail || (BdayBallTrail = {}));
var BdayShower = /** @class */ (function (_super) {
    __extends(BdayShower, _super);
    function BdayShower() {
        var _this = _super.call(this) || this;
        _this.addTimer(0.3, function () { return _this.addEmoji(); }, Infinity);
        return _this;
    }
    BdayShower.prototype.addEmoji = function () {
        this.world.addWorldObject(new Sprite({
            x: Random.float(20, global.gameWidth - 20), y: -20,
            texture: "bdayemojis/" + Random.int(0, 3),
            vy: 100,
            gravityy: 100,
            life: 1,
            update: function () {
                this.alpha = M.lerp(1, 0, this.life.progress);
            }
        }));
    };
    return BdayShower;
}(WorldObject));
var BlurFilter = /** @class */ (function (_super) {
    __extends(BlurFilter, _super);
    function BlurFilter(strength) {
        var _this = this;
        var samples_f = "40.0";
        _this = _super.call(this, {
            uniforms: {
                'float strength': strength,
            },
            code: "\n                outp = vec4(0.0, 0.0, 0.0, 0.0);\n                for (float angle = 0.0; angle < 2.0*PI; angle += PI/2.0/" + samples_f + ") {\n                    float distance = 0.0;\n                    for (float i = 0.0; i < " + samples_f + "; i++) {\n                        distance += strength / " + samples_f + ";\n                        outp += getColor(clamp(x + distance * cos(angle), 0.0, width-1.0), clamp(y + distance * sin(angle), 0.0, height-1.0));\n                    }\n                }\n                outp /= 4.0 * " + samples_f + " * " + samples_f + ";\n            "
        }) || this;
        _this._strength = strength;
        return _this;
    }
    Object.defineProperty(BlurFilter.prototype, "strength", {
        get: function () { return this._strength; },
        set: function (value) {
            this._strength = value;
            this.setUniform('strength', value);
        },
        enumerable: false,
        configurable: true
    });
    BlurFilter.load = function () {
        Texture.EFFECT_ONLY.renderTo(new BasicTexture(1, 1, 'BlurFilter.load'), { filters: [new BlurFilter(26.7)] });
    };
    return BlurFilter;
}(TextureFilter));
var BoundsInfoBox = /** @class */ (function (_super) {
    __extends(BoundsInfoBox, _super);
    function BoundsInfoBox(anchor, floatTime) {
        var _this = _super.call(this, {
            useGlobalTime: true,
            visible: false,
        }) || this;
        _this.enabled = true;
        _this.anchor = vec2(anchor);
        _this.text = _this.addChild(new SpriteText({
            anchor: Vector2.CENTER,
            justify: 'center',
            copyFromParent: ['layer'],
        }));
        _this.floatTimer = new Timer(floatTime, function () { return _this.setVisible(true); });
        return _this;
    }
    BoundsInfoBox.prototype.update = function () {
        var _a;
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        var objects = this.world.select.overlap(mouseBounds).filter(function (obj) { return obj.data.infoBoxDescription; });
        var closestObject = M.argmin(objects, function (obj) { return G.distance(obj, mouseBounds); });
        var desc = this.enabled ? (_a = closestObject === null || closestObject === void 0 ? void 0 : closestObject.data) === null || _a === void 0 ? void 0 : _a.infoBoxDescription : undefined;
        if (desc) {
            this.text.setText(desc);
            var width = this.text.getTextWidth() + 2 * BoundsInfoBox.PADDING.x;
            var height = this.text.getTextHeight() + 2 * BoundsInfoBox.PADDING.y - 1;
            this.setTexture(InfoBox.getTextureForSize(width, height));
            var ax = M.map(this.anchor.x, 0, 1, 1, -1);
            var ay = M.map(this.anchor.y, 0, 1, 1, -1);
            var extraMove = IS_MOBILE ? 20 : 0;
            this.x = mouseBounds.x + ax * width / 2 + ax * extraMove;
            this.y = mouseBounds.y + ay * height / 2 + ay * extraMove;
            this.floatTimer.update(this.delta);
        }
        else {
            this.setVisible(false);
            this.floatTimer.reset();
        }
        this.keepOnScreen();
    };
    BoundsInfoBox.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.moveWorldObjectToFront(this);
        World.Actions.moveWorldObjectToFront(this.text);
    };
    BoundsInfoBox.prototype.keepOnScreen = function () {
        var width = this.getTexture().width;
        var height = this.getTexture().height;
        this.x = M.clamp(this.x, width / 2, global.gameWidth - width / 2);
        this.y = M.clamp(this.y, height / 2, global.gameHeight - height / 2);
    };
    BoundsInfoBox.PADDING = vec2(8, 4);
    return BoundsInfoBox;
}(Sprite));
var BugChecker = /** @class */ (function (_super) {
    __extends(BugChecker, _super);
    function BugChecker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BugChecker.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!youArePlaying(this.world))
            return;
        var allies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend' && !ball.isInShop; });
        if (!GAME_DATA.hasBuggedSquad && allies.filter(function (ball) { return ball.equipment && ball.equipment instanceof Equipments.TheBug; }).length >= 5) {
            GAME_DATA.hasBuggedSquad = true;
            updateAchievementProgress('BugSquad', function (p) { return p + 1; });
            var world_1 = this.world;
            this.kill();
            global.game.stopMusic();
            global.theater.playSound('windowserror');
            global.theater.loadStage(function () { return bugWorld(world_1); });
        }
    };
    return BugChecker;
}(WorldObject));
function bugWorld(oldWorld) {
    var world = new World({
        allowPause: false,
    });
    world.addWorldObject(new Sprite({
        texture: oldWorld.takeSnapshot(),
        effects: { post: { filters: [new TextureFilter({ code: "outp.rgb = round(outp.rgb*4.0)/4.0;" })] } },
    }));
    world.addWorldObjects(lciDocumentToWorldObjects('bugged'));
    var _a = world.select.names(Sprite, 'window', 'yes', 'no', 'ack'), window = _a.window, yes = _a.yes, no = _a.no, ack = _a.ack;
    ack.setVisible(false);
    yes.addModule(new Button({
        hoverTint: 0xBBBBBB,
        clickTint: 0x888888,
        onClick: function () {
            global.game.playSound('click');
            global.theater.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world.removeWorldObjects(A.clone(world.worldObjects));
                            return [4 /*yield*/, S.wait(0.6)];
                        case 1:
                            _a.sent();
                            global.game.loadMainMenu();
                            return [2 /*return*/];
                    }
                });
            });
        },
    }));
    no.addModule(new Button({
        hoverTint: 0xBBBBBB,
        clickTint: 0x888888,
        onClick: function () {
            global.game.playSound('click');
            global.theater.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world.removeWorldObjects([window, yes, no]);
                            ack.setVisible(true);
                            return [4 /*yield*/, S.wait(1.8)];
                        case 1:
                            _a.sent();
                            global.theater.loadStage(function () { return oldWorld; });
                            return [2 /*return*/];
                    }
                });
            });
        },
    }));
    return world;
}
var BulgeFilter = /** @class */ (function (_super) {
    __extends(BulgeFilter, _super);
    function BulgeFilter(bulgeAmount, radiusScale) {
        if (radiusScale === void 0) { radiusScale = 1; }
        var _this = _super.call(this, {
            uniforms: { 'float bulgeAmount': bulgeAmount, 'float radiusScale': radiusScale },
            code: "\n                float dx = x - width/2.0;\n                float dy = y - height/2.0;\n                float distance = sqrt(dx*dx + dy*dy) + 0.00001;\n\n                float radius = max(width/2.0, height/2.0);\n\n                float bulgeFactor = max(distance / radius, pow(distance / radius / radiusScale, 1.0 - bulgeAmount) * radiusScale);\n\n                float newX = width/2.0 + dx * radius * bulgeFactor / distance;\n                float newY = height/2.0 + dy * radius * bulgeFactor / distance;\n\n                outp = getColor(mod(newX, width), mod(newY, height));\n            "
        }) || this;
        _this._bulgeAmount = bulgeAmount;
        return _this;
    }
    Object.defineProperty(BulgeFilter.prototype, "bulgeAmount", {
        get: function () { return this._bulgeAmount; },
        set: function (v) {
            if (this._bulgeAmount === v)
                return;
            this._bulgeAmount = v;
            this.setUniform('bulgeAmount', v);
        },
        enumerable: false,
        configurable: true
    });
    return BulgeFilter;
}(TextureFilter));
var DEFAULT_SHEENS = {
    howToPlay: '0.0.0',
    unlockables: '0.0.0',
    almanac: '0.0.0',
    discord: '0.0.0',
    twitter: '0.0.0',
    patchNotes: '0.0.0',
};
var SHEENS_LAST_UPDATED = {
    howToPlay: '1.1.0',
    unlockables: '1.4.2',
    almanac: '1.4.2',
    discord: '1.4.2',
    twitter: '1.4,2',
    patchNotes: '1.4.2',
};
function shouldSheen(sheen) {
    var sheens = loadSheens();
    if (!sheens[sheen] || !SHEENS_LAST_UPDATED[sheen])
        return false;
    return API.cmpFormattedVersions(sheens[sheen], SHEENS_LAST_UPDATED[sheen]) < 0;
}
function setSheenSeen(sheen, seen) {
    var sheens = loadSheens();
    sheens[sheen] = seen ? API.VISIBLE_CORE_VERSION + "." + API.VISIBLE_MAJOR_VERSION + "." + API.VISIBLE_MINOR_VERSION : '0.0.0';
    saveSheens(sheens);
}
var CenterBlackHole = /** @class */ (function (_super) {
    __extends(CenterBlackHole, _super);
    function CenterBlackHole(x, y, gravityFactor) {
        var _this = _super.call(this, { x: x, y: y }) || this;
        _this.gravityFactor = gravityFactor;
        return _this;
    }
    return CenterBlackHole;
}(WorldObject));
var Cheat = {
    win: function () {
        global.world.removeWorldObjects(global.world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'enemy'; }));
    },
    lose: function () {
        global.world.removeWorldObjects(global.world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend'; }));
    },
    draw: function () {
        global.world.removeWorldObjects(global.world.select.typeAll(Ball));
    },
    victory: function () {
        GAME_DATA.wins = 7;
        Cheat.win();
    },
    gameover: function () {
        GAME_DATA.health = 1;
        Cheat.lose();
    },
    invincible: function () {
        global.world.select.typeAll(Ball).forEach(function (ball) { return ball.hp = ball.maxhp = 10000; });
    },
    reset: function () {
        global.world.select.typeAll(Ball).forEach(function (ball) { return ball.hp = ball.maxhp = 6; });
    },
    round: function (r) {
        GAME_DATA.round = r;
        GAME_DATA.gold = 100;
    },
};
Object.defineProperty(window, 'GOLD', {
    get: function () { return GAME_DATA.gold; },
    set: function (v) { return GAME_DATA.gold = v; },
});
Object.defineProperty(window, 'ROUND', {
    get: function () { return GAME_DATA.round; },
    set: function (v) { return GAME_DATA.round = v; },
});
var CloudSave = /** @class */ (function () {
    function CloudSave() {
    }
    CloudSave.load = function () {
        var _this = this;
        var saveInfo = getSaveInfo();
        if (!saveInfo) {
            debug('No save info specified, skipping load from cloud');
            this.hasLoaded = true;
            return;
        }
        "modded_remove_from";
        API.getsave(function (getSaveResponse, err) {
            _this.hasLoaded = true;
            if (err) {
                console.error('Error loading save from cloud:', err);
                return;
            }
            mergeCloudSaveDataEncodedToLocal(getSaveResponse.saveData);
            setSaveTime(getSaveResponse.saveTime);
            debug('Loaded save from cloud');
        }, saveInfo.saveId, Persistence.getProfileId());
        "modded_remove_to";
    };
    CloudSave.save = function () {
        var _a;
        var saveId = (_a = getSaveInfo()) === null || _a === void 0 ? void 0 : _a.saveId;
        if (!saveId) {
            console.error('Error saving to cloud: No save id');
            return;
        }
        "modded_remove_from";
        API.getsave(function (getSaveResponse, err) {
            if (err) {
                console.error('Error loading save from cloud:', err);
                return;
            }
            debug('Got save data from cloud for save():', decodeCloudSaveData(getSaveResponse.saveData));
            var dataToSave = mergeLocalToCloudSaveDataEncoded(getSaveResponse.saveData);
            debug('Merged local data for save():', decodeCloudSaveData(dataToSave));
            API.save(function (saveResponse, err) {
                if (err) {
                    console.error('Error saving to cloud:', err);
                    return;
                }
                if (getSaveInfo())
                    setSaveTime(saveResponse.saveTime);
                debug('Saved to cloud');
            }, saveId, dataToSave, loadName(), Persistence.getProfileId());
        }, saveId, Persistence.getProfileId());
        "modded_remove_to";
    };
    CloudSave.hasLoaded = false;
    return CloudSave;
}());
var COMPLETE_ALMANAC_CUTSCENE = {
    script: function () {
        var line1, line2, line3, line4, done, mm;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, S.fadeOut(0)];
                case 1:
                    _a.sent();
                    global.theater.playSound('shake', { humanized: false });
                    global.game.stopMusic();
                    global.theater.loadStage(function () { return new World(); });
                    return [4 /*yield*/, S.wait(5)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, S.fadeSlides(0)];
                case 3:
                    _a.sent();
                    line1 = global.world.addWorldObject(new SpriteText({
                        x: global.world.width / 2, y: 30,
                        text: "You did it, you overcame Auto Balls' ultimate challenge!",
                        maxWidth: 280,
                        anchor: Vector2.CENTER,
                        justify: 'center',
                        style: { color: 0xFFFFFF },
                        alpha: 0,
                    }));
                    line2 = global.world.addWorldObject(new SpriteText({
                        x: global.world.width / 2, y: 90,
                        text: "I can't overstate how much I appreciate you playing to this end. Players like you make game making feel worth it!",
                        maxWidth: 280,
                        anchor: Vector2.CENTER,
                        justify: 'center',
                        style: { color: 0xFFFFFF },
                        alpha: 0,
                    }));
                    line3 = global.world.addWorldObject(new SpriteText({
                        x: global.world.width / 2, y: 165,
                        text: "From the bottom of my heart, thank you for playing Auto Balls. I hope you continue to enjoy racking up those wins. :)",
                        maxWidth: 280,
                        anchor: Vector2.CENTER,
                        justify: 'center',
                        style: { color: 0xFFFFFF },
                        alpha: 0,
                    }));
                    line4 = global.world.addWorldObject(new SpriteText({
                        x: global.world.width / 2, y: 220,
                        text: "~ lectvs",
                        maxWidth: 280,
                        anchor: Vector2.CENTER,
                        justify: 'center',
                        style: { color: 0xFFFFFF },
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.tween(2, line1, 'alpha', 0, 1)];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, S.wait(0.5)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, S.tween(2, line2, 'alpha', 0, 1)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, S.wait(0.5)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, S.tween(2, line3, 'alpha', 0, 1)];
                case 8:
                    _a.sent();
                    return [4 /*yield*/, S.wait(0.5)];
                case 9:
                    _a.sent();
                    return [4 /*yield*/, S.tween(2, line4, 'alpha', 0, 1)];
                case 10:
                    _a.sent();
                    return [4 /*yield*/, S.wait(0.5)];
                case 11:
                    _a.sent();
                    return [4 /*yield*/, S.wait(2)];
                case 12:
                    _a.sent();
                    done = false;
                    mm = global.world.addWorldObject(new MenuTextButton({
                        x: 226, y: 222,
                        text: "Main Menu >",
                        style: { color: 0x888888 },
                        hoverColor: 0x555555,
                        alpha: 0,
                        onClick: function () {
                            global.game.playSound('click');
                            done = true;
                            this.enabled = false;
                        }
                    }));
                    return [4 /*yield*/, S.tween(1, mm, 'alpha', 0, 1)];
                case 13:
                    _a.sent();
                    return [4 /*yield*/, S.waitUntil(function () { return done; })];
                case 14:
                    _a.sent();
                    return [4 /*yield*/, S.fadeOut(1.5)];
                case 15:
                    _a.sent();
                    return [4 /*yield*/, S.wait(2)];
                case 16:
                    _a.sent();
                    saveSeenAlmanacComplete(true);
                    global.game.loadMainMenu();
                    return [2 /*return*/];
            }
        });
    }
};
function createVsGame(world, settings) {
    return function () {
        var fade, createVsGameText, createVsGameSpinner, frameRate, hostPacks, nonhostPacks, gameid, err, callDone, startTime, totalTime;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    global.game.allowPauseWithPauseKey = false;
                    world.select.modules(Button).forEach(function (button) { return button.enabled = false; });
                    fade = world.addWorldObject(new Sprite({
                        texture: Texture.filledRect(world.width, world.height, 0x000000, 0.85),
                        alpha: 0,
                    }));
                    createVsGameText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: global.gameHeight / 2 - 60,
                        text: 'Creating a game...',
                        anchor: Vector2.CENTER,
                        alpha: 0,
                    }));
                    createVsGameSpinner = world.addWorldObject(new Spinner(world.width / 2, global.gameHeight / 2, 4, 16));
                    createVsGameSpinner.alpha = 0;
                    return [4 /*yield*/, S.doOverTime(1, function (t) {
                            fade.alpha = t;
                            createVsGameText.alpha = t;
                            createVsGameSpinner.alpha = t;
                            if (global.game.musicManager.currentMusic) {
                                global.game.musicManager.currentMusic.volume = 1 - 0.5 * t;
                            }
                        })];
                case 1:
                    _a.sent();
                    frameRate = Persistence.getAverageFrameRate();
                    hostPacks = settings.hostPack === PACK_ALL_ID ? OFFICIAL_PACKS : [settings.hostPack];
                    nonhostPacks = settings.nonhostPack === PACK_ALL_ID ? OFFICIAL_PACKS : [settings.nonhostPack];
                    callDone = false;
                    API.createvsgame(function (_gameid, e) {
                        gameid = _gameid;
                        err = e;
                        callDone = true;
                        debug('Got VS gameid:', gameid);
                    }, loadName(), settings.startHealth, getAvailableBallTypesOnlyUnlocked(), getAvailableItemTypesOnlyUnlocked(), frameRate === 0 ? 1 / 60 : 1 / frameRate, Persistence.getProfileId(), settings.startRound, settings.startGameGold, settings.startRoundGold, settings.maxSquadSize, settings.timeLimit, settings.speedCap, settings.arena, hostPacks, nonhostPacks);
                    startTime = Date.now();
                    return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                case 2:
                    _a.sent();
                    if (!callDone) {
                        err = ERROR_TIMED_OUT;
                    }
                    totalTime = Random.int(500, 1000);
                    return [4 /*yield*/, S.waitUntil(function () { return Date.now() - startTime > totalTime; })];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            createVsGameText.alpha = 1 - t;
                        })];
                case 4:
                    _a.sent();
                    createVsGameText.kill();
                    if (!err) return [3 /*break*/, 6];
                    return [4 /*yield*/, createVsGameError(world, fade)];
                case 5:
                    _a.sent();
                    return [3 /*break*/, 8];
                case 6: return [4 /*yield*/, waitForJoinVsGame(world, gameid)];
                case 7:
                    _a.sent();
                    _a.label = 8;
                case 8: return [2 /*return*/];
            }
        });
    };
}
function waitForJoinVsGame(world, gameid) {
    return function () {
        var codeText, waitingForJoinText, errorText, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    codeText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: global.gameHeight / 2 - 60,
                        text: gameid,
                        anchor: Vector2.CENTER,
                        scale: 3,
                        alpha: 0,
                    }));
                    waitingForJoinText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: global.gameHeight / 2 + 52,
                        text: 'Waiting for another player\nto join with the code above...',
                        anchor: Vector2.TOP_CENTER,
                        justify: 'center',
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.doOverTime(1, function (t) {
                            codeText.alpha = t;
                            waitingForJoinText.alpha = t;
                            if (global.game.musicManager.currentMusic) {
                                global.game.musicManager.currentMusic.volume = 1 - 0.5 * t;
                            }
                        })];
                case 1:
                    _a.sent();
                    world.runScript(function () {
                        var backButton;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, S.wait(3)];
                                case 1:
                                    _a.sent();
                                    backButton = world.addWorldObject(new MenuTextButton({
                                        x: 4, y: global.gameHeight - 18,
                                        text: "\\< back",
                                        alpha: 0,
                                        onClick: function () {
                                            global.theater.loadStage(function () { return VSModeScreen.STAGE(loadVsSettings()); });
                                        }
                                    }));
                                    return [4 /*yield*/, S.doOverTime(1, function (t) { return backButton.alpha = M.lerp(0, 1, t); })];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                    errorText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 220,
                        anchor: Vector2.CENTER,
                        style: { color: 0x888888 },
                    }));
                    result = {};
                    return [4 /*yield*/, GameFragments.waitForVSGameCondition(gameid, loadName(), false, function (game) { return game.enemyname; }, result, function (err) { return errorText.setText(err ? 'An error occurred' : ''); })];
                case 2:
                    _a.sent();
                    GameFragments.startVsGame(gameid, result.game, true, false);
                    return [2 /*return*/];
            }
        });
    };
}
function createVsGameError(world, fade) {
    return function () {
        var spinner, foundOpponentTextTop, foundOpponentTextBottom;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    spinner = world.select.type(Spinner);
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            spinner.alpha = 1 - t;
                        })];
                case 1:
                    _a.sent();
                    spinner.kill();
                    foundOpponentTextTop = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 110,
                        text: 'Failed to create game :(',
                        anchor: Vector2.CENTER,
                        alpha: 0,
                    }));
                    foundOpponentTextBottom = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 130,
                        text: 'Please try again!',
                        anchor: Vector2.CENTER,
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            foundOpponentTextTop.alpha = t;
                            foundOpponentTextBottom.alpha = t;
                        })];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, S.wait(2)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            fade.alpha = 1 - t;
                            foundOpponentTextTop.alpha = 1 - t;
                            foundOpponentTextBottom.alpha = 1 - t;
                        })];
                case 4:
                    _a.sent();
                    fade.kill();
                    foundOpponentTextTop.kill();
                    foundOpponentTextBottom.kill();
                    world.select.modules(Button).forEach(function (button) { return button.enabled = true; });
                    return [2 /*return*/];
            }
        });
    };
}
var CreditsNames;
(function (CreditsNames) {
    CreditsNames.ACIDGUY = "AcidGuy";
    CreditsNames.ANYTHING_GOES = "Anything Goes";
    CreditsNames.BALLAM = "Ballam";
    CreditsNames.C_RRY = "C_rry";
    CreditsNames.CONFLICTING_THEMES = "conflicting themes";
    CreditsNames.DEAGLE_EYE = "Deagle_eye";
    CreditsNames.EVERYONE = "many many people";
    CreditsNames.FIREBALLME = "Fireballme";
    CreditsNames.FLAREDESEL = "Flaredesel";
    CreditsNames.HOPOO_GAMES = "\nHopoo Games";
    CreditsNames.ISAAC = "Isaac";
    CreditsNames.JAEIL = "Jaeil";
    CreditsNames.JUNJ = "Junj";
    CreditsNames.LIFEWRATH = "Lifewrath";
    CreditsNames.MATERWELONS = "Materwelons";
    CreditsNames.NEPDEP = "NepDep";
    CreditsNames.POPAN = "Popan";
    CreditsNames.RATIS = "ratis";
    CreditsNames.SHUICHI_SAIHARA = "Shuichi Saihara";
    CreditsNames.TOMMYDOG145 = "TommyDog145";
    CreditsNames.WALUX = "walux";
    CreditsNames.XIAOSLOTH = "Xephia";
})(CreditsNames || (CreditsNames = {}));
var CustomBattle;
(function (CustomBattle) {
    function STAGE(friendSquad, enemySquad, gameid, round) {
        var e_88, _a;
        var world = Arenas.BASE();
        Arenas.SET_FOR_ARENA(world, VS_GAME.arena);
        world.addWorldObject(new AbilitySystem());
        var friendHealth = GAME_MODE === 'vs' || GAME_MODE === 'spectate' ? VS_GAME.yourhealth : 0;
        var enemyHealth = GAME_MODE === 'vs' || GAME_MODE === 'spectate' ? VS_GAME.enemyhealth : 0;
        var leftName = world.addWorldObject(new SpriteText({
            x: 2, y: 0,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_LEFT,
            justify: 'left',
            effects: { outline: { color: 0x000000 } },
        }));
        var rightName = world.addWorldObject(new SpriteText({
            name: 'opponentname',
            x: world.width - 2, y: 0,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_RIGHT,
            justify: 'right',
            effects: { outline: { color: 0x000000 } },
        }));
        seedAll(gameid, round, DAILY);
        if (friendSquad.name < enemySquad.name) {
            leftName.setText(formatName(friendSquad.name, friendHealth, 'friend'));
            rightName.setText(formatName(enemySquad.name, enemyHealth, 'enemy'));
            SWAP_DIRECTIONS = false;
            addSquad(world, friendSquad, 'friend', false);
            addSquad(world, enemySquad, 'enemy', true);
        }
        else {
            leftName.setText(formatName(enemySquad.name, enemyHealth, 'enemy'));
            rightName.setText(formatName(friendSquad.name, friendHealth, 'friend'));
            SWAP_DIRECTIONS = true;
            addSquad(world, enemySquad, 'enemy', false);
            addSquad(world, friendSquad, 'friend', true);
        }
        var balls = world.select.typeAll(Ball);
        try {
            for (var balls_8 = __values(balls), balls_8_1 = balls_8.next(); !balls_8_1.done; balls_8_1 = balls_8.next()) {
                var ball = balls_8_1.value;
                ball.onTeamsSpawned();
            }
        }
        catch (e_88_1) { e_88 = { error: e_88_1 }; }
        finally {
            try {
                if (balls_8_1 && !balls_8_1.done && (_a = balls_8.return)) _a.call(balls_8);
            }
            finally { if (e_88) throw e_88.error; }
        }
        world.addWorldObject(new BallHighlighter());
        world.addWorldObject(new InfoBox());
        setDataStartShop();
        setDataStartShopPostEffects();
        world.addWorldObject(new GameTimer());
        world.addWorldObject(new MusicChanger());
        if (GAME_MODE === 'mm')
            world.addWorldObject(new SaveValidator.Obj());
        world.addWorldObject(new BugChecker());
        global.game.allowPauseWithPauseKey = false;
        world.select.modules(Button).forEach(function (button) { return button.enabled = false; });
        world.addWorldObject(newOptionsGear());
        global.game.stopMusic(1);
        var pauseChar = IS_MOBILE ? '[offset 5 -3]<touch_tap>[/]' : '<lmb>';
        var speedUpChar = IS_MOBILE ? '[offset 5 -3]<touch_hold>[/]' : '<rmb>';
        world.addWorldObject(new SpriteText({
            x: world.width / 2, y: 232,
            text: pauseChar + " Pause    " + speedUpChar + " Speed Up",
            anchor: Vector2.CENTER,
            effects: { outline: { color: 0x000000, alpha: 1 } },
            layer: Battle.Layers.ui,
        }));
        world.onTransitioned = function () {
            if (GAME_MODE === 'vs' || GAME_MODE == 'spectate') {
                Main.fixedDelta = VS_GAME.frameTime;
            }
            seedAll(gameid, round, DAILY);
            world.data.youArePlaying = GAME_MODE !== 'spectate';
            global.theater.select.type(BattleSpeedController).enabled = true;
            world.runScript(GameFragments.gameCountdownAndStartScript(world));
        };
        return world;
    }
    CustomBattle.STAGE = STAGE;
    function addSquad(world, squad, team, flippedSide) {
        for (var i = 0; i < squad.balls.length; i++) {
            var ball = world.addWorldObject(squadBallToWorldBall(squad.balls[i], squad, team === 'friend' ? i : -1, team, flippedSide));
            ball.showAllStats();
        }
    }
    function formatName(name, health, team) {
        if (GAME_MODE === 'vs' || GAME_MODE === 'spectate') {
            var color = Ball.getTeamColor(team);
            return "[color " + color + "]" + name + "[/]\n[r]<heart>[/r]" + health;
        }
        return name;
    }
    function seedAll(gameid, round, daily) {
        var seed = getRandomSeed(gameid, daily);
        Random.seed("custombattle_" + seed + "_" + round);
        Ball.Random.seed("custombattle_ball_" + seed + "_" + round);
        debug('seeded', "custombattle_ball_" + seed + "_" + round);
    }
})(CustomBattle || (CustomBattle = {}));
var DailySquadInfoBox = /** @class */ (function (_super) {
    __extends(DailySquadInfoBox, _super);
    function DailySquadInfoBox(maskBounds) {
        var _this = _super.call(this, {
            useGlobalTime: true,
            visible: false,
        }) || this;
        _this.maskBounds = maskBounds;
        _this.enabled = true;
        _this.currentEntry = -1;
        _this.squadWorld = _this.addChild(new YourTeamWorld(new World()));
        _this.floatTimer = new Timer(0.5, function () { return _this.setVisible(true); });
        return _this;
    }
    DailySquadInfoBox.prototype.update = function () {
        var _a, _b;
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        var objects = G.rectContainsPt(this.maskBounds, mouseBounds)
            ? this.world.select.typeAll(SpriteText).filter(function (obj) { return obj.data.bounds && mouseBounds.isOverlapping(obj.data.bounds); })
            : [];
        var closestObject = M.argmin(objects, function (obj) {
            var bounds = obj.data.bounds.getBoundingBox();
            var midpoint = vec2(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2);
            return G.distance(midpoint, mouseBounds);
        });
        this.currentText = closestObject;
        var entry = this.enabled ? (_a = closestObject === null || closestObject === void 0 ? void 0 : closestObject.data) === null || _a === void 0 ? void 0 : _a.entry : -1;
        var squad = (_b = closestObject === null || closestObject === void 0 ? void 0 : closestObject.data) === null || _b === void 0 ? void 0 : _b.squad;
        if (entry >= 0) {
            if (entry !== this.currentEntry) {
                this.currentEntry = entry;
                this.squadWorld.kill();
                if (squad) {
                    this.squadWorld = this.addChild(createTeamWorld(squad, 100, false));
                    this.squadWorld.localx = -this.squadWorld.containedWorld.width / 2;
                    this.squadWorld.localy = -100;
                    this.squadWorld.alpha = 1;
                    this.squadWorld.containedWorld.update();
                }
                else {
                    this.squadWorld = this.addChild(new YourTeamWorld(new World()));
                }
            }
            var width = squad ? 52 + 32 * (squad.balls.length - 1) : 180;
            if (squad.balls.length === 3)
                width = 180;
            if (squad.balls.length === 2)
                width = 116;
            var height = 60;
            this.setTexture(InfoBox.getTextureForSize(width, height));
            var extraMove = IS_MOBILE ? 20 : 0;
            this.x = mouseBounds.x + width / 2 - 10;
            this.y = mouseBounds.y - height / 2 - 10 - extraMove;
            this.floatTimer.update(this.delta);
        }
        else if (!IS_MOBILE || Input.justDown('click')) {
            this.setVisible(false);
            this.floatTimer.reset();
        }
        this.keepOnScreen();
    };
    DailySquadInfoBox.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.moveWorldObjectToFront(this);
        World.Actions.moveWorldObjectToFront(this.squadWorld);
    };
    DailySquadInfoBox.prototype.keepOnScreen = function () {
        var width = this.getTexture().width;
        var height = this.getTexture().height;
        this.x = M.clamp(this.x, width / 2, global.gameWidth - width / 2);
        this.y = M.clamp(this.y, height / 2, global.gameHeight - height / 2);
    };
    return DailySquadInfoBox;
}(Sprite));
// Core Constants
function GET_START_ROUND_GOLD() {
    if (GAME_MODE === 'vs' && VS_GAME) {
        if (VS_GAME.round === VS_GAME.startRound)
            return VS_GAME.startGameGold;
        return VS_GAME.startRoundGold;
    }
    return 10 + getModifierGoldDiff();
}
function GET_MAX_SQUAD_SIZE() {
    var squadSizeBase = 5;
    if (GAME_MODE === 'vs' && VS_GAME) {
        squadSizeBase = VS_GAME.maxSquadSize;
    }
    return squadSizeBase + getModifierSquadSizeDiff();
}
function GET_MAX_WINS() {
    return 8;
}
function GET_TIME_LIMIT() {
    if (GAME_MODE === 'vs' && VS_GAME) {
        return VS_GAME.timeLimit;
    }
    return -1;
}
function GET_SPEED_CAP_MULT() {
    if (isModifierActive('nospeedcap'))
        return Infinity;
    if ((GAME_MODE === 'vs' || GAME_MODE === 'spectate') && VS_GAME) {
        return VS_GAME.speedCap ? 1 : Infinity;
    }
    return 1;
}
function IS_SUBMISSION_DISABLED() {
    return !GAME_DATA || GAME_DATA.squad.name === 'test' || GAME_DATA.squad.name === 'Guest';
}
// Global
var GAME_MODE;
var GAME_DATA = newGameData();
var CHALLENGE_MODE_ENABLED = false;
var DAILY;
var SWAP_DIRECTIONS;
var ENEMY_SQUAD_DATA;
var USELESS_CROWN_REPLACEMENT;
var VS_GAME;
function resetData() {
    GAME_DATA = newGameData();
    ENEMY_SQUAD_DATA = undefined;
}
function setDataStartShop() {
    GAME_DATA.gold = GET_START_ROUND_GOLD();
    GAME_DATA.restocksThisRound = 0;
    GAME_DATA.argTrigger = { zombie: false, restocks: 0 };
    GAME_DATA.freeRestocksUntilPlay = 0;
    ENEMY_SQUAD_DATA = undefined;
}
function setDataStartShopPostEffects() {
    GAME_DATA.startShopEffects = [];
    GAME_DATA.gold = Math.max(GAME_DATA.gold, 0);
    USELESS_CROWN_REPLACEMENT = false;
}
function setDataPlay() {
    GAME_DATA.freeRestocksUntilPlay = 0;
}
function setBallPositions(world) {
    var e_89, _a;
    var squadBalls = world.select.typeAll(Ball).filter(function (b) { return b.team === 'friend' && !b.isInShop && b.state === Ball.States.PREP && b.squadIndexReference >= 0 && b.squadIndexReference < GAME_DATA.squad.balls.length; });
    try {
        for (var squadBalls_1 = __values(squadBalls), squadBalls_1_1 = squadBalls_1.next(); !squadBalls_1_1.done; squadBalls_1_1 = squadBalls_1.next()) {
            var ball = squadBalls_1_1.value;
            GAME_DATA.squad.balls[ball.squadIndexReference].x = ball.x;
            GAME_DATA.squad.balls[ball.squadIndexReference].y = ball.y;
        }
    }
    catch (e_89_1) { e_89 = { error: e_89_1 }; }
    finally {
        try {
            if (squadBalls_1_1 && !squadBalls_1_1.done && (_a = squadBalls_1.return)) _a.call(squadBalls_1);
        }
        finally { if (e_89) throw e_89.error; }
    }
}
function getNewGameId() {
    var chars = '0123456789ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    return A.range(4).map(function (i) { return chars[Random.int(0, chars.length - 1)]; }).join('');
}
function getLastRoundResult() {
    if (_.isEmpty(GAME_DATA.roundResults))
        return 'none';
    var lastRound = M.max(Object.keys(GAME_DATA.roundResults), parseInt);
    return GAME_DATA.roundResults[lastRound];
}
function getLastWinStreak() {
    var e_90, _a;
    if (_.isEmpty(GAME_DATA.roundResults))
        return 0;
    var lastRounds = A.sort(Object.keys(GAME_DATA.roundResults), function (round) { return parseInt(round); }, true);
    var wonRoundsInARow = 0;
    try {
        for (var lastRounds_1 = __values(lastRounds), lastRounds_1_1 = lastRounds_1.next(); !lastRounds_1_1.done; lastRounds_1_1 = lastRounds_1.next()) {
            var round = lastRounds_1_1.value;
            if (GAME_DATA.roundResults[round] !== 'win')
                break;
            wonRoundsInARow++;
        }
    }
    catch (e_90_1) { e_90 = { error: e_90_1 }; }
    finally {
        try {
            if (lastRounds_1_1 && !lastRounds_1_1.done && (_a = lastRounds_1.return)) _a.call(lastRounds_1);
        }
        finally { if (e_90) throw e_90.error; }
    }
    return wonRoundsInARow;
}
function getLastDrawStreak() {
    var e_91, _a;
    if (_.isEmpty(GAME_DATA.roundResults))
        return 0;
    var lastRounds = A.sort(Object.keys(GAME_DATA.roundResults), function (round) { return parseInt(round); }, true);
    var drawedRoundsInARow = 0;
    try {
        for (var lastRounds_2 = __values(lastRounds), lastRounds_2_1 = lastRounds_2.next(); !lastRounds_2_1.done; lastRounds_2_1 = lastRounds_2.next()) {
            var round = lastRounds_2_1.value;
            if (GAME_DATA.roundResults[round] !== 'draw')
                break;
            drawedRoundsInARow++;
        }
    }
    catch (e_91_1) { e_91 = { error: e_91_1 }; }
    finally {
        try {
            if (lastRounds_2_1 && !lastRounds_2_1.done && (_a = lastRounds_2.return)) _a.call(lastRounds_2);
        }
        finally { if (e_91) throw e_91.error; }
    }
    return drawedRoundsInARow;
}
function isTierCrown() {
    return getShopTierForRound(GAME_DATA.round) > 3 && GAME_DATA.lap > 1;
}
function hasDoveBallInSquad() {
    return !!GAME_DATA.squad.balls.find(function (ball) { return ball.properties.type === 127; });
}
function vsOpponentHadDoveBallInSquadLastRound() {
    var _a, _b;
    return GAME_MODE === 'vs' && ((_b = (_a = VS_GAME === null || VS_GAME === void 0 ? void 0 : VS_GAME.enemylastsquad) === null || _a === void 0 ? void 0 : _a.balls) === null || _b === void 0 ? void 0 : _b.find(function (ball) { return ball.properties.type === 127; }));
}
/// <reference path="../lectvs/dialog/dialogProfile.ts" />
var dialogProfiles = {
    'system': {
        name: null,
        dialogStart: 'dialogstart',
        dialogSpeak: 'dialogspeak',
        entries: {
            'default': {},
        }
    },
};
var DisplayedGold = /** @class */ (function (_super) {
    __extends(DisplayedGold, _super);
    function DisplayedGold(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: Battle.Layers.ui,
            anchor: Vector2.CENTER_LEFT,
        }) || this;
        _this.reservedGold = 0;
        return _this;
    }
    DisplayedGold.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateText();
    };
    DisplayedGold.prototype.updateText = function () {
        this.setText("" + (GAME_DATA.gold - this.reservedGold));
    };
    DisplayedGold.prototype.addReservedGold = function (reservedGold) {
        this.reservedGold += reservedGold;
    };
    DisplayedGold.prototype.removeReservedGold = function (reservedGold) {
        this.reservedGold -= reservedGold;
    };
    return DisplayedGold;
}(SpriteText));
var DragScroller = /** @class */ (function (_super) {
    __extends(DragScroller, _super);
    function DragScroller(scrollBar, scrollTotalHeight, bounds) {
        var _this = _super.call(this) || this;
        _this.scrollBar = scrollBar;
        _this.scrollTotalHeight = scrollTotalHeight;
        _this.bounds = bounds;
        _this.dragPercent = scrollBar.getScrollPercent();
        _this.dragVelocity = 0;
        return _this;
    }
    DragScroller.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateDragState();
        this.updateDragEffect();
    };
    DragScroller.prototype.updateDragState = function () {
        if (this.drag) {
            if (Input.isUp('click')) {
                this.drag = undefined;
                this.dragPercent = M.clamp(this.dragPercent, 0, 1);
            }
        }
        else {
            if (Input.justDown('click') && G.rectContainsPt(this.bounds, this.world.getWorldMouseBounds()) && !this.scrollBar.isScrolling) {
                this.drag = {
                    startPos: this.world.getWorldMousePosition(),
                    startPercent: this.scrollBar.getScrollPercent(),
                };
                this.dragPercent = this.drag.startPercent;
            }
        }
    };
    DragScroller.prototype.updateDragEffect = function () {
        if (!this.drag) {
            if (this.dragVelocity !== 0) {
                this.dragPercent += this.dragVelocity * this.delta;
                this.dragPercent = M.clamp(this.dragPercent, 0, 1);
                this.dragVelocity = PhysicsUtils.applyFriction1d(this.dragVelocity, 800 / this.scrollTotalHeight, this.delta);
                if (this.dragPercent === 0 || this.dragPercent === 1) {
                    this.dragVelocity = 0;
                }
                this.scrollBar.setScrollPercent(this.dragPercent);
            }
            return;
        }
        var d = this.world.getWorldMouseY() - this.drag.startPos.y;
        var dp = d / this.scrollTotalHeight;
        var p = this.drag.startPercent - dp;
        this.scrollBar.setScrollPercent(p);
        this.dragVelocity = this.delta === 0 ? 0 : (p - this.dragPercent) / this.delta;
        this.dragPercent = p;
    };
    return DragScroller;
}(WorldObject));
var DropShadowFilter = /** @class */ (function (_super) {
    __extends(DropShadowFilter, _super);
    function DropShadowFilter() {
        return _super.call(this, {
            code: "\n                float a = getColor(x-1.0, y-1.0).a;\n                if (inp.a == 0.0 && a > 0.0) {\n                    outp = vec4(0.0, 0.0, 0.0, 0.5 * a);\n                }\n            "
        }) || this;
    }
    return DropShadowFilter;
}(TextureFilter));
var EndScreens;
(function (EndScreens) {
    var VICTORY_MESSAGES = [
        "I'm so proud of you :')",
        "Great job!!!",
        "Nice balls!!",
        "You are the AUTO BALL!",
    ];
    var GAMEOVER_MESSAGES = [
        "We'll just have to do\nbetter next time!",
        "...But I bet the next game\nwill be a win for sure! :)",
        "Tough competition today!",
    ];
    var WIN_MESSAGES = [
        "You can do it! :)",
        "Keep on going!",
        "Let's go!!!",
    ];
    var LOSE_MESSAGES = [
        "Come back stronger!",
        "Don't give up!\nYou can do this! :)",
        "You're not out yet!\nStay in there! :)",
        "But you can still come back!",
    ];
    var DRAW_MESSAGES = [
        "You're still in there...!",
        "At least it's not a\nloss, right?",
        "That was a close one!",
    ];
    var SPECTATE_MESSAGES = [
        "The battle continues!",
        "Who will come out on top?",
    ];
    var VS_DEFEATED_VERBS = [
        "DEFEATED", "CRUSHED", "OBLITERATED", "DEMOLISHED", "DUNKED ON", "CLAPPED", "OUTPLAYED",
    ];
    function getVictoryMessageForBalls(balls) {
        var message = Random.element(VICTORY_MESSAGES);
        if (message === VICTORY_MESSAGES[2] && balls === 1) {
            return 'Nice ball!!';
        }
        return message;
    }
    function showVictory(priorLap, priorWins, priorHealth, priorRound, result) {
        return function () {
            var timeScale, totalWins, totalMaxWins, winsText, wins, youwin, message, shareText, clipboardShareButton, twitterShareButton, continueButtonText, continueButtonFilters, areYouSureShown, continueSelection, continueButton, victoryLapButton, waitForVictoryLapButton;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        totalWins = priorWins + 1 + (priorLap - 1) * 8;
                        totalMaxWins = GET_MAX_WINS() + (priorLap - 1) * 8;
                        winsText = priorLap === 1 ? totalWins + "/" + totalMaxWins : "[gold]" + totalWins + "/" + totalMaxWins + "[/gold]";
                        wins = global.world.addWorldObject(new SpriteText({
                            name: 'wintext',
                            x: global.gameWidth / 2, y: 42,
                            text: "[gold]<trophy>[/gold] " + winsText + "   [r]<heart>[/r] " + priorHealth + "   [rb]R[/rb] " + priorRound + "   <clock> " + secondsToFormattedTime(GAME_DATA.gameTime),
                            style: { color: 0xFFFFFF },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(2 * timeScale, wins, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 2:
                        _a.sent();
                        if (!isEscape())
                            global.theater.playSound('win');
                        youwin = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 76,
                            text: escapeGarble("VICTORY!!!"),
                            scale: 2,
                            style: { color: isEscape() ? 0xDDDDDD : (isBotted() && GAME_DATA.lap >= 7 ? 0xFFD800 : 0x00FF00) },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(1 * timeScale, youwin, 'alpha', 0, 1)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, showYourSquad(100, true, timeScale, priorLap)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 6:
                        _a.sent();
                        message = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 166,
                            text: escapeGarble(getVictoryMessageForBalls(GAME_DATA.squad.balls.length)),
                            style: { color: 0xFFFFFF },
                            justify: 'center',
                            anchor: Vector2.TOP,
                            alpha: 0,
                        }));
                        World.Actions.orderWorldObjectBefore(message, global.world.select.type(YourTeamWorld));
                        return [4 /*yield*/, S.tween(1 * timeScale, message, 'alpha', 0, 1)];
                    case 7:
                        _a.sent();
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 8:
                        _a.sent();
                        if (isBotted()) {
                            global.world.addWorldObject(new Sprite({
                                texture: Texture.filledRect(Math.min(GAME_DATA.offlineCount, global.gameWidth), 1, 0x111111),
                            }));
                        }
                        shareText = global.world.addWorldObject(new SpriteText({
                            name: 'sharetext',
                            x: global.gameWidth / 2 - 52, y: 202,
                            text: 'SHARE :)',
                            anchor: Vector2.CENTER_LEFT,
                            font: 'smallnumbers',
                            alpha: 0,
                        }));
                        World.Actions.orderWorldObjectBefore(shareText, global.world.select.type(YourTeamWorld));
                        clipboardShareButton = global.world.addWorldObject(new ImageShareButton(global.gameWidth / 2 - 80, 201));
                        clipboardShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(clipboardShareButton, global.world.select.type(YourTeamWorld));
                        if (IS_MOBILE) {
                            clipboardShareButton.removeFromWorld();
                        }
                        twitterShareButton = global.world.addWorldObject(new TwitterShareButton(global.gameWidth / 2 - 63, 201, 'win'));
                        twitterShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(twitterShareButton, global.world.select.type(YourTeamWorld));
                        continueButtonText = 'Main Menu >';
                        continueButtonFilters = [];
                        if (isEscape()) {
                            continueButtonText = 'ESCAPE >';
                            continueButtonFilters = [new StaticFilter(0xFFFFFF, 1)];
                        }
                        else if (isBallmanacToComplete()) {
                            continueButtonText = '[r]C[color 0xFF7F00]o[y]m[g]p[color 0x0000FF]l[color 0x4B0082]e[color 0x9400D3]t[r]e >';
                            continueButtonFilters = [new HueSpinFilter()];
                        }
                        else if (DAILY) {
                            continueButtonText = 'Results >';
                        }
                        areYouSureShown = false;
                        continueSelection = undefined;
                        continueButton = global.world.addWorldObject(new MenuTextButton({
                            name: 'continuebutton',
                            x: global.gameWidth / 2 + 8, y: 195,
                            text: continueButtonText,
                            style: { color: 0xFFFFFF },
                            effects: { post: { filters: continueButtonFilters } },
                            alpha: 0,
                            useGlobalTime: true,
                            onClick: function () {
                                global.game.playSound('click');
                                if (!isEscape() && !areYouSureShown && priorLap > 1) {
                                    areYouSureShown = true;
                                    continueButton.runScript(function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, S.tween(0.1, continueButton, 'alpha', 1, 0.4, Tween.Easing.OutQuad)];
                                                case 1:
                                                    _a.sent();
                                                    continueButton.setText("Are you sure? >");
                                                    return [4 /*yield*/, S.tween(0.1, continueButton, 'alpha', 0.4, 1, Tween.Easing.InQuad)];
                                                case 2:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    });
                                }
                                else {
                                    continueButton.enabled = false;
                                    victoryLapButton.enabled = false;
                                    continueSelection = 'continue';
                                }
                            }
                        }));
                        World.Actions.orderWorldObjectBefore(continueButton, global.world.select.type(YourTeamWorld));
                        victoryLapButton = global.world.addWorldObject(new MenuTextButton({
                            name: 'victorylapbutton',
                            x: global.gameWidth / 2, y: 224,
                            text: '<crownl><crownr> I WANT TO KEEP PLAYING <crownl><crownr>',
                            font: 'smallnumbers',
                            style: { color: 0xFFD800 },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                            hoverColor: 0xBB8400,
                            onClick: function () {
                                global.game.playSound('click');
                                continueButton.enabled = false;
                                victoryLapButton.enabled = false;
                                continueSelection = 'victorylap';
                            }
                        }));
                        victoryLapButton.enabled = false;
                        World.Actions.orderWorldObjectBefore(victoryLapButton, global.world.select.type(YourTeamWorld));
                        return [4 /*yield*/, [
                                S.tween(1 * timeScale, continueButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, shareText, 'alpha', 0, 1),
                                S.tween(1 * timeScale, clipboardShareButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, twitterShareButton, 'alpha', 0, 1),
                            ]];
                    case 9:
                        _a.sent();
                        if (!DAILY) {
                            victoryLapButton.enabled = true;
                            waitForVictoryLapButton = priorLap <= 1 ? 3 : 0;
                            global.theater.runScript(S.chain(S.wait(waitForVictoryLapButton * timeScale), S.simul(S.tween(3 * timeScale, victoryLapButton, 'alpha', 0, 1), S.doOverTime(3 * timeScale, function (t) { return victoryLapButton.x = global.gameWidth / 2 + (1 - t) * Random.float(-4, 4); }))));
                        }
                        return [4 /*yield*/, S.waitUntil(function () { return continueSelection; })];
                    case 10:
                        _a.sent();
                        result.continueSelection = continueSelection;
                        return [2 /*return*/];
                }
            });
        };
    }
    EndScreens.showVictory = showVictory;
    function showVsResult() {
        return function () {
            var timeScale, wins, youAreWinner, winnerName, loserName, winnerSquad, loserSquad, winnerHealth, loserHealth, vsResult, shareText, clipboardShareButton, twitterShareButton, shouldContinue, continueButton;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        wins = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 23,
                            text: "[rb]R[/rb] " + GAME_DATA.round + "   <clock> " + secondsToFormattedTime(GAME_DATA.gameTime),
                            style: { color: 0xFFFFFF },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(2 * timeScale, wins, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 2:
                        _a.sent();
                        if (VS_GAME.enemyhealth <= VS_GAME.yourhealth) {
                            youAreWinner = true;
                            winnerName = VS_GAME.yourname;
                            loserName = VS_GAME.enemyname;
                            winnerSquad = VS_GAME.yoursquad || VS_GAME.yourlastsquad;
                            loserSquad = VS_GAME.enemysquad || VS_GAME.enemylastsquad;
                            winnerHealth = VS_GAME.yourhealth;
                            loserHealth = VS_GAME.enemyhealth;
                        }
                        else {
                            youAreWinner = false;
                            winnerName = VS_GAME.enemyname;
                            loserName = VS_GAME.yourname;
                            winnerSquad = VS_GAME.enemysquad || VS_GAME.enemylastsquad;
                            loserSquad = VS_GAME.yoursquad || VS_GAME.yourlastsquad;
                            winnerHealth = VS_GAME.enemyhealth;
                            loserHealth = VS_GAME.yourhealth;
                        }
                        Random.seed(getRandomSeed(GAME_DATA.gameId, DAILY));
                        vsResult = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: global.gameHeight / 2,
                            text: winnerName + "  [r]<heart>[/r]" + winnerHealth + "\n[gold]~ " + Random.element(VS_DEFEATED_VERBS) + " ~[/gold]\n" + loserName + "  [r]<heart>[/r]" + loserHealth,
                            anchor: Vector2.CENTER,
                            justify: 'center',
                            alpha: 0,
                        }));
                        return [4 /*yield*/, [
                                showVsSquads(global.gameHeight / 2, youAreWinner, winnerSquad, loserSquad, timeScale),
                                S.tween(1 * timeScale, vsResult, 'alpha', 0, 1),
                            ]];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 4:
                        _a.sent();
                        shareText = global.world.addWorldObject(new SpriteText({
                            name: 'sharetext',
                            x: global.gameWidth / 2 - 52, y: 215,
                            text: 'SHARE :)',
                            anchor: Vector2.CENTER_LEFT,
                            font: 'smallnumbers',
                            alpha: 0,
                        }));
                        World.Actions.orderWorldObjectBefore(shareText, global.world.select.type(YourTeamWorld));
                        clipboardShareButton = global.world.addWorldObject(new ImageShareButton(global.gameWidth / 2 - 80, 214));
                        clipboardShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(clipboardShareButton, global.world.select.type(YourTeamWorld));
                        if (IS_MOBILE) {
                            clipboardShareButton.removeFromWorld();
                        }
                        twitterShareButton = global.world.addWorldObject(new TwitterShareButton(global.gameWidth / 2 - 63, 214, youAreWinner ? 'win' : 'loss'));
                        twitterShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(twitterShareButton, global.world.select.type(YourTeamWorld));
                        shouldContinue = false;
                        continueButton = global.world.addWorldObject(new MenuTextButton({
                            name: 'continuebutton',
                            x: global.gameWidth / 2 + 8, y: 208,
                            text: 'Continue >',
                            style: { color: 0xFFFFFF },
                            alpha: 0,
                            onClick: function () {
                                global.game.playSound('click');
                                continueButton.enabled = false;
                                shouldContinue = true;
                            }
                        }));
                        World.Actions.orderWorldObjectBefore(continueButton, global.world.select.type(YourTeamWorld));
                        return [4 /*yield*/, [
                                S.tween(1 * timeScale, continueButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, shareText, 'alpha', 0, 1),
                                S.tween(1 * timeScale, clipboardShareButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, twitterShareButton, 'alpha', 0, 1),
                            ]];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, S.waitUntil(function () { return shouldContinue; })];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    }
    EndScreens.showVsResult = showVsResult;
    function showGameOver() {
        return function () {
            var timeScale, round, totalWins, totalMaxWins, winsText, wins, gameover, tryharder, shareText, clipboardShareButton, twitterShareButton, continueButtonText, continueButtonFilters, continueButtonClicked, continueButton;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        round = GAME_DATA.round - 1;
                        totalWins = GAME_DATA.wins + (GAME_DATA.lap - 1) * 8;
                        totalMaxWins = GET_MAX_WINS() + (GAME_DATA.lap - 1) * 8;
                        winsText = GAME_DATA.lap === 1 ? totalWins + "/" + totalMaxWins : "[gold]" + totalWins + "/" + totalMaxWins + "[/gold]";
                        wins = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 38,
                            text: "[gold]<trophy>[/gold] " + winsText + "   [r]<heart>[/r] " + GAME_DATA.health + "   [rb]R[/rb] " + round + "   <clock> " + secondsToFormattedTime(GAME_DATA.gameTime),
                            style: { color: 0xFFFFFF },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(2 * timeScale, wins, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 2:
                        _a.sent();
                        if (!isEscape())
                            global.theater.playSound('lose');
                        gameover = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2 + 24, y: 66,
                            text: escapeGarble("GAME OVER..."),
                            scale: 2,
                            style: { color: isEscape() ? 0xDDDDDD : 0xFF0000 },
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(1 * timeScale, gameover, 'alpha', 0, 1)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, showYourSquad(88, false, timeScale, GAME_DATA.lap)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 6:
                        _a.sent();
                        tryharder = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 154,
                            text: escapeGarble(Random.element(GAMEOVER_MESSAGES)),
                            style: { color: 0xFFFFFF },
                            justify: 'center',
                            anchor: Vector2.TOP,
                            alpha: 0,
                        }));
                        World.Actions.orderWorldObjectBefore(tryharder, global.world.select.type(YourTeamWorld));
                        return [4 /*yield*/, S.tween(1 * timeScale, tryharder, 'alpha', 0, 1)];
                    case 7:
                        _a.sent();
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 8:
                        _a.sent();
                        shareText = global.world.addWorldObject(new SpriteText({
                            name: 'sharetext',
                            x: global.gameWidth / 2 - 52, y: 174 + tryharder.getTextHeight(),
                            text: 'SHARE :)',
                            anchor: Vector2.CENTER_LEFT,
                            font: 'smallnumbers',
                            alpha: 0,
                        }));
                        World.Actions.orderWorldObjectBefore(shareText, global.world.select.type(YourTeamWorld));
                        clipboardShareButton = global.world.addWorldObject(new ImageShareButton(global.gameWidth / 2 - 80, 173 + tryharder.getTextHeight()));
                        clipboardShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(clipboardShareButton, global.world.select.type(YourTeamWorld));
                        if (IS_MOBILE) {
                            clipboardShareButton.removeFromWorld();
                        }
                        twitterShareButton = global.world.addWorldObject(new TwitterShareButton(global.gameWidth / 2 - 63, 173 + tryharder.getTextHeight(), 'loss'));
                        twitterShareButton.alpha = 0;
                        World.Actions.orderWorldObjectBefore(twitterShareButton, global.world.select.type(YourTeamWorld));
                        continueButtonText = 'Main Menu >';
                        continueButtonFilters = [];
                        if (isEscape()) {
                            continueButtonText = 'ESCAPE >';
                            continueButtonFilters = [new StaticFilter(0xFFFFFF, 1)];
                        }
                        else if (DAILY) {
                            continueButtonText = 'Results >';
                        }
                        continueButtonClicked = false;
                        continueButton = global.world.addWorldObject(new MenuTextButton({
                            name: 'continuebutton',
                            x: global.gameWidth / 2 + 8, y: 166 + tryharder.getTextHeight(),
                            text: continueButtonText,
                            style: { color: 0xFFFFFF },
                            effects: { post: { filters: continueButtonFilters } },
                            alpha: 0,
                            useGlobalTime: true,
                            onClick: function () {
                                global.game.playSound('click');
                                continueButton.enabled = false;
                                continueButtonClicked = true;
                            }
                        }));
                        World.Actions.orderWorldObjectBefore(continueButton, global.world.select.type(YourTeamWorld));
                        return [4 /*yield*/, [
                                S.tween(1 * timeScale, continueButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, shareText, 'alpha', 0, 1),
                                S.tween(1 * timeScale, clipboardShareButton, 'alpha', 0, 1),
                                S.tween(1 * timeScale, twitterShareButton, 'alpha', 0, 1),
                            ]];
                    case 9:
                        _a.sent();
                        return [4 /*yield*/, S.waitUntil(function () { return continueButtonClicked; })];
                    case 10:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    }
    EndScreens.showGameOver = showGameOver;
    function showWin() {
        return function () {
            return __generator(this, function (_a) {
                global.theater.playSound('win');
                if (vsOpponentHadDoveBallInSquadLastRound()) {
                    global.world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 55,
                        text: '<dove1><dove2> Opponent Protected!',
                        style: { color: 0xFFFFFF },
                        anchor: Vector2.CENTER,
                    }));
                }
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 110,
                    text: ' WIN!',
                    scale: 2,
                    style: { color: 0x00FF00 },
                    anchor: Vector2.CENTER,
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 135,
                    text: "[gold]<trophy>[/gold] " + (GET_MAX_WINS() - GAME_DATA.wins) + " to go...",
                    style: { color: 0xFFFFFF },
                    anchor: Vector2.CENTER,
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 163,
                    text: Random.element(WIN_MESSAGES),
                    style: { color: 0xFFFFFF },
                    justify: 'center',
                    anchor: Vector2.TOP,
                }));
                return [2 /*return*/];
            });
        };
    }
    EndScreens.showWin = showWin;
    function showLose() {
        return function () {
            return __generator(this, function (_a) {
                global.theater.playSound('lose');
                if (hasDoveBallInSquad()) {
                    global.world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 55,
                        text: '<dove1><dove2> Protected!',
                        style: { color: 0xFFFFFF },
                        anchor: Vector2.CENTER,
                    }));
                }
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 110,
                    text: 'LOSS',
                    scale: 2,
                    style: { color: 0xFF0000 },
                    anchor: Vector2.CENTER,
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 135,
                    text: "[color 0xFF0000]<heart>[/] " + GAME_DATA.health + " left...",
                    style: { color: 0xFFFFFF },
                    anchor: Vector2.CENTER,
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 167,
                    text: Random.element(LOSE_MESSAGES),
                    style: { color: 0xFFFFFF },
                    justify: 'center',
                    anchor: Vector2.TOP,
                }));
                return [2 /*return*/];
            });
        };
    }
    EndScreens.showLose = showLose;
    function showDraw(type) {
        return function () {
            return __generator(this, function (_a) {
                global.theater.playSound('draw');
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 110,
                    text: 'DRAW',
                    scale: 2,
                    style: { color: 0xFFFFFF },
                    anchor: Vector2.CENTER,
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 128,
                    text: type === 'timeout' ? "The battle timed out!" : Random.element(DRAW_MESSAGES),
                    style: { color: 0xFFFFFF },
                    justify: 'center',
                    anchor: Vector2.TOP,
                }));
                return [2 /*return*/];
            });
        };
    }
    EndScreens.showDraw = showDraw;
    function showSpectateNonDraw(winner, drawType) {
        return function () {
            var winText;
            return __generator(this, function (_a) {
                global.theater.playSound('win');
                winText = "";
                if (winner) {
                    winText = "[gold]" + winner + "[/gold]\n[offsetx 2]WINS ROUND " + (VS_GAME.round - 1) + "![/]";
                }
                else {
                    winText = 'DRAW';
                }
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 66,
                    text: winText,
                    scale: 2,
                    anchor: Vector2.CENTER,
                    justify: 'center',
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 130,
                    text: VS_GAME.yourname + " [r]<heart>[/r]" + VS_GAME.yourhealth + "\n" + VS_GAME.enemyname + " [r]<heart>[/r]" + VS_GAME.enemyhealth,
                    style: { color: 0xFFFFFF },
                    anchor: Vector2.CENTER,
                    justify: 'left',
                }));
                global.world.addWorldObject(new SpriteText({
                    x: global.gameWidth / 2, y: 175,
                    text: drawType === 'timeout' ? "The battle timed out!" : Random.element(SPECTATE_MESSAGES),
                    style: { color: 0xFFFFFF },
                    justify: 'center',
                    anchor: Vector2.TOP,
                }));
                return [2 /*return*/];
            });
        };
    }
    EndScreens.showSpectateNonDraw = showSpectateNonDraw;
    function showYourSquad(y, win, timeScale, priorLap) {
        return function () {
            function addWin(p, i, numBalls, book) {
                global.theater.playSound('buyball', { volume: 0.6, speed: Math.pow(2, [0, 2, 4, 5, 7, 9, 11][i % 7] / 12) });
                var win = yourTeamWorld.containedWorld.addWorldObject(new SpriteText({
                    x: p.x, y: p.y - 5,
                    text: '[gold][offsetx 0]<crown>[/][/]',
                    anchor: Vector2.CENTER,
                    effects: { outline: {} },
                    alpha: 0,
                }));
                win.runScript(function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, [
                                    S.tween(1 * timeScale, win, 'y', win.y, win.y - 10, Tween.Easing.OutCubic),
                                    S.tween(1 * timeScale, win, 'alpha', 0, 1, Tween.Easing.OutCubic),
                                ]];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, S.wait(0.3 * (numBalls - 1 - i) * timeScale)];
                            case 2:
                                _a.sent();
                                return [4 /*yield*/, [
                                        S.tween(0.5 * timeScale, win, 'x', win.x, book.x, Tween.Easing.InCubic),
                                        S.tween(0.5 * timeScale, win, 'y', win.y, book.y, Tween.Easing.InQuad),
                                    ]];
                            case 3:
                                _a.sent();
                                global.theater.playSound('bookopen', { volume: 0.6 });
                                book.runScript(S.tween(0.1, book, 'scale', 1.2, 1));
                                win.kill();
                                return [2 /*return*/];
                        }
                    });
                });
            }
            var yourSquadText, yourTeamWorld;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        yourSquadText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: y,
                            text: escapeGarble(win ? "~ " + crownedName(GAME_DATA.squad.name) + "'s WINNING Squad ~" : "~ " + GAME_DATA.squad.name + "'s Squad ~"),
                            style: { color: 0xFFFFFF },
                            justify: 'center',
                            anchor: Vector2.TOP,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(1 * timeScale, yourSquadText, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        yourTeamWorld = global.world.addWorldObject(createTeamWorld());
                        addSquadToTeamWorld(yourTeamWorld.containedWorld, y + 40, GAME_DATA.squad, 'friend', false);
                        return [4 /*yield*/, S.tween(1 * timeScale, yourTeamWorld, 'alpha', 0, 1)];
                    case 2:
                        _a.sent();
                        if (GAME_MODE === 'mm' && win && priorLap === 1) {
                            yourTeamWorld.runScript(function () {
                                var book, balls, i, balls_9, balls_9_1, ball, e_92_1, percent, completion;
                                var e_92, _a;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            book = yourTeamWorld.containedWorld.addWorldObject(new Sprite({
                                                x: 270, y: 130,
                                                texture: 'almanacicon/open',
                                                alpha: 0,
                                            }));
                                            book.runScript(S.tween(0.5, book, 'alpha', 0, 1));
                                            balls = yourTeamWorld.containedWorld.select.typeAll(Ball);
                                            i = 0;
                                            _b.label = 1;
                                        case 1:
                                            _b.trys.push([1, 6, 7, 8]);
                                            balls_9 = __values(balls), balls_9_1 = balls_9.next();
                                            _b.label = 2;
                                        case 2:
                                            if (!!balls_9_1.done) return [3 /*break*/, 5];
                                            ball = balls_9_1.value;
                                            addWin(ball, i, balls.length, book);
                                            return [4 /*yield*/, S.wait(0.2 * timeScale)];
                                        case 3:
                                            _b.sent();
                                            i++;
                                            _b.label = 4;
                                        case 4:
                                            balls_9_1 = balls_9.next();
                                            return [3 /*break*/, 2];
                                        case 5: return [3 /*break*/, 8];
                                        case 6:
                                            e_92_1 = _b.sent();
                                            e_92 = { error: e_92_1 };
                                            return [3 /*break*/, 8];
                                        case 7:
                                            try {
                                                if (balls_9_1 && !balls_9_1.done && (_a = balls_9.return)) _a.call(balls_9);
                                            }
                                            finally { if (e_92) throw e_92.error; }
                                            return [7 /*endfinally*/];
                                        case 8: return [4 /*yield*/, S.wait(2 * timeScale)];
                                        case 9:
                                            _b.sent();
                                            return [4 /*yield*/, S.tween(0.2 * timeScale, book, 'scale', 1, 1.1)];
                                        case 10:
                                            _b.sent();
                                            global.theater.playSound('bookclose', { volume: 0.5 });
                                            book.setTexture('almanacicon/closed');
                                            book.x += 3;
                                            return [4 /*yield*/, S.tween(0.2 * timeScale, book, 'scale', 1.1, 0.9)];
                                        case 11:
                                            _b.sent();
                                            return [4 /*yield*/, S.tween(0.1 * timeScale, book, 'scale', 0.9, 1)];
                                        case 12:
                                            _b.sent();
                                            return [4 /*yield*/, S.wait(0.25 * timeScale)];
                                        case 13:
                                            _b.sent();
                                            percent = Math.floor(getAlmanacTotalCompletionPercent().won * 100);
                                            completion = yourTeamWorld.containedWorld.addWorldObject(new SpriteText({
                                                x: book.x + 2, y: book.y - 1,
                                                text: percent + "%",
                                                font: 'smallnumbers',
                                                style: { color: 0xFFD800 },
                                                anchor: Vector2.CENTER,
                                                alpha: 0,
                                            }));
                                            return [4 /*yield*/, S.schedule(0, S.tween(1 * timeScale, book, 'alpha', 1, 0), 0.5 * timeScale, S.tween(1 * timeScale, completion, 'alpha', 0, 1), 3, S.tween(1, completion, 'alpha', 1, 0))];
                                        case 14:
                                            _b.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        }
                        return [2 /*return*/];
                }
            });
        };
    }
    function showVsSquads(y, youAreWinner, topSquad, bottomSquad, timeScale) {
        return function () {
            var yourTeamWorld;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        yourTeamWorld = global.world.addWorldObject(createTeamWorld());
                        addSquadToTeamWorld(yourTeamWorld.containedWorld, y - 56, topSquad, youAreWinner ? 'friend' : 'enemy', true);
                        addSquadToTeamWorld(yourTeamWorld.containedWorld, y + 52, bottomSquad, youAreWinner ? 'enemy' : 'friend', false);
                        return [4 /*yield*/, S.tween(1 * timeScale, yourTeamWorld, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    }
    function escapeGarble(text) {
        var e_93, _a;
        var result = '';
        try {
            for (var text_1 = __values(text), text_1_1 = text_1.next(); !text_1_1.done; text_1_1 = text_1.next()) {
                var char = text_1_1.value;
                if (isEscape() && char.match(/[a-zA-Z]/i)) {
                    result += "<g" + Random.int(1, 5) + ">";
                }
                else {
                    result += char;
                }
            }
        }
        catch (e_93_1) { e_93 = { error: e_93_1 }; }
        finally {
            try {
                if (text_1_1 && !text_1_1.done && (_a = text_1.return)) _a.call(text_1);
            }
            finally { if (e_93) throw e_93.error; }
        }
        return result;
    }
    function isEscape() {
        return GAME_DATA.arg2Trigger.strategy;
    }
    function isBotted() {
        return GAME_DATA.offlineCount >= 10;
    }
})(EndScreens || (EndScreens = {}));
function isBallmanacToComplete() {
    return hasCompletedAchievement('CompleteTheBallmanac') && !loadSeenAlmanacComplete();
}
var FactoryPipeController = /** @class */ (function (_super) {
    __extends(FactoryPipeController, _super);
    function FactoryPipeController(topPipe, bottomPipe) {
        var _this = _super.call(this) || this;
        _this.arenaShrinkFactor = 0;
        var fpc = _this;
        _this.runScript(function () {
            var initialWaitForNSeconds, spawnEveryNSeconds, currentPipe, waitTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        initialWaitForNSeconds = 1;
                        spawnEveryNSeconds = M.mapClamp(GAME_DATA.round, 1, 7, 3, 1.5);
                        return [4 /*yield*/, S.waitUntil(function () { return getBattleState(topPipe.world) === Ball.States.BATTLE; })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(initialWaitForNSeconds)];
                    case 2:
                        _a.sent();
                        currentPipe = bottomPipe;
                        _a.label = 3;
                    case 3:
                        if (!true) return [3 /*break*/, 6];
                        currentPipe.shoot();
                        waitTime = M.lerp(spawnEveryNSeconds, 1, fpc.arenaShrinkFactor);
                        return [4 /*yield*/, S.wait(waitTime)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, S.waitUntil(function () { return topPipe.world.select.tag(Tags.SPAWNED_BY_FACTORY).length < FactoryPipeController.MAX_NEUTRAL_BALLS_SPAWNED; })];
                    case 5:
                        _a.sent();
                        currentPipe = currentPipe === bottomPipe ? topPipe : bottomPipe;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    FactoryPipeController.MAX_NEUTRAL_BALLS_SPAWNED = 10;
    return FactoryPipeController;
}(WorldObject));
var FactoryPipe = /** @class */ (function (_super) {
    __extends(FactoryPipe, _super);
    function FactoryPipe(x, y, flipped) {
        return _super.call(this, {
            x: x, y: y,
            texture: 'factorypipe',
            flipY: flipped,
            layer: Battle.Layers.walls,
            effects: { outline: {} },
        }) || this;
    }
    Object.defineProperty(FactoryPipe.prototype, "extend", {
        get: function () { return this.scaleY; },
        set: function (v) {
            this.scaleX = 1 / v;
            this.scaleY = v;
        },
        enumerable: false,
        configurable: true
    });
    FactoryPipe.prototype.shoot = function () {
        if (this.shootScript && !this.shootScript.done)
            return;
        var pipe = this;
        this.shootScript = this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(1, pipe, 'extend', 1, 0.7)];
                    case 1:
                        _a.sent();
                        pipe.world.playSound('shoot', { speed: 0.5, humanized: false });
                        return [4 /*yield*/, S.tween(0.05, pipe, 'extend', 0.7, 1.5, Tween.Easing.OutQuad)];
                    case 2:
                        _a.sent();
                        pipe.summonNeutralBall(pipe.flipY);
                        return [4 /*yield*/, S.tween(0.1, pipe, 'extend', 1.5, 0.9, Tween.Easing.InOutQuad)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.tween(0.1, pipe, 'extend', 0.9, 1, Tween.Easing.InQuad)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    FactoryPipe.prototype.summonNeutralBall = function (flipped) {
        var spawnSpecial = Ball.Random.boolean(0.2);
        var ballSpawn = spawnSpecial ? Ball.Random.element(FactoryPipe.BALL_SPAWNS) : FactoryPipe.BALL_SPAWNS[0];
        var ball = this.world.addWorldObject(squadBallToWorldBall({
            x: this.x,
            y: this.y + (flipped ? -40 : 40),
            properties: {
                type: ballSpawn.type,
                level: 1,
                damage: ballSpawn.damage,
                health: ballSpawn.health,
                equipment: -1,
                metadata: {},
            },
        }, undefined, -1, 'neutral'));
        ball.v.set(Ball.Random.float(-50, 50), flipped ? -150 : 150);
        ball.neutralFlowDirection = Ball.Random.sign();
        ball.addTag(Tags.SPAWNED_BY_FACTORY);
    };
    FactoryPipe.BALL_SPAWNS = [
        {
            type: 0,
            damage: 1,
            health: 2,
        },
        // { // Crusher
        //     type: 4,
        //     damage: 0,
        //     health: 6,
        // },
        {
            type: 7,
            damage: 1,
            health: 0,
        },
        {
            type: 11,
            damage: 0,
            health: 6,
        },
        // { // Zombie
        //     type: 15,
        //     damage: 1,
        //     health: 3,
        // },
        {
            type: 108,
            damage: 0,
            health: 10,
        },
    ];
    return FactoryPipe;
}(Sprite));
var TIP_NUM = 0;
var TIPS = [
    "(Everything that happens in battle resets on the next round!)",
    "(Every few turns, the shop upgrades to sell better balls!)",
    "(Combining Coins will combine their gold stores!)",
    "(Don't forget to freeze!)",
    "(If you win 8 rounds, your name gets a [color 0xD3B000][offsetx -3]<crown>[/o][/c]Crown!)",
];
var ERROR_TIMED_OUT = 'Timed out';
function findOpponent(world, predefinedEnemySquad, isPredefinedEnemySquadBot) {
    return function () {
        var fade, findOpponentText, findOpponentSpinner, tipText, arenaName, apiVersionForSubmit, dailyDay, week, bannedBallTypes, packsForOpponent, enemySquadData, startTime, err, isBot, retriesLeft, getArenaName, _loop_5, state_1, totalTime, _a, _b, ball, pos, translatedPos, formattedEnemyName, i, ball, balls, balls_10, balls_10_1, ball, foundOpponentTextTop, foundOpponentTextBottom, gear, pauseChar, speedUpChar, timeControlText, sidePanel;
        var e_94, _c, e_95, _d;
        var _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    global.game.allowPauseWithPauseKey = false;
                    world.select.modules(Button).forEach(function (button) { return button.enabled = false; });
                    world.select.type(BallMover).removeFromWorld();
                    world.select.type(BallFreezer).removeFromWorld();
                    world.select.type(BallHighlighter).enabled = false;
                    world.select.type(InfoBox).enabled = false;
                    world.select.type(BoundsInfoBox).enabled = false;
                    return [4 /*yield*/, waitUntilFindOpponentDelayComplete(world)];
                case 1:
                    _f.sent();
                    setBallPositions(world);
                    // After all changes to the squad have been finalized...
                    saveMatchmakingOrChallengeModeOrDailyGameData({
                        gameData: GAME_DATA,
                        state: 'play',
                        lock: gameDataLock(),
                    }, CHALLENGE_MODE_ENABLED, DAILY);
                    fade = world.addWorldObject(new Sprite({
                        texture: Texture.filledRect(world.width, world.height, 0x000000, 0.8),
                        alpha: 0,
                    }));
                    findOpponentText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 136,
                        text: predefinedEnemySquad ? 'Starting battle...' : 'Finding an opponent...',
                        anchor: Vector2.TOP_CENTER,
                        alpha: 0,
                    }));
                    findOpponentSpinner = world.addWorldObject(new Spinner(world.width / 2, 100, 4, 16));
                    findOpponentSpinner.alpha = 0;
                    return [4 /*yield*/, S.doOverTime(1, function (t) {
                            fade.alpha = t;
                            findOpponentText.alpha = t;
                            findOpponentSpinner.alpha = t;
                            if (global.game.musicManager.currentMusic) {
                                global.game.musicManager.currentMusic.volume = 1 - 0.5 * t;
                            }
                        })];
                case 2:
                    _f.sent();
                    tipText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: global.gameHeight - 8,
                        text: TIPS[TIP_NUM],
                        maxWidth: global.gameWidth - 40,
                        anchor: Vector2.BOTTOM_CENTER,
                        justify: 'center',
                        style: { color: 0xAAAAAA },
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.tween(1, tipText, 'alpha', 0, 1)];
                case 3:
                    _f.sent();
                    TIP_NUM = M.mod(TIP_NUM + 1, TIPS.length);
                    arenaName = world.data.arenaName;
                    apiVersionForSubmit = getApiVersionForSquadSubmit(GAME_DATA);
                    dailyDay = DAILY ? DAILY.day : undefined;
                    week = GAME_DATA.weekly ? GAME_DATA.weekly.week : undefined;
                    "modded_remove_from";
                    if (!IS_SUBMISSION_DISABLED()
                        && !GAME_DATA.squad.balls.some(function (ball) { return ball.properties.type === 41; })
                        && _.contains(Arenas.ARENAS, arenaName)
                        && !predefinedEnemySquad
                        && apiVersionForSubmit) {
                        API.submitsquad(function (_, err) {
                            if (err) {
                                console.error(err);
                                return;
                            }
                            debug('Submitted squad:', GAME_DATA.squad);
                        }, GAME_DATA.squad.name, GAME_DATA.round, GAME_DATA.squad, GAME_DATA.gameId, Persistence.getProfileId(), GAME_DATA.lap, GAME_DATA.offlineCount, arenaName, GAME_DATA.packs, apiVersionForSubmit, dailyDay, week);
                    }
                    "modded_remove_to";
                    bannedBallTypes = [41];
                    if (!hasCompletedAchievement('ArgPart1'))
                        bannedBallTypes.push(42);
                    packsForOpponent = GAME_DATA.packs;
                    if (isModifierActive('packclash') && packsForOpponent.length === 1) {
                        if (packsForOpponent[0] === 'weekly')
                            packsForOpponent = ['weekly'];
                        else if (packsForOpponent[0] === 'classic')
                            packsForOpponent = ['community'];
                        else
                            packsForOpponent = ['classic'];
                    }
                    startTime = Date.now();
                    isBot = false;
                    if (!predefinedEnemySquad) return [3 /*break*/, 4];
                    enemySquadData = predefinedEnemySquad;
                    isBot = !!isPredefinedEnemySquadBot;
                    return [3 /*break*/, 9];
                case 4:
                    if (!(DAILY && GAME_DATA.round - 1 < DAILY.squads.length && DAILY.squads[GAME_DATA.round - 1])) return [3 /*break*/, 5];
                    enemySquadData = O.deepClone(DAILY.squads[GAME_DATA.round - 1]);
                    transformDailyEnemySquad(enemySquadData);
                    return [3 /*break*/, 9];
                case 5:
                    retriesLeft = 5;
                    getArenaName = _.contains(Arenas.ARENAS, arenaName) ? arenaName : Arenas.ARENA_FIRST;
                    _loop_5 = function () {
                        var callDone;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    callDone = false;
                                    API.getsquad(function (squadData, e) {
                                        enemySquadData = squadData;
                                        err = e;
                                        callDone = true;
                                        debug('Received squad data:', squadData);
                                    }, GAME_DATA.squad.name, GAME_DATA.round, getAllowProfaneSquadNames(), bannedBallTypes, GAME_DATA.lap, getArenaName, packsForOpponent, week);
                                    startTime = Date.now();
                                    return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                                case 1:
                                    _a.sent();
                                    if (!callDone) {
                                        err = ERROR_TIMED_OUT;
                                    }
                                    if (err) {
                                        console.error('Error fetching squad:', err);
                                    }
                                    if (!(err && retriesLeft > 0)) return [3 /*break*/, 3];
                                    retriesLeft--;
                                    return [4 /*yield*/, S.wait(3)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, "continue"];
                                case 3: return [2 /*return*/, "break"];
                            }
                        });
                    };
                    _f.label = 6;
                case 6:
                    if (!(retriesLeft >= 0)) return [3 /*break*/, 8];
                    return [5 /*yield**/, _loop_5()];
                case 7:
                    state_1 = _f.sent();
                    if (state_1 === "break")
                        return [3 /*break*/, 8];
                    return [3 /*break*/, 6];
                case 8:
                    if (err) {
                        console.error('Failed to get squad:', err);
                        enemySquadData = {
                            squad: generateBotSquadForRound(GAME_DATA.round, packsForOpponent, GAME_DATA.weekly),
                            version: API.VERSION,
                            arena: GAME_DATA.arena,
                        };
                        isBot = true;
                        if (err === API.ERROR_NO_SQUAD_RECEIVED) {
                            GAME_DATA.offlineCount++;
                        }
                    }
                    _f.label = 9;
                case 9:
                    totalTime = Random.int(1000, 3000);
                    return [4 /*yield*/, S.waitUntil(function () { return Date.now() - startTime > totalTime; })];
                case 10:
                    _f.sent();
                    cleanseEnemySquadData(enemySquadData);
                    ENEMY_SQUAD_DATA = enemySquadData;
                    if (ENEMY_SQUAD_DATA.arena !== GAME_DATA.arena && !predefinedEnemySquad) {
                        try {
                            for (_a = __values(ENEMY_SQUAD_DATA.squad.balls), _b = _a.next(); !_b.done; _b = _a.next()) {
                                ball = _b.value;
                                pos = vec2(ball);
                                translatedPos = Arenas.translateCoordinate(pos, ENEMY_SQUAD_DATA.arena, GAME_DATA.arena);
                                ball.x = translatedPos.x;
                                ball.y = translatedPos.y;
                            }
                        }
                        catch (e_94_1) { e_94 = { error: e_94_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_94) throw e_94.error; }
                        }
                    }
                    saveMatchmakingOrChallengeModeOrDailyGameData({
                        gameData: GAME_DATA,
                        state: 'battle',
                        enemySquadData: ENEMY_SQUAD_DATA,
                        isEnemySquadBot: isBot,
                        lock: gameDataLock(),
                    }, CHALLENGE_MODE_ENABLED, DAILY);
                    formattedEnemyName = enemySquadData.squad.name;
                    if (enemySquadData.gameResult === 'win') {
                        formattedEnemyName = crownedName(enemySquadData.squad.name);
                    }
                    world.select.name('opponentname').setText(formattedEnemyName);
                    (_e = world.select.name('midwall')) === null || _e === void 0 ? void 0 : _e.removeFromWorld();
                    for (i = 0; i < enemySquadData.squad.balls.length; i++) {
                        ball = world.addWorldObject(squadBallToWorldBall(enemySquadData.squad.balls[i], undefined, -1, 'enemy', true));
                        if (isBot) {
                            ball.hp = ball.maxhp = ball.properties.health - 1 + ball.getShopHp();
                            ball.dmg = ball.properties.damage - 1 + ball.getShopDmg();
                        }
                        ball.showAllStats();
                    }
                    balls = world.select.typeAll(Ball).filter(function (ball) { return !ball.isInShop; });
                    try {
                        for (balls_10 = __values(balls), balls_10_1 = balls_10.next(); !balls_10_1.done; balls_10_1 = balls_10.next()) {
                            ball = balls_10_1.value;
                            ball.onTeamsSpawned();
                        }
                    }
                    catch (e_95_1) { e_95 = { error: e_95_1 }; }
                    finally {
                        try {
                            if (balls_10_1 && !balls_10_1.done && (_d = balls_10.return)) _d.call(balls_10);
                        }
                        finally { if (e_95) throw e_95.error; }
                    }
                    global.game.stopMusic(1);
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            findOpponentText.alpha = 1 - t;
                            findOpponentSpinner.alpha = 1 - t;
                            tipText.alpha = 1 - t;
                        })];
                case 11:
                    _f.sent();
                    findOpponentText.kill();
                    findOpponentSpinner.kill();
                    tipText.kill();
                    foundOpponentTextTop = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 120,
                        text: err ? 'Could not find opponent.' : "You are battling [y]" + formattedEnemyName + "[/y]!",
                        anchor: Vector2.CENTER,
                        alpha: 0,
                    }));
                    foundOpponentTextBottom = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 140,
                        text: err ? 'Auto-generating one instead!' : "(Good luck! :D)",
                        anchor: Vector2.CENTER,
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            foundOpponentTextTop.alpha = t;
                            foundOpponentTextBottom.alpha = t;
                        })];
                case 12:
                    _f.sent();
                    return [4 /*yield*/, S.wait(1)];
                case 13:
                    _f.sent();
                    return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                            fade.alpha = 1 - t;
                            foundOpponentTextTop.alpha = 1 - t;
                            foundOpponentTextBottom.alpha = 1 - t;
                        })];
                case 14:
                    _f.sent();
                    fade.kill();
                    foundOpponentTextTop.kill();
                    foundOpponentTextBottom.kill();
                    gear = global.world.select.name('gear');
                    gear.getModule(Button).enabled = true;
                    pauseChar = IS_MOBILE ? '[offset 5 -3]<touch_tap>[/]' : '<lmb>';
                    speedUpChar = IS_MOBILE ? '[offset 5 -3]<touch_hold>[/]' : '<rmb>';
                    timeControlText = world.addWorldObject(new SpriteText({
                        x: world.width / 2, y: 232,
                        text: pauseChar + " Pause    " + speedUpChar + " Speed Up",
                        anchor: Vector2.CENTER,
                        alpha: 0,
                        effects: { outline: { color: 0x000000, alpha: 0 } },
                        layer: Battle.Layers.ui,
                    }));
                    sidePanel = world.select.name('sidepanel');
                    return [4 /*yield*/, [
                            S.tween(1, sidePanel, 'x', 0, world.width, Tween.Easing.InOutQuad),
                            S.doOverTime(1, function (t) {
                                timeControlText.alpha = t;
                                timeControlText.effects.outline.alpha = t;
                            }),
                        ]];
                case 15:
                    _f.sent();
                    sidePanel.kill();
                    world.select.type(BallHighlighter).enabled = true;
                    world.select.type(InfoBox).enabled = true;
                    world.data.youArePlaying = true;
                    global.theater.select.type(BattleSpeedController).enabled = true;
                    return [4 /*yield*/, GameFragments.gameCountdownAndStartScript(world)];
                case 16:
                    _f.sent();
                    return [2 /*return*/];
            }
        });
    };
}
function getBattleState(world) {
    if (!world)
        return undefined;
    return world.data.battleState;
}
function youArePlaying(world) {
    return world && !!world.data.youArePlaying;
}
function cleanseEnemySquadData(enemySquadData) {
    if (GAME_DATA.lap <= 1)
        return;
    if (enemySquadData.version === API.VERSION)
        return;
    /* Re-enable if VL stat skewing is needed */
    // let yourTotalStats = A.sum(GAME_DATA.squad.balls, ball => ball.properties.damage + ball.properties.health);
    // let enemyTotalStats = A.sum(enemySquadData.squad.balls, ball => ball.properties.damage + ball.properties.health);
    // if (enemyTotalStats > yourTotalStats) {
    //     for (let ball of enemySquadData.squad.balls) {
    //         ball.properties.health = Math.ceil(ball.properties.health * yourTotalStats/enemyTotalStats);
    //         ball.properties.damage = Math.ceil(ball.properties.damage * yourTotalStats/enemyTotalStats);
    //     }
    // }
    // let yourTotalLevel = A.sum(GAME_DATA.squad.balls, ball => ball.properties.level);
    // let enemyTotalLevel = A.sum(enemySquadData.squad.balls, ball => ball.properties.level);
    // if (enemyTotalLevel > yourTotalLevel) {
    //     for (let ball of enemySquadData.squad.balls) {
    //         ball.properties.level = Math.ceil(ball.properties.level * yourTotalLevel/enemyTotalLevel);
    //     }
    // }
}
function transformDailyEnemySquad(enemySquadData) {
    var e_96, _a;
    Random.seed("dailyadjustments_" + getRandomSeed(GAME_DATA.gameId, DAILY) + "_" + GAME_DATA.round);
    try {
        for (var _b = __values(enemySquadData.squad.balls), _c = _b.next(); !_c.done; _c = _b.next()) {
            var ball = _c.value;
            adjustSquadBallForModifiers(ball);
        }
    }
    catch (e_96_1) { e_96 = { error: e_96_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_96) throw e_96.error; }
    }
}
var FIND_OPPONENT_WAIT_TIME = 0;
function waitUntilFindOpponentDelayComplete(world) {
    return function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(FIND_OPPONENT_WAIT_TIME > 0)) return [3 /*break*/, 2];
                    FIND_OPPONENT_WAIT_TIME -= world.delta;
                    return [4 /*yield*/];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 0];
                case 2: return [4 /*yield*/, S.waitUntil(function () { return _.isEmpty(world.select.tag(Tags.DELAY_PLAY)); })];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
}
var VS_TIP_NUM = 0;
var VS_TIPS = [
    "(Each round, you and your opponent receive the same shops!)",
    "(Your opponent is adapting to your squad... can you adapt faster?)",
    "(\"The key to victory is finding your opponent's weak point.\"\n~ Ballam)",
];
function findOpponentVs(world, autoplay) {
    if (autoplay === void 0) { autoplay = false; }
    return function () {
        var fade, waitingForText, waitingForSpinner, tipText, errorText, _loop_6, state_2, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    global.game.allowPauseWithPauseKey = false;
                    world.select.modules(Button).forEach(function (button) { return button.enabled = false; });
                    world.select.type(BallMover).removeFromWorld();
                    world.select.type(BallFreezer).removeFromWorld();
                    world.select.type(BallHighlighter).enabled = false;
                    world.select.type(InfoBox).enabled = false;
                    world.select.type(BoundsInfoBox).enabled = false;
                    world.select.type(VsStatusCheckmarker).removeFromWorld();
                    return [4 /*yield*/, waitUntilFindOpponentDelayComplete(world)];
                case 1:
                    _a.sent();
                    setBallPositions(world);
                    fade = world.addWorldObject(new Sprite({
                        texture: Texture.filledRect(world.width, world.height, 0x000000, 0.8),
                        alpha: 0,
                    }));
                    waitingForText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 136,
                        text: autoplay ? "Waiting for " + VS_GAME.enemyname + "..." : "Submitting squad...",
                        anchor: Vector2.TOP_CENTER,
                        alpha: 0,
                    }));
                    waitingForSpinner = world.addWorldObject(new Spinner(world.width / 2, 100, 4, 16));
                    waitingForSpinner.alpha = 0;
                    return [4 /*yield*/, S.doOverTime(1, function (t) {
                            fade.alpha = t;
                            waitingForText.alpha = t;
                            waitingForSpinner.alpha = t;
                            if (global.game.musicManager.currentMusic) {
                                global.game.musicManager.currentMusic.volume = 1 - 0.5 * t;
                            }
                        })];
                case 2:
                    _a.sent();
                    tipText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: global.gameHeight - 8,
                        text: VS_TIPS[VS_TIP_NUM],
                        maxWidth: global.gameWidth - 40,
                        anchor: Vector2.BOTTOM_CENTER,
                        justify: 'center',
                        style: { color: 0xAAAAAA },
                        alpha: 0,
                    }));
                    return [4 /*yield*/, S.tween(1, tipText, 'alpha', 0, 1)];
                case 3:
                    _a.sent();
                    VS_TIP_NUM = M.mod(VS_TIP_NUM + 1, VS_TIPS.length);
                    errorText = world.addWorldObject(new SpriteText({
                        x: global.gameWidth / 2, y: 178,
                        anchor: Vector2.CENTER,
                        style: { color: 0x888888 },
                    }));
                    if (!!autoplay) return [3 /*break*/, 9];
                    _loop_6 = function () {
                        var err, callDone, startTime;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    callDone = false;
                                    API.submitvssquad(function (_, _err) {
                                        err = _err;
                                        callDone = true;
                                        if (!err)
                                            debug('Submitted VS squad:', GAME_DATA.squad);
                                    }, GAME_DATA.gameId, GAME_DATA.squad.name, GAME_DATA.round, GAME_DATA.squad, Persistence.getProfileId());
                                    startTime = Date.now();
                                    return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                                case 1:
                                    _a.sent();
                                    if (!callDone) {
                                        err = ERROR_TIMED_OUT;
                                    }
                                    if (!err) return [3 /*break*/, 3];
                                    debug("Error:", err);
                                    errorText.setText('An error occurred');
                                    return [4 /*yield*/, S.wait(2)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, "continue"];
                                case 3:
                                    errorText.setText('');
                                    return [2 /*return*/, "break"];
                            }
                        });
                    };
                    _a.label = 4;
                case 4:
                    if (!true) return [3 /*break*/, 6];
                    return [5 /*yield**/, _loop_6()];
                case 5:
                    state_2 = _a.sent();
                    if (state_2 === "break")
                        return [3 /*break*/, 6];
                    return [3 /*break*/, 4];
                case 6: return [4 /*yield*/, S.tween(0.5, waitingForText, 'alpha', 1, 0)];
                case 7:
                    _a.sent();
                    waitingForText.setText("Waiting for " + VS_GAME.enemyname + "...");
                    return [4 /*yield*/, S.tween(0.5, waitingForText, 'alpha', 0, 1)];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    result = {};
                    return [4 /*yield*/, GameFragments.waitForVSGameCondition(GAME_DATA.gameId, GAME_DATA.squad.name, false, function (game) { return game.enemysquad || game.round > GAME_DATA.round; }, result, function (err) { return errorText.setText(err ? 'An error occurred' : ''); })];
                case 10:
                    _a.sent();
                    if (!(result.game.startTime && result.game.startTime >= Date.now() && result.game.startTime <= Date.now() + 6000)) return [3 /*break*/, 12];
                    return [4 /*yield*/, S.waitUntil(function () { return Date.now() >= result.game.startTime; })];
                case 11:
                    _a.sent();
                    _a.label = 12;
                case 12:
                    saveVersusModeGameData({
                        gameData: GAME_DATA,
                        state: 'battle',
                    });
                    global.game.stopMusic(1);
                    GameFragments.startVsGame(GAME_DATA.gameId, result.game, false, false);
                    return [2 /*return*/];
            }
        });
    };
}
var FireFilter = /** @class */ (function (_super) {
    __extends(FireFilter, _super);
    function FireFilter() {
        var _this = _super.call(this, {
            uniforms: { 'float toffset': Random.float(0, 1), 'float angle': 0, 'float length': 1 },
            code: "\n                float ou = map(x / width, 1.0/3.0, 2.0/3.0, -0.5, 0.5);\n                float ov = map(y / height, 1.0/3.0, 2.0/3.0, -0.5, 0.5);\n\n                float s = sin(angle * PI / 180.0);\n                float c = cos(angle * PI / 180.0);\n                float u = c*ou - s*ov;\n                float v = s*ou + c*ov;\n\n                float noise = map(pnoise(u*4.25, v*4.25 + (t + toffset)*5.0, 20.3), -1.0, 1.0, 0.0, 1.0);\n\n                float gradient = mapClamp(v, -1.1, -0.3, 0.0, 1.0);\n\n                float l1 = 0.35 * length;\n                float l2 = 0.65 * length;\n\n                float base = mapClamp(sqrt(u*u + v*v), 0.5, 0.45, 0.0, 1.0);\n                float flame1 = mapClamp(sqrt(u*u + (v+l1)*(v+l1)), 0.5, 0.3, 0.0, 1.0);\n                float flame2 = mapClamp(sqrt(u*u + (v+l2)*(v+l2)), 0.3, 0.2, 0.0, 1.0);\n\n                float total = clamp(base + flame1 + flame2, 0.0, 1.0) * gradient;\n\n                float step1 = step(noise, total);\n\n                outp.a = step1 * inp.a;\n\n                if (u < -0.5 || u > 0.5 || v < -1.0 || v > 0.5) outp.a = 0.0;\n            "
        }) || this;
        _this.angle = 0;
        _this.length = 1;
        return _this;
    }
    Object.defineProperty(FireFilter.prototype, "angle", {
        get: function () { return this._angle; },
        set: function (v) {
            this._angle = v;
            this.setUniform('angle', v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FireFilter.prototype, "length", {
        get: function () { return this._length; },
        set: function (v) {
            this._length = v;
            this.setUniform('length', v);
        },
        enumerable: false,
        configurable: true
    });
    return FireFilter;
}(TextureFilter));
var FlashingStatusEffectFilter = /** @class */ (function (_super) {
    __extends(FlashingStatusEffectFilter, _super);
    function FlashingStatusEffectFilter() {
        var _this = _super.call(this, {
            uniforms: { 'float amount': 0, 'vec3 color': [1, 1, 1] },
            code: "\n                float blendAmount = amount * map(sin(40.0*t), -1.0, 1.0, 0.2, 1.0);\n                outp.rgb = outp.rgb * (1.0 - blendAmount) + color * blendAmount;\n            "
        }) || this;
        _this._amount = 0;
        _this._color = 0xFFFFFF;
        return _this;
    }
    Object.defineProperty(FlashingStatusEffectFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (value) {
            this._amount = value;
            this.setUniform('amount', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FlashingStatusEffectFilter.prototype, "color", {
        get: function () { return this._color; },
        set: function (value) {
            this._color = value;
            this.setUniform('color', M.colorToVec3(value));
        },
        enumerable: false,
        configurable: true
    });
    return FlashingStatusEffectFilter;
}(TextureFilter));
var FlipbookFilter = /** @class */ (function (_super) {
    __extends(FlipbookFilter, _super);
    /**
     * @param strength - the amplitude of the offset
     * @param speed - the speed at which the offset cycles
     * @param granularity - how big is the time rubberbanding
     * @param offset - time offset
     */
    function FlipbookFilter(strength, speed, granularity, spread, offset) {
        if (offset === void 0) { offset = 0; }
        var _this = _super.call(this, {
            uniforms: {
                'float strength': strength,
                'float speed': speed,
                'float granularity': granularity,
                'float offset': offset,
                'float spread': spread,
            },
            code: "\n                float zoom = 11.0 * spread;\n                float tt = floor((t + offset) * speed * granularity) / granularity;\n                float offsety = pnoise(x/zoom, 0.0, tt*5.1) * strength;\n                float offsetx = pnoise(0.0, y/zoom, tt*5.1) * strength;\n                outp = getColor(x + offsetx, y + offsety);\n            "
        }) || this;
        _this._strength = strength;
        _this._speed = speed;
        _this._granularity = granularity;
        _this._offset = offset;
        return _this;
    }
    Object.defineProperty(FlipbookFilter.prototype, "strength", {
        get: function () { return this._strength; },
        set: function (value) {
            this._strength = value;
            this.setUniform('strength', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FlipbookFilter.prototype, "speed", {
        get: function () { return this._speed; },
        set: function (value) {
            this._speed = value;
            this.setUniform('speed', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FlipbookFilter.prototype, "granularity", {
        get: function () { return this._granularity; },
        set: function (value) {
            this._granularity = value;
            this.setUniform('granularity', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FlipbookFilter.prototype, "offset", {
        get: function () { return this._offset; },
        set: function (value) {
            this._offset = value;
            this.setUniform('offset', value);
        },
        enumerable: false,
        configurable: true
    });
    return FlipbookFilter;
}(TextureFilter));
var Flow;
(function (Flow) {
    function GET_FIXED_FLOW_TEXTURE() {
        return Texture.filledRect(global.gameWidth, global.gameHeight, 0x808080)
            .transform({ filters: [new GenFilter()] }, 'Flow.GET_FIXED_FLOW_TEXTURE');
    }
    Flow.GET_FIXED_FLOW_TEXTURE = GET_FIXED_FLOW_TEXTURE;
    function getVectors(texture) {
        var pixels = Main.renderer.plugins.extract.pixels(texture.renderTextureSprite.renderTexture);
        var result = [];
        for (var y = 0; y < texture.height; y++) {
            var line = [];
            for (var x = 0; x < texture.width; x++) {
                var i = x + y * texture.width;
                var r = pixels[4 * i + 0];
                var g = pixels[4 * i + 1];
                var haxis = r === 128 ? 0 : 2 * r / 255 - 1;
                var vaxis = g === 128 ? 0 : 2 * g / 255 - 1;
                line.push(vec2(haxis, vaxis));
            }
            result.push(line);
        }
        return result;
    }
    Flow.getVectors = getVectors;
})(Flow || (Flow = {}));
var FlowFilter = /** @class */ (function (_super) {
    __extends(FlowFilter, _super);
    function FlowFilter(amount, speed) {
        if (speed === void 0) { speed = 1; }
        return _super.call(this, {
            uniforms: { 'float amount': amount, 'float speed': speed },
            code: "\n                float vx = 2.0*inp.r - 1.0;\n                float vy = 2.0*inp.g - 1.0;\n                float v = sqrt(vx*vx + vy*vy) - 0.00277;\n\n                float theta = atan(vy, vx);\n\n                float flow = mod(-theta/PI*8.0 + 1.5*speed*t, 1.0);\n\n                float famt = amount * v;\n                outp.rgb = outp.rgb * (1.0 - famt) + vec3(flow, flow, flow) * famt;\n            "
        }) || this;
    }
    return FlowFilter;
}(TextureFilter));
var FlowFilterFactory = /** @class */ (function (_super) {
    __extends(FlowFilterFactory, _super);
    function FlowFilterFactory() {
        return _super.call(this, {
            code: "\n                float theta = atan(y - height/2.0, x - width/2.0);\n\n                float light = mod(theta/PI*1.0 - 0.2*t, 1.0);\n\n                outp.rgb = outp.rgb * lerp(0.3, 1.0, light);\n            "
        }) || this;
    }
    return FlowFilterFactory;
}(TextureFilter));
var FlowHolder = /** @class */ (function (_super) {
    __extends(FlowHolder, _super);
    function FlowHolder(flowTexture) {
        var _this = _super.call(this) || this;
        _this.flowTexture = flowTexture;
        _this.flow = Flow.getVectors(flowTexture);
        return _this;
    }
    return FlowHolder;
}(WorldObject));
function newGameData() {
    var gameId = getNewGameId();
    return {
        apiVersion: API.VERSION,
        gameId: gameId,
        arena: Arenas.ARENA_FIRST,
        wins: 0,
        health: 4,
        round: 1,
        lap: 1,
        packs: ['classic'],
        modifiers: [],
        squad: {
            name: 'Unknown',
            balls: [],
        },
        shopMusic: selectRandomShopMusic(gameId),
        battleMusic: selectRandomBattleMusic(gameId),
        availableBallTypes: undefined,
        availableItemTypes: undefined,
        weekly: undefined,
        startShopEffects: [],
        restockQueue: [],
        frozenThings: [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined],
        gold: 10,
        restocksThisRound: 0,
        freeRestocksUntilPlay: 0,
        hasPurchasedDove: false,
        bankedGold: [],
        hasBuggedSquad: false,
        roundResults: {},
        gameTime: 0,
        offlineCount: 0,
        playersWhoBeatYou: [],
        hasBoughtEquipment: false,
        hasFrozen: false,
        hasRestocked: false,
        hasLostRound: false,
        hasLeveledUp: false,
        hasSold: false,
        hasBoughtItem: false,
        ballTypesForAlmanacWin: [],
        itemTypesForAlmanacWin: [],
        argTrigger: { zombie: false, restocks: 0 },
        arg2Trigger: { strategy: false },
    };
}
function fixGameDataFromPreviousVersion(gameData) {
    if (!gameData.bankedGold)
        gameData.bankedGold = [];
}
// Matchmaking
function saveMatchmakingOrChallengeModeOrDailyGameData(gameData, challengeMode, daily) {
    if (daily) {
        saveData('dailyGameData', {
            matchmakingGameData: gameData,
            day: daily.day,
        });
        return;
    }
    if (challengeMode) {
        saveData('challengeModeGameData', gameData);
        return;
    }
    saveData('matchmakingGameData', gameData);
}
function loadMatchmakingGameData() {
    var data = loadDataObject('matchmakingGameData', undefined);
    fillInGameData(data === null || data === void 0 ? void 0 : data.gameData);
    return data;
}
function loadChallengeModeGameData() {
    var data = loadDataObject('challengeModeGameData', undefined);
    fillInGameData(data === null || data === void 0 ? void 0 : data.gameData);
    return data;
}
function loadDailyGameData(currentDay) {
    var data = loadDataObject('dailyGameData', undefined);
    if (!data || !data.matchmakingGameData || data.day !== currentDay) { // Daily is only valid on the day it is ran.
        return undefined;
    }
    fillInGameData(data.matchmakingGameData.gameData);
    return data;
}
function fillInGameData(gameData) {
    if (!gameData)
        return;
    if (!gameData.modifiers)
        gameData.modifiers = [];
}
// Versus Mode
function saveVersusModeGameData(gameData) {
    saveData('versusModeGameData', gameData ? __assign(__assign({}, gameData), { lastPingTime: Date.now() }) : undefined);
}
function loadVersusModeGameData(config) {
    var gameData = loadDataObject('versusModeGameData', undefined);
    if (!gameData || Date.now() - gameData.lastPingTime > 3600000) {
        return undefined; // Valid time is one hour
    }
    if (config.type === 'current' && (!gameData.gameData || gameData.gameData.gameId !== config.gameid)) {
        return undefined; // Game Id doesn't match
    }
    return gameData;
}
function addBallTypeForAlmanacWin(ballType) {
    if (_.contains(GAME_DATA.ballTypesForAlmanacWin, ballType))
        return;
    GAME_DATA.ballTypesForAlmanacWin.push(ballType);
}
function addItemTypeForAlmanacWin(itemType) {
    if (_.contains(GAME_DATA.itemTypesForAlmanacWin, itemType))
        return;
    GAME_DATA.itemTypesForAlmanacWin.push(itemType);
}
function getApiVersionForSquadSubmit(gameData) {
    if (!gameData.apiVersion)
        return undefined;
    if (gameData.apiVersion === API.VERSION)
        return API.VERSION;
    if (gameData.apiVersion > API.VERSION)
        return undefined;
    for (var v = gameData.apiVersion + 1; v <= API.VERSION; v++) {
        if (_.includes(API.BREAKING_VERSIONS, v))
            return undefined;
    }
    return gameData.apiVersion;
}
function getRandomSeed(gameId, daily) {
    if (daily)
        return daily.seed;
    return gameId;
}
var lockSessionId = new UIDGenerator().generate();
function gameDataLock() {
    return {
        lockSessionId: lockSessionId,
        ms: Date.now(),
    };
}
var GameFragments;
(function (GameFragments) {
    function startMatchmakingGame(gameData, challengeMode, daily) {
        GAME_DATA = gameData.gameData;
        fixGameDataFromPreviousVersion(GAME_DATA);
        CHALLENGE_MODE_ENABLED = challengeMode;
        DAILY = daily;
        SaveValidator.storeLastCloudLockSessionId();
        if (gameData.state === 'startshop') {
            global.theater.loadStage(Stages.PREP, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        if (gameData.state === 'midshop') {
            global.theater.loadStage(Stages.PREP_SKIP_PRE_SHOP_EFFECTS, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        if (gameData.state === 'play') {
            global.theater.loadStage(Stages.PREP_SKIP_PRE_SHOP_EFFECTS, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }), function (world) {
                world.runScript(findOpponent(world));
            });
            return;
        }
        if (gameData.state === 'battle') {
            global.theater.loadStage(Stages.PREP_SKIP_PRE_SHOP_EFFECTS, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }), function (world) {
                world.runScript(findOpponent(world, gameData.enemySquadData, gameData.isEnemySquadBot));
            });
            return;
        }
        if (gameData.state === 'result') {
            if (GAME_DATA.wins >= GET_MAX_WINS()) {
                global.theater.playCutscene(RoundResults.VICTORY);
                return;
            }
            if (GAME_DATA.health <= 0) {
                global.theater.playCutscene(RoundResults.GAMEOVER);
                return;
            }
            global.theater.loadStage(Stages.PREP, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        console.error('Unknown game state, defaulting to shop:', gameData.state);
        global.theater.loadStage(Stages.PREP, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
    }
    GameFragments.startMatchmakingGame = startMatchmakingGame;
    function startVsGame(gameid, game, newGame, spectate) {
        if (spectate)
            GAME_MODE = 'spectate';
        CHALLENGE_MODE_ENABLED = false;
        DAILY = undefined;
        VS_GAME = game;
        Input.preventRegularKeyboardInput = false;
        var savedGameData = loadVersusModeGameData({ type: 'current', gameid: gameid });
        if (savedGameData && !spectate) {
            GAME_DATA = savedGameData.gameData;
            fixGameDataFromPreviousVersion(GAME_DATA);
        }
        else {
            if (newGame)
                GAME_DATA = newGameData();
            GAME_DATA.squad.name = VS_GAME.yourname;
        }
        GAME_DATA.gameId = gameid;
        GAME_DATA.availableBallTypes = VS_GAME.allowedBallTypes;
        GAME_DATA.availableItemTypes = VS_GAME.allowedItemTypes;
        GAME_DATA.arena = game.arena;
        GAME_DATA.packs = game.yourpacks;
        GAME_DATA.weekly = game.weekly;
        if (game.yourhealth === 0) {
            GAME_DATA.round = VS_GAME.round;
            GAME_DATA.health = VS_GAME.yourhealth;
            GAME_DATA.wins = 8 - VS_GAME.enemyhealth;
            global.theater.playCutscene(RoundResults.GAMEOVER);
            return;
        }
        if (game.enemyhealth === 0) {
            GAME_DATA.round = VS_GAME.round;
            GAME_DATA.health = VS_GAME.yourhealth;
            GAME_DATA.wins = 8 - VS_GAME.enemyhealth;
            global.theater.playCutscene(RoundResults.VICTORY);
            return;
        }
        if (game.yoursquad && game.enemysquad) {
            GAME_DATA.squad = game.yoursquad;
            GAME_DATA.round = VS_GAME.round;
            GAME_DATA.health = VS_GAME.yourhealth;
            GAME_DATA.wins = 8 - VS_GAME.enemyhealth;
            if (!spectate) {
                saveVersusModeGameData({
                    gameData: GAME_DATA,
                    state: 'battle',
                });
            }
            global.theater.loadStage(function () { return CustomBattle.STAGE(game.yoursquad, game.enemysquad, GAME_DATA.gameId, VS_GAME.round); }, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        if (spectate) {
            GAME_DATA.round = VS_GAME.round;
            global.theater.loadStage(SpectateWaitingRoom.STAGE, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        if (game.yoursquad) {
            GAME_DATA.squad = game.yoursquad;
            GAME_DATA.gold = 0;
            global.theater.loadStage(Stages.PREP_SKIP_PRE_SHOP_EFFECTS, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }), function (world) {
                world.runScript(findOpponentVs(world, true));
            });
            return;
        }
        if (game.yourlastsquad && !savedGameData) {
            GAME_DATA.squad = game.yourlastsquad;
        }
        if (savedGameData && savedGameData.state === 'midshop') {
            global.theater.loadStage(Stages.PREP_SKIP_PRE_SHOP_EFFECTS, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
            return;
        }
        global.theater.loadStage(Stages.PREP, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
    }
    GameFragments.startVsGame = startVsGame;
    function playPrep(world) {
        var e_97, _a;
        if (world.data.clickedPlay)
            return;
        world.playSound('play');
        world.data.clickedPlay = true;
        var timeLimitTimer = world.select.name('timelimittimer', false);
        if (timeLimitTimer) {
            timeLimitTimer.getTimers()[0].paused = true;
        }
        FIND_OPPONENT_WAIT_TIME = 0;
        var playerBalls = world.select.typeAll(Ball).filter(function (ball) { return !ball.isInShop; });
        try {
            for (var playerBalls_1 = __values(playerBalls), playerBalls_1_1 = playerBalls_1.next(); !playerBalls_1_1.done; playerBalls_1_1 = playerBalls_1.next()) {
                var ball = playerBalls_1_1.value;
                ball.playButtonClicked();
            }
        }
        catch (e_97_1) { e_97 = { error: e_97_1 }; }
        finally {
            try {
                if (playerBalls_1_1 && !playerBalls_1_1.done && (_a = playerBalls_1.return)) _a.call(playerBalls_1);
            }
            finally { if (e_97) throw e_97.error; }
        }
        setDataPlay();
        if (GAME_MODE === 'vs') {
            world.runScript(findOpponentVs(world));
        }
        else {
            world.runScript(findOpponent(world));
        }
    }
    GameFragments.playPrep = playPrep;
    function gameCountdownAndStartScript(world) {
        return function () {
            function doCountdownNumber(count) {
                var cd;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cd = world.addWorldObject(new Sprite({
                                x: global.gameWidth / 2, y: global.gameHeight / 2,
                                texture: "countdown/" + count,
                                life: 0.5,
                                update: function () {
                                    this.alpha = 1 - Tween.Easing.InQuad(this.life.progress);
                                    if (count === 0 && Random.boolean(30 * this.delta))
                                        this.tint = 0xFFFFFF - this.tint;
                                }
                            }));
                            return [4 /*yield*/, S.waitUntil(function () { return !cd.world; })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }
            var _a, _b, ball, count, abilitySystem, _c, _d, ball, activatedAnyPreBattleAbility, activatedCatchAllAbilities, abilities, initialWaitTime, allWaitConditionScripts, balls, startEarlyBalls, maxStartEarlyTime, _loop_7, balls_11, balls_11_1, ball;
            var e_98, _e, e_99, _f, e_100, _g;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0: return [4 /*yield*/, S.wait(0.5)];
                    case 1:
                        _h.sent();
                        seedBattle(GAME_DATA.gameId, GAME_DATA.round, DAILY);
                        world.data.battleState = Ball.States.PRE_BATTLE;
                        try {
                            for (_a = __values(world.select.typeAll(Ball)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                ball = _b.value;
                                ball.setState(Ball.States.PRE_BATTLE);
                            }
                        }
                        catch (e_98_1) { e_98 = { error: e_98_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                            }
                            finally { if (e_98) throw e_98.error; }
                        }
                        count = 3;
                        _h.label = 2;
                    case 2:
                        if (!(count >= 1)) return [3 /*break*/, 6];
                        return [4 /*yield*/, S.wait(0.5)];
                    case 3:
                        _h.sent();
                        global.world.playSound('countdown', { humanized: false });
                        return [5 /*yield**/, __values(doCountdownNumber(count))];
                    case 4:
                        _h.sent();
                        _h.label = 5;
                    case 5:
                        count--;
                        return [3 /*break*/, 2];
                    case 6: return [4 /*yield*/, S.wait(0.2)];
                    case 7:
                        _h.sent();
                        world.addWorldObject(new BallLimiter());
                        abilitySystem = world.select.type(AbilitySystem);
                        abilitySystem.reset();
                        try {
                            for (_c = __values(world.select.typeAll(Ball)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                ball = _d.value;
                                ball.queueAbilities('onPreBattle');
                            }
                        }
                        catch (e_99_1) { e_99 = { error: e_99_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                            }
                            finally { if (e_99) throw e_99.error; }
                        }
                        abilitySystem.consistentizeQueuedAbilities();
                        activatedAnyPreBattleAbility = false;
                        activatedCatchAllAbilities = false;
                        _h.label = 8;
                    case 8:
                        if (!abilitySystem.hasManualAbilitiesQueued()) return [3 /*break*/, 12];
                        abilities = abilitySystem.activateNextManualAbilities();
                        if (_.isEmpty(abilities))
                            return [3 /*break*/, 12];
                        activatedAnyPreBattleAbility = true;
                        initialWaitTime = M.max(abilities, function (ability) { return ability.source.preBattleAbilityInitialWaitTime; });
                        allWaitConditionScripts = abilities.map(function (ability) { return S.waitUntil(function () { return !ability.source.isPreBattleAbilityActive; }); });
                        return [4 /*yield*/, S.wait(initialWaitTime)];
                    case 9:
                        _h.sent();
                        return [4 /*yield*/, S.either(S.wait(8), S.simul.apply(S, __spread(allWaitConditionScripts)))];
                    case 10:
                        _h.sent();
                        return [4 /*yield*/, S.wait(0.2)];
                    case 11:
                        _h.sent();
                        abilitySystem.purgeDeadPreBattleAbilities();
                        return [3 /*break*/, 8];
                    case 12:
                        if (!activatedCatchAllAbilities) return [3 /*break*/, 14];
                        return [4 /*yield*/, S.wait(1)];
                    case 13:
                        _h.sent();
                        _h.label = 14;
                    case 14:
                        if (!activatedAnyPreBattleAbility) return [3 /*break*/, 16];
                        return [4 /*yield*/, S.wait(1)];
                    case 15:
                        _h.sent();
                        _h.label = 16;
                    case 16: return [4 /*yield*/, S.wait(0.3)];
                    case 17:
                        _h.sent();
                        global.world.runScript(function () {
                            var i;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        i = 0;
                                        _a.label = 1;
                                    case 1:
                                        if (!(i < 5)) return [3 /*break*/, 4];
                                        global.world.playSound('countdownfight', { humanized: false });
                                        return [4 /*yield*/, S.wait(0.1)];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3:
                                        i++;
                                        return [3 /*break*/, 1];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        });
                        global.game.playMusic(pickMusicForThisRoundBattle(GAME_DATA), 1);
                        return [5 /*yield**/, __values(doCountdownNumber(0))];
                    case 18:
                        _h.sent();
                        world.data.startEarlyTime = world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend' && !ball.isInShop; });
                        world.data.battleState = Ball.States.BATTLE;
                        balls = world.select.typeAll(Ball);
                        startEarlyBalls = balls.filter(function (ball) { return ball.getStartEarlyTime() > 0; });
                        maxStartEarlyTime = _.isEmpty(startEarlyBalls) ? 0 : M.max(startEarlyBalls, function (ball) { return ball.getStartEarlyTime(); });
                        _loop_7 = function (ball) {
                            var waitTime = maxStartEarlyTime - ball.getStartEarlyTime();
                            if (waitTime > 0) {
                                ball.doAfterTime(waitTime, function () {
                                    ball.setState(Ball.States.BATTLE);
                                    ball.enterBattle();
                                });
                            }
                            else {
                                ball.setState(Ball.States.BATTLE);
                                ball.enterBattle();
                            }
                        };
                        try {
                            for (balls_11 = __values(balls), balls_11_1 = balls_11.next(); !balls_11_1.done; balls_11_1 = balls_11.next()) {
                                ball = balls_11_1.value;
                                _loop_7(ball);
                            }
                        }
                        catch (e_100_1) { e_100 = { error: e_100_1 }; }
                        finally {
                            try {
                                if (balls_11_1 && !balls_11_1.done && (_g = balls_11.return)) _g.call(balls_11);
                            }
                            finally { if (e_100) throw e_100.error; }
                        }
                        return [4 /*yield*/, S.wait(maxStartEarlyTime)];
                    case 19:
                        _h.sent();
                        world.select.type(InfoBox).disableWhenGameIsRunning = true;
                        world.addWorldObject(new BattleTimer());
                        world.runScript(RoundResults.RESULT_CHECK());
                        global.game.allowPauseWithPauseKey = true;
                        if (world.data.onBattleStart)
                            world.data.onBattleStart();
                        return [2 /*return*/];
                }
            });
        };
    }
    GameFragments.gameCountdownAndStartScript = gameCountdownAndStartScript;
    function seedBattle(gameid, round, daily) {
        var seed = getRandomSeed(gameid, daily);
        Random.seed("battle_" + seed + "_" + round);
        Ball.Random.seed("battle_ball_" + seed + "_" + round);
        debug('seeded', "battle_ball_" + seed + "_" + round);
    }
    function waitForVSGameCondition(gameid, squadName, spectate, condition, returnObject, onError) {
        return function () {
            var game, _loop_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _loop_8 = function () {
                            var err, callDone, startTime;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        err = undefined;
                                        callDone = false;
                                        API.getvsgame(function (_game, e) {
                                            game = _game;
                                            err = e;
                                            callDone = true;
                                        }, gameid, squadName, spectate, true, Persistence.getProfileId());
                                        startTime = Date.now();
                                        return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                                    case 1:
                                        _a.sent();
                                        if (!callDone) {
                                            err = ERROR_TIMED_OUT;
                                        }
                                        if (!err) return [3 /*break*/, 3];
                                        console.error('Failed to get game state:', err);
                                        onError(err);
                                        return [4 /*yield*/, S.wait(2)];
                                    case 2:
                                        _a.sent();
                                        return [2 /*return*/, "continue"];
                                    case 3:
                                        debug('Got VS game:', game);
                                        if (onError)
                                            onError(undefined);
                                        if (!(!game || !condition(game))) return [3 /*break*/, 5];
                                        return [4 /*yield*/, S.wait(2)];
                                    case 4:
                                        _a.sent();
                                        _a.label = 5;
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        _a.label = 1;
                    case 1:
                        if (!(!game || !condition(game))) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_8()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        if (returnObject) {
                            returnObject.game = game;
                        }
                        return [2 /*return*/];
                }
            });
        };
    }
    GameFragments.waitForVSGameCondition = waitForVSGameCondition;
})(GameFragments || (GameFragments = {}));
var GameTimer = /** @class */ (function (_super) {
    __extends(GameTimer, _super);
    function GameTimer() {
        return _super.call(this, {
            useGlobalTime: true
        }) || this;
    }
    GameTimer.prototype.update = function () {
        _super.prototype.update.call(this);
        GAME_DATA.gameTime += this.delta;
    };
    return GameTimer;
}(WorldObject));
var GenFilter = /** @class */ (function (_super) {
    __extends(GenFilter, _super);
    function GenFilter() {
        return _super.call(this, {
            code: "\n                float dx = x - 160.0;\n                float dy = y - 120.0;\n\n                vec2 v = normalize(vec2(-dy, dx));\n\n                float r = (v.x + 1.0) / 2.0;\n                float g = (v.y + 1.0) / 2.0;\n                float b = 128.0 / 255.0;\n\n                outp.rgb = vec3(r, g, b);\n            "
        }) || this;
    }
    return GenFilter;
}(TextureFilter));
var HueSpinFilter = /** @class */ (function (_super) {
    __extends(HueSpinFilter, _super);
    function HueSpinFilter() {
        return _super.call(this, {
            uniforms: {},
            code: "\n                vec3 hsv = rgb2hsv(inp.rgb);\n                hsv.x += t;\n                outp = vec4(hsv2rgb(hsv), inp.a);\n            "
        }) || this;
    }
    return HueSpinFilter;
}(TextureFilter));
var InfoBox = /** @class */ (function (_super) {
    __extends(InfoBox, _super);
    function InfoBox(onlyOperateInBounds) {
        var _this = _super.call(this, {
            layer: Battle.Layers.infobox,
            visible: false,
            useGlobalTime: true,
        }) || this;
        _this.nameText = _this.addChild(new SpriteText({
            anchor: Vector2.TOP,
            justify: 'center',
            copyFromParent: ['layer'],
        }));
        _this.tierText = _this.addChild(new SpriteText({
            font: 'smallnumbers',
            anchor: Vector2.TOP,
            justify: 'center',
            copyFromParent: ['layer'],
        }));
        _this.descText = _this.addChild(new SpriteText({
            anchor: Vector2.TOP,
            justify: 'center',
            maxWidth: 150,
            copyFromParent: ['layer'],
        }));
        _this.floatTimer = new Timer(0.25, function () { return _this.setVisible(true); });
        _this.enabled = true;
        _this.disableWhenGameIsRunning = false;
        _this.onlyOperateInBounds = onlyOperateInBounds;
        _this.isTriggering = false;
        _this.showCredits = false;
        return _this;
    }
    InfoBox.prototype.update = function () {
        _super.prototype.update.call(this);
        var lookAt = this.getLookAtThing();
        if (Input.justDown('lmb')) {
            this.setVisible(false);
            this.floatTimer.reset();
        }
        this.isTriggering = lookAt && this.isTriggeringInfoBox(lookAt);
        if (this.isTriggering) {
            this.updateInfoBoxData(lookAt);
            this.updatePosition();
            this.floatTimer.update(this.delta);
        }
        else if (this.isUntriggeringInfoBox()) {
            this.setVisible(false);
            this.floatTimer.reset();
        }
    };
    InfoBox.prototype.updateInfoBoxData = function (lookAt) {
        var name = lookAt.getName();
        var desc = lookAt.getDesc();
        var type = lookAt.getType().toUpperCase();
        var tier = lookAt.tier;
        var descPrefix = lookAt.getDescPrefix();
        if (descPrefix) {
            desc = descPrefix + "\n\n" + desc;
        }
        if (lookAt instanceof Ball && lookAt.equipment && !St.isBlank(lookAt.equipment.getDesc())) {
            desc += "\n-----------------\n" + lookAt.equipment.getDesc();
        }
        if (this.showCredits && !_.isEmpty(lookAt.getCredits())) {
            var formattedCredits = lookAt.getCredits().map(function (c) { return "[gold]" + c + "[/gold]"; });
            desc += "\n-----------------\nConcept by: " + formattedCredits.join(', ');
        }
        var tierDisplay = (tier === 4 ? 'III+' : 'I'.repeat(tier));
        this.nameText.setText(name);
        this.tierText.setText("TIER " + tierDisplay + " " + type);
        this.tierText.style.color = getColorForTier(tier);
        this.descText.setText(desc);
        var width = Math.max(this.nameText.getTextWidth() + 12, 160);
        var height = 39 + this.descText.getTextHeight();
        this.setTexture(InfoBox.getTextureForSize(width, height));
        this.nameText.localy = -height / 2 + 6;
        this.tierText.localy = -height / 2 + 21;
        this.descText.localy = -height / 2 + 33;
    };
    InfoBox.prototype.updatePosition = function () {
        this.x = this.world.getWorldMouseX();
        this.y = this.world.getWorldMouseY();
        var texture = this.getTexture();
        var extraMove = IS_MOBILE ? 20 : 0;
        if (this.x < global.gameWidth / 2)
            this.x += texture.width / 2 + extraMove;
        else
            this.x -= texture.width / 2 + extraMove;
        if (this.y < global.gameHeight / 2 + 16)
            this.y += texture.height / 2 + extraMove;
        else
            this.y -= texture.height / 2 + extraMove;
        if (texture.height <= global.gameHeight) {
            this.y = M.clamp(this.y, texture.height / 2, global.gameHeight - texture.height / 2);
        }
        else {
            this.y = texture.height / 2;
        }
    };
    InfoBox.prototype.isTriggeringInfoBox = function (lookAt) {
        var ballMover = this.world.select.type(BallMover, false);
        var inBounds = !this.onlyOperateInBounds || G.overlapRectangles(this.onlyOperateInBounds, lookAt.getVisibleScreenBounds());
        var movingThing = ballMover === null || ballMover === void 0 ? void 0 : ballMover.movingThing;
        if (IS_MOBILE) {
            var hasMoved = lookAt === movingThing && (ballMover === null || ballMover === void 0 ? void 0 : ballMover.hasMovedAwayFromStartPos());
            return this.isEnabled() && !hasMoved && inBounds;
        }
        return this.isEnabled() && !movingThing && inBounds;
    };
    InfoBox.prototype.isUntriggeringInfoBox = function () {
        if (IS_MOBILE) {
            var ballMover = this.world.select.type(BallMover, false);
            var isMovingThing = ballMover && ballMover.movingThing && ballMover.hasMovedAwayFromStartPos();
            return !this.isEnabled() || isMovingThing;
        }
        return true;
    };
    InfoBox.prototype.isEnabled = function () {
        var _a, _b;
        var battleSpeedController = (_b = (_a = global.theater) === null || _a === void 0 ? void 0 : _a.select) === null || _b === void 0 ? void 0 : _b.type(BattleSpeedController);
        var gamePaused = battleSpeedController === null || battleSpeedController === void 0 ? void 0 : battleSpeedController.paused;
        var battleSpeedControllerEnabled = battleSpeedController === null || battleSpeedController === void 0 ? void 0 : battleSpeedController.enabled;
        return this.enabled && (!this.disableWhenGameIsRunning || !battleSpeedControllerEnabled || gamePaused);
    };
    InfoBox.prototype.getLookAtThing = function () {
        var ballMover = this.world.select.type(BallMover, false);
        var movingThing = ballMover === null || ballMover === void 0 ? void 0 : ballMover.movingThing;
        if (movingThing)
            return movingThing;
        var balls = this.world.select.typeAll(Ball);
        var items = this.world.select.typeAll(BallItem);
        var ballHighlighter = this.world.select.type(BallHighlighter, false);
        var hoveredBall = ballHighlighter === null || ballHighlighter === void 0 ? void 0 : ballHighlighter.getHoveredBall(balls, ballMover);
        var hoveredItem = ballHighlighter === null || ballHighlighter === void 0 ? void 0 : ballHighlighter.getHoveredItem(items);
        return hoveredItem || hoveredBall;
    };
    return InfoBox;
}(Sprite));
(function (InfoBox) {
    var textureCache = new DualKeyPool(function (width, height) {
        var texture = AssetCache.getTexture('infobox_9p');
        if (!texture)
            return undefined;
        return new AnchoredTexture(Texture.ninepatch(texture, rect(4, 4, 4, 4), width, height), 0.5, 0.5);
    }, function (width, height) { return width + "," + height; });
    function getTextureForSize(width, height) {
        var texture = textureCache.borrow(width, height);
        textureCache.return(width, height, texture);
        return texture;
    }
    InfoBox.getTextureForSize = getTextureForSize;
})(InfoBox || (InfoBox = {}));
var JaggyRemoverFilter = /** @class */ (function (_super) {
    __extends(JaggyRemoverFilter, _super);
    function JaggyRemoverFilter() {
        return _super.call(this, {
            code: "\n                vec4 gcxp = getColor(x + 1.0, y);\n                vec4 gcxn = getColor(x - 1.0, y);\n                vec4 gcyp = getColor(x, y + 1.0);\n                vec4 gcyn = getColor(x, y - 1.0);\n                if (gcxp.a == 0.0 && gcxn.a == 0.0) {\n                    outp.a = 0.0;\n                }\n                if (gcyp.a == 0.0 && gcyn.a == 0.0) {\n                    outp.a = 0.0;\n                }\n            ",
        }) || this;
    }
    return JaggyRemoverFilter;
}(TextureFilter));
var Keyboard = /** @class */ (function (_super) {
    __extends(Keyboard, _super);
    function Keyboard(x, y, onTypeCharacter, type) {
        var _this = _super.call(this, {
            x: x, y: y,
        }) || this;
        var keys = _this.createKeys(onTypeCharacter, type);
        _this.numberKeys = keys.numberKeys;
        _this.lowercaseKeys = keys.lowercaseKeys;
        _this.uppercaseKeys = keys.uppercaseKeys;
        _this.spaceKey = keys.spaceKey;
        _this.backspaceKey = keys.backspaceKey;
        _this.shiftKey = keys.shiftKey;
        _this.enterKey = keys.enterKey;
        _this.type = type;
        _this.shifted = false;
        _this.convertToType();
        return _this;
    }
    Keyboard.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.addChildren(this.numberKeys);
        this.addChildren(this.lowercaseKeys);
        this.addChildren(this.uppercaseKeys);
        this.addChild(this.spaceKey);
        this.addChild(this.backspaceKey);
        this.addChild(this.shiftKey);
        this.addChild(this.enterKey);
    };
    Keyboard.prototype.createKeys = function (onTypeCharacter, type) {
        var _this = this;
        var numberKeys = [];
        for (var i = 1; i <= 10; i++) {
            numberKeys.push(Keyboard.charKey(M.equidistantLine(0, 24, 10, i - 1), -48, "" + i % 10, onTypeCharacter));
        }
        var lowercaseKeys = [];
        var uppercaseKeys = [];
        for (var i = 0; i < 26; i++) {
            var x = void 0, y = void 0;
            if (i < 8) {
                x = M.equidistantLine(-17, 24, 8, i);
                y = -24;
            }
            else if (i < 18) {
                x = M.equidistantLine(0, 24, 10, i - 8);
                y = 0;
            }
            else {
                x = M.equidistantLine(-17, 24, 8, i - 18);
                y = 24;
            }
            lowercaseKeys.push(Keyboard.charKey(x, y, A.ALPHABET_LOWERCASE[i], function (char) {
                onTypeCharacter(char);
                if (_this.shifted)
                    _this.shift();
            }));
            uppercaseKeys.push(Keyboard.charKey(x, y, A.ALPHABET_UPPERCASE[i], function (char) {
                onTypeCharacter(char);
                if (_this.shifted)
                    _this.shift();
            }));
        }
        var spaceKey = Keyboard.spaceKey(0, 50, function (char) {
            onTypeCharacter(char);
            if (_this.shifted)
                _this.shift();
        });
        var backspaceKey = Keyboard.backspaceKey(96, -24, function (char) {
            onTypeCharacter(char);
            if (_this.shifted)
                _this.shift();
        });
        var shiftKey = Keyboard.shiftKey(96, 24, function () {
            global.world.playSound('typename');
            _this.shift();
        });
        var enterKey = Keyboard.enterKey(89, 50, onTypeCharacter);
        return { numberKeys: numberKeys, lowercaseKeys: lowercaseKeys, uppercaseKeys: uppercaseKeys, spaceKey: spaceKey, backspaceKey: backspaceKey, shiftKey: shiftKey, enterKey: enterKey };
    };
    Keyboard.prototype.convertToType = function () {
        if (this.type === 'full') {
            this.uppercaseKeys.forEach(function (key) { return key.disable(); });
        }
        else if (this.type === 'gameid') {
            this.spaceKey.disable();
            this.shiftKey.disable();
            this.enterKey.x = this.shiftKey.x;
            this.enterKey.y = this.shiftKey.y;
            this.lowercaseKeys.forEach(function (key) { return key.disable(); });
            this.shifted = true;
        }
    };
    Keyboard.prototype.shift = function () {
        // Do not shift for gameid type
        if (this.type === 'gameid')
            return;
        if (this.shifted) {
            // Unshift
            this.lowercaseKeys.forEach(function (key) { return key.enable(); });
            this.uppercaseKeys.forEach(function (key) { return key.disable(); });
            this.shiftKey.baseTint = 0xFFFFFF;
            this.shifted = false;
        }
        else {
            // Shift
            this.lowercaseKeys.forEach(function (key) { return key.disable(); });
            this.uppercaseKeys.forEach(function (key) { return key.enable(); });
            this.shiftKey.baseTint = 0x0094FF;
            this.shifted = true;
        }
    };
    return Keyboard;
}(WorldObject));
(function (Keyboard) {
    var Key = /** @class */ (function (_super) {
        __extends(Key, _super);
        function Key(x, y, texture, onClick) {
            var _this = _super.call(this, {
                x: x, y: y,
                texture: texture,
                bounds: new RectBounds(-texture.width / 2, -texture.height / 2, texture.width, texture.height),
            }) || this;
            _this.baseTint = 0xFFFFFF;
            _this.addModule(new Button({
                baseTint: _this.baseTint,
                clickTint: 0x666666,
                hoverTint: 0xBBBBBB,
                onClick: onClick,
            }));
            return _this;
        }
        Key.prototype.update = function () {
            _super.prototype.update.call(this);
            this.getModule(Button).baseTint = this.baseTint;
        };
        Key.prototype.enable = function () {
            this.setVisible(true);
            this.setActive(true);
        };
        Key.prototype.disable = function () {
            this.setVisible(false);
            this.setActive(false);
        };
        return Key;
    }(Sprite));
    Keyboard.Key = Key;
    function charKey(x, y, char, onClick) {
        return new Key(x, y, charKeyTexture(char), function () { return onClick(char); });
    }
    Keyboard.charKey = charKey;
    function spaceKey(x, y, onClick) {
        return new Key(x, y, AssetCache.getTexture('keyboardkeyspace'), function () { return onClick(' '); });
    }
    Keyboard.spaceKey = spaceKey;
    function backspaceKey(x, y, onClick) {
        return new Key(x, y, AssetCache.getTexture('keyboardkeybackspace'), function () { return onClick('Backspace'); });
    }
    Keyboard.backspaceKey = backspaceKey;
    function shiftKey(x, y, onClick) {
        return new Key(x, y, AssetCache.getTexture('keyboardkeyshift'), onClick);
    }
    Keyboard.shiftKey = shiftKey;
    function enterKey(x, y, onClick) {
        return new Key(x, y, AssetCache.getTexture('keyboardkeyenter'), function () { return onClick('Enter'); });
    }
    Keyboard.enterKey = enterKey;
    function charKeyTexture(char) {
        return lazy("keyboardCharKeyTexture/" + char, function () {
            var texture = AssetCache.getTexture('keyboardkey').clone('Keyboard.charKeyTexture');
            var charTexture = AssetCache.getTexture("deluxe16/chars/" + char);
            charTexture.renderTo(texture, { x: 6, y: 3 });
            return texture;
        });
    }
})(Keyboard || (Keyboard = {}));
var LiveVersion = /** @class */ (function () {
    function LiveVersion() {
    }
    Object.defineProperty(LiveVersion, "BDAY_VS", {
        get: function () { return this.BDAY; },
        enumerable: false,
        configurable: true
    });
    LiveVersion.load = function () {
        var _this = this;
        API.getliveversion(function (response, err) {
            if (response) {
                _this.BDAY = response.bday;
                _this.APRIL_FOOLS = response.aprilFools;
                _this.ALMANAC_EXPERTS = response.almanacExperts;
                _this.DAILY_SCHEDULE = response.dailySchedule;
            }
            else {
                _this.BDAY = false;
                _this.APRIL_FOOLS = false;
                _this.ALMANAC_EXPERTS = [];
                _this.DAILY_SCHEDULE = ["Anything is possible!"];
            }
            _this.hasLoaded = true;
        });
    };
    LiveVersion.hasLoaded = false;
    return LiveVersion;
}());
var Locations;
(function (Locations) {
    function getRandomLocation(source, world, side, fitnessFunction) {
        var randomLocations = A.range(20).map(function (_) { return getLocationCandidate(source, world, side); })
            .filter(function (location) { return isLocationValid(source, world, location, fitnessFunction); });
        if (_.isEmpty(randomLocations)) {
            return source.getPosition();
        }
        return M.argmax(randomLocations, function (location) { return fitnessFunction(location); });
    }
    Locations.getRandomLocation = getRandomLocation;
    function getLocationCandidate(source, world, side) {
        var bounds;
        if (side === 'all') {
            bounds = rect(16 + source.physicalRadius, 16 + source.physicalRadius, world.width - 32 - 2 * source.physicalRadius, world.height - 32 - 2 * source.physicalRadius);
        }
        else if (side === 'left') {
            bounds = rect(16 + source.physicalRadius, 16 + source.physicalRadius, world.width / 2 - 16 - source.physicalRadius, world.height - 32 - 2 * source.physicalRadius);
        }
        else if (side === 'right') {
            bounds = rect(world.width / 2, 16 + source.physicalRadius, world.width / 2 - 16 - source.physicalRadius, world.height - 32 - 2 * source.physicalRadius);
        }
        return vec2(Ball.Random.float(bounds.x, bounds.x + bounds.width), Ball.Random.float(bounds.y, bounds.y + bounds.height));
    }
    function isLocationValid(source, world, location, fitnessFunction) {
        CHECK_BOUNDS.x = location.x;
        CHECK_BOUNDS.y = location.y;
        CHECK_BOUNDS.radius = source.physicalRadius;
        return _.isEmpty(world.select.overlap(CHECK_BOUNDS, [Battle.PhysicsGroups.walls])) && fitnessFunction(location) > -Infinity;
    }
    var CHECK_BOUNDS = new CircleBounds(0, 0, 0);
})(Locations || (Locations = {}));
Main.loadConfig(function () { return ({
    gameCodeName: "committeejam",
    gameWidth: 320,
    gameHeight: 240,
    canvasScale: 3,
    backgroundColor: 0x000000,
    fpsLimit: 15,
    preventScrollOnCanvas: true,
    preloadBackgroundColor: 0x000000,
    preloadProgressBarColor: 0xFFFFFF,
    textures: Assets.textures,
    sounds: Assets.sounds,
    tilesets: Assets.tilesets,
    pyxelTilemaps: Assets.pyxelTilemaps,
    fonts: Assets.fonts,
    customResources: Assets.customResources,
    spriteTextTags: Assets.spriteTextTags,
    dialogProfiles: dialogProfiles,
    defaultZBehavior: 'threequarters',
    defaultSpriteTextFont: 'deluxe16',
    simulateMouseWithTouches: true,
    defaultOptions: {
        volume: 1,
        sfx_volume: 0.5,
        music_volume: 0.5,
        controls: {
            // General
            'fullscreen': ['f'],
            // Game
            'click': ['MouseLeft'],
            'rightclick': ['MouseRight'],
            'pausebattle': [' ', 'MouseLeft'],
            'speedupbattle': ['ArrowRight', 'MouseRight'],
            'left': ['ArrowLeft', 'a'],
            'right': ['ArrowRight', 'd'],
            'up': ['ArrowUp', 'w'],
            'down': ['ArrowDown', 's'],
            'grab': [' '],
            'ach_cheat': ['p'],
            // Presets
            'game_advanceCutscene': ['x', 'z'],
            'game_pause': ['Escape', 'Backspace'],
            'game_closeMenu': ['Escape'],
            'game_select': ['MouseLeft'],
            'debug_moveCameraUp': ['i'],
            'debug_moveCameraDown': ['k'],
            'debug_moveCameraLeft': ['j'],
            'debug_moveCameraRight': ['l'],
            'debug_recordMetrics': ['0'],
            'debug_showMetricsMenu': ['9'],
            'debug_toggleOverlay': ['o'],
            'debug_frameSkipStep': ['1'],
            'debug_frameSkipRun': ['2'],
            'debug_frameSkipDisable': ['3'],
            'debug_skipRate': ['4'],
            // Debug
            '1': ['1'],
            '2': ['2'],
            '3': ['3'],
            '4': ['4'],
            '5': ['5'],
            '6': ['6'],
            '7': ['7'],
            '8': ['8'],
            '9': ['9'],
            '0': ['0'],
            'lmb': ['MouseLeft'],
            'rmb': ['MouseRight'],
        }
    },
    game: {
        entryPointMenu: function () { return new LoadMenu(); },
        mainMenu: function () { return new MainMenu(); },
        pauseMenu: function () { return new PauseMenu(); },
        theaterFactory: function () { return new TheaterWithAchievements({
            dialogBox: function () { return new DialogBox({
                x: global.gameWidth / 2, y: global.gameHeight - 40,
                texture: 'dialogbox',
                defaultTextFont: 'deluxe16',
                textAreaFull: { x: -150, y: -30, width: 300, height: 60 },
                textAreaPortrait: { x: -72, y: -30, width: 222, height: 60 },
                portraitPosition: { x: -120, y: 0 },
                nameTexture: 'dialogbox_name',
                nameFont: 'deluxe16',
                namePosition: { x: -150, y: -40 },
                nameTextOffset: { x: 0, y: -2 },
                defaultDialogStart: null,
                defaultDialogSpeak: 'dialogspeak',
            }); },
        }); },
    },
    debug: {
        debug: false,
        font: 'deluxe16',
        fontStyle: { color: 0xFFFFFF },
        showAllPhysicsBounds: false,
        showTouches: true,
        moveCameraWithArrows: true,
        showOverlay: false,
        overlayFeeds: [],
        skipRate: 1,
        programmaticInput: false,
        autoplay: true,
        skipMainMenuStage: undefined,
        frameStepEnabled: false,
        resetOptionsAtStart: false,
        experiments: {},
    },
    persistIntervalSeconds: 30,
    persist: function () {
        "modded_remove_from";
        if (CloudSave.hasLoaded && getSaveInfo())
            CloudSave.save();
        Persistence.submit();
        "modded_remove_to";
    },
    beforePreload: function () {
        CloudSave.load();
        LiveVersion.load();
        Weekly.load({ onSuccess: function () { }, onError: function () { } });
    },
    beforeStart: function () {
        PrerenderBalls.render();
    },
}); });
var MODIFIERS = {
    'nospeedcap': {
        description: "The speed cap is disabled",
    },
    'extradmg': {
        description: "Shop balls gain [r]+2<sword>[/r]",
    },
    'extrahp': {
        description: "Shop balls gain [g]+2<heart>[/g]",
    },
    'extrastars': {
        description: "Shop balls gain +1[gold]<star>[/gold]",
    },
    'lessgold': {
        description: "Start each shop with [r]-[/r][gold]1<coin>[/gold]",
    },
    'moregold': {
        description: "Start each shop with [g]+[/g][gold]1<coin>[/gold]",
    },
    'preequipped': {
        description: "Shop balls come pre-equipped",
    },
    'sameballsstocked': {
        description: "The shop stocks identical balls",
    },
    'birthday': {
        description: "Happy Birthday Auto Balls!",
    },
    'packclash': {
        description: "Pack Clash!\nClassic vs Community!",
    },
    // 'sharedhp': {
    //     description: "Allies share a common HP pool",
    // },
    'spores': {
        description: "Shop balls come with\n[dg]spore equipments[/dg]",
    },
    'lesssell': {
        description: "Balls sell for [r]-[/r][gold]1<coin>[/gold]",
    },
    'moresell': {
        description: "Balls sell for [g]+[/g][gold]1<coin>[/gold]",
    },
    'challengemode': {
        description: "Face only\n[gold][offsetx -3]<crown>[/offsetx][/gold]Winning squads",
    },
    'noitems': {
        description: "The shop does not stock\nitems or equipment",
    },
    'moreballs': {
        description: "The shop stocks one more\nball and one fewer item",
    },
    'slowcollisions': {
        description: "Balls stop on collision\nwith an enemy",
    },
    'ballsexplode': {
        description: "Balls explode on death, dealing [r]1<sword>[/r]\nto [r]both enemies and allies[/r]",
    },
    'earlyshrink': {
        description: "The arena's anti-timeout\nis active immediately",
    },
    'pickles': {
        description: "The shop stocks random pickles",
    },
    'onlyintier': {
        description: "The shop stocks balls\nfrom the current tier only",
    },
    'lesssquadsize': {
        description: "You can have one fewer\nball in your squad",
    },
    'moresquadsize': {
        description: "You can have one more\nball in your squad",
    },
    'lessrestockcost': {
        description: "Restocks cost [g]-[/g][gold]1<coin>[/gold]",
    },
    'morerestockcost': {
        description: "Restocks cost [r]+[/r][gold]1<coin>[/gold]",
    },
    'wallshurt': {
        description: "The arena's walls deal [r]0.5<sword>[/r]\non collision",
    },
    'wallsbounce': {
        description: "The arena's walls are bouncy",
    },
};
function getModifierDescription(modifier) {
    if (modifier in MODIFIERS) {
        return MODIFIERS[modifier].description;
    }
    return "Unknown modifier";
}
function getModifierIconTexture(modifier) {
    var key = "dailyicons/modifier/" + modifier;
    if (key in AssetCache.textures) {
        return key;
    }
    return "dailyicons/modifier/unknown";
}
function isModifierActive(modifier) {
    if (!GAME_DATA || !GAME_DATA.modifiers)
        return false;
    if (GAME_MODE === 'mm' && !DAILY)
        return false;
    return _.contains(GAME_DATA.modifiers, modifier);
}
function getModifierExtraDmg() {
    return isModifierActive('extradmg') ? 2 : 0;
}
function getModifierExtraHp() {
    return isModifierActive('extrahp') ? 2 : 0;
}
function getModifierExtraStars() {
    return isModifierActive('extrastars') ? 1 : 0;
}
function getModifierGoldDiff() {
    return (isModifierActive('lessgold') ? -1 : 0) + (isModifierActive('moregold') ? 1 : 0);
}
function getModifierSellDiff() {
    return (isModifierActive('lesssell') ? -1 : 0) + (isModifierActive('moresell') ? 1 : 0);
}
function getModifierStockItemsDiff() {
    return isModifierActive('moreballs') ? -1 : 0;
}
function getModifierArenaShrinkStartTime() {
    return isModifierActive('earlyshrink') ? 29 : 0; // 1 second earlier to help prevent balls sticking to the ceiling on Trampoline
}
function getModifierArenaShrinkTimeScale() {
    return isModifierActive('earlyshrink') ? 4 : 1;
}
function getModifierSquadSizeDiff() {
    return (isModifierActive('lesssquadsize') ? -1 : 0) + (isModifierActive('moresquadsize') ? 1 : 0);
}
function getModifierRestockCostDiff() {
    return (isModifierActive('lessrestockcost') ? -1 : 0) + (isModifierActive('morerestockcost') ? 1 : 0);
}
// Change both of these functions
function adjustSquadBallForModifiers(ball) {
    ball.properties.damage += getModifierExtraDmg();
    ball.properties.health += getModifierExtraHp();
    ball.properties.level += getModifierExtraStars();
    if (isModifierActive('noitems')) {
        ball.properties.equipment = -1;
    }
    else if (isModifierActive('preequipped') && ball.properties.equipment < 0) {
        ball.properties.equipment = Random.element(getPurchasableEquipmentTypesForRound(GAME_DATA.round));
    }
    else if (isModifierActive('spores') && ball.properties.equipment < 0) {
        ball.properties.equipment = 14;
    }
}
function adjustBallForModifiers(ball) {
    ball.properties.damage += getModifierExtraDmg();
    ball.dmg += getModifierExtraDmg();
    ball.properties.health += getModifierExtraHp();
    ball.hp += getModifierExtraHp();
    ball.maxhp += getModifierExtraHp();
    for (var i = 0; i < getModifierExtraStars(); i++) {
        ball.properties.level++;
        ball.levelUp(undefined, false, false);
    }
    if (isModifierActive('noitems')) {
        ball.unequip();
        ball.properties.equipment = -1;
    }
    else if (isModifierActive('preequipped') && (!ball.equipment || ball.equipment.equipmentType < 0)) {
        var equipmentType = Random.element(getPurchasableEquipmentTypesForRound(GAME_DATA.round));
        ball.equip(equipmentType);
        ball.properties.equipment = equipmentType;
    }
    else if (isModifierActive('spores') && (!ball.equipment || ball.equipment.equipmentType < 0)) {
        var equipmentType = 14;
        ball.equip(equipmentType);
        ball.properties.equipment = equipmentType;
    }
}
function selectRandomShopMusic(gameId) {
    if (!gameId || gameId.length < 2)
        return 'music/shop';
    if (gameId.charCodeAt(0) % 2 === 1)
        return 'music/shop2';
    return 'music/shop';
}
function selectRandomBattleMusic(gameId) {
    if (!gameId || gameId.length < 2)
        return 'music/battle';
    if (gameId.charCodeAt(1) % 2 === 1)
        return 'music/battle2';
    return 'music/battle';
}
function pickMusicForThisRoundShop(gameData) {
    var musicType = getMusicType();
    if (musicType === 'Random')
        return gameData.shopMusic;
    if (musicType === 'Side A')
        return 'music/shop';
    if (musicType === 'Side B')
        return 'music/shop2';
    if (musicType === 'Themed')
        return _.includes(gameData.packs, 'classic') ? 'music/shop' : 'music/shop2';
    console.error('Invalid musicType:', musicType);
    return 'music/shop';
}
function pickMusicForThisRoundBattle(gameData) {
    var musicType = getMusicType();
    if (musicType === 'Random')
        return gameData.battleMusic;
    if (musicType === 'Side A')
        return 'music/battle';
    if (musicType === 'Side B')
        return 'music/battle2';
    if (musicType === 'Themed')
        return _.includes(gameData.packs, 'classic') ? 'music/battle' : 'music/battle2';
    console.error('Invalid musicType:', musicType);
    return 'music/battle';
}
var MusicChanger = /** @class */ (function (_super) {
    __extends(MusicChanger, _super);
    function MusicChanger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MusicChanger.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.everyNSeconds(0.5))
            return;
        var battleState = getBattleState(this.world);
        if (!battleState || battleState === Ball.States.PREP) {
            var currentMusic = global.game.musicManager.currentMusicKey;
            var newMusic = pickMusicForThisRoundShop(GAME_DATA);
            if ((currentMusic === null || currentMusic === void 0 ? void 0 : currentMusic.includes('shop')) && currentMusic !== newMusic) {
                global.game.musicManager.playMusic(newMusic, 1);
            }
        }
        if (battleState === Ball.States.BATTLE) {
            var currentMusic = global.game.musicManager.currentMusicKey;
            var newMusic = pickMusicForThisRoundBattle(GAME_DATA);
            if ((currentMusic === null || currentMusic === void 0 ? void 0 : currentMusic.includes('battle')) && currentMusic !== newMusic) {
                global.game.musicManager.playMusic(newMusic, 1);
            }
        }
    };
    return MusicChanger;
}(WorldObject));
function newOptionsGear() {
    var gear = new Sprite({
        name: 'gear',
        x: 11, y: global.gameHeight - 11,
        texture: 'gear',
        layer: Battle.Layers.ui,
        bounds: new CircleBounds(0, 0, 11),
        useGlobalTime: true,
        updateOnNonUpdate: true,
    });
    gear.addModule(new Button({
        hoverTint: 0xFFFF00,
        clickTint: 0xBBBB00,
        onClick: function () {
            gear.tint = 0xFFFFFF;
            global.game.playSound('click');
            global.game.pauseGame();
        },
    }));
    return gear;
}
function getAllowProfaneSquadNames() {
    return !!Options.getOption('allowProfaneSquadNames');
}
function setAllowProfaneSquadNames(allowProfaneSquadNames) {
    Options.updateOption('allowProfaneSquadNames', allowProfaneSquadNames);
}
function getFastBattleTransitions() {
    return !!Options.getOption('fastBattleTransitions');
}
function getBattleTransitionTimeScale() {
    return getFastBattleTransitions() ? 0.33 : 1;
}
function setFastBattleTransitions(fastBattleTransitions) {
    Options.updateOption('fastBattleTransitions', fastBattleTransitions);
}
function getBigDragging() {
    var _a;
    return (_a = Options.getOption('bigDragging')) !== null && _a !== void 0 ? _a : true;
}
function setBigDragging(bigDragging) {
    Options.updateOption('bigDragging', bigDragging);
}
function getMusicType() {
    var _a;
    return (_a = Options.getOption('musicType')) !== null && _a !== void 0 ? _a : 'Themed';
}
function setMusicType(musicType) {
    Options.updateOption('musicType', musicType);
}
function addNumberSetting(world, x, y, minValue, maxValue, prefix, getAttr, setAttr) {
    var d = 48 / 2;
    world.addWorldObject(new MenuTextButton({
        x: x + d, y: y,
        text: '\\>',
        anchor: Vector2.TOP_RIGHT,
        justify: 'right',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        hoverColor: 0xFFFF00,
        onClick: function () {
            global.game.playSound('click');
            var nextValue = getIncrValue(getAttr());
            if (nextValue > maxValue)
                nextValue = minValue;
            setAttr(nextValue);
        },
    }));
    world.addWorldObject(new MenuTextButton({
        x: x - d, y: y,
        text: '\\<',
        anchor: Vector2.TOP_RIGHT,
        justify: 'right',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        hoverColor: 0xFFFF00,
        onClick: function () {
            global.game.playSound('click');
            var nextValue = getDecrValue(getAttr());
            if (nextValue < minValue)
                nextValue = maxValue;
            setAttr(nextValue);
        },
    }));
    world.addWorldObject(new SpriteText({
        x: x - 4, y: y,
        text: "" + prefix + getAttr(),
        anchor: Vector2.TOP_CENTER,
        justify: 'center',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        update: function () {
            this.setText("" + prefix + getAttr());
        }
    }));
}
function addOptionSetting(world, x, y, options, prefix, getAttrOption, setAttrOption, onChange) {
    var d = Math.max(M.max(options, function (op) { return op.length * 8 + 16; }), 48) / 2;
    world.addWorldObject(new MenuTextButton({
        x: x + d, y: y,
        text: '\\>',
        anchor: Vector2.TOP_RIGHT,
        justify: 'right',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        hoverColor: 0xFFFF00,
        onClick: function () {
            global.game.playSound('click');
            var currentOptionIndex = options.indexOf(getAttrOption());
            var incrOptionIndex = currentOptionIndex < 0 ? 0 : currentOptionIndex + 1;
            if (incrOptionIndex > options.length - 1)
                incrOptionIndex = 0;
            setAttrOption(options[incrOptionIndex]);
        },
    }));
    world.addWorldObject(new MenuTextButton({
        x: x - d, y: y,
        text: '\\<',
        anchor: Vector2.TOP_RIGHT,
        justify: 'right',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        hoverColor: 0xFFFF00,
        onClick: function () {
            global.game.playSound('click');
            var currentOptionIndex = options.indexOf(getAttrOption());
            var decrOptionIndex = currentOptionIndex < 0 ? 0 : currentOptionIndex - 1;
            if (decrOptionIndex < 0)
                decrOptionIndex = options.length - 1;
            setAttrOption(options[decrOptionIndex]);
        },
    }));
    world.addWorldObject(new SpriteText({
        x: x - 4, y: y,
        text: "" + prefix + getAttrOption(),
        anchor: Vector2.TOP_CENTER,
        justify: 'center',
        effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        update: function () {
            var text = "" + prefix + getAttrOption();
            if (this.getCurrentText() !== text && onChange)
                onChange(getAttrOption());
            this.setText(text);
        }
    }));
    if (onChange)
        onChange(getAttrOption());
}
function getIncrValue(currentValue) {
    if (Math.abs(currentValue) >= 20 && currentValue % 5 === 0) {
        return currentValue + 5;
    }
    return currentValue + 1;
}
function getDecrValue(currentValue) {
    if (Math.abs(currentValue) >= 25 && currentValue % 5 === 0) {
        return currentValue - 5;
    }
    return currentValue - 1;
}
function addOptionsMenu(world) {
    world.addWorldObjects(lciDocumentToWorldObjects('optionsmenu'));
    world.select.name('options').updateCallback = function () {
        this.angle = Math.sin(2 * this.life.time) * 3;
    };
    var sfxVolumeLabel = world.select.name('sfxvolumelabel');
    var musicVolumeLabel = world.select.name('musicvolumelabel');
    world.addWorldObject(new OptionsSlider(sfxVolumeLabel.x, sfxVolumeLabel.y + 19, 96, 0, 1, function () { return Options.sfxVolume; }, function (value) { return Options.sfxVolume = value; }));
    world.addWorldObject(new OptionsSlider(musicVolumeLabel.x, musicVolumeLabel.y + 19, 96, 0, 1, function () { return Options.musicVolume; }, function (value) { return Options.musicVolume = value; }));
    var musicLabel = world.select.name('musiclabel');
    addOptionSetting(world, musicLabel.x + 4, musicLabel.y + 16, ['Themed', 'Random', 'Side A', 'Side B'], '', function () { return getMusicType(); }, function (v) { return setMusicType(v); });
    var profanitycheckmark = world.select.name('profanitycheckmark');
    profanitycheckmark.updateCallback = function () {
        this.setVisible(getAllowProfaneSquadNames());
    };
    profanitycheckmark.setVisible(getAllowProfaneSquadNames());
    world.select.name('profanitycheckbox').addModule(new Button({
        hoverTint: 0xFFFF00,
        clickTint: 0xBBBB00,
        onJustHovered: function () {
            juiceButton(2).apply(this);
            juiceObject(profanitycheckmark, 2);
        },
        onClick: function () {
            global.game.playSound('click');
            setAllowProfaneSquadNames(!getAllowProfaneSquadNames());
            juiceButton(2).apply(this);
            juiceObject(profanitycheckmark, 2);
        },
    }));
    var fasttransitionscheckmark = world.select.name('fasttransitionscheckmark');
    fasttransitionscheckmark.updateCallback = function () {
        this.setVisible(getFastBattleTransitions());
    };
    fasttransitionscheckmark.setVisible(getFastBattleTransitions());
    world.select.name('fasttransitionscheckbox').addModule(new Button({
        hoverTint: 0xFFFF00,
        clickTint: 0xBBBB00,
        onJustHovered: function () {
            juiceButton(2).apply(this);
            juiceObject(fasttransitionscheckmark, 2);
        },
        onClick: function () {
            global.game.playSound('click');
            setFastBattleTransitions(!getFastBattleTransitions());
            juiceButton(2).apply(this);
            juiceObject(fasttransitionscheckmark, 2);
        },
    }));
    var fullscreencheckmark = world.select.name('fullscreencheckmark');
    fullscreencheckmark.updateCallback = function () {
        this.setVisible(Fullscreen.enabled);
    };
    fullscreencheckmark.setVisible(Fullscreen.enabled);
    world.select.name('fullscreencheckbox').addModule(new Button({
        hoverTint: 0xFFFF00,
        clickTint: 0xBBBB00,
        onJustHovered: function () {
            juiceButton(2).apply(this);
            juiceObject(fullscreencheckmark, 2);
        },
        onClick: function () {
            global.game.playSound('click');
            Fullscreen.toggleFullscreen();
            juiceButton(2).apply(this);
            juiceObject(fullscreencheckmark, 2);
        },
    }));
    var bigdraggingcheckmark = world.select.name('bigdraggingcheckmark');
    bigdraggingcheckmark.updateCallback = function () {
        this.setVisible(getBigDragging());
    };
    bigdraggingcheckmark.setVisible(getBigDragging());
    world.select.name('bigdraggingcheckbox').addModule(new Button({
        hoverTint: 0xFFFF00,
        clickTint: 0xBBBB00,
        onJustHovered: function () {
            juiceButton(2).apply(this);
            juiceObject(bigdraggingcheckmark, 2);
        },
        onClick: function () {
            global.game.playSound('click');
            setBigDragging(!getBigDragging());
            juiceButton(2).apply(this);
            juiceObject(bigdraggingcheckmark, 2);
        },
    }));
    if (IS_MOBILE) {
        world.removeWorldObject(world.select.name('fullscreencheckmark'));
        world.removeWorldObject(world.select.name('fullscreencheckbox'));
        world.removeWorldObject(world.select.name('fullscreenlabel'));
    }
    else {
        world.removeWorldObject(world.select.name('bigdraggingcheckmark'));
        world.removeWorldObject(world.select.name('bigdraggingcheckbox'));
        world.removeWorldObject(world.select.name('bigdragginglabel'));
    }
}
var OptionsSlider = /** @class */ (function (_super) {
    __extends(OptionsSlider, _super);
    function OptionsSlider(centerX, y, barLength, minValue, maxValue, getValue, setValue) {
        var _this = _super.call(this, {
            x: centerX,
            y: y,
            texture: 'sliderbar',
            bounds: new RectBounds(-barLength / 2 - 4, -6, barLength + 8, 12),
        }) || this;
        _this.grabbing = false;
        _this.lastHovered = false;
        _this.centerX = centerX;
        _this.barLength = barLength;
        _this.minValue = minValue;
        _this.maxValue = maxValue;
        _this.getValue = getValue;
        _this.setValue = setValue;
        _this.slider = _this.addChild(new Sprite({
            x: _this.valueToWorldX(_this.getValue()) - centerX,
            texture: 'slider',
        }));
        return _this;
    }
    OptionsSlider.prototype.update = function () {
        _super.prototype.update.call(this);
        var mousePos = this.world.getWorldMousePosition();
        var hovered = this.bounds.containsPoint(mousePos);
        if (hovered && Input.justDown('click')) {
            global.game.playSound('click');
            this.grabbing = true;
        }
        if (Input.isUp('click')) {
            if (this.grabbing)
                global.game.playSound('click');
            this.grabbing = false;
        }
        if (this.grabbing) {
            this.tint = 0xBBBB00;
            this.slider.tint = 0xBBBB00;
            this.slider.x = M.clamp(mousePos.x, this.centerX - this.barLength / 2, this.centerX + this.barLength / 2);
            this.setValue(this.worldXToValue(this.slider.x));
        }
        else if (hovered) {
            this.tint = 0xFFFF00;
            this.slider.tint = 0xFFFF00;
            if (!this.lastHovered) {
                juiceObject(this, 0.5);
                juiceObject(this.slider, 3);
            }
        }
        else {
            this.tint = 0xFFFFFF;
            this.slider.tint = 0xFFFFFF;
        }
        this.lastHovered = hovered;
    };
    OptionsSlider.prototype.worldXToValue = function (x) {
        return M.map(x, this.centerX - this.barLength / 2, this.centerX + this.barLength / 2, this.minValue, this.maxValue);
    };
    OptionsSlider.prototype.valueToWorldX = function (value) {
        return M.map(value, this.minValue, this.maxValue, this.centerX - this.barLength / 2, this.centerX + this.barLength / 2);
    };
    return OptionsSlider;
}(Sprite));
var OFFICIAL_PACKS = ['classic', 'community'];
function getParticleLevel() {
    return IS_MOBILE ? 0.5 : 1;
}
function newPuff(x, y, layer, type) {
    var radius = { 'small': 2, 'medium': 4 }[type];
    var maxLife = { 'small': 0.4, 'medium': 0.5 }[type];
    return new BurstPuffSystem({
        x: x, y: y,
        layer: layer,
        puffCount: Math.floor(10 * getParticleLevel()),
        puffConfigFactory: function () { return ({
            maxLife: maxLife,
            v: Random.inCircle(70),
            color: 0xFFFFFF,
            radius: radius,
            finalRadius: 0,
        }); },
    });
}
function newBdayPuff(x, y, layer, type) {
    var radius = { 'small': 2, 'medium': 4 }[type];
    var maxLife = { 'small': 0.6, 'medium': 1 }[type];
    return new BurstPuffSystem({
        x: x, y: y,
        layer: layer,
        puffCount: Math.floor(10 * getParticleLevel()),
        puffConfigFactory: function () { return ({
            maxLife: maxLife,
            v: Random.inCircle(70),
            color: Random.element([0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF]),
            radius: radius,
            finalRadius: 0,
        }); },
    });
}
var Parts;
(function (Parts) {
    var COMMON_CONFIG = {
        layer: Battle.Layers.walls,
        physicsGroup: Battle.PhysicsGroups.walls,
        immovable: true,
    };
    function circle(x, y, radius) {
        return new PhysicsWorldObject(__assign({ x: x, y: y, bounds: new CircleBounds(0, 0, radius) }, COMMON_CONFIG));
    }
    Parts.circle = circle;
    function rect(x, y, width, height) {
        return new PhysicsWorldObject(__assign({ x: x, y: y, bounds: new RectBounds(0, 0, width, height) }, COMMON_CONFIG));
    }
    Parts.rect = rect;
    function slope(x, y, width, height, direction) {
        return new PhysicsWorldObject(__assign({ x: x, y: y, bounds: new SlopeBounds(0, 0, width, height, direction) }, COMMON_CONFIG));
    }
    Parts.slope = slope;
    function trapezoidV(x, y, topWidth, bottomWidth, height) {
        if (topWidth === bottomWidth)
            return rect(x, y, topWidth, height);
        var result = new WorldObject({ x: x, y: y });
        result.addChild(rect(Math.abs(topWidth - bottomWidth) / 2, 0, Math.min(topWidth, bottomWidth), height));
        result.addChild(slope(0, 0, Math.abs(topWidth - bottomWidth) / 2, height, topWidth > bottomWidth ? 'downleft' : 'upleft'));
        result.addChild(slope(Math.min(topWidth, bottomWidth) + Math.abs(topWidth - bottomWidth) / 2, 0, Math.abs(topWidth - bottomWidth) / 2, height, topWidth > bottomWidth ? 'downright' : 'upright'));
        return result;
    }
    Parts.trapezoidV = trapezoidV;
    function trapezoidH(x, y, leftHeight, rightHeight, width) {
        if (leftHeight === rightHeight)
            return rect(x, y, width, leftHeight);
        var result = new WorldObject({ x: x, y: y });
        result.addChild(rect(0, Math.abs(leftHeight - rightHeight) / 2, width, Math.min(leftHeight, rightHeight)));
        result.addChild(slope(0, 0, width, Math.abs(leftHeight - rightHeight) / 2, leftHeight > rightHeight ? 'upright' : 'upleft'));
        result.addChild(slope(0, Math.min(leftHeight, rightHeight) + Math.abs(leftHeight - rightHeight) / 2, width, Math.abs(leftHeight - rightHeight) / 2, leftHeight > rightHeight ? 'downright' : 'downleft'));
        return result;
    }
    Parts.trapezoidH = trapezoidH;
})(Parts || (Parts = {}));
var PATCH_NOTES_INT = ["\n- Patch 9/?? -\n\nBalance\n+ Ball of Ice: now costs [dgold]1<star>[/] to use\n        its ability\n+ Toxin: [r]1<sword>[/r] [pg]2<heart>[/pg] -> [r]3<sword>[/r] [pg]3<heart>[/pg],\n        now a Tier II ball, acid\n        pool shrinks 33% faster\n\nMinor Changes\n+ You can now see damage/health\n  values of certain objects (e.g\n  medpacks, mines, buffs, bullets,\n  etc.) while paused\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 8/17 -\n\nBug Fixes\n+ Fixed an issue where some \"on\n  enter battle\" abilities would\n  trigger twice if a Mocha was in\n  play\n+ Added a tiny, unnoticeable\n  cooldown to Seeker's ability to\n  prevent it from rapidly shooting\n  spikes in certain situations\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 8/11 -\n\nBalance\n+ Curry is no longer completely\n  negated by Nullifier at the\n  start of battle. Its effect\n  will continue after Nullify\n  wears off.\n+ Nullifier: ability time scaling\n  reduced per level and now caps\n  at 7s (reduced from 10s)\n+ Toxin: acid pool radius now\n  decreases over time\n\n\nMinor Changes\n+ Increased the weight of\n  Cannonballs.\n+ Applied slight tints to Toxin's\n  and Butterball's abilities to\n  visually differentiate teams.\n+ Increased battle transition\n  speed with Fast Battle\n  Transitions enabled.\n\nBug Fixes\n+ Fixed issue where you could\n  pause the game during round\n  resolution.\n+ Fixed issue where Mechanic could\n  waste its ability if its target\n  ally died before the equipment\n  reached it.\n+ Fixed issue where a Cue Ball\n  equipped with Mocha could boost\n  an ally with unbounded velocity\n+ Fixed issue where a Jetpack-\n  equipped ball would not be\n  stopped by Stopper.\n+ Fixed issue where Ball of Yarn's\n  and Butterball's trails would\n  reset when starting early with\n  Mocha.\n+ Fixed bug where Nullifier's\n  ability would sometimes not end\n  on death.\n+ Fixed bug where some balls like\n  Alchemist and Poke Ball could\n  still activate their abilities\n  after being nullified.\n+ Fixed visual bug where Stopper's\n  effect would not play if it died\n  on collision.\n+ Fixed visual bug with ball stats\n  sometimes disappearing.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 8/8 -\n\nChanges\n+ Updated the Shuffle matchmaker to\n  match you with other weekly\n  squads!\n+ Fixed issue where rounds\n  sometimes ended while Phoenix's\n  or Best Friend's revivals were\n  still activating.  \n+ The Bug can no longer change\n  balls into invalid ball mutations\n  in the Victory Lap.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.4B -\n\n[pg]The Auto Balls Weekly Shuffle is here![/pg] A random pack of balls from Classic and Community generated every week!\n\nMajor Changes\n+ The Auto Balls Weekly Shuffle is\n  here!\n+ 4 new balls!\n+ 2 new items!\n+ 3 new achievements!\n+ A whole week of Dailies with new\n  modifiers!\n+ You can now pick separate packs\n  for players in VS Mode!\n+ New VS Mode pack: Shuffle!\n\nBalance Changes\n+ Dolly: now works with Green Cube!\n+ Glitched Ball: new abilities\n        + Leave acid pool\n        + Stop enemy for 1s\n+ Greater Mimic: removed from the\n        game, extra power given to\n        the normal Mimic\n+ Mimic: now gains half the\n        target's level during\n        battle\n+ Vagrant: can no longer take\n        Molecular Disassemblers\n        from the shop. You are\n        safe now! :)\n\nBug Fixes\n+ Fixed various issues related to\n  round results being decided too\n  early (during the slowdown)\n+ Fixed issue where Haunt's ghost\n  could keep the game going even\n  after one team lost\n+ Fixed issue where Versus Mode\n  games were not keeping track of\n  certain game statistics when\n  reloading the game.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.4.1 -\n\nBalance Changes\n+ Bandaid: health gain on purchase\n        now applies on equip too\n        (so it works when given by\n        Mechanic or stolen by Thief\n        Mask, for example)\n+ Bank: payout period now maxes at\n        6 rounds\n+ Burner: radius now has falloff at\n        high levels similar to\n        Grenade\n+ Curry: now lasts for 10 seconds\n        in battle\n+ Medkit: healing timer [grey]3[/]s -> [grey]2[/]s\n+ Mimic: [r]1<sword>[/r] [pg]8<heart>[/pg] -> [r]2<sword>[/r] [pg]8<heart>[/pg],\n        shop stocks Greater Mimics\n        instead of Mimics in\n        Tier 3+\n+ Nullifier: effect now ends\n        immediately if the\n        Nullifier dies\n\nBug Fixes\n+ Fixed bug where old game state\n  would sometimes carry over into\n  a new Versus Mode game\n+ Fixed some issues with abilities\n  activating in the wrong order\n+ Fixed bug where Joker was not\n  removed after use if equipped on\n  a Mimic\n+ Fixed bug where some abilities\n  would not wait for Hitman's\n  ability to finish before\n  activating\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 7/1 -\n\nChanges\n+ You can now view others' final\n  squads on the Daily leaderboard!\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 6/30 -\n\nChanges\n+ Updated the Daily leaderboard to\n  treat low rounds as better for\n  victories and high rounds as\n  better for defeats.\n\nBug Fixes\n+ Fixed bug where too many Hunter's\n  Marks crashed the game\n+ Fixed bug where Bandaid could\n  activate multiple times in a\n  battle\n+ Fixed bug where multiple Dollies\n  would not all activate\n+ Fixed bug where sometimes a\n  second item would appear in the\n  shop when there should only be\n  one\n+ Fixed bug where you would appear\n  to get Ballmanac progress for\n  each Victory Lap win\n+ Fixed bug where the wrong win\n  count was displayed for the\n  Classic pack\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.4 -\n\n[pg]Auto Balls Dailies are here![/pg] Compete with other players for the top spot; same opponents, same shop, same RNG! But be careful, you only get one shot!\n\nMajor Changes\n+ Auto Balls Dailies are here!\n+ 5 new Community Pack balls!\n+ 2 new items!\n+ 5 new achievement unlockables!\n+ Congrats to [pg]Materwelons[/] for\n  winning the Auto Balls Community\n  Bash tournament!\n+ Added anti-timeout mechanisms to\n  the arenas from the last update.\n+ Changed Zoomer unlock criteria,\n  you may have to re-unlock it even\n  if you had it before.\n\nBalance Changes\n+ Angel: [r]2<sword>[/r] [pg]1<heart>[/pg] -> [r]3<sword>[/r] [pg]1<heart>[/pg]\n+ Armor Plating:\n        damage reduction [r]1<sword>[/r] -> [r]2<sword>[/r]\n+ Bank: (rework) now pays out money\n        over several rounds\n+ Butter Ball: now additionally\n        boosts ally acceleration as\n        well as max speed\n+ Devil: spike damage is now a\n        fixed [r]2/3/4<sword>[/r],\n        removed target limit\n+ Fireball: [r]0<sword>[/r] [pg]2<heart>[/pg] -> [r]0<sword>[/r] [pg]3<heart>[/pg]\n+ Fragmenter: [r]1<sword>[/r] [pg]2<heart>[/pg] -> [r]1<sword>[/r] [pg]3<heart>[/pg]\n+ Grave: summoned skeletons\n        [grey]1[/] -> [grey]2[/]\n+ Guardian: (rework) now heals\n        allies when they take\n        damage\n+ Haunt: ghost now appears much\n        quicker\n+ Hitman: now only sacrifices half\n        of its [r]<sword>[/r]\n+ Impostor: decreased detection\n        radius by 25%\n+ Jetpack: increased acceleration\n        by 33%\n+ Mitosis: copies no longer count\n        as summons\n+ Necromancer: summon limit\n        [grey]4[/] -> [grey]5[/]\n+ Nullifier: now only targets\n        enemies with battle effects\n+ Old Crystal Ball: [r]1<sword>[/r] [pg]7<heart>[/pg] -> [r]6<sword>[/r] [pg]2<heart>[/pg]\n+ Phoenix: can no longer revive\n        more than twice when\n        equipped with Green Cube\n+ Protection Bubble: damage\n        reduction [grey]33%[/] -> [grey]50%[/]\n+ Reducer: stars removed\n        [grey]2/3/4[/][dgold]<star>[/] -> [grey]1/2/3[/][dgold]<star>[/]\n+ Scrap Cannon: restocks needed to\n        reach full power [grey]5[/] -> [grey]4[/]\n+ Sleeper: self-healing\n        [pg]0.5/1/1.5[/] -> [pg]0.25/0.5/0.75[/],\n        increased heal radius by\n        50%, now starts healing\n        immediately when entering\n        battle\n+ Unstable Catalyst: health drain\n        -[pg]0.3<heart>/s[/pg] -> -[pg]0.25<heart>/s[/pg]\n+ Vampire: [r]4<sword>[/r] [pg]1<heart>[/pg] -> [r]5<sword>[/r] [pg]2<heart>[/pg]\n+ Vanguard: increased protection\n        radius by 25%\n+ Watcher: (rework) now gains buff\n        when an ally or enemy is\n        summoned,\n        removed activation limit\n+ Wizard: now gains [r]1<sword>[/r] [pg]1<heart>[/pg] when it\n        reappears in the shop\n+ Wobby: health buff is now given\n        to itself as well as allies\n\nBug Fixes\n+ Fixed bug where some players were\n  locked out of their matchmaking\n  game after reloading the game.\n+ Fixed bug where Leech and Cheel\n  did not disperse remaining [r]<sword>[/]/[pg]<heart>[/] on\n  death.\n+ Fixed bug where Joker could\n  scramble a team to the opposite\n  side of the arena.\n+ Fixed bug where Versus Mode games\n  incorrectly counted toward your\n  matchmaking win count.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Patch 5/17 -\n\nChanges\n+ Complete the Ballmanac and get\n  your name added to the credits!\n+ Cloud Sync now smartly merges\n  cloud data with local data to\n  help avoid data being\n  unintentionally overwritten\n\nBug Fixes\n+ The Ballmanac now properly syncs\n  with Cloud Save\n+ Orbiting Potato now correctly\n  counts victories in the Ballmanac\n+ Fixed Orbiting Potato not\n  blocking projectiles during\n  prebattle\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.3.0 -\n\nIntroducing the [pg]Auto Balls Community Pack[/pg]! A brand new pack of balls suggested by the amazing gamers in the Auto Balls Discord server!\n\n[pg]35[/] new balls!\n[pg]15[/] new items!\n\nMajor Changes\n+ A shiny pack of 35 new balls\n  suggested by you guys!\n+ Track your wins with every ball\n  and item in the [pg]Ballmanac[/pg]!\n+ Looking for a challenge? Test\n  your skill against [dgold][offsetx -3]<crown>[/offsetx][/dgold]Winning\n  squads in Challenge Mode!\n+ Your Matchmaking and Versus Mode\n  games are now saved locally, so\n  you can quit and pick up where\n  you left off later!\n+ Abilities activating at the start\n  of battle are now done one at a\n  time for better clarity\n+ Introducing Tier [dgold]<crown>[/dgold], a special\n  tier for Victory Lap that offers\n  powerful mutated balls in the\n  shop!\n+ You now gain +1[r]<heart>[/r] every lap in\n  Victory Lap\n+ And too many quality-of-life\n  changes to list!\n\nBalance Changes\n+ Bandaid: now gives [pg]1<heart>[/pg] on purchase\n+ Claw: increased damage [r]3<sword>[/r] -> [r]4<sword>[/r]\n+ Clout-In-A-Jar: removed level cap\n        restriction\n+ Coin: can store a max of 50[gold]<coin>[/gold]\n+ Commando: [r]<sword>[/]/[pg]<heart>[/] gained per death\n        [grey]10%/20%/30%[/grey] -> [grey]0.5/1/1.5[/grey]\n+ Crown: bonus stars\n        1/2/3[gold]<star>[/gold] -> 0/1/2[gold]<star>[/gold],\n        can now be killed by allies\n        like Poke Ball, etc. at the\n        start of battle.\n        allies will not replace the\n        crown on kill\n+ Crusher: damage gain on hit\n        [r]1/1.5/2<sword>[/r] -> [r]1/2/3<sword>[/r]\n+ Hyper Driver: multiple Hyper\n        Drivers now take 5[gold]<coin>[/gold] each\n        for consistency\n+ Magnet: now takes about a second\n        for the magnetism to ramp\n        up at the start of battle\n+ Necromancer: no longer\n        distinguishes between\n        \"living\" and \"non-living\"\n        allies\n+ Ninja: spikes shot\n        [grey]2/3/4[/grey] -> [grey]2/4/6[/grey],\n        spikes no longer change\n        target if the target dies\n+ Overcharger: each zap now deals\n        [r]2<sword>/s[/], decaying to [r]1<sword>/s[/]\n        over 1s;\n        increased range slightly\n+ Poke Ball: ally level increase\n        [grey]-2/-1/0[/grey][gold]<star>[/gold] -> [grey]0/1/2[/grey][gold]<star>[/gold]\n+ Sniper: now shoots bullets at\n        enemies instead of spikes,\n        ability activates when an\n        enemy is summoned or\n        gains 1 [pg]<heart>[/pg]/[r]<sword>[/r]\n+ Trainer: damage buff\n        [r]1/2/3<sword>[/r] -> [r]1/1.5/2<sword>[/r],\n        now gives buff when an ally\n        enters battle\n+ Vanguard: damage reduction\n        [r]1/1.5/2<sword>[/r] -> [r]1/2/3<sword>[/r]\n+ Wobby: can now buff other Wobbies\n\nBug Fixes\n+ Pause and fast-forward are smooth\n  once again! (in Matchmaking)\n+ Toxic Fungus now destroys itself\n  after use\n+ Balls can no longer activate\n  their abilities on the same frame\n  they are eaten by Poke Ball\n+ Poke Ball no longer removes\n  Grenade health after storing it\n+ Balls revived by Best Friend are\n  now correctly treated as equal to\n  the original\n+ Improved performance when using\n  Ball of Yarn\n+ Fixed some issues with dragging\n  and freezing on mobile\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Happy Birthday Auto Balls!!! -\n\n[pg]Thank you all so much for playing and supporting the game! :) Enjoy a week-long celebration with a limited-time new ball, and an item that transforms the game...[/]\n\nAvailable Jan 19 - Jan 25!\n\nBug Fixes:\n+ Fixed bug where Medic's medkits\n  did not heal the correct amount\n+ Fixed bug where Cue Ball could\n  yeet itself out of existence at\n  the start of battle\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.5 (Patch) -\n\n[pg]The Auto Balls Itch page now works on iOS!! (mostly!)[/] This is a work in progress, please let me know if you notice any issues :)\n\nI'm working to improve matchmaking over the next week or so. You may notice better variety in opponents coming soon!\n\nBalance Changes\n+ Voodoo Ball: removed ability\n        damage cap\n\nApp Bug Fixes (Requires app update)\n+ Fixed bug where you could get\n    stuck in Twitter when sharing\n    on mobile\n+ Probably fixed a bug where audio\n    would continue playing after\n    switching or closing the app\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.5 -\n\n[pg]Auto Balls is now on Android!! Check it out now on Google Play or Itch.io![/]\n\nMajor Changes\n+ 1 new ball and 1 new item!\n+ Sync your save data to the cloud\n    with [pg]Cloud Sync[/], in the bottom-\n    left corner of the main menu!\n+ \"Complete a Victory Lap\" is now a\n    secret achievement\n+ Booster is now unlocked from a\n    new achievement. If you had\n    Booster unlocked previously,\n    it will remain unlocked :)\n+ Adjusted several descriptions to\n    be more accurate\n\nBalance Changes\n+ Armor Plating: damage limit\n        1 -> 0.75\n+ Crown: ability now activates only\n        when killed by an enemy\n+ Smoke Bomb: now a Tier 2\n        equipment\n+ Vagrant: can now take any item\n        from the shop, frozen or\n        unfrozen\n+ Vampire: [r]4<sword>[/r] [pg]4<heart>[/pg] -> [r]4<sword>[/r] [pg]1<heart>[/pg],\n        now a Tier 3 ball,\n        now drains health at a rate\n        of [pg]3<heart>/s[/pg] from nearby allies\n+ Vanguard: damage limit\n        1 -> 0.75\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.4 -\n\nMajor Changes\n+ [pg]1 new ball and 1 new item![/]\n+ By popular demand, you can now\n    [dgold]spectate[/] others' Versus Mode\n    games! Check it out in the\n    Versus Mode menu :)\n+ Spruced up the UI in Versus Mode.\n    Now you'll know when the other\n    player is ready!\n+ Removed the Bio-Grenade\n    achievement... for now.\n\nBalance Changes\n+ Booster: now a Tier 2 ball,\n        [r]1<sword>[/r] [pg]3<heart>[/pg] -> [r]3<sword>[/r] [pg]4<heart>[/pg]\n+ Hyper Driver: gold requirement\n        now increases by [dgold]<coin>3[/]\n        per additional Hyper Driver\n        in your squad\n+ Medic: dispensed medkits are now\n        slightly magnetic toward\n        hurt friendly balls\n+ Psychic: now waits one frame\n        after battle start before\n        determining which ball to\n        lock\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.3 -\n\nMajor Changes\n+ Added option for fast transitions\n    between battles\n\nBalance Changes\n+ Best Friend: revive with\n        [r]half <sword>[/r] [pg]1<heart>[/pg] -> [r]1<sword>[/r] [pg]1<heart>[/pg]\n+ Booster: now spreads boosts\n        across multiple allies\n+ Necromancer: skeleton health\n        [pg]1/1/1<heart>[/pg] -> [pg]1/2/3<heart>[/pg]\n+ Rejuvenator: removed healing cap\n+ Skull Charm: skeleton gains [r]1<sword>[/r]\n        for each [dgold]<star>[/dgold] on the equipped\n        ball\n+ Unstable Catalyst: health drain\n        -[pg]0.5<heart>/s[/pg] -> -[pg]0.3<heart>/s[/pg]\n\nBug Fixes:\n+ Fixed bug where balls could\n    activate previous equipment if\n    leveled-up in battle\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.2 (Patch) -\n\nBalance Changes\n+ Retro Glasses: \"guaranteed\" ->\n        \"significantly more likely\"\n    - effect is decreased on\n        certain balls such as\n        Crystal Ball\n    - removed the discount for\n        equipped balls\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.2 (1.2B) -\n\n[pg]2[/] new balls!\n[pg]4[/] new items!\n[pg]1[/] new achievement!\n\nMajor Changes\n+ Don't feel like quitting after\n    winning? Take a Victory Lap!\n+ Customize your Versus Mode\n    experience with new settings!\n+ Removed Bio-Grenade... for now.\n\nBalance Changes\n+ Ball of Ice: [r]3<sword>[/r] [pg]4<heart>[/pg] -> [r]2<sword>[/r] [pg]4<heart>[/pg],\n        multiple BOIs can no longer\n        target the same frozen ball\n+ Ball of Yarn: now slows on hit\n        in addition to its trail\n+ Necromancer: [r]2<sword>[/r] [pg]5<heart>[/pg] -> [r]1<sword>[/r] [pg]6<heart>[/pg],\n        skeleton damage\n            [r]1/1/1<sword>[/r] -> [r]1/2/3<sword>[/r]\n        skeleton health\n            [pg]1/2/3<heart>[/pg] -> [pg]1/1/1<heart>[/pg]\n        now can only summon a\n        maximum of 4 skeletons\n+ Sapper: removed cap on sapped\n        enemies (previously 2 max)\n+ Thief Mask: now activates\n        before enemy equipment\n\nBug Fixes:\n+ Fixed a bug where Assassin would\n    target some balls immediately\n    after they spawn\n+ Fixed a bug where you could get\n    some achievements in Versus\n    Mode by rejoining before\n    victory\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.1 -\n\nChanges\n+ Minor improvements to how stats\n    and info boxes are shown before\n    and after the battle\n\nBalance Changes\n+ Assassin: execute threshold\n            [r]2/3/4[/r] -> [r]1/2/3[/r]\n+ Bandaid: effect is now applied\n    at death, meaning it is now\n    affected by Mechanic, Thief\n    Mask, etc.\n+ Gladiator: no longer gives dmg\n    bonus, now gains a Shield on\n    the first [grey]1/2/3[/grey] kills\n+ Mechanic: no longer gives\n    \"useless\" equipment\n    (e.g. Hyper Driver)\n+ VIP Ticket: now a Tier 3 item\n\nBug Fixes:\n+ Fixed a bug where the equipment\n    stolen by Thief Mask would\n    return to the enemy if the\n    recipient died\n+ Fixed a bug where you could join\n    a Versus Mode game as both\n    sides from the same browser\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.2.0 -\n\n[pg]Versus Mode[/] BETA is here! Play 1v1 against a friend!\n\n[pg]5[/] new balls!\n[pg]2[/] new items!\n[pg]2[/] new achievements!\n\nMajor Changes\n+ The shop ball distribution is now\n    slightly skewed, making it more\n    likely to get higher tier balls\n    as the game progresses\n+ In Shop Tier 3+, at least one\n    Tier 3+ ball is guaranteed on\n    every stock/restock\n+ All equipment with \"On Enter\n    Battle\" conditions will now\n    activate if equipped during\n    battle\n+ Two achievements have been\n    balanced to be slightly easier:\n    + [grey]<lte>2 balls[/grey] -> [grey]<lte>3 balls[/grey]\n    + [grey][r]8<sword>[/r] [pg]8<heart>[/pg] squad[/grey] -> [grey][r]7<sword>[/r] [pg]7<heart>[/pg] squad[/grey]\n+ Detail box now differentiates\n    between Balls, Items, and\n    Equipments\n+ Added a link to the wiki in the\n    main menu\n\nBalance Changes\n+ 8-Ball: [r]1<sword>[/r] [pg]2<heart>[/pg] -> [r]1<sword>[/r] [pg]3<heart>[/pg]\n+ Ball of Ice: [r]2<sword>[/r] [pg]3<heart>[/pg] -> [r]3<sword>[/r] [pg]4<heart>[/pg],\n            buff amount\n            [grey]1/1.5/2[r]<sword>[/r][pg]<heart>[/pg][/grey] -> [grey]1/2/3[r]<sword>[/r][pg]<heart>[/pg][/grey]\n            now grants buff to a\n            random frozen shop ball\n+ Bio-Grenade: toxic cloud lasts\n    twice as long (0.5s -> 1s)\n+ Coin: [r]1<sword>[/r] [pg]2<heart>[/pg] -> [r]1<sword>[/r] [pg]3<heart>[/pg]\n+ Leech: increased aura radius\n+ Mechanic: equipments given\n            [grey]1/2/3/4[/grey] -> [grey]2/2/2/3[/grey],\n            can give equipment even\n            after the battle starts\n+ Ninja: spikes now change target\n            should their target die\n+ Powerball: [r]1<sword>[/r] [pg]2<heart>[/pg] -> [r]1<sword>[/r] [pg]3<heart>[/pg]\n+ Psychic: hits required to break\n            lock now stacks with\n            multiple Psychics\n+ Smoke Bomb: explosion damage\n            [r]3x<sword>[/r] -> [r]2x<sword>[/r],\n            slightly decreased\n            explosion radius\n+ Sniper: no longer attacks balls\n            buffed immediately at\n            the start of battle\n            (e.g. Vampire)\n+ Spiker: [r]2<sword>[/r] [pg]6<heart>[/pg] -> [r]1<sword>[/r] [pg]6<heart>[/pg]\n+ Trainer: buff is now instant\n+ Vagrant: items taken from shop\n            [grey]1/1/1[/grey] -> [grey]1/2/3[/grey],\n            no longer requires gold\n\nBug Fixes\n+ Fixed exploit where you could\n    push balls across the mid line\n    during the shop phase\n+ Fixed bug where Bounty would give\n    gold even if equipped by an\n    enemy\n+ Fixed issue where Snowball could\n    get stuck on the center ring\n\nThere is more to come in 1.2!\nStay tuned! :)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- Auto Balls v1.1.1 -\n\nMajor Changes\n+ Each team may only have at most\n    25 balls in the battle at once\n+ Many balls' abilities now\n    activate when entering a battle\n    (e.g. summoned) instead of only\n    at battle start\n+ Fixed a bug where game options\n    (e.g. volume) were not saved\n+ Decreased loading time\n+ Improved matchmaking :)\n\nBalance Changes\n+ Ball of Ice: [r]3<sword>[/r] [pg]3<heart>[/pg] -> [r]2<sword>[/r] [pg]3<heart>[/pg],\n            damage and health buff\n            [grey]1/2/3[r]<sword>[/r][pg]<heart>[/pg][/grey] -> [grey]1/1.5/2[r]<sword>[/r][pg]<heart>[/pg][/grey]\n+ Bio-Grenade: NEW ABILITY!\n+ Buffer: \"On battle start\"\n            -> \"On enter battle\"\n+ Death Star: ability no longer\n            activates from other\n            Death Stars\n+ Green Crystal Ball:\n            [r]1<sword>[/r] [pg]3<heart>[/pg] -> [r]1<sword>[/r] [pg]4<heart>[/pg]\n+ Mechanic: \"On battle start\"\n            -> \"On enter battle\"\n+ Ninja: \"On battle start\"\n            -> \"On enter battle\",\n            spikes shot\n            [grey]1/2/3[/grey] -> [grey]2/3/4[/grey]\n+ Sapper: \"On battle start\"\n            -> \"On enter battle\"\n+ Smoke Bomb: \"On battle start\"\n            -> \"On enter battle\"\n+ Snowball: time to fully grow\n            [grey]8[/grey] -> [grey]10[/grey] seconds\n+ Spiker: spikes shot per hit\n            [grey]2/4/6[/grey] -> [grey]2/3/4[/grey]\n            spike damage\n            [r]1/1/1[/r] -> [r]1/1.25/1.5[/r]\n+ Splinter: spikes shot\n            [grey]1/2/3[/grey] -> [grey]2/3/4[/grey]\n+ Spore: extra damage per hit\n            [r]3<sword>[/r] -> [r]1<sword>[/r]\n+ Toxic Fungus: NEW ABILITY!\n+ Vagrant: now takes UNFROZEN items\n            only\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "\n- AUTO BALLS v1.1 -\n\n[pg]14[/] new balls!\n[pg]8[/] new items!\nA brand new tier, [pg]Tier 3+[/]!\n[pg]14[/] new achievements! Go get those\nunlocks!\n\nMajor Changes\n+ [pb]Freezing[/pb] is here!! Right-click on\n    a shop ball to keep it around!\n+ Removed the Thief ball. Added the\n    Thief Mask item.\n+ The arena now starts to shrink\n    after a while to avoid\n    unnecessary timeouts.\n+ Did you win? Your squad will get\n    a little [dgold][offsetx -3]<crown>[/offsetx][/dgold]crown so everyone\n    knows they're battling a\n    champion! :)\n+ Removed loading tip \"A squad of\n    five is always better than a\n    squad of four\"\\ \\ @AyumiDev >_>\n+ Updated some descriptions to be\n    more accurate\n+ Added a list of Portugese bad\n    words to the profanity filter\n+ Updated the localization files\n+ Removed Herobrine\n\nBalance Changes\n  + Buffer: damage buff\n            [r]2/3/4<sword>[/r] -> [r]2/4/6<sword>[/r]\n  + Cat Ears: they're now free??\n  + Coin:   [r]1<sword>[/r] [pg]3<heart>[/pg] -> [r]1<sword>[/r] [pg]2<heart>[/pg],\n            now tracks total sell\n            value instead of extra\n  + Crown:  [r]4<sword>[/r] [pg]4<heart>[/pg] -> [r]6<sword>[/r] [pg]6<heart>[/pg],\n            bonus stars\n              0/1/2[gold]<star>[/gold] -> 1/2/3[gold]<star>[/gold],\n            moved to Tier 3+,\n            when replaced, keeps\n            its original health\n            and damage\n  + Crusher: damage gain\n            [r]1/2/3<sword>[/r] -> [r]1/1.5/2<sword>[/r]\n  + Crystal Ball: [r]1<sword>[/r] [pg]3<heart>[/pg] -> [r]2<sword>[/r] [pg]4<heart>[/pg]\n            moved to Tier 2,\n            weaker versions appear\n            in Tier 1\n  + Gacha Ball: spawned ball stats\n            [grey]1/2/3[r]<sword>[/r][pg]<heart>[/pg][/grey] -> [grey]2/3/4[r]<sword>[/r][pg]<heart>[/pg][/grey]\n            no longer spawns\n            useless balls\n            (Coin, Crown, etc.)\n  + Healer: increased heal radius,\n            increased heal rate\n            [pg]1/1.5/2<heart>[/pg] -> [pg]1.5/2/2.5<heart>[/pg]\n  + Necromancer: skeleton damage\n            [r]2<sword>[/r] -> [r]1<sword>[/r]\n  + Pickleball: [r]2<sword>[/r] [pg]2<heart>[/pg] -> [r]2<sword>[/r] [pg]1<heart>[/pg]\n            now creates pickles\n            equal to the current\n            round (max 6)\n  + Powerball: [r]2<sword>[/r] [pg]2<heart>[/pg] -> [r]1<sword>[/r] [pg]2<heart>[/pg]\n  + Sapper: enemies sapped\n            [grey]1/1/2[/grey] -> [grey]1/2/2[/grey]\n  + Spiker: spikes shot per hit\n            [grey]1/2/3[/grey] -> [grey]2/4/6[/grey]\n  + Trainer: [r]3<sword>[/r] [pg]4<heart>[/pg] -> [r]5<sword>[/r] [pg]7<heart>[/pg]\n            moved to Tier 3+,\n            removed health buff\n  + Turret: increased bullet speed,\n            reduced wind up time\n  + Vampire: [r]2<sword>[/r] [pg]2<heart>[/pg] -> [r]4<sword>[/r] [pg]4<heart>[/pg],\n            moved to Tier 3+\n"];
var PatchNotes;
(function (PatchNotes) {
    function formatNotes(notes) {
        var lines = notes.split('\n');
        lines.shift();
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            var newLine = line.trim();
            if (newLine.startsWith('+')) {
                newLine = '<bullet>' + newLine.substring(1);
            }
            while (line.startsWith(' ')) {
                line = line.substring(1);
                newLine = '\\ ' + newLine;
            }
            lines[i] = newLine;
        }
        return lines.join('\n');
    }
    PatchNotes.formatNotes = formatNotes;
})(PatchNotes || (PatchNotes = {}));
var PATCH_NOTES = PATCH_NOTES_INT.map(PatchNotes.formatNotes);
var Stages;
(function (Stages) {
    function PREP() {
        return _PREP(false);
    }
    Stages.PREP = PREP;
    function PREP_SKIP_PRE_SHOP_EFFECTS() {
        return _PREP(true);
    }
    Stages.PREP_SKIP_PRE_SHOP_EFFECTS = PREP_SKIP_PRE_SHOP_EFFECTS;
    function _PREP(skipPreShopEffects) {
        var e_101, _a, e_102, _b;
        if (GAME_MODE === 'vs') {
            GAME_DATA.round = VS_GAME.round;
            GAME_DATA.health = VS_GAME.yourhealth;
            GAME_DATA.wins = 8 - VS_GAME.enemyhealth;
        }
        if (GAME_MODE === 'mm' && !skipPreShopEffects) {
            saveMatchmakingOrChallengeModeOrDailyGameData({
                gameData: GAME_DATA,
                state: 'startshop',
                lock: gameDataLock(),
            }, CHALLENGE_MODE_ENABLED, DAILY);
        }
        if (GAME_MODE === 'vs' && !skipPreShopEffects) {
            saveVersusModeGameData({
                gameData: GAME_DATA,
                state: 'startshop',
            });
        }
        Main.fixedDelta = undefined;
        SWAP_DIRECTIONS = false;
        var world = Arenas.BASE();
        Arenas.SET_FOR_ARENA(world, GAME_DATA.arena);
        var abilitySystem = world.addWorldObject(new AbilitySystem());
        var mmShopName = GAME_DATA.lap > 1 ? crownedName(GAME_DATA.squad.name) : GAME_DATA.squad.name;
        var mmShopNameX = GAME_DATA.lap > 1 ? 6 : 2;
        var shopNames = world.addWorldObject(new SpriteText({
            x: mmShopNameX, y: 0,
            text: mmShopName,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_LEFT,
            effects: { outline: { color: 0x000000 } },
        }));
        if (GAME_MODE === 'vs') {
            shopNames.setText("[color " + Ball.getTeamColor('friend') + "]" + VS_GAME.yourname + "[/]\n[color " + Ball.getTeamColor('enemy') + "]" + VS_GAME.enemyname + "[/]");
            var vsHearts = world.addWorldObject(new Sprite({
                x: 2 + shopNames.getTextWidth() + 4, y: 0,
                texture: 'vshearts',
                layer: Battle.Layers.playernames,
            }));
            var vsHealthText = world.addWorldObject(new SpriteText({
                x: vsHearts.x + 17, y: 0,
                text: VS_GAME.yourhealth + "\n" + VS_GAME.enemyhealth,
                layer: Battle.Layers.playernames,
                anchor: Vector2.TOP_LEFT,
                effects: { outline: { color: 0x000000 } },
            }));
            var yourCheckmark = world.addWorldObject(new Sprite({
                x: vsHealthText.x + vsHealthText.getTextWidth() + 10, y: 6,
                texture: 'checkmark',
                layer: Battle.Layers.playernames,
                tint: 0x4CFF00,
                effects: { outline: { color: 0x000000 } },
                visible: !!VS_GAME.yoursquad,
            }));
            var enemyCheckmark = world.addWorldObject(new Sprite({
                x: vsHealthText.x + vsHealthText.getTextWidth() + 10, y: 21,
                texture: 'checkmark',
                layer: Battle.Layers.playernames,
                tint: 0x4CFF00,
                effects: { outline: { color: 0x000000 } },
                visible: !!VS_GAME.enemysquad,
            }));
            world.addWorldObject(new VsStatusCheckmarker(yourCheckmark, enemyCheckmark));
        }
        world.addWorldObject(new SpriteText({
            name: 'opponentname',
            x: world.width - 2, y: 0,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_RIGHT,
            effects: { outline: { color: 0x000000 } },
        }));
        world.addWorldObject(new PhysicsWorldObject({
            name: 'midwall',
            physicsGroup: Battle.PhysicsGroups.walls,
            bounds: new InvertedRectBounds(0, 0, global.gameWidth / 2, global.gameHeight),
            immovable: true,
        }));
        if (GAME_MODE === 'mm' && GAME_DATA.arg2Trigger.strategy) {
            world.addWorldObject(new Sprite({
                name: 'strategy',
                x: 0, y: 0,
                texture: 'strategy',
                layer: Battle.Layers.ground,
                alpha: 0.8,
            }));
        }
        var sidePanel = world.addWorldObject(new WorldObject({ name: 'sidepanel' }));
        sidePanel.addChildren(lciDocumentToWorldObjects('preppanel'));
        var goldcoin = world.select.name('goldcoin');
        sidePanel.addChild(new DisplayedGold(goldcoin.x + 8, goldcoin.y + 1));
        var trophy = world.select.name('trophy');
        if (GAME_MODE === 'vs') {
            trophy.setVisible(false);
        }
        else {
            var winText = sidePanel.addChild(new SpriteText({
                x: trophy.x + 9, y: trophy.y + 1,
                text: GAME_DATA.wins + "/" + GET_MAX_WINS(),
                layer: Battle.Layers.ui,
                anchor: Vector2.CENTER_LEFT,
            }));
            if (GAME_DATA.lap > 1) {
                addVictoryLapCount(world, sidePanel);
                winText.style.color = 0xFFD800;
            }
        }
        var heart = world.select.name('heart');
        if (GAME_MODE === 'vs') {
            heart.setVisible(false);
        }
        else {
            sidePanel.addChild(new SpriteText({
                x: heart.x + 9, y: heart.y + 1,
                text: "" + GAME_DATA.health,
                layer: Battle.Layers.ui,
                anchor: Vector2.CENTER_LEFT,
            }));
        }
        var round = world.select.name('round');
        if (GAME_MODE === 'vs') {
            round.setVisible(false);
        }
        else {
            sidePanel.addChild(new SpriteText({
                x: round.x + 9, y: round.y + 1,
                text: "" + GAME_DATA.round,
                layer: Battle.Layers.ui,
                anchor: Vector2.CENTER_LEFT,
            }));
        }
        var round_vs = world.select.name('round_vs');
        if (GAME_MODE === 'vs') {
            sidePanel.addChild(new SpriteText({
                x: round_vs.x + 9, y: round_vs.y + 1,
                text: "" + GAME_DATA.round,
                layer: Battle.Layers.ui,
                anchor: Vector2.CENTER_LEFT,
            }));
        }
        else {
            round_vs.setVisible(false);
        }
        var timelimit = world.select.name('timelimit');
        if (GAME_MODE === 'vs' && GET_TIME_LIMIT() > 0) {
            var timeLimitTimer_1 = new Timer(GET_TIME_LIMIT() + 1, function () {
                if (WarningBox.isShowing(world)) {
                    WarningBox.hide(world);
                }
                GameFragments.playPrep(world);
            });
            sidePanel.addChild(new SpriteText({
                name: 'timelimittimer',
                x: timelimit.x + 9, y: timelimit.y + 1,
                text: secondsToFormattedTime(GET_TIME_LIMIT()),
                layer: Battle.Layers.ui,
                anchor: Vector2.CENTER_LEFT,
                timers: [timeLimitTimer_1],
                update: function () {
                    this.setText(secondsToFormattedTime(Math.max(GET_TIME_LIMIT() - timeLimitTimer_1.time, 0)));
                    if (GET_TIME_LIMIT() - timeLimitTimer_1.time < 29) {
                        this.style.color = Tween.Easing.OscillateSine(4)(timeLimitTimer_1.time) > 0.5 ? 0xFFFFFF : 0xFF8888;
                    }
                }
            }));
        }
        else {
            timelimit.setVisible(false);
        }
        if (GAME_MODE === 'vs') {
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(169, 0, 36, 21),
                update: function () { this.data.infoBoxDescription = GAME_DATA.gold + " gold"; }
            }));
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(205, 0, 33, 21),
                update: function () { this.data.infoBoxDescription = "Round " + GAME_DATA.round; }
            }));
        }
        else {
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(169, 0, 36, 21),
                update: function () { this.data.infoBoxDescription = GAME_DATA.gold + " gold"; }
            }));
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(205, 0, 45, 21),
                update: function () { var lap = GAME_DATA.lap === 1 ? '' : "Lap " + (GAME_DATA.lap - 1) + ", "; this.data.infoBoxDescription = "" + lap + GAME_DATA.wins + "/" + GET_MAX_WINS() + " wins"; }
            }));
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(250, 0, 29, 21),
                update: function () { this.data.infoBoxDescription = GAME_DATA.health + " losses\nto game over"; }
            }));
            world.addWorldObject(new PhysicsWorldObject({
                bounds: new RectBounds(279, 0, 33, 21),
                update: function () { this.data.infoBoxDescription = "Facing Round " + GAME_DATA.round + "\nopponents"; }
            }));
        }
        var versus = world.select.name('versus');
        if (GAME_MODE !== 'vs' || GET_TIME_LIMIT() > 0) {
            versus.setVisible(false);
        }
        var shopLevel = getShopTierForRound(GAME_DATA.round);
        var shopLevelDisplay = (shopLevel === 4 ? '3+' : "" + shopLevel);
        var instructionsText = IS_MOBILE ? '[offset 5 -3]<touch_hold_t>[/] Info [offset 5 -3]<touch_tap_t>[/] [fb]Freeze[/fb]\\ '
            : '<lmb> [gold]Buy[/gold]  <rmb> [fb]Freeze[/fb]';
        var shopTierText = isTierCrown() ? '[gold]Shop Tier <crown>[/gold]'
            : "Shop Tier [color " + getColorForTier(shopLevel) + "]" + shopLevelDisplay + "[/color] :)";
        sidePanel.addChild(new SpriteText({
            x: 242, y: IS_MOBILE ? 36 : 34,
            text: shopLevel === 1 ? instructionsText : shopTierText,
            layer: Battle.Layers.ui,
            anchor: Vector2.CENTER,
            justify: 'center',
        }));
        var restockCostBase = 1 + getModifierRestockCostDiff();
        world.select.name('restockbutton').addChild(new SpriteText({
            x: -19, y: -19,
            font: 'smallnumbers',
            layer: Battle.Layers.ui,
            update: function () {
                if (GAME_DATA.freeRestocksUntilPlay > 0) {
                    this.setText("[g]" + GAME_DATA.freeRestocksUntilPlay + "[/g]");
                }
                else {
                    this.setText("[gold]<coin>" + restockCostBase + "[/gold]");
                }
            }
        }));
        world.select.name('restockbutton').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                var e_103, _a;
                world.playSound('click');
                var costOfRestock = GAME_DATA.freeRestocksUntilPlay > 0 ? 0 : restockCostBase;
                if (GAME_DATA.gold < costOfRestock)
                    return;
                GAME_DATA.gold -= costOfRestock;
                GAME_DATA.freeRestocksUntilPlay = Math.max(GAME_DATA.freeRestocksUntilPlay - 1, 0);
                if (GAME_DATA.argTrigger.zombie) {
                    GAME_DATA.argTrigger.restocks++;
                    if (GAME_DATA.argTrigger.restocks === 5) {
                        global.theater.runScript(glitchSmall(world));
                    }
                }
                GAME_DATA.hasRestocked = true;
                Shop.restockNormal(world);
                var playerBalls = world.select.typeAll(Ball).filter(function (ball) { return !ball.isInShop; });
                try {
                    for (var playerBalls_3 = __values(playerBalls), playerBalls_3_1 = playerBalls_3.next(); !playerBalls_3_1.done; playerBalls_3_1 = playerBalls_3.next()) {
                        var ball = playerBalls_3_1.value;
                        ball.queueAbilities('onRestock');
                    }
                }
                catch (e_103_1) { e_103 = { error: e_103_1 }; }
                finally {
                    try {
                        if (playerBalls_3_1 && !playerBalls_3_1.done && (_a = playerBalls_3.return)) _a.call(playerBalls_3);
                    }
                    finally { if (e_103) throw e_103.error; }
                }
            },
        }));
        var playbutton = world.select.name('playbutton');
        if (GAME_MODE === 'vs') {
            world.select.name('playbutton').setVisible(false);
            playbutton = world.select.name('playbutton_vs');
        }
        else {
            world.select.name('playbutton_vs').setVisible(false);
        }
        playbutton.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            canHover: function () { return !world.select.modules(Button).some(function (button) { return button.enabled && button.worldObject.hasTag(Tags.MODIFIER_ICON) && button.isOverlappingMouse(); }); },
            onClick: function () {
                var ballHighlighter = world.select.type(BallHighlighter);
                var ballMover = world.select.type(BallMover);
                var balls = world.select.typeAll(Ball);
                var items = world.select.typeAll(BallItem);
                if (ballHighlighter.getHoveredBall(balls, ballMover) || ballHighlighter.getHoveredItem(items) || ballMover.movingThing) {
                    return;
                }
                if (GAME_DATA.squad.balls.length === 0) {
                    world.playSound('click');
                    WarningBox.show(world, 'noballs', function () {
                        GameFragments.playPrep(world);
                    });
                }
                else if (GAME_DATA.gold > 0) {
                    world.playSound('click');
                    WarningBox.show(world, 'gold', function () {
                        GameFragments.playPrep(world);
                    });
                }
                else {
                    GameFragments.playPrep(world);
                }
            },
        }));
        for (var i = 0; i < GAME_DATA.modifiers.length; i++) {
            var icon = sidePanel.addChild(getModifierIcon(playbutton.x + M.equidistantLine(0, 20, GAME_DATA.modifiers.length, i), playbutton.y + 21, GAME_DATA.modifiers[i]));
            icon.layer = Battle.Layers.ui;
        }
        world.addWorldObject(newOptionsGear());
        world.addWorldObject(new BoundsInfoBox(Vector2.TOP_RIGHT, 0));
        for (var i = 0; i < GAME_DATA.squad.balls.length; i++) {
            var ball = world.addWorldObject(squadBallToWorldBall(GAME_DATA.squad.balls[i], GAME_DATA.squad, i, 'friend'));
            ball.showAllStats();
        }
        if (!skipPreShopEffects) {
            setDataStartShop();
        }
        if (GAME_DATA.restocksThisRound === 0) {
            Shop.stockInitial(world);
        }
        else {
            Shop.stockRestock(world, true);
        }
        world.addWorldObject(new BallHighlighter());
        world.addWorldObject(new BallMover());
        world.addWorldObject(new BallFreezer());
        world.addWorldObject(new InfoBox());
        if (!skipPreShopEffects) {
            var seed = getRandomSeed(GAME_DATA.gameId, DAILY);
            Random.seed("startshop_" + seed + "_" + GAME_DATA.round);
            Ball.Random.seed("startshop_" + seed + "_" + GAME_DATA.round);
            // Start Shop abilities
            abilitySystem.reset();
            var playerBalls = world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend' && !ball.isInShop; });
            try {
                for (var playerBalls_2 = __values(playerBalls), playerBalls_2_1 = playerBalls_2.next(); !playerBalls_2_1.done; playerBalls_2_1 = playerBalls_2.next()) {
                    var ball = playerBalls_2_1.value;
                    ball.queueAbilities('onStartShop');
                }
            }
            catch (e_101_1) { e_101 = { error: e_101_1 }; }
            finally {
                try {
                    if (playerBalls_2_1 && !playerBalls_2_1.done && (_a = playerBalls_2.return)) _a.call(playerBalls_2);
                }
                finally { if (e_101) throw e_101.error; }
            }
            abilitySystem.activateAbilities();
            var shopItems = world.select.typeAll(BallItem);
            try {
                for (var shopItems_1 = __values(shopItems), shopItems_1_1 = shopItems_1.next(); !shopItems_1_1.done; shopItems_1_1 = shopItems_1.next()) {
                    var item = shopItems_1_1.value;
                    item.onStartShopBeforeStartShopEffects();
                }
            }
            catch (e_102_1) { e_102 = { error: e_102_1 }; }
            finally {
                try {
                    if (shopItems_1_1 && !shopItems_1_1.done && (_b = shopItems_1.return)) _b.call(shopItems_1);
                }
                finally { if (e_102) throw e_102.error; }
            }
            GAME_DATA.bankedGold = GAME_DATA.bankedGold.filter(function (banked) {
                if (banked.roundsLeft > 0) {
                    addStartShopEffect({
                        type: 'gold',
                        sourceSquadIndex: banked.squadIndex,
                        gold: banked.goldPerRound,
                    });
                }
                banked.roundsLeft--;
                return banked.roundsLeft > 0;
            });
            applyStartShopEffects(GAME_DATA.startShopEffects, world);
            if (USELESS_CROWN_REPLACEMENT) {
                world.runScript(function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/];
                            case 1:
                                _a.sent();
                                updateAchievementProgress('Useless', function (p) { return p + 1; });
                                return [2 /*return*/];
                        }
                    });
                });
                USELESS_CROWN_REPLACEMENT = false;
            }
            setDataStartShopPostEffects();
        }
        world.addWorldObject(new GameTimer());
        world.addWorldObject(new MusicChanger());
        if (GAME_MODE === 'mm')
            world.addWorldObject(new SaveValidator.Obj());
        world.addWorldObject(new BugChecker());
        world.onTransitioned = function () {
            global.game.playMusic(pickMusicForThisRoundShop(GAME_DATA), 0.1);
            global.game.allowPauseWithPauseKey = true;
            world.data.youArePlaying = true;
            if (GAME_DATA.round >= 12) {
                updateAchievementProgress('ReachRoundTwelve', function (p) { return Math.max(p, GAME_DATA.round); });
            }
            if (GAME_DATA.round === 5 && GAME_DATA.squad.balls.some(function (ball) { return ball.properties.type === 41; })) {
                global.theater.runScript(glitchSmall(world));
            }
        };
        return world;
    }
    function addVictoryLapCount(world, sidePanel) {
        var lap = "" + (GAME_DATA.lap - 1);
        var trophy = world.select.name('trophy');
        sidePanel.addChild(new Sprite({
            x: trophy.x, y: trophy.y,
            texture: new AnchoredTexture(Texture.filledRect(1 + 4 * lap.length, 7, 0x000000), 0.5, 0.5),
            layer: Battle.Layers.ui,
        }));
        sidePanel.addChild(new SpriteText({
            x: trophy.x + 1, y: trophy.y + 1,
            text: lap,
            font: 'smallnumbers',
            layer: Battle.Layers.ui,
            anchor: Vector2.CENTER,
            style: { color: 0xFFD800 }
        }));
    }
})(Stages || (Stages = {}));
var PrepPanelInfoBox = /** @class */ (function (_super) {
    __extends(PrepPanelInfoBox, _super);
    function PrepPanelInfoBox() {
        var _this = _super.call(this, {
            layer: Battle.Layers.infobox,
            useGlobalTime: true,
        }) || this;
        _this.text = _this.addChild(new SpriteText({
            x: 1,
            anchor: Vector2.CENTER,
            justify: 'center',
            copyFromParent: ['layer'],
        }));
        _this.floatTimer = new Timer(0, function () { return _this.setVisible(true); });
        return _this;
    }
    PrepPanelInfoBox.prototype.update = function () {
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        var desc = undefined;
        if (GAME_MODE === 'vs') {
            if (PrepPanelInfoBox.VS_GOLD_BOUNDS.containsPoint(mouseBounds)) {
                desc = GAME_DATA.gold + " gold";
            }
            else if (PrepPanelInfoBox.VS_ROUND_BOUNDS.containsPoint(mouseBounds)) {
                desc = "Round " + GAME_DATA.round;
            }
        }
        else {
            if (PrepPanelInfoBox.GOLD_BOUNDS.containsPoint(mouseBounds)) {
                desc = GAME_DATA.gold + " gold";
            }
            else if (PrepPanelInfoBox.WINS_BOUNDS.containsPoint(mouseBounds)) {
                var lap = GAME_DATA.lap === 1 ? '' : "Lap " + (GAME_DATA.lap - 1) + ", ";
                desc = "" + lap + GAME_DATA.wins + "/" + GET_MAX_WINS() + " wins";
            }
            else if (PrepPanelInfoBox.HEALTH_BOUNDS.containsPoint(mouseBounds)) {
                desc = GAME_DATA.health + " losses\nto game over";
            }
            else if (PrepPanelInfoBox.ROUND_BOUNDS.containsPoint(mouseBounds)) {
                desc = "Facing Round " + GAME_DATA.round + "\nopponents";
            }
        }
        if (desc) {
            this.text.setText(desc);
            var width = this.text.getTextWidth() + 2 * PrepPanelInfoBox.PADDING.x;
            var height = this.text.getTextHeight() + 2 * PrepPanelInfoBox.PADDING.y;
            this.setTexture(InfoBox.getTextureForSize(width, height));
            var extraMove = IS_MOBILE ? 20 : 0;
            this.x = mouseBounds.x - width / 2 - extraMove;
            this.y = mouseBounds.y + height / 2 + extraMove;
            this.floatTimer.update(this.delta);
        }
        else {
            this.setVisible(false);
            this.floatTimer.reset();
        }
    };
    PrepPanelInfoBox.GOLD_BOUNDS = new RectBounds(169, 0, 36, 21);
    PrepPanelInfoBox.WINS_BOUNDS = new RectBounds(205, 0, 45, 21);
    PrepPanelInfoBox.HEALTH_BOUNDS = new RectBounds(250, 0, 29, 21);
    PrepPanelInfoBox.ROUND_BOUNDS = new RectBounds(279, 0, 33, 21);
    PrepPanelInfoBox.VS_GOLD_BOUNDS = new RectBounds(169, 0, 36, 21);
    PrepPanelInfoBox.VS_ROUND_BOUNDS = new RectBounds(205, 0, 33, 21);
    PrepPanelInfoBox.PADDING = vec2(8, 4);
    return PrepPanelInfoBox;
}(Sprite));
var PrerenderBalls;
(function (PrerenderBalls) {
    function render() {
        var e_104, _a;
        for (var ballType in TYPE_TO_BALL_TYPE_DEF) {
            var ball = squadBallToWorldBall({
                x: 0, y: 0,
                properties: {
                    type: parseInt(ballType),
                    damage: 1,
                    health: 1,
                    level: 1,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, 'friend');
            ball.render(Texture.NOOP, 0, 0);
            try {
                for (var _b = (e_104 = void 0, __values(ball.children)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    child.render(Texture.NOOP, 0, 0);
                }
            }
            catch (e_104_1) { e_104 = { error: e_104_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_104) throw e_104.error; }
            }
        }
    }
    PrerenderBalls.render = render;
})(PrerenderBalls || (PrerenderBalls = {}));
var RestoreCode = /** @class */ (function (_super) {
    __extends(RestoreCode, _super);
    function RestoreCode() {
        var _this = _super.call(this) || this;
        _this.lastFour = "xxxx";
        return _this;
    }
    RestoreCode.prototype.update = function () {
        _super.prototype.update.call(this);
        for (var n = 0; n <= 9; n++) {
            if (Input.justDown("" + n)) {
                this.pushChar("" + n);
            }
        }
        if (Input.justDown('ach_cheat')) {
            this.pushChar('p');
        }
        if (this.lastFour === 'p' + '6' + '6' + '8') {
            unlockAllAchievements();
            this.kill();
        }
        if (this.lastFour === 'p' + '8' + '9' + '6') {
            seeAllAlmanacEntries();
            this.kill();
        }
        if (this.lastFour === 'p' + '7' + '0' + '6') {
            restoreCompleteAlmanac();
            this.kill();
        }
        if (this.lastFour === 'p' + '9' + '6' + '9') {
            unlockAllAchievements();
            restoreCompleteAlmanac();
            this.kill();
        }
    };
    RestoreCode.prototype.pushChar = function (char) {
        this.lastFour = this.lastFour.substring(1, 4) + ("" + char);
    };
    return RestoreCode;
}(WorldObject));
var RevealFilter = /** @class */ (function (_super) {
    __extends(RevealFilter, _super);
    function RevealFilter(amount) {
        var _this = _super.call(this, {
            uniforms: { 'float amount': amount },
            code: "\n                float pn = map(pnoise(x/12.0, y/12.0, 10.6), -1.0, 1.0, 0.0, 1.0);\n                float a = amount * 1.2;\n                if (pn >= a) {\n                    outp.a = 0.0;\n                } else if (pn > a - 0.1) {\n                    outp.a *= map(pn, a, a - 0.1, 0.0, 1.0);\n                }\n            "
        }) || this;
        _this._amount = amount;
        return _this;
    }
    Object.defineProperty(RevealFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (value) {
            this._amount = value;
            this.setUniform('amount', value);
        },
        enumerable: false,
        configurable: true
    });
    return RevealFilter;
}(TextureFilter));
var RoundResults;
(function (RoundResults) {
    function RESULT_CHECK() {
        return function () {
            var delayResolveObjects, lastDelayResolveObjects, executedOnEndGameBeforeDelayResolveObjects, foundDelayResolveObjects, _loop_9, state_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        delayResolveObjects = [];
                        lastDelayResolveObjects = [];
                        executedOnEndGameBeforeDelayResolveObjects = false;
                        foundDelayResolveObjects = false;
                        _loop_9 = function () {
                            var battleTimer, balls, balls_12, balls_12_1, ball, roundResult;
                            var e_105, _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/];
                                    case 1:
                                        _b.sent();
                                        if (!isStartOfEndOfGame()) {
                                            foundDelayResolveObjects = false;
                                            return [2 /*return*/, "continue"];
                                        }
                                        return [4 /*yield*/];
                                    case 2:
                                        _b.sent();
                                        battleTimer = global.world.select.type(BattleTimer);
                                        balls = global.world.select.typeAll(Ball);
                                        if (!executedOnEndGameBeforeDelayResolveObjects) {
                                            try {
                                                for (balls_12 = (e_105 = void 0, __values(balls)), balls_12_1 = balls_12.next(); !balls_12_1.done; balls_12_1 = balls_12.next()) {
                                                    ball = balls_12_1.value;
                                                    ball.onEndGameBeforeDelayResolveObjects();
                                                }
                                            }
                                            catch (e_105_1) { e_105 = { error: e_105_1 }; }
                                            finally {
                                                try {
                                                    if (balls_12_1 && !balls_12_1.done && (_a = balls_12.return)) _a.call(balls_12);
                                                }
                                                finally { if (e_105) throw e_105.error; }
                                            }
                                            executedOnEndGameBeforeDelayResolveObjects = true;
                                        }
                                        if (!foundDelayResolveObjects) {
                                            delayResolveObjects = getDelayResolveObjects(global.world);
                                            foundDelayResolveObjects = true;
                                        }
                                        delayResolveObjects = delayResolveObjects.filter(function (dro) { return dro.world && getDelayResolveObjectTeam(dro); });
                                        roundResult = getRoundResult(battleTimer, balls, delayResolveObjects, lastDelayResolveObjects);
                                        if (roundResult.ongoing) {
                                            lastDelayResolveObjects = getDelayResolveObjects(global.world);
                                            return [2 /*return*/, "continue"];
                                        }
                                        debug('Started end of game with result', roundResult, 'and delayResolveObjects', delayResolveObjects);
                                        global.theater.runScript(function () {
                                            var gearButton, balls_13, balls_13_1, ball;
                                            var e_106, _a;
                                            var _b, _c;
                                            return __generator(this, function (_d) {
                                                switch (_d.label) {
                                                    case 0:
                                                        global.theater.select.type(BattleSpeedController).enabled = false;
                                                        battleTimer.setActive(false);
                                                        global.game.allowPauseWithPauseKey = false;
                                                        gearButton = (_b = global.world.select.name('gear', false)) === null || _b === void 0 ? void 0 : _b.getModule(Button);
                                                        if (gearButton)
                                                            gearButton.enabled = false;
                                                        return [4 /*yield*/, slowWorldAndFade()];
                                                    case 1:
                                                        _d.sent();
                                                        // Reevaluate the round result after the fade finishes
                                                        balls = global.world.select.typeAll(Ball);
                                                        roundResult = getRoundResult(battleTimer, balls, [], []);
                                                        debug('Real round result:', roundResult);
                                                        try {
                                                            // Do end of battle abilities
                                                            for (balls_13 = __values(balls), balls_13_1 = balls_13.next(); !balls_13_1.done; balls_13_1 = balls_13.next()) {
                                                                ball = balls_13_1.value;
                                                                if (ball.team !== 'friend')
                                                                    continue;
                                                                ball.queueAbilities('onSurviveBattle');
                                                            }
                                                        }
                                                        catch (e_106_1) { e_106 = { error: e_106_1 }; }
                                                        finally {
                                                            try {
                                                                if (balls_13_1 && !balls_13_1.done && (_a = balls_13.return)) _a.call(balls_13);
                                                            }
                                                            finally { if (e_106) throw e_106.error; }
                                                        }
                                                        (_c = global.world.select.type(AbilitySystem, false)) === null || _c === void 0 ? void 0 : _c.activateAbilities();
                                                        if (roundResult.result === 'loss' && ENEMY_SQUAD_DATA && !_.includes(GAME_DATA.playersWhoBeatYou, ENEMY_SQUAD_DATA.squad.name)) {
                                                            GAME_DATA.playersWhoBeatYou.push(ENEMY_SQUAD_DATA.squad.name);
                                                        }
                                                        return [4 /*yield*/, playCutsceneForRoundResult(roundResult.result, roundResult.isTimeout)];
                                                    case 2:
                                                        _d.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                        return [2 /*return*/, "break"];
                                }
                            });
                        };
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_9()];
                    case 2:
                        state_3 = _a.sent();
                        if (state_3 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
    }
    RoundResults.RESULT_CHECK = RESULT_CHECK;
    function isStartOfEndOfGame() {
        var battleTimer = global.world.select.type(BattleTimer);
        if (battleTimer && battleTimer.battleTime > 60)
            return true;
        var balls = global.world.select.typeAll(Ball);
        if (balls.length === 0)
            return true;
        if (balls.every(function (ball) { return ball.team === 'friend' || ball.team === 'neutral'; }))
            return true;
        if (balls.every(function (ball) { return ball.team === 'enemy' || ball.team === 'neutral'; }))
            return true;
        return false;
    }
    function getRoundResult(battleTimer, balls, delayResolveObjects, lastDelayResolveObjects) {
        var result;
        var ongoing;
        var isTimeout = false;
        var winningTeam;
        if (balls.length === 0 || balls.every(function (ball) { return ball.team === 'neutral'; })) {
            result = 'draw';
            ongoing = false;
        }
        else if (balls.every(function (ball) { return ball.team === 'friend' || ball.team === 'neutral'; })) {
            result = 'win';
            ongoing = false;
            winningTeam = 'friend';
        }
        else if (balls.every(function (ball) { return ball.team === 'enemy' || ball.team === 'neutral'; })) {
            result = 'loss';
            ongoing = false;
            winningTeam = 'enemy';
        }
        else {
            result = 'draw';
            ongoing = true;
        }
        var existsLosingTeamDelayResolveObjects = winningTeam && __spread(delayResolveObjects, lastDelayResolveObjects).some(function (dro) {
            var droTeam = getDelayResolveObjectTeam(dro);
            return droTeam !== winningTeam && droTeam !== 'neutral';
        });
        var existsForceDelayResolveObjects = __spread(delayResolveObjects, lastDelayResolveObjects).some(function (dro) {
            return dro.hasTag(Tags.FORCE_DELAY_RESOLVE);
        });
        if (battleTimer && battleTimer.battleTime > 60) {
            ongoing = false;
            isTimeout = true;
        }
        else if (existsLosingTeamDelayResolveObjects || existsForceDelayResolveObjects) {
            ongoing = true;
        }
        return { result: result, ongoing: ongoing, isTimeout: isTimeout };
    }
    function playCutsceneForRoundResult(roundResult, isTimeout) {
        return function () {
            var roundResultError, result, drawType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        roundResultError = false;
                        if (!(GAME_MODE === 'vs' || GAME_MODE === 'spectate')) return [3 /*break*/, 8];
                        if (!(VS_GAME.youarehost && GAME_MODE !== 'spectate')) return [3 /*break*/, 2];
                        return [4 /*yield*/, submitHostRoundResult(roundResult)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        result = {};
                        return [4 /*yield*/, waitForVSHostRoundResult(result)];
                    case 3:
                        _a.sent();
                        roundResultError = (result.roundResult !== roundResult);
                        roundResult = result.roundResult;
                        _a.label = 4;
                    case 4: return [4 /*yield*/, S.wait(1)];
                    case 5:
                        _a.sent();
                        if (!roundResultError) return [3 /*break*/, 8];
                        "modded_remove_from";
                        API.submiterror(function (_, err) {
                            if (err) {
                                console.error('Error while submitting error:', err);
                                return;
                            }
                            debug('Submitted desync error');
                        }, Persistence.getProfileId(), "Desynced VS results for gameid=" + GAME_DATA.gameId + ", round=" + GAME_DATA.round);
                        "modded_remove_to";
                        return [4 /*yield*/, showRoundResultError()];
                    case 6:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8:
                        if (roundResult === 'draw') {
                            drawType = isTimeout ? 'timeout' : 'normal';
                            if (GAME_MODE === 'spectate') {
                                global.theater.playCutscene(SPECTATE_RESULT(null, drawType));
                            }
                            else {
                                global.theater.playCutscene(DRAW(drawType));
                            }
                        }
                        else if (roundResult === 'win') {
                            if (GAME_MODE === 'spectate') {
                                if (VS_GAME.yourhealth <= 0 || VS_GAME.enemyhealth <= 0) {
                                    global.theater.playCutscene(RoundResults.VICTORY);
                                }
                                else {
                                    global.theater.playCutscene(SPECTATE_RESULT(VS_GAME.yourname, null));
                                }
                            }
                            else if (GAME_DATA.wins + 1 >= GET_MAX_WINS() && !vsOpponentHadDoveBallInSquadLastRound()) {
                                global.theater.playCutscene(RoundResults.VICTORY);
                            }
                            else {
                                global.theater.playCutscene(RoundResults.WIN);
                            }
                        }
                        else if (roundResult === 'loss') {
                            if (GAME_MODE === 'spectate') {
                                if (VS_GAME.yourhealth <= 0 || VS_GAME.enemyhealth <= 0) {
                                    global.theater.playCutscene(RoundResults.GAMEOVER);
                                }
                                else {
                                    global.theater.playCutscene(SPECTATE_RESULT(VS_GAME.enemyname, null));
                                }
                            }
                            else if (GAME_DATA.health - 1 <= 0 && !hasDoveBallInSquad()) {
                                global.theater.playCutscene(RoundResults.GAMEOVER);
                            }
                            else {
                                global.theater.playCutscene(RoundResults.LOSE);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        };
    }
    RoundResults.VICTORY = {
        script: function () {
            var priorLap, priorWins, priorHealth, priorRound, timeScale, dailySubmissionResult, _a, _b, pack, wins, hasRefreshedGame, inVictoryLap, dailyFailed, result, vignette, currentHeaderText;
            var e_107, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        priorLap = GAME_DATA.lap;
                        priorWins = GAME_DATA.wins;
                        priorHealth = GAME_DATA.health;
                        priorRound = GAME_DATA.round;
                        if (youArePlaying(global.world)) {
                            GAME_DATA.roundResults[GAME_DATA.round] = 'win';
                            GAME_DATA.round++;
                            GAME_DATA.wins++;
                            if (GAME_MODE === 'mm') {
                                GAME_DATA.lap++;
                                GAME_DATA.wins = 0;
                                GAME_DATA.health = M.clamp(GAME_DATA.health + 1, 1, 4);
                            }
                        }
                        if (GAME_MODE === 'vs') {
                            saveVersusModeGameData(undefined);
                        }
                        else if (!DAILY) {
                            saveEndOfRoundGameData('win');
                        }
                        timeScale = getBattleTransitionTimeScale();
                        dailySubmissionResult = { success: true };
                        if (!youArePlaying(global.world)) return [3 /*break*/, 3];
                        if (priorLap === 1) {
                            if (GAME_MODE === 'mm') {
                                try {
                                    for (_a = __values(GAME_DATA.packs), _b = _a.next(); !_b.done; _b = _a.next()) {
                                        pack = _b.value;
                                        wins = loadWins(pack);
                                        saveWins(pack, wins + 1);
                                    }
                                }
                                catch (e_107_1) { e_107 = { error: e_107_1 }; }
                                finally {
                                    try {
                                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                                    }
                                    finally { if (e_107) throw e_107.error; }
                                }
                            }
                            hasRefreshedGame = GAME_MODE === 'vs' && VS_GAME && VS_GAME.yourjoins > 1;
                            updateAchievementProgress('WinGame', function (p) { return p + 1; });
                            updateAchievementProgress('PlayFiveGames', function (p) { return p + 1; });
                            if (GAME_DATA.squad.balls.length <= 3) {
                                updateAchievementProgress('VictoryWithTwoBalls', function (p) { return p + 1; });
                            }
                            if (GAME_DATA.squad.balls.length <= 1) {
                                updateAchievementProgress('OneBall', function (p) { return p + 1; });
                            }
                            if (GAME_DATA.gameTime <= 900 && !hasRefreshedGame) {
                                updateAchievementProgress('WinInTenMinutes', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasBoughtEquipment && !hasRefreshedGame) {
                                updateAchievementProgress('WinWithoutEquipment', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasFrozen && !hasRefreshedGame) {
                                updateAchievementProgress('WinWithoutFreezing', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasRestocked && !hasRefreshedGame) {
                                updateAchievementProgress('NoRestocks', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasLeveledUp && !hasRefreshedGame) {
                                updateAchievementProgress('NoLevelUp', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasSold && !hasRefreshedGame) {
                                updateAchievementProgress('NoSell', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasBoughtItem && !hasRefreshedGame) {
                                updateAchievementProgress('NoItems', function (p) { return p + 1; });
                            }
                            if (!GAME_DATA.hasLostRound && !hasRefreshedGame) {
                                updateAchievementProgress('WinWithoutLosing', function (p) { return p + 1; });
                            }
                            if (GAME_DATA.squad.balls.some(function (ball) { return ball.properties.type === 41; })) {
                                updateAchievementProgress('WinWithGlitchedBall', function (p) { return p + 1; });
                            }
                            if (GAME_MODE === 'vs') {
                                updateAchievementProgress('WinVSGame', function (p) { return p + 1; });
                            }
                            if (GAME_MODE === 'mm' && CHALLENGE_MODE_ENABLED) {
                                updateAchievementProgress('WinChallengeMode', function (p) { return p + 1; });
                            }
                            if (global.world.data.arenaName === Arenas.ARENA_BDAY || GAME_DATA.arena === Arenas.ARENA_BDAY) {
                                updateAchievementProgress('WinBirthdayMode', function (p) { return p + 1; });
                            }
                            if (GAME_DATA.squad.balls.some(function (ball) { return ball.properties.type === 127; })) {
                                updateAchievementProgress('PeaceWasNeverAnOption', function (p) { return p + 1; });
                            }
                            if (DAILY) {
                                updateAchievementProgress('WinDaily', function (p) { return p + 1; });
                            }
                            if (_.includes(GAME_DATA.packs, 'weekly')) {
                                updateAchievementProgress('WinWeekly', function (p) { return p + 1; });
                            }
                            updateWinRoundAchievements();
                            updatePlayRoundAchievements();
                            if (GAME_MODE === 'mm') {
                                updateAlmanacEntriesForWin();
                            }
                        }
                        if (priorLap > 1) {
                            updateAchievementProgress('CompleteVictoryLap', function (p) { return p + 1; });
                        }
                        if (priorLap > 2) {
                            updateAchievementProgress('CompleteTwoVictoryLaps', function (p) { return p + 1; });
                        }
                        if (USELESS_CROWN_REPLACEMENT) {
                            updateAchievementProgress('Useless', function (p) { return p + 1; });
                            USELESS_CROWN_REPLACEMENT = false;
                        }
                        "modded_remove_from";
                        if (!(GAME_MODE === 'mm')) return [3 /*break*/, 2];
                        submitGameResults('win');
                        if (!DAILY) return [3 /*break*/, 2];
                        dailySubmissionResult = {};
                        return [4 /*yield*/, submitDailyResults(dailySubmissionResult, priorWins + 1, priorHealth, priorRound)];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        "modded_remove_to";
                        _d.label = 3;
                    case 3:
                        inVictoryLap = priorLap > 1;
                        dailyFailed = DAILY && !dailySubmissionResult.success;
                        if (GAME_MODE === 'mm' && !inVictoryLap && !dailyFailed) {
                            saveMatchmakingOrChallengeModeOrDailyGameData(undefined, CHALLENGE_MODE_ENABLED, DAILY);
                        }
                        Persist.persist();
                        result = {};
                        if (!(GAME_MODE === 'vs' || GAME_MODE === 'spectate')) return [3 /*break*/, 5];
                        return [4 /*yield*/, EndScreens.showVsResult()];
                    case 4:
                        _d.sent();
                        result.continueSelection = 'continue';
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, EndScreens.showVictory(priorLap, priorWins, priorHealth, priorRound, result)];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        if (!(result.continueSelection === 'victorylap')) return [3 /*break*/, 11];
                        vignette = global.world.addWorldObject(new Sprite({
                            texture: 'vignette',
                            tint: 0xFFD800,
                            alpha: 0,
                        }));
                        global.theater.playSound('impact');
                        global.theater.playSound('freeze', { humanized: false });
                        return [4 /*yield*/, S.tween(0.5, vignette, 'alpha', 0, 0.8, Tween.Easing.OutBounce(2))];
                    case 8:
                        _d.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 9:
                        _d.sent();
                        currentHeaderText = global.world.select.name('wintext');
                        if (currentHeaderText) {
                            currentHeaderText.setText(currentHeaderText.getCurrentText().replace(/\[r\]<heart>\[\/r\] [0-9]+ /, "[r]<heart>[/r] [gold]" + GAME_DATA.health + "[/gold] "));
                            global.world.playSound('buff', { humanized: false });
                        }
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 10:
                        _d.sent();
                        global.theater.loadStage(Stages.PREP, transition());
                        return [3 /*break*/, 19];
                    case 11:
                        if (!GAME_DATA.arg2Trigger.strategy) return [3 /*break*/, 12];
                        global.theater.runScript(function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/];
                                    case 1:
                                        _a.sent();
                                        global.theater.playCutscene(ARG.Cutscenes.BEGIN_ARG_2);
                                        return [2 /*return*/];
                                }
                            });
                        });
                        return [3 /*break*/, 19];
                    case 12:
                        if (!isBallmanacToComplete()) return [3 /*break*/, 13];
                        global.theater.runScript(function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/];
                                    case 1:
                                        _a.sent();
                                        global.theater.playCutscene(COMPLETE_ALMANAC_CUTSCENE);
                                        return [2 /*return*/];
                                }
                            });
                        });
                        return [3 /*break*/, 19];
                    case 13:
                        if (!DAILY) return [3 /*break*/, 16];
                        return [4 /*yield*/, S.fadeOut(1, 0x000000)];
                    case 14:
                        _d.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 15:
                        _d.sent();
                        global.game.loadMainMenu();
                        global.game.startGame(function () { return DailyScreen.STAGE(); });
                        return [3 /*break*/, 19];
                    case 16: return [4 /*yield*/, S.fadeOut(1, 0x000000)];
                    case 17:
                        _d.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 18:
                        _d.sent();
                        global.game.loadMainMenu();
                        _d.label = 19;
                    case 19: return [2 /*return*/];
                }
            });
        }
    };
    RoundResults.GAMEOVER = {
        script: function () {
            var dailySubmissionResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (youArePlaying(global.world)) {
                            GAME_DATA.roundResults[GAME_DATA.round] = 'loss';
                            GAME_DATA.hasLostRound = true;
                            GAME_DATA.round++;
                            GAME_DATA.health--;
                        }
                        if (GAME_MODE === 'vs') {
                            saveVersusModeGameData(undefined);
                        }
                        else if (!DAILY) {
                            saveMatchmakingOrChallengeModeOrDailyGameData(undefined, CHALLENGE_MODE_ENABLED, DAILY);
                        }
                        dailySubmissionResult = { success: true };
                        if (!youArePlaying(global.world)) return [3 /*break*/, 3];
                        updateAchievementProgress('PlayFiveGames', function (p) { return p + 1; });
                        if (USELESS_CROWN_REPLACEMENT) {
                            updateAchievementProgress('Useless', function (p) { return p + 1; });
                            USELESS_CROWN_REPLACEMENT = false;
                        }
                        updatePlayRoundAchievements();
                        "modded_remove_from";
                        if (!(GAME_MODE === 'mm')) return [3 /*break*/, 2];
                        if (GAME_DATA.lap === 1) {
                            submitGameResults('loss');
                        }
                        else {
                            submitGameResults('win');
                        }
                        if (!DAILY) return [3 /*break*/, 2];
                        dailySubmissionResult = {};
                        return [4 /*yield*/, submitDailyResults(dailySubmissionResult, GAME_DATA.wins, GAME_DATA.health, GAME_DATA.round - 1)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        "modded_remove_to";
                        _a.label = 3;
                    case 3:
                        if (GAME_MODE === 'mm' && (!DAILY || dailySubmissionResult.success)) {
                            saveMatchmakingOrChallengeModeOrDailyGameData(undefined, CHALLENGE_MODE_ENABLED, DAILY);
                        }
                        Persist.persist();
                        if (!(GAME_MODE === 'vs' || GAME_MODE === 'spectate')) return [3 /*break*/, 5];
                        return [4 /*yield*/, EndScreens.showVsResult()];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, EndScreens.showGameOver()];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!GAME_DATA.arg2Trigger.strategy) return [3 /*break*/, 8];
                        global.theater.runScript(function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/];
                                    case 1:
                                        _a.sent();
                                        global.theater.playCutscene(ARG.Cutscenes.BEGIN_ARG_2);
                                        return [2 /*return*/];
                                }
                            });
                        });
                        return [3 /*break*/, 14];
                    case 8:
                        if (!DAILY) return [3 /*break*/, 11];
                        return [4 /*yield*/, S.fadeOut(1, 0x000000)];
                    case 9:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 10:
                        _a.sent();
                        global.game.loadMainMenu();
                        global.game.startGame(function () { return DailyScreen.STAGE(); });
                        return [3 /*break*/, 14];
                    case 11: return [4 /*yield*/, S.fadeOut(1, 0x000000)];
                    case 12:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 13:
                        _a.sent();
                        global.game.loadMainMenu();
                        _a.label = 14;
                    case 14: return [2 /*return*/];
                }
            });
        }
    };
    RoundResults.WIN = {
        script: function () {
            var timeScale;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (youArePlaying(global.world)) {
                            GAME_DATA.roundResults[GAME_DATA.round] = 'win';
                            GAME_DATA.round++;
                            if (!vsOpponentHadDoveBallInSquadLastRound()) {
                                GAME_DATA.wins++;
                            }
                        }
                        saveEndOfRoundGameData('win');
                        timeScale = getBattleTransitionTimeScale();
                        if (youArePlaying(global.world)) {
                            updateWinRoundAchievements();
                            updatePlayRoundAchievements();
                        }
                        Persist.persist();
                        return [4 /*yield*/, EndScreens.showWin()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(4 * timeScale)];
                    case 2:
                        _a.sent();
                        if (GAME_MODE === 'spectate') {
                            // Safety
                            global.theater.loadStage(SpectateWaitingRoom.STAGE, transition());
                        }
                        else {
                            global.theater.loadStage(Stages.PREP, transition());
                        }
                        return [2 /*return*/];
                }
            });
        }
    };
    RoundResults.LOSE = {
        script: function () {
            var timeScale;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (youArePlaying(global.world)) {
                            GAME_DATA.roundResults[GAME_DATA.round] = 'loss';
                            GAME_DATA.hasLostRound = true;
                            GAME_DATA.round++;
                            if (!hasDoveBallInSquad()) {
                                GAME_DATA.health--;
                            }
                        }
                        saveEndOfRoundGameData('loss');
                        timeScale = getBattleTransitionTimeScale();
                        if (youArePlaying(global.world)) {
                            updatePlayRoundAchievements();
                        }
                        Persist.persist();
                        return [4 /*yield*/, EndScreens.showLose()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(4 * timeScale)];
                    case 2:
                        _a.sent();
                        if (GAME_MODE === 'spectate') {
                            // Safety
                            global.theater.loadStage(SpectateWaitingRoom.STAGE, transition());
                        }
                        else {
                            global.theater.loadStage(Stages.PREP, transition());
                        }
                        return [2 /*return*/];
                }
            });
        }
    };
    function DRAW(type) {
        return {
            script: function () {
                var timeScale;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (youArePlaying(global.world)) {
                                GAME_DATA.roundResults[GAME_DATA.round] = 'draw';
                                GAME_DATA.round++;
                            }
                            saveEndOfRoundGameData('draw');
                            timeScale = getBattleTransitionTimeScale();
                            if (youArePlaying(global.world)) {
                                updatePlayRoundAchievements();
                                if (type === 'timeout') {
                                    updateAchievementProgress('TimeOut', function (p) { return p + 1; });
                                }
                                updateAchievementProgress('DrawsInARow', function (p) { return Math.max(p, getLastDrawStreak()); });
                            }
                            Persist.persist();
                            return [4 /*yield*/, EndScreens.showDraw(type)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(4 * timeScale)];
                        case 2:
                            _a.sent();
                            if (GAME_MODE === 'spectate') {
                                // Safety
                                global.theater.loadStage(SpectateWaitingRoom.STAGE, transition());
                            }
                            else {
                                global.theater.loadStage(Stages.PREP, transition());
                            }
                            return [2 /*return*/];
                    }
                });
            }
        };
    }
    RoundResults.DRAW = DRAW;
    function SPECTATE_RESULT(winner, drawType) {
        return {
            script: function () {
                var timeScale;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            GAME_DATA.round++;
                            timeScale = getBattleTransitionTimeScale();
                            return [4 /*yield*/, EndScreens.showSpectateNonDraw(winner, drawType)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(4 * timeScale)];
                        case 2:
                            _a.sent();
                            global.theater.loadStage(SpectateWaitingRoom.STAGE, transition());
                            return [2 /*return*/];
                    }
                });
            }
        };
    }
    RoundResults.SPECTATE_RESULT = SPECTATE_RESULT;
    function slowWorldAndFade() {
        return function () {
            var timeScale, bsc, screen_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        if (!!global.world.select.name('fadescreen', false)) return [3 /*break*/, 4];
                        bsc = global.theater.select.type(BattleSpeedController);
                        bsc.enabled = false;
                        bsc.endOfGame = true;
                        global.game.stopMusic(2);
                        global.world.select.typeAll(Ball).forEach(function (ball) { return ball.showAllStats(); });
                        return [4 /*yield*/, S.tween(2, global.world, 'timeScale', 1, 0, Tween.Easing.OutQuad)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1 * timeScale)];
                    case 2:
                        _a.sent();
                        global.game.allowPauseWithPauseKey = false;
                        screen_1 = global.world.addWorldObject(new Sprite({
                            name: 'fadescreen',
                            texture: Texture.filledRect(global.gameWidth, global.gameHeight, 0x000000, 0.8),
                            alpha: 0,
                            ignoreCamera: true,
                        }));
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) { return screen_1.alpha = t; })];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        };
    }
    function submitHostRoundResult(roundResult) {
        return function () {
            var timeScale, waitingForText, waitingForSpinner, errorText, hostProtected, nonhostProtected, _loop_10, state_4, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        waitingForText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 136,
                            text: "Submitting round results...",
                            anchor: Vector2.TOP_CENTER,
                            alpha: 0,
                        }));
                        waitingForSpinner = global.world.addWorldObject(new Spinner(global.world.width / 2, 100, 4, 16));
                        waitingForSpinner.useGlobalTime = true;
                        waitingForSpinner.alpha = 0;
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = t;
                                waitingForSpinner.alpha = t;
                            })];
                    case 1:
                        _a.sent();
                        errorText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 178,
                            anchor: Vector2.CENTER,
                            style: { color: 0x888888 },
                        }));
                        hostProtected = hasDoveBallInSquad();
                        nonhostProtected = !!VS_GAME.enemysquad.balls.find(function (ball) { return ball.properties.type === 127; });
                        _loop_10 = function () {
                            var err, callDone, startTime;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        callDone = false;
                                        API.submitvsgameresult(function (_, _err) {
                                            err = _err;
                                            callDone = true;
                                            if (!err)
                                                debug('Submitted VS squad:', GAME_DATA.squad);
                                        }, GAME_DATA.gameId, GAME_DATA.squad.name, GAME_DATA.round, roundResult, hostProtected, nonhostProtected, Persistence.getProfileId());
                                        startTime = Date.now();
                                        return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                                    case 1:
                                        _a.sent();
                                        if (!callDone) {
                                            err = ERROR_TIMED_OUT;
                                        }
                                        if (!err) return [3 /*break*/, 3];
                                        console.error("Error:", err);
                                        errorText.setText('An error occurred');
                                        return [4 /*yield*/, S.wait(2)];
                                    case 2:
                                        _a.sent();
                                        return [2 /*return*/, "continue"];
                                    case 3:
                                        errorText.setText('');
                                        return [2 /*return*/, "break"];
                                }
                            });
                        };
                        _a.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_10()];
                    case 3:
                        state_4 = _a.sent();
                        if (state_4 === "break")
                            return [3 /*break*/, 4];
                        return [3 /*break*/, 2];
                    case 4:
                        result = {};
                        return [4 /*yield*/, GameFragments.waitForVSGameCondition(GAME_DATA.gameId, GAME_DATA.squad.name, false, function (game) { return game; }, result, function (err) { return errorText.setText(err ? 'An error occurred' : ''); })];
                    case 5:
                        _a.sent();
                        VS_GAME = result.game;
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = 1 - t;
                                waitingForSpinner.alpha = 1 - t;
                            })];
                    case 6:
                        _a.sent();
                        waitingForText.kill();
                        waitingForSpinner.kill();
                        return [2 /*return*/];
                }
            });
        };
    }
    function waitForVSHostRoundResult(roundResult) {
        return function () {
            var timeScale, waitingForText, waitingForSpinner, errorText, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        waitingForText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 136,
                            text: "Waiting for round results...",
                            anchor: Vector2.TOP_CENTER,
                            alpha: 0,
                        }));
                        waitingForSpinner = global.world.addWorldObject(new Spinner(global.world.width / 2, 100, 4, 16));
                        waitingForSpinner.useGlobalTime = true;
                        waitingForSpinner.alpha = 0;
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = t;
                                waitingForSpinner.alpha = t;
                            })];
                    case 1:
                        _a.sent();
                        errorText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 178,
                            anchor: Vector2.CENTER,
                            style: { color: 0x888888 },
                        }));
                        result = {};
                        return [4 /*yield*/, GameFragments.waitForVSGameCondition(GAME_DATA.gameId, GAME_DATA.squad.name, false, function (game) { return game.round > GAME_DATA.round || !game.yoursquad || !game.enemysquad; }, result, function (err) { return errorText.setText(err ? 'An error occurred' : ''); })];
                    case 2:
                        _a.sent();
                        VS_GAME = result.game;
                        roundResult.roundResult = VS_GAME.lastroundresult;
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = 1 - t;
                                waitingForSpinner.alpha = 1 - t;
                            })];
                    case 3:
                        _a.sent();
                        waitingForText.kill();
                        waitingForSpinner.kill();
                        return [2 /*return*/];
                }
            });
        };
    }
    function showRoundResultError() {
        return function () {
            var timeScale, errorText;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timeScale = getBattleTransitionTimeScale();
                        errorText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: global.gameHeight / 2,
                            text: "An error occurred...\n\nResults do not match\nthe host's!",
                            anchor: Vector2.CENTER,
                            justify: 'center',
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.tween(1 * timeScale, errorText, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.tween(1 * timeScale, errorText, 'alpha', 1, 0)];
                    case 3:
                        _a.sent();
                        errorText.kill();
                        return [2 /*return*/];
                }
            });
        };
    }
    function transition() {
        return new Transitions.Curtains({ inTime: 0.5, midTime: 1, outTime: 0.5 });
    }
    function updateWinRoundAchievements() {
        var e_108, _a;
        if (global.world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend'; }).length >= 5) {
            updateAchievementProgress('FiveRemainingBalls', function (p) { return 1; });
        }
        updateAchievementProgress('RoundsInARow', function (p) { return Math.max(p, getLastWinStreak()); });
        updateAchievementProgress('WinFiftyRounds', function (p) { return p + 1; });
        if (ENEMY_SQUAD_DATA) {
            if (ENEMY_SQUAD_DATA.gameResult === 'win') {
                updateAchievementProgress('DefeatCrownedSquads', function (p) { return p + 1; });
            }
            if (ENEMY_SQUAD_DATA.squad.name.trim() === 'lectvs') {
                updateAchievementProgress('DefeatLectvs', function (p) { return p + 1; });
            }
            if (ENEMY_SQUAD_DATA.squad.name.trim() === 'Materwelons') {
                updateAchievementProgress('DefeatMaterwelons', function (p) { return p + 1; });
            }
        }
        var ballTypeCounts = {};
        try {
            for (var _b = __values(GAME_DATA.squad.balls), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ball = _c.value;
                if (!(ball.properties.type in ballTypeCounts))
                    ballTypeCounts[ball.properties.type] = 0;
                ballTypeCounts[ball.properties.type]++;
            }
        }
        catch (e_108_1) { e_108 = { error: e_108_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_108) throw e_108.error; }
        }
        if (Object.keys(ballTypeCounts).some(function (k) { return ballTypeCounts[k] >= 3; })) {
            updateAchievementProgress('SameBall', function (p) { return p + 1; });
        }
        var startingFriendBalls = global.world.data.startingFriendBalls;
        if (_.isArray(startingFriendBalls) && startingFriendBalls.every(function (ball) { return ball instanceof Ball && ball.alive && !ball.dead && ball.world; })) {
            updateAchievementProgress('NoBallsDied', function (p) { return p + 1; });
        }
        var battleTimer = global.world.select.type(BattleTimer, false);
        if (battleTimer && battleTimer.battleTime <= 3) {
            updateAchievementProgress('WinFast', function (p) { return p + 1; });
        }
        if (ENEMY_SQUAD_DATA && _.includes(GAME_DATA.playersWhoBeatYou, ENEMY_SQUAD_DATA.squad.name) && GAME_MODE === 'mm') {
            updateAchievementProgress('GetRevenge', function (p) { return p + 1; });
        }
    }
    function updatePlayRoundAchievements() {
        updateAchievementProgress('PlayHundredRounds', function (p) { return p + 1; });
    }
    function updateAlmanacEntriesForWin() {
        var e_109, _a, e_110, _b, e_111, _c;
        try {
            for (var _d = __values(GAME_DATA.squad.balls), _e = _d.next(); !_e.done; _e = _d.next()) {
                var ball = _e.value;
                addAlmanacBallWin(ball.properties.type);
                if (ball.properties.type === 2) {
                    addAlmanacBallWin(3); // Splitter Spawn
                }
                if (ball.properties.type === 15 || ball.properties.type === 19) {
                    addAlmanacBallWin(16); // Skeleton
                }
                if (ball.properties.type === 53) {
                    addAlmanacBallWin(54); // Cannonball
                }
                if (ball.properties.equipment >= 0) {
                    addAlmanacItemWin(getItemTypeForEquipmentType(ball.properties.equipment));
                }
            }
        }
        catch (e_109_1) { e_109 = { error: e_109_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_109) throw e_109.error; }
        }
        try {
            for (var _f = __values(GAME_DATA.ballTypesForAlmanacWin), _g = _f.next(); !_g.done; _g = _f.next()) {
                var ballType = _g.value;
                addAlmanacBallWin(ballType);
            }
        }
        catch (e_110_1) { e_110 = { error: e_110_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_110) throw e_110.error; }
        }
        try {
            for (var _h = __values(GAME_DATA.itemTypesForAlmanacWin), _j = _h.next(); !_j.done; _j = _h.next()) {
                var itemType = _j.value;
                addAlmanacItemWin(itemType);
            }
        }
        catch (e_111_1) { e_111 = { error: e_111_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            }
            finally { if (e_111) throw e_111.error; }
        }
    }
    "modded_remove_from";
    function submitGameResults(gameResult) {
        API.submitgameresults(function (_, err) {
            if (err) {
                console.error(err);
                return;
            }
            debug('Submitted game results:', GAME_DATA.gameId, GAME_DATA.roundResults, gameResult);
        }, GAME_DATA.gameId, GAME_DATA.roundResults, gameResult, Persistence.getProfileId(), GAME_DATA.packs);
    }
    "modded_remove_to";
    "modded_remove_from";
    function submitDailyResults(result, wins, health, rounds) {
        return function () {
            var timeScale, waitingForText, waitingForSpinner, done, err, errorTextText, errorText_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (IS_SUBMISSION_DISABLED()) {
                            result.success = true;
                            return [2 /*return*/];
                        }
                        timeScale = getBattleTransitionTimeScale();
                        waitingForText = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: 136,
                            text: "Submitting results...",
                            anchor: Vector2.TOP_CENTER,
                            alpha: 0,
                        }));
                        waitingForSpinner = global.world.addWorldObject(new Spinner(global.world.width / 2, 100, 4, 16));
                        waitingForSpinner.useGlobalTime = true;
                        waitingForSpinner.alpha = 0;
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = t;
                                waitingForSpinner.alpha = t;
                            })];
                    case 1:
                        _a.sent();
                        done = false;
                        API.submitdailyresults(function (_, errr) {
                            done = true;
                            if (errr) {
                                console.error(errr);
                                err = errr;
                                return;
                            }
                            debug('Submitted daily results:', DAILY.day, GAME_DATA.gameId);
                        }, DAILY.day, GAME_DATA.squad.name, Persistence.getProfileId(), loadPlayerId(), GAME_DATA.gameId, wins, health, rounds, GAME_DATA.gameTime, GAME_DATA.squad);
                        return [4 /*yield*/, S.wait(3)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.either(S.waitUntil(function () { return done; }), S.wait(7))];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                waitingForText.alpha = 1 - t;
                                waitingForSpinner.alpha = 1 - t;
                            })];
                    case 4:
                        _a.sent();
                        waitingForText.kill();
                        waitingForSpinner.kill();
                        if (!done) {
                            done = true;
                            err = 'Timed out';
                        }
                        if (!err) return [3 /*break*/, 10];
                        result.success = false;
                        errorTextText = "Could not submit results :(\n\nPlease try again in a few minutes";
                        if (err === 'PAST_DAILY') {
                            errorTextText = "The daily has expired :(\n\nPlay today's daily instead!";
                            result.success = true;
                        }
                        errorText_1 = global.world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: global.gameHeight / 2,
                            text: errorTextText,
                            anchor: Vector2.CENTER,
                            justify: 'center',
                            alpha: 0,
                        }));
                        return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                                errorText_1.alpha = t;
                            })];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, S.wait(2 * timeScale)];
                    case 6:
                        _a.sent();
                        if (!!result.success) return [3 /*break*/, 8];
                        return [4 /*yield*/, S.fadeOut(2)];
                    case 7:
                        _a.sent();
                        global.game.loadMainMenu();
                        global.game.startGame(function () { return DailyScreen.STAGE(); });
                        return [2 /*return*/];
                    case 8: return [4 /*yield*/, S.doOverTime(1 * timeScale, function (t) {
                            errorText_1.alpha = 1 - t;
                        })];
                    case 9:
                        _a.sent();
                        errorText_1.kill();
                        _a.label = 10;
                    case 10:
                        result.success = true;
                        saveLastDailyCompleted(DAILY.day);
                        return [2 /*return*/];
                }
            });
        };
    }
    "modded_remove_to";
    function saveEndOfRoundGameData(roundResult) {
        if (GAME_MODE === 'mm') {
            saveMatchmakingOrChallengeModeOrDailyGameData({
                gameData: GAME_DATA,
                state: 'result',
                roundResult: roundResult,
                lock: gameDataLock(),
            }, CHALLENGE_MODE_ENABLED, DAILY);
        }
        if (GAME_MODE === 'vs') {
            saveVersusModeGameData({
                gameData: GAME_DATA,
                state: 'result',
            });
        }
    }
    function getDelayResolveObjects(world) {
        return _.flatten(['friend', 'enemy', 'neutral'].map(function (team) { return world.select.tag(Tags.DELAY_RESOLVE(team)); }));
    }
    function getDelayResolveObjectTeam(dro) {
        var e_112, _a, e_113, _b;
        if (!dro)
            return undefined;
        try {
            for (var _c = __values(dro.tags), _d = _c.next(); !_d.done; _d = _c.next()) {
                var tag = _d.value;
                try {
                    for (var _e = (e_113 = void 0, __values(['friend', 'enemy', 'neutral'])), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var team = _f.value;
                        if (tag === Tags.DELAY_RESOLVE(team)) {
                            return team;
                        }
                    }
                }
                catch (e_113_1) { e_113 = { error: e_113_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_113) throw e_113.error; }
                }
            }
        }
        catch (e_112_1) { e_112 = { error: e_112_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_112) throw e_112.error; }
        }
        return undefined;
    }
})(RoundResults || (RoundResults = {}));
var Rumper;
(function (Rumper) {
    Rumper.CACHE = {
        balls: {},
    };
    function getAllBallProperties() {
        var e_114, _a;
        var balls = Object.keys(TYPE_TO_BALL_TYPE_DEF).map(function (ballType) { return squadBallToWorldBall({
            x: 0, y: 0,
            properties: {
                type: parseInt(ballType),
                damage: 1,
                health: 1,
                level: 1,
                equipment: -1,
                metadata: {},
            }
        }, undefined, -1, 'friend'); });
        var result = {};
        try {
            for (var balls_14 = __values(balls), balls_14_1 = balls_14.next(); !balls_14_1.done; balls_14_1 = balls_14.next()) {
                var ball = balls_14_1.value;
                var name_7 = ball.constructor.name;
                var prototype = O.deepClone(Object.getPrototypeOf(ball));
                for (var key in prototype) {
                    if (_.isFunction(prototype[key])) {
                        prototype[key] = prototype[key].toString();
                    }
                }
                result[name_7] = prototype;
            }
        }
        catch (e_114_1) { e_114 = { error: e_114_1 }; }
        finally {
            try {
                if (balls_14_1 && !balls_14_1.done && (_a = balls_14.return)) _a.call(balls_14);
            }
            finally { if (e_114) throw e_114.error; }
        }
        return result;
    }
    function load() {
        Rumper.CACHE.balls = getAllBallProperties();
    }
    Rumper.load = load;
    function check() {
    }
    Rumper.check = check;
})(Rumper || (Rumper = {}));
// COMMON
function loadAllData() {
    var data = LocalStorage.getJson(global.gameCodeName + "_data");
    if (!data)
        return {};
    return data;
}
function loadDataString(key, defaultValue) {
    var data = loadAllData();
    var value = data[key];
    if (value === undefined)
        return defaultValue;
    if (!_.isString(value)) {
        console.error("Error: data with key \"" + key + "\" expected to be a string, but is: " + value);
        return defaultValue;
    }
    return value;
}
function loadDataNumber(key, defaultValue) {
    var data = loadAllData();
    var value = data[key];
    if (value === undefined)
        return defaultValue;
    if (!_.isNumber(value)) {
        console.error("Error: data with key \"" + key + "\" expected to be a number, but is: " + value);
        return defaultValue;
    }
    return value;
}
function loadDataBoolean(key, defaultValue) {
    var data = loadAllData();
    var value = data[key];
    if (value === undefined)
        return defaultValue;
    if (!_.isBoolean(value)) {
        console.error("Error: data with key \"" + key + "\" expected to be a boolean, but is: " + value);
        return defaultValue;
    }
    return value;
}
function loadDataObject(key, defaultValue) {
    var data = loadAllData();
    var value = data[key];
    if (!value)
        return defaultValue;
    if (!_.isObject(value)) {
        console.error("Error: data with key \"" + key + "\" expected to be an object, but is: " + value);
        return defaultValue;
    }
    return value;
}
function saveAllData(data) {
    LocalStorage.setJson(global.gameCodeName + "_data", data);
}
function saveData(key, value) {
    var data = loadAllData();
    data[key] = value;
    saveAllData(data);
}
function mergeAutoBallsDataAndSave(data) {
    var currentData = loadAllData();
    mergeAutoBallsDatas(data, currentData);
    saveAllData(currentData);
}
function mergeAutoBallsDatas(data, into) {
    var _a, _b;
    into.name = (_a = data.name) !== null && _a !== void 0 ? _a : into.name;
    into.playerId = (_b = data.playerId) !== null && _b !== void 0 ? _b : into.playerId;
    into.vsSettings = data.vsSettings;
    into.sheens = data.sheens;
    into.noBalls = into.noBalls || data.noBalls;
    into.seenAlmanacComplete = into.seenAlmanacComplete || data.seenAlmanacComplete;
    into.classicWins = Math.max(into.classicWins || 0, data.classicWins || 0);
    into.communityWins = Math.max(into.communityWins || 0, data.communityWins || 0);
    into.lastDailyCompleted = Math.max(into.lastDailyCompleted || 0, data.lastDailyCompleted || 0);
    into.matchmakingGameData = data.matchmakingGameData;
    into.challengeModeGameData = data.challengeModeGameData;
    into.versusModeGameData = data.versusModeGameData;
    into.dailyGameData = data.dailyGameData;
}
// CLOUD SAVE
function getSaveInfo() {
    return LocalStorage.getJson(global.gameCodeName + "_saveinfo");
}
function setSaveInfo(save) {
    LocalStorage.setJson(global.gameCodeName + "_saveinfo", save);
}
function createSaveInfo(saveId, saveTime) {
    var saveInfo = {
        saveId: saveId,
        saveTime: saveTime,
    };
    setSaveInfo(saveInfo);
}
function setSaveTime(saveTime) {
    var saveInfo = getSaveInfo();
    if (!saveInfo) {
        console.error('Trying to set saveTime when save does not exist');
        return;
    }
    saveInfo.saveTime = saveTime;
    setSaveInfo(saveInfo);
}
function deleteSaveInfo() {
    LocalStorage.delete(global.gameCodeName + "_saveinfo");
}
function getLocalCloudSaveData() {
    return {
        data: loadAllData(),
        ach: ACHIEVEMENTS_PROGRESS,
        almanac: ALMANAC_ENTRIES,
    };
}
function mergeCloudSaveDataEncodedToLocal(saveDataEnc) {
    var saveData = decodeCloudSaveData(saveDataEnc);
    if (!saveData)
        return;
    mergeAutoBallsDataAndSave(saveData.data);
    mergeAchievementsProgressAndSave(saveData.ach);
    if (saveData.almanac) {
        mergeAlmanacEntriesAndSave(saveData.almanac);
    }
}
function mergeLocalToCloudSaveDataEncoded(saveDataEnc) {
    var localData = getLocalCloudSaveData();
    var cloudSaveData = decodeCloudSaveData(saveDataEnc);
    if (cloudSaveData.data) {
        mergeAutoBallsDatas(localData.data, cloudSaveData.data);
    }
    else {
        cloudSaveData.data = localData.data;
    }
    if (cloudSaveData.ach) {
        mergeAchievementsProgresses(localData.ach, cloudSaveData.ach);
    }
    else {
        cloudSaveData.ach = localData.ach;
    }
    if (cloudSaveData.almanac) {
        mergeAlmanacEntrieses(localData.almanac, cloudSaveData.almanac);
    }
    else {
        cloudSaveData.almanac = localData.almanac;
    }
    return encodeCloudSaveData(cloudSaveData);
}
function encodeCloudSaveData(saveData) {
    return St.encodeB64S(JSON.stringify(saveData));
}
function decodeCloudSaveData(saveDataEnc) {
    var saveData = JSON.parse(St.decodeB64S(saveDataEnc));
    if (!saveData || !saveData.data || !saveData.ach)
        return undefined;
    return saveData;
}
// NAME
function saveName(name) {
    saveData('name', name);
}
function loadName() {
    return loadDataString('name', undefined);
}
// PLAYER ID
function loadPlayerId() {
    var playerId = loadDataString('playerId', undefined);
    if (!playerId) {
        playerId = new UIDGenerator().generate();
        saveData('playerId', playerId);
    }
    return playerId;
}
// VS SETTINGS
function saveVsSettings(vsSettings) {
    saveData('vsSettings', vsSettings);
}
function loadVsSettings() {
    var defaults = VSModeSettings.GET_DEFAULT_SETTINGS();
    var settings = loadDataObject('vsSettings', defaults);
    _.defaults(settings, defaults);
    if (settings && settings.arena === Arenas.ARENA_BDAY && !LiveVersion.BDAY_VS) {
        settings.arena = defaults.arena;
    }
    return settings;
}
// SHEENS
function saveSheens(sheens) {
    saveData('sheens', sheens);
}
function loadSheens() {
    var sheens = loadDataObject('sheens', {});
    if (!Object.keys(sheens).every(function (k) { return _.isString(sheens[k]) && sheens[k].split('.').length === 3; })) {
        sheens = {};
    }
    _.defaults(sheens, DEFAULT_SHEENS);
    return sheens;
}
// NO BALLS
function saveNoBalls(noBalls) {
    saveData('noBalls', noBalls);
}
function loadNoBalls() {
    return loadDataBoolean('noBalls', false);
}
// ALMANAC COMPLETE
function saveSeenAlmanacComplete(almanacComplete) {
    saveData('seenAlmanacComplete', almanacComplete);
}
function loadSeenAlmanacComplete() {
    return loadDataBoolean('seenAlmanacComplete', false);
}
// PACK WINS
function saveWins(pack, wins) {
    var key = pack === 'community' ? 'communityWins' : (pack === 'weekly' ? 'weeklyWins' : 'classicWins');
    saveData(key, wins);
}
function loadWins(pack) {
    var key = pack === 'community' ? 'communityWins' : (pack === 'weekly' ? 'weeklyWins' : 'classicWins');
    var wins = loadDataNumber(key, undefined);
    if (wins === undefined) {
        if (pack === 'classic') {
            var existingWins = ACHIEVEMENTS_PROGRESS.WinGame;
            wins = existingWins;
            saveWins(pack, wins);
        }
        else {
            wins = 0;
        }
    }
    return wins;
}
// LAST DAILY COMPLETED
function saveLastDailyCompleted(day) {
    saveData('lastDailyCompleted', day);
}
function loadLastDailyCompleted() {
    return loadDataNumber('lastDailyCompleted', -99);
}
var SaveValidator;
(function (SaveValidator) {
    var lastCloudLockSessionId;
    function storeLastCloudLockSessionId() {
        debug('getting last lockSessionId...');
        lastCloudLockSessionId = undefined;
        var saveInfo = getSaveInfo();
        if (!saveInfo) {
            debug('No cloud save active, fetching from local');
            var data = loadAllData();
            if (!data) {
                debug('No local lock found');
                return;
            }
            lastCloudLockSessionId = getLockSessionIdFromData(data);
            debug('Set lastCloudLockSessionId:', lastCloudLockSessionId);
            return;
        }
        "modded_remove_from";
        API.getsave(function (getSaveResponse, err) {
            if (err) {
                console.error('Error loading save from cloud:', err);
                return;
            }
            debug('Got save from cloud for lastCloudLockSessionId:', getSaveResponse);
            var saveData = decodeCloudSaveData(getSaveResponse.saveData);
            if (!saveData)
                return;
            lastCloudLockSessionId = getLockSessionIdFromData(saveData.data);
            debug('Set lastCloudLockSessionId:', lastCloudLockSessionId);
        }, saveInfo.saveId, Persistence.getProfileId());
        "modded_remove_to";
    }
    SaveValidator.storeLastCloudLockSessionId = storeLastCloudLockSessionId;
    function validateAsync() {
        debug('validating...');
        var saveInfo = getSaveInfo();
        if (!saveInfo) {
            var data = loadAllData();
            if (!data)
                return;
            var valid = isDataValid(data);
            enforceValidation(valid);
            return;
        }
        "modded_remove_from";
        API.getsave(function (getSaveResponse, err) {
            if (err) {
                console.error('Error loading save from cloud:', err);
                return;
            }
            debug('Got save from cloud for validation:', getSaveResponse);
            var saveData = decodeCloudSaveData(getSaveResponse.saveData);
            if (!saveData)
                return;
            var valid = isDataValid(saveData.data);
            enforceValidation(valid);
        }, saveInfo.saveId, Persistence.getProfileId());
        "modded_remove_to";
    }
    SaveValidator.validateAsync = validateAsync;
    function isDataValid(data) {
        var fetchedLockSessionId = getLockSessionIdFromData(data);
        if (!fetchedLockSessionId)
            return true;
        if (fetchedLockSessionId === lockSessionId) {
            lastCloudLockSessionId = lockSessionId;
        }
        if (fetchedLockSessionId !== lockSessionId) {
            if (fetchedLockSessionId === lastCloudLockSessionId) {
                debug('fetched data matches lastCloudLockSessionId:', fetchedLockSessionId);
            }
            else {
                debug('fetched data lockSessionId is from another session', fetchedLockSessionId);
                return false;
            }
        }
        return true;
    }
    function enforceValidation(valid) {
        if (valid) {
            debug('data is valid');
            return;
        }
        debug('data is invalid!');
        global.theater.runScript(function () {
            var syncing;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        syncing = global.theater.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: global.gameHeight / 2,
                            text: '\\ Syncing...',
                            anchor: Vector2.CENTER,
                            alpha: 0,
                        }));
                        return [4 /*yield*/, [
                                S.fadeOut(1),
                                S.tween(1, syncing, 'alpha', 0, 1),
                            ]];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1)];
                    case 2:
                        _a.sent();
                        CloudSave.load();
                        return [4 /*yield*/, [
                                S.tween(0.5, syncing, 'alpha', 1, 0),
                            ]];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.wait(0.5)];
                    case 4:
                        _a.sent();
                        global.game.loadMainMenu();
                        return [2 /*return*/];
                }
            });
        });
    }
    function getLockSessionIdFromData(data) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (DAILY) {
            return (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.dailyGameData) === null || _a === void 0 ? void 0 : _a.matchmakingGameData) === null || _b === void 0 ? void 0 : _b.lock) === null || _c === void 0 ? void 0 : _c.lockSessionId;
        }
        if (CHALLENGE_MODE_ENABLED) {
            return (_e = (_d = data === null || data === void 0 ? void 0 : data.challengeModeGameData) === null || _d === void 0 ? void 0 : _d.lock) === null || _e === void 0 ? void 0 : _e.lockSessionId;
        }
        return (_g = (_f = data === null || data === void 0 ? void 0 : data.matchmakingGameData) === null || _f === void 0 ? void 0 : _f.lock) === null || _g === void 0 ? void 0 : _g.lockSessionId;
    }
    var Obj = /** @class */ (function (_super) {
        __extends(Obj, _super);
        function Obj() {
            var _this = _super.call(this, {
                useGlobalTime: true,
            }) || this;
            _this.runScript(function () {
                var interval;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(20)];
                        case 1:
                            _a.sent();
                            SaveValidator.validateAsync();
                            interval = getSaveInfo() ? 20 : 5;
                            _a.label = 2;
                        case 2:
                            if (!true) return [3 /*break*/, 4];
                            return [4 /*yield*/, S.wait(interval)];
                        case 3:
                            _a.sent();
                            SaveValidator.validateAsync();
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        return Obj;
    }(WorldObject));
    SaveValidator.Obj = Obj;
})(SaveValidator || (SaveValidator = {}));
var ScrollBar = /** @class */ (function (_super) {
    __extends(ScrollBar, _super);
    function ScrollBar(x, y, texture, totalHeight, pixelsPerScroll, scrollTo) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: texture,
        }) || this;
        _this.clicked = false;
        _this.grabbing = false;
        _this.grabDy = 0;
        _this.slideSpeed = 256;
        _this.bounds = new RectBounds(-2, -2, 8, _this.getTexture().height, _this);
        _this.handle = _this.addChild(new Sprite({
            x: 1, y: 1,
            texture: 'scrollbarhandle',
            copyFromParent: ['layer'],
            bounds: new RectBounds(-3, 0, 8, 16),
        }));
        _this.scrollTo = scrollTo;
        _this.targetScrollY = _this.handle.localy;
        _this.totalHeight = totalHeight;
        _this.pixelsPerScroll = pixelsPerScroll;
        return _this;
    }
    Object.defineProperty(ScrollBar.prototype, "isScrolling", {
        get: function () { return this.grabbing; },
        enumerable: false,
        configurable: true
    });
    ScrollBar.prototype.update = function () {
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        var hovered = this.bounds.isOverlapping(mouseBounds);
        if (hovered && Input.justDown('click')) {
            this.clicked = true;
        }
        if (Input.isUp('click')) {
            this.clicked = false;
            this.grabbing = false;
        }
        if (this.clicked) {
            if (this.grabbing) {
                this.handle.localy = (mouseBounds.y - this.y) + this.grabDy;
                this.targetScrollY = this.handle.localy;
            }
            else if (this.handle.bounds.isOverlapping(mouseBounds)) {
                this.grabDy = this.handle.localy - (mouseBounds.y - this.y);
                this.grabbing = true;
                this.targetScrollY = this.handle.localy;
            }
            else {
                this.targetScrollY = mouseBounds.y - this.y;
            }
        }
        else {
            this.targetScrollY = this.targetScrollY + M.map(this.pixelsPerScroll, 0, this.totalHeight, 0, this.getTexture().height - 18) * Input.mouseScrollDelta;
        }
        this.targetScrollY = M.clamp(this.targetScrollY, 1, this.getTexture().height - 17);
        if (this.handle.localy < this.targetScrollY) {
            this.handle.localy = Math.min(this.handle.localy + this.slideSpeed * this.delta, this.targetScrollY);
        }
        else if (this.handle.localy > this.targetScrollY) {
            this.handle.localy = Math.max(this.handle.localy - this.slideSpeed * this.delta, this.targetScrollY);
        }
        this.handle.localy = M.clamp(this.handle.localy, 1, this.getTexture().height - 17);
        this.scrollTo(this.getScrollPercent());
        if (this.clicked) {
            this.handle.tint = 0xBBBB00;
        }
        else if (hovered) {
            this.handle.tint = 0xFFFF00;
        }
        else {
            this.handle.tint = 0xFFFFFF;
        }
    };
    ScrollBar.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectAfter(this.handle, this);
    };
    ScrollBar.prototype.getScrollPercent = function () {
        return this.worldYToPercent(this.handle.localy);
    };
    ScrollBar.prototype.setScrollPercent = function (p) {
        this.handle.localy = this.targetScrollY = this.percentToWorldY(p);
        this.scrollTo(p);
    };
    ScrollBar.prototype.percentToWorldY = function (y) {
        return M.map(y, 0, 1, 1, this.getTexture().height - 17);
    };
    ScrollBar.prototype.worldYToPercent = function (y) {
        return M.map(y, 1, this.getTexture().height - 17, 0, 1);
    };
    return ScrollBar;
}(Sprite));
var ShareButton = /** @class */ (function (_super) {
    __extends(ShareButton, _super);
    function ShareButton(x, y, texture, shareScript) {
        var _this = _super.call(this, {
            name: "share_" + texture,
            x: x, y: y,
            useGlobalTime: true,
        }) || this;
        _this.alpha = 1;
        _this.shared = false;
        var sb = _this;
        _this.stateMachine.addState('share', {
            callback: function () {
                var _a;
                (_a = _this.image) === null || _a === void 0 ? void 0 : _a.kill();
                _this.image = _this.addChild(new Sprite({
                    texture: texture,
                    bounds: new RectBounds(-8, -8, 16, 16),
                    data: { on: true },
                    update: function () {
                        var on = this.bounds.containsPoint(this.world.getWorldMousePosition());
                        if (on && !this.data.on) {
                            sb.onHover(false);
                        }
                        this.data.on = on;
                    }
                }));
                _this.image.addModule(new Button({
                    hoverTint: 0xBBBBBB,
                    clickTint: 0x888888,
                    onClick: function () {
                        global.game.playSound('click');
                        _this.setState('load');
                    }
                }));
            },
        });
        _this.stateMachine.addState('load', {
            callback: function () {
                var _a;
                (_a = _this.image) === null || _a === void 0 ? void 0 : _a.kill();
                _this.image = _this.addChild(new Spinner(0, 0, 1.5, 4));
                _this.image.useGlobalTime = true;
            },
            script: shareScript,
            transitions: [{ toState: 'share' }],
        });
        _this.stateMachine.addState('error', {
            callback: function () {
                var _a;
                (_a = _this.image) === null || _a === void 0 ? void 0 : _a.kill();
                _this.image = undefined;
                _this.onHover(true);
            },
            transitions: [{ toState: 'share', delay: 3 }],
        });
        _this.setState('share');
        return _this;
    }
    ShareButton.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectBefore(this, this.parent);
        if (this.image) {
            this.image.alpha = this.alpha;
            World.Actions.orderWorldObjectBefore(this.image, this);
        }
    };
    ShareButton.prototype.onHover = function (errored) {
    };
    return ShareButton;
}(WorldObject));
var TwitterShareButton = /** @class */ (function (_super) {
    __extends(TwitterShareButton, _super);
    function TwitterShareButton(x, y, result) {
        var _this = _super.call(this, x, y, 'twitterlogosmall', function () {
            var fetchedUrl, fetchError, timeOut;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        Share.shareGetUrl(result, function (url, error) {
                            fetchedUrl = url;
                            fetchError = error;
                        });
                        timeOut = 5;
                        _a.label = 1;
                    case 1:
                        if (!(!fetchedUrl && !fetchError && timeOut > 0)) return [3 /*break*/, 3];
                        timeOut -= global.script.delta;
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        if (timeOut <= 0) {
                            fetchError = ERROR_TIMED_OUT;
                        }
                        if (fetchError) {
                            console.error('Error sharing:', fetchError);
                            sb.setState('error');
                            return [2 /*return*/];
                        }
                        debug('Shared squad at url:', fetchedUrl);
                        sb.shared = true;
                        Share.loadUrl(fetchedUrl, result);
                        return [2 /*return*/];
                }
            });
        }) || this;
        var sb = _this;
        return _this;
    }
    TwitterShareButton.prototype.onHover = function (errored) {
        var _a;
        _super.prototype.onHover.call(this, errored);
        var text = errored ? '[r]ERROR[/r]' : 'TWITTER';
        (_a = this.world.select.name('sharetext')) === null || _a === void 0 ? void 0 : _a.setText(text);
    };
    return TwitterShareButton;
}(ShareButton));
var ImageShareButton = /** @class */ (function (_super) {
    __extends(ImageShareButton, _super);
    function ImageShareButton(x, y) {
        var _this = _super.call(this, x, y, 'imagelogosmall', function () {
            var saveBlob, saveError, timeOut;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        Share.shareSaveToClipboard(function (blob, err) {
                            saveBlob = blob;
                            saveError = err;
                        });
                        timeOut = 5;
                        _a.label = 1;
                    case 1:
                        if (!(!saveBlob && !saveError && timeOut > 0)) return [3 /*break*/, 3];
                        timeOut -= global.script.delta;
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        if (timeOut <= 0) {
                            saveError = ERROR_TIMED_OUT;
                        }
                        if (saveError) {
                            console.error('Error opening image:', saveError);
                            sb.setState('error');
                            return [2 /*return*/];
                        }
                        debug('Opened squad image in new tab');
                        sb.shared = true;
                        window.open(URL.createObjectURL(saveBlob), '_blank');
                        return [2 /*return*/];
                }
            });
        }) || this;
        var sb = _this;
        return _this;
    }
    ImageShareButton.prototype.onHover = function (errored) {
        var _a;
        _super.prototype.onHover.call(this, errored);
        var text = errored ? '[r]ERROR[/r]' : 'SAVE IMAGE';
        (_a = this.world.select.name('sharetext')) === null || _a === void 0 ? void 0 : _a.setText(text);
    };
    return ImageShareButton;
}(ShareButton));
var Share;
(function (Share) {
    function shareGetUrl(result, callback) {
        prepare();
        var imageData = getSnapshot('half');
        unprepare();
        API.share(callback, GAME_DATA.squad.name, GAME_DATA.gameId, GAME_DATA.round, result, imageData);
    }
    Share.shareGetUrl = shareGetUrl;
    function loadUrl(url, result) {
        var message = encodeURIComponent(getMessage(result));
        var encodedUrl = encodeURIComponent(url);
        window.open("https://twitter.com/intent/tweet?text=" + message + "&url=" + encodedUrl + "&hashtags=AutoBalls");
    }
    Share.loadUrl = loadUrl;
    function shareSaveToClipboard(callback) {
        prepare();
        getSnapshotBlob(callback);
        unprepare();
    }
    Share.shareSaveToClipboard = shareSaveToClipboard;
    function shareGetOctetStream() {
        prepare();
        var snapshot = getSnapshot('full');
        unprepare();
        return snapshot.replace("image/png", "image/octet-stream");
    }
    Share.shareGetOctetStream = shareGetOctetStream;
    function prepare() {
        var e_115, _a;
        var _b, _c, _d, _e, _f;
        var yourTeamWorld = global.world.select.type(YourTeamWorld);
        if (yourTeamWorld) {
            var balls = yourTeamWorld.containedWorld.select.typeAll(Ball);
            try {
                for (var balls_15 = __values(balls), balls_15_1 = balls_15.next(); !balls_15_1.done; balls_15_1 = balls_15.next()) {
                    var ball = balls_15_1.value;
                    ball.setForShare();
                }
            }
            catch (e_115_1) { e_115 = { error: e_115_1 }; }
            finally {
                try {
                    if (balls_15_1 && !balls_15_1.done && (_a = balls_15.return)) _a.call(balls_15);
                }
                finally { if (e_115) throw e_115.error; }
            }
        }
        (_b = global.world.select.name('sharetext')) === null || _b === void 0 ? void 0 : _b.setVisible(false);
        (_c = global.world.select.name('continuebutton')) === null || _c === void 0 ? void 0 : _c.setVisible(false);
        (_d = global.world.select.name('victorylapbutton', false)) === null || _d === void 0 ? void 0 : _d.setVisible(false);
        (_e = global.world.select.type(TwitterShareButton)) === null || _e === void 0 ? void 0 : _e.setVisible(false);
        (_f = global.world.select.type(ImageShareButton, false)) === null || _f === void 0 ? void 0 : _f.setVisible(false);
        Main.forceRender();
    }
    function unprepare() {
        var _a, _b, _c, _d, _e;
        (_a = global.world.select.name('sharetext')) === null || _a === void 0 ? void 0 : _a.setVisible(true);
        (_b = global.world.select.name('continuebutton')) === null || _b === void 0 ? void 0 : _b.setVisible(true);
        (_c = global.world.select.name('victorylapbutton', false)) === null || _c === void 0 ? void 0 : _c.setVisible(true);
        (_d = global.world.select.type(TwitterShareButton)) === null || _d === void 0 ? void 0 : _d.setVisible(true);
        (_e = global.world.select.type(ImageShareButton, false)) === null || _e === void 0 ? void 0 : _e.setVisible(true);
    }
    function getSnapshot(type) {
        var canvas = type === 'full' ? getCanvasForSnapshotFull() : getCanvasForSnapshot();
        return canvas.toDataURL('image/png');
    }
    function getSnapshotBlob(callback) {
        getCanvasForSnapshotFull().toBlob(function (blob) {
            if (!blob) {
                callback(undefined, 'blank blob');
                return;
            }
            callback(blob, undefined);
        });
    }
    function getCanvasForSnapshot() {
        var hcanvas = document.createElement('canvas');
        hcanvas.width = 320 * Main.config.canvasScale;
        hcanvas.height = 167 * Main.config.canvasScale;
        var hctx = hcanvas.getContext('2d');
        hctx.drawImage(Main.renderer.view, 0 * Main.config.canvasScale, 25 * Main.config.canvasScale, 320 * Main.config.canvasScale, 167 * Main.config.canvasScale, 0 * Main.config.canvasScale, 0 * Main.config.canvasScale, 320 * Main.config.canvasScale, 167 * Main.config.canvasScale);
        return hcanvas;
    }
    function getCanvasForSnapshotFull() {
        var hcanvas = document.createElement('canvas');
        hcanvas.width = 320 * Main.config.canvasScale;
        hcanvas.height = 240 * Main.config.canvasScale;
        var hctx = hcanvas.getContext('2d');
        hctx.drawImage(Main.renderer.view, 0 * Main.config.canvasScale, 0 * Main.config.canvasScale, 320 * Main.config.canvasScale, 240 * Main.config.canvasScale, 0 * Main.config.canvasScale, 0 * Main.config.canvasScale, 320 * Main.config.canvasScale, 240 * Main.config.canvasScale);
        return hcanvas;
    }
    function getMessage(result) {
        var messages = [];
        if (result === 'win') {
            messages.push("Auto Balls VICTORY!");
            messages.push("This game is easy B)");
            if (GAME_DATA.health === 1)
                messages.push("One heart left, but I did it!");
        }
        else {
            messages.push("Didn't quite get to the end, but check out my squad!");
            messages.push("This game is hard!");
            if (GAME_DATA.wins === GET_MAX_WINS() - 2)
                messages.push("So close!");
            if (GAME_DATA.squad.balls.length === 0) {
                messages = ["Lost with zero balls B)"];
            }
        }
        return Random.element(messages);
    }
})(Share || (Share = {}));
var ShineFilter = /** @class */ (function (_super) {
    __extends(ShineFilter, _super);
    function ShineFilter(color) {
        return _super.call(this, {
            uniforms: { 'vec3 shineColor': M.colorToVec3(color) },
            code: "\n                float xyt = 0.5*x + y - 80.0*t;\n                float p = floor(0.341 * sin(0.03*xyt) + 0.66);\n                outp.rgb = p * shineColor + (1.0-p) * outp.rgb;\n            "
        }) || this;
    }
    return ShineFilter;
}(TextureFilter));
var Shop;
(function (Shop) {
    var SHOP_SPOT_POSITIONS = [
        vec2(196, 72), vec2(241, 72), vec2(286, 72),
        vec2(196, 117), vec2(241, 117), vec2(286, 117),
        vec2(196, 162), vec2(241, 162),
    ];
    function GET_DEBUG_GUARANTEED_THING(stockThings) {
        // return {
        //     type: 'ball',
        //     squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, undefined, stockThings, 144),
        //     frozen: false,
        //     useExistingStats: false,
        // };
        // return {
        //     type: 'item',
        //     itemType: 55,
        //     frozen: false,
        // };
        return undefined;
    }
    function stockInitial(world) {
        var _a = getShopBallItemCounts(world), shopBalls = _a.shopBalls, shopItems = _a.shopItems;
        var stockThings = [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined];
        // Add frozen things
        fillFrozenStockThings(stockThings);
        // Debug add guaranteed thing
        seedRandomFor('forceDebugGuaranteedThing');
        var forcedDebugSpot = M.min(availableBallSpots(stockThings, shopBalls), function (s) { return s; });
        var debugThing = GET_DEBUG_GUARANTEED_THING(stockThings);
        if ((Debug.DEBUG || IS_MODDED) && forcedDebugSpot >= 0 && isFinite(forcedDebugSpot) && debugThing) {
            stockThings[forcedDebugSpot] = debugThing;
        }
        // Force guaranteed balls, from Retro Glasses for example
        addGuaranteedBalls(world, stockThings, shopBalls);
        // Force a new ball if tier just unlocked
        seedRandomFor('forceTierUnlocked');
        var tierJustUnlocked = getTierJustUnlocked();
        var forcedBallSpot = Random.element(availableBallSpots(stockThings, shopBalls));
        var forcedBallType = Random.element(getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly)
            .filter(function (type) { return TYPE_TO_BALL_TYPE_DEF[type].tier === tierJustUnlocked; }));
        if (forcedBallSpot >= 0 && forcedBallType) {
            stockThings[forcedBallSpot] = {
                type: 'ball',
                squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings, forcedBallType),
                frozen: false,
                useExistingStats: false,
            };
        }
        if (GAME_DATA.round === 1 && LiveVersion.BDAY && GAME_MODE === 'mm' && !DAILY) {
            seedRandomFor('forceBirthdayCake');
            stockThings[7] = {
                type: 'item',
                itemType: 38,
                frozen: false,
            };
        }
        // Force Glitched Item if applicable
        if (GAME_DATA.round >= 5 && !DAILY && !IS_MOBILE && GAME_DATA.squad.balls.some(function (ball) { return ball.properties.type === 41; })) {
            seedRandomFor('forceGlitchedItem');
            var forcedGlitchedItemSpot = Random.element(availableItemSpots(stockThings, shopItems));
            if (!forcedGlitchedItemSpot) {
                forcedGlitchedItemSpot = 7;
                GAME_DATA.frozenThings[forcedGlitchedItemSpot] = undefined;
            }
            stockThings[forcedGlitchedItemSpot] = {
                type: 'item',
                itemType: 25,
                frozen: false,
            };
        }
        // Force Scribbled Map if applicable
        if (hasCompletedAchievement('ArgPart1') && !hasCompletedAchievement('B') && GAME_MODE === 'mm' && GAME_DATA.lap === 1 && !DAILY && !IS_MOBILE && !GAME_DATA.arg2Trigger.strategy && Random.boolean(1 / API.B)) {
            seedRandomFor('forceScribbledMap');
            var forcedScribbledMapSpot = Random.element(availableItemSpots(stockThings, shopItems));
            if (!forcedScribbledMapSpot) {
                forcedScribbledMapSpot = 7;
                GAME_DATA.frozenThings[forcedScribbledMapSpot] = undefined;
            }
            stockThings[forcedScribbledMapSpot] = {
                type: 'item',
                itemType: 32,
                frozen: false,
            };
        }
        // Force Participation Trophy if applicable
        if (getLastRoundResult() === 'loss' && getTierLevelAvailableForRound(2, GAME_DATA.round) <= 0 && (isItemTypeUnlocked(37) || GAME_MODE === 'vs')) {
            seedRandomFor('forceParticipationTrophy');
            var forcedParticipationTrophySpot = 7;
            if (forcedParticipationTrophySpot) {
                stockThings[forcedParticipationTrophySpot] = {
                    type: 'item',
                    itemType: 37,
                    frozen: false,
                };
            }
        }
        // Force Consolation Prize if applicable
        if (getLastRoundResult() === 'loss' && getTierLevelAvailableForRound(2, GAME_DATA.round) > 0 && (isItemTypeUnlocked(14) || GAME_MODE === 'vs')) {
            seedRandomFor('forceConsolationPrize');
            var forcedConsolationPrizeSpot = Random.element(availableItemSpots(stockThings, shopItems));
            if (forcedConsolationPrizeSpot) {
                stockThings[forcedConsolationPrizeSpot] = {
                    type: 'item',
                    itemType: 14,
                    frozen: false,
                };
            }
        }
        if (getShopTierForRound(GAME_DATA.round) === 4) {
            addTierThreePlusBall(stockThings, shopBalls);
        }
        if (isModifierActive('pickles')) {
            addModifierPickles(stockThings, shopBalls, shopItems);
        }
        if (world.data.arenaName === Arenas.ARENA_BDAY) {
            addPinata(stockThings, shopBalls);
            addGift(stockThings, shopItems);
        }
        fillRandomStockThings(stockThings, shopBalls, shopItems);
        if (isModifierActive('sameballsstocked')) {
            convertToUniformStock(stockThings);
        }
        addStockThings(world, stockThings, false);
    }
    Shop.stockInitial = stockInitial;
    function restockNormal(world) {
        destroyCurrentShopThings(world);
        GAME_DATA.restocksThisRound++;
        stockRestock(world, false);
        saveAfterRestock(world);
    }
    Shop.restockNormal = restockNormal;
    function restockPickles(world) {
        for (var i = 0; i < GAME_DATA.frozenThings.length; i++) {
            if (GAME_DATA.frozenThings[i]) {
                unfreezeThingAtSpot(world, i);
            }
        }
        GAME_DATA.frozenThings.fill(undefined);
        destroyCurrentShopThings(world);
        stockPickles(world);
    }
    Shop.restockPickles = restockPickles;
    function stockRestock(world, initial) {
        var e_116, _a;
        var _b = getShopBallItemCounts(world), shopBalls = _b.shopBalls, shopItems = _b.shopItems;
        Random.seed("shop_" + getRandomSeed(GAME_DATA.gameId, DAILY) + "_" + GAME_DATA.round + "_" + GAME_DATA.restocksThisRound);
        var stockThings = [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined];
        // Add frozen things
        fillFrozenStockThings(stockThings);
        // Debug add guaranteed thing
        seedRandomFor('forceDebugGuaranteedThing');
        var forcedDebugSpot = M.min(availableBallSpots(stockThings, shopBalls), function (s) { return s; });
        var debugThing = GET_DEBUG_GUARANTEED_THING(stockThings);
        if ((Debug.DEBUG || IS_MODDED) && forcedDebugSpot >= 0 && isFinite(forcedDebugSpot) && debugThing) {
            stockThings[forcedDebugSpot] = debugThing;
        }
        // Force restock queue balls
        if (!initial) {
            try {
                for (var _c = __values(GAME_DATA.restockQueue), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var rq = _d.value;
                    rq.restocksLeft--;
                }
            }
            catch (e_116_1) { e_116 = { error: e_116_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_116) throw e_116.error; }
            }
            addRestockQueueBalls(stockThings, shopBalls);
        }
        // Force guaranteed balls, from Retro Glasses for example
        addGuaranteedBalls(world, stockThings, shopBalls);
        // Force Glitched Ball if applicable
        if (GAME_DATA.argTrigger.zombie && GAME_DATA.argTrigger.restocks === 5 && !IS_MOBILE) {
            var forcedGlitchedBallSpot = Random.element(availableBallSpots(stockThings, shopBalls));
            if (!forcedGlitchedBallSpot) {
                forcedGlitchedBallSpot = 0;
                unfreezeThingAtSpot(world, forcedGlitchedBallSpot);
                GAME_DATA.frozenThings[forcedGlitchedBallSpot] = undefined;
                killThingAtSpot(world, forcedGlitchedBallSpot);
            }
            stockThings[forcedGlitchedBallSpot] = {
                type: 'ball',
                squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings, 41),
                frozen: false,
                useExistingStats: false,
            };
        }
        if (getShopTierForRound(GAME_DATA.round) === 4) {
            addTierThreePlusBall(stockThings, shopBalls);
        }
        if (isModifierActive('pickles')) {
            addModifierPickles(stockThings, shopBalls, shopItems);
        }
        if (world.data.arenaName === Arenas.ARENA_BDAY) {
            addPinata(stockThings, shopBalls);
            addGift(stockThings, shopItems);
        }
        fillRandomStockThings(stockThings, shopBalls, shopItems);
        // Remove frozen things as we are not restocking them
        if (!initial)
            removeFrozenStockThings(stockThings);
        if (isModifierActive('sameballsstocked')) {
            convertToUniformStock(stockThings);
        }
        addStockThings(world, stockThings, !initial);
    }
    Shop.stockRestock = stockRestock;
    function stockPickles(world) {
        Random.seed("shop_" + getRandomSeed(GAME_DATA.gameId, DAILY) + "_" + GAME_DATA.round + "_" + GAME_DATA.restocksThisRound);
        var stockThings = [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined];
        fillPickleStockThings(stockThings);
        addStockThings(world, stockThings, true);
    }
    function ballSpotsForCount(count) {
        return [0, 1, 2, 3, 4, 5, 7, 6].slice(0, count);
    }
    function itemSpotsForCount(count) {
        return [6, 7, 5, 4, 3, 2, 1, 0].slice(0, count);
    }
    function availableBallSpots(stockThings, shopBalls) {
        return ballSpotsForCount(shopBalls).filter(function (i) { return !stockThings[i]; });
    }
    function availableItemSpots(stockThings, shopItems) {
        return itemSpotsForCount(shopItems).filter(function (i) { return !stockThings[i]; });
    }
    function fillFrozenStockThings(stockThings) {
        for (var i = 0; i < GAME_DATA.frozenThings.length; i++) {
            var frozenThing = GAME_DATA.frozenThings[i];
            if (!frozenThing)
                continue;
            if (frozenThing.type === 'ball') {
                stockThings[i] = {
                    type: 'ball',
                    squadBall: frozenThing.squadBall,
                    frozen: true,
                    useExistingStats: false,
                };
            }
            else if (frozenThing.type === 'item') {
                stockThings[i] = {
                    type: 'item',
                    itemType: frozenThing.itemType,
                    frozen: true,
                };
            }
        }
    }
    function addTierThreePlusBall(stockThings, shopBalls) {
        seedRandomFor('forceTierThreePlusBall');
        if (!Random.boolean(0.5))
            return;
        var spot = Random.element(availableBallSpots(stockThings, shopBalls));
        var ballType = Random.element(getPurchasableBallTypesForRoundTier(GAME_DATA.round, 4, GAME_DATA.packs, GAME_DATA.weekly));
        if (spot >= 0 && ballType) {
            stockThings[spot] = {
                type: 'ball',
                squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings, ballType),
                frozen: false,
                useExistingStats: false,
            };
        }
    }
    function addRestockQueueBalls(stockThings, shopBalls) {
        var e_117, _a;
        seedRandomFor('forceRestockQueueBalls');
        var restocked = [];
        try {
            for (var _b = __values(GAME_DATA.restockQueue), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rq = _c.value;
                if (rq.restocksLeft > 0)
                    continue;
                var spot = Random.element(availableBallSpots(stockThings, shopBalls));
                if (spot >= 0) {
                    stockThings[spot] = {
                        type: 'ball',
                        squadBall: {
                            x: 0, y: 0,
                            properties: rq.ball,
                        },
                        frozen: false,
                        useExistingStats: true,
                    };
                    restocked.push(rq);
                }
            }
        }
        catch (e_117_1) { e_117 = { error: e_117_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_117) throw e_117.error; }
        }
        GAME_DATA.restockQueue = GAME_DATA.restockQueue.filter(function (rq) { return !_.includes(restocked, rq); });
    }
    function addGuaranteedBalls(world, stockThings, shopBalls) {
        var e_118, _a, e_119, _b;
        var validBalls = getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly);
        var guaranteedBalls = world.select.typeAll(Ball)
            .filter(function (ball) { var _a; return ball.team === 'friend' && _.includes(validBalls, ball.properties.type) && !ball.isInShop && ((_a = ball.equipment) === null || _a === void 0 ? void 0 : _a.stockEquippedBall) && !ball.isNullified(); })
            .map(function (ball) { return ball.properties.type; });
        A.removeDuplicates(guaranteedBalls);
        guaranteedBalls = guaranteedBalls.filter(function (ballType) { return Random.boolean(getBallShopGuaranteedChanceForType(ballType)); });
        var currentBallTypes = stockThings.map(function (st) { return (st && st.type === 'ball') ? st.squadBall.properties.type : undefined; }).filter(function (t) { return t !== undefined; });
        try {
            for (var currentBallTypes_1 = __values(currentBallTypes), currentBallTypes_1_1 = currentBallTypes_1.next(); !currentBallTypes_1_1.done; currentBallTypes_1_1 = currentBallTypes_1.next()) {
                var currentBallType = currentBallTypes_1_1.value;
                var i = guaranteedBalls.indexOf(currentBallType);
                if (i >= 0) {
                    guaranteedBalls.splice(i, 1);
                }
            }
        }
        catch (e_118_1) { e_118 = { error: e_118_1 }; }
        finally {
            try {
                if (currentBallTypes_1_1 && !currentBallTypes_1_1.done && (_a = currentBallTypes_1.return)) _a.call(currentBallTypes_1);
            }
            finally { if (e_118) throw e_118.error; }
        }
        seedRandomFor('forceGuaranteedBalls');
        try {
            for (var guaranteedBalls_1 = __values(guaranteedBalls), guaranteedBalls_1_1 = guaranteedBalls_1.next(); !guaranteedBalls_1_1.done; guaranteedBalls_1_1 = guaranteedBalls_1.next()) {
                var ballType = guaranteedBalls_1_1.value;
                var forcedSpot = Random.element(availableBallSpots(stockThings, shopBalls));
                if (forcedSpot >= 0) {
                    stockThings[forcedSpot] = {
                        type: 'ball',
                        squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings, ballType),
                        frozen: false,
                        useExistingStats: false,
                    };
                }
            }
        }
        catch (e_119_1) { e_119 = { error: e_119_1 }; }
        finally {
            try {
                if (guaranteedBalls_1_1 && !guaranteedBalls_1_1.done && (_b = guaranteedBalls_1.return)) _b.call(guaranteedBalls_1);
            }
            finally { if (e_119) throw e_119.error; }
        }
    }
    function addPinata(stockThings, shopBalls) {
        seedRandomFor('forcePinata');
        var spot = Random.element(availableBallSpots(stockThings, shopBalls));
        if (spot >= 0 && Random.boolean(0.33)) {
            stockThings[spot] = {
                type: 'ball',
                squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings, 77),
                frozen: false,
                useExistingStats: false,
            };
        }
    }
    function addGift(stockThings, shopItems) {
        seedRandomFor('forceGift');
        var spot = Random.element(availableItemSpots(stockThings, shopItems));
        if (spot >= 0 && Random.boolean(0.1)) {
            stockThings[spot] = {
                type: 'item',
                itemType: 39,
                frozen: false,
            };
        }
    }
    function addModifierPickles(stockThings, shopBalls, shopItems) {
        var e_120, _a;
        var _b;
        var availableSpots = __spread(availableBallSpots(stockThings, shopBalls), availableItemSpots(stockThings, shopItems));
        try {
            for (var availableSpots_1 = __values(availableSpots), availableSpots_1_1 = availableSpots_1.next(); !availableSpots_1_1.done; availableSpots_1_1 = availableSpots_1.next()) {
                var spot = availableSpots_1_1.value;
                seedRandomFor("modifierPickles_spot_" + spot);
                if (!((_b = stockThings[spot]) === null || _b === void 0 ? void 0 : _b.frozen) && Random.boolean(0.1)) {
                    stockThings[spot] = {
                        type: 'item',
                        itemType: Random.element([12, 13]),
                        frozen: false,
                    };
                }
            }
        }
        catch (e_120_1) { e_120 = { error: e_120_1 }; }
        finally {
            try {
                if (availableSpots_1_1 && !availableSpots_1_1.done && (_a = availableSpots_1.return)) _a.call(availableSpots_1);
            }
            finally { if (e_120) throw e_120.error; }
        }
    }
    function convertToUniformStock(stockThings) {
        var e_121, _a;
        var validBalls = stockThings.filter(function (st) { return st && st.type === 'ball' && !st.frozen && !st.useExistingStats; });
        if (validBalls.length === 0)
            return;
        try {
            for (var validBalls_1 = __values(validBalls), validBalls_1_1 = validBalls_1.next(); !validBalls_1_1.done; validBalls_1_1 = validBalls_1.next()) {
                var ball = validBalls_1_1.value;
                ball.squadBall.properties.type = validBalls[0].squadBall.properties.type;
            }
        }
        catch (e_121_1) { e_121 = { error: e_121_1 }; }
        finally {
            try {
                if (validBalls_1_1 && !validBalls_1_1.done && (_a = validBalls_1.return)) _a.call(validBalls_1);
            }
            finally { if (e_121) throw e_121.error; }
        }
    }
    function fillRandomStockThings(stockThings, shopBalls, shopItems) {
        var e_122, _a, e_123, _b;
        try {
            // Stock rest as random balls
            for (var _c = __values(availableBallSpots(stockThings, shopBalls)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var spot = _d.value;
                seedRandomForBallSpot(spot);
                stockThings[spot] = {
                    type: 'ball',
                    squadBall: getShopSquadBall(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly, stockThings),
                    frozen: false,
                    useExistingStats: false,
                };
            }
        }
        catch (e_122_1) { e_122 = { error: e_122_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_122) throw e_122.error; }
        }
        try {
            // Stock rest as random items
            for (var _e = __values(availableItemSpots(stockThings, shopItems)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var spot = _f.value;
                seedRandomForItemSpot(spot);
                stockThings[spot] = {
                    type: 'item',
                    itemType: getShopBallItemType(GAME_DATA.round),
                    frozen: false,
                };
            }
        }
        catch (e_123_1) { e_123 = { error: e_123_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_123) throw e_123.error; }
        }
    }
    function fillPickleStockThings(stockThings) {
        var pickles = Math.min(GAME_DATA.round, 6);
        for (var i = 0; i < pickles; i++) {
            seedRandomForItemSpot(i);
            stockThings[i] = {
                type: 'item',
                itemType: Random.boolean() ? 12 : 13,
                frozen: false,
            };
        }
    }
    function removeFrozenStockThings(stockThings) {
        for (var i = 0; i < stockThings.length; i++) {
            if (stockThings[i] && stockThings[i].frozen) {
                stockThings[i] = undefined;
            }
        }
    }
    function addStockThings(world, stockThings, addPuffs) {
        var sidePanel = world.select.name('sidepanel');
        var _loop_11 = function (i) {
            var stockThing = stockThings[i];
            if (!stockThing)
                return "continue";
            if (isModifierActive('noitems') && stockThing.type === 'item') {
                return "continue";
            }
            var spotPosition = SHOP_SPOT_POSITIONS[i];
            var thing = stockThing.type === 'ball'
                ? getNewBallForShop(spotPosition.x, spotPosition.y, stockThing.squadBall, stockThing.frozen || stockThing.useExistingStats)
                : getNewItemForShop(spotPosition.x, spotPosition.y, stockThing.itemType);
            thing.shopSpot = i;
            if (stockThing.frozen || stockThing['useExistingStats']) {
                thing.freeze(true);
            }
            sidePanel.addChild(thing);
            var costText = "" + thing.getShopCost();
            if (thing.isGlitched())
                costText = '?';
            if (!thing.isPurchasable())
                costText = '-';
            var costColor = thing.getShopCost() <= 0 ? 'g' : 'gold';
            sidePanel.addChild(new SpriteText({
                x: spotPosition.x - 19, y: spotPosition.y - 19,
                text: "[" + costColor + "]<coin>" + costText + "[/]",
                font: 'smallnumbers',
                layer: Battle.Layers.ui,
                update: function () {
                    if (!thing.world)
                        this.kill();
                    if (thing instanceof Ball && !thing.isInShop)
                        this.kill();
                }
            }));
            if (addPuffs) {
                world.addWorldObject(newPuff(thing.x, thing.y, Battle.Layers.ui, 'medium'));
            }
            if (thing instanceof Ball && thing.properties.metadata.mutated) {
                var ball_1 = thing;
                world.runScript(function () {
                    var ps, _loop_12, ps_2, ps_2_1, p, e_124_1;
                    var e_124, _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                ps = [
                                    Vector2.fromPolar(ball_1.physicalRadius * 0.7, 0).add(ball_1),
                                    Vector2.fromPolar(ball_1.physicalRadius * 0.7, -120).add(ball_1),
                                    Vector2.fromPolar(ball_1.physicalRadius * 0.7, 120).add(ball_1),
                                    Vector2.fromPolar(ball_1.physicalRadius * 0.7, 60).add(ball_1),
                                    Vector2.fromPolar(ball_1.physicalRadius * 0.7, -60).add(ball_1),
                                ];
                                _loop_12 = function (p) {
                                    var puff;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                puff = world.addWorldObject(new Sprite({
                                                    p: p,
                                                    texture: new AnchoredTexture(Texture.filledCircle(ball_1.physicalRadius * 0.75, 0x00FF00, 0.5), 0.5, 0.5),
                                                    layer: Battle.Layers.ui,
                                                    blendMode: Texture.BlendModes.ADD,
                                                    scale: 0,
                                                }));
                                                puff.runScript(function () {
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0: return [4 /*yield*/, S.tween(0.1, puff, 'scale', 0, 1)];
                                                            case 1:
                                                                _a.sent();
                                                                return [4 /*yield*/, S.wait(0.2)];
                                                            case 2:
                                                                _a.sent();
                                                                return [4 /*yield*/, S.tween(0.3, puff, 'alpha', 1, 0)];
                                                            case 3:
                                                                _a.sent();
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                });
                                                return [4 /*yield*/, S.wait(0.1)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                };
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 6, 7, 8]);
                                ps_2 = __values(ps), ps_2_1 = ps_2.next();
                                _b.label = 2;
                            case 2:
                                if (!!ps_2_1.done) return [3 /*break*/, 5];
                                p = ps_2_1.value;
                                return [5 /*yield**/, _loop_12(p)];
                            case 3:
                                _b.sent();
                                _b.label = 4;
                            case 4:
                                ps_2_1 = ps_2.next();
                                return [3 /*break*/, 2];
                            case 5: return [3 /*break*/, 8];
                            case 6:
                                e_124_1 = _b.sent();
                                e_124 = { error: e_124_1 };
                                return [3 /*break*/, 8];
                            case 7:
                                try {
                                    if (ps_2_1 && !ps_2_1.done && (_a = ps_2.return)) _a.call(ps_2);
                                }
                                finally { if (e_124) throw e_124.error; }
                                return [7 /*endfinally*/];
                            case 8: return [2 /*return*/];
                        }
                    });
                });
            }
        };
        for (var i = 0; i < stockThings.length; i++) {
            _loop_11(i);
        }
    }
    function getNewBallForShop(x, y, squadBall, useExistingStats) {
        var ball = squadBallToWorldBall(squadBall, undefined, -1, 'friend');
        if (!useExistingStats) {
            ball.properties.damage = ball.getShopDmg();
            ball.dmg = ball.properties.damage;
            ball.properties.health = ball.getShopHp();
            ball.hp = ball.maxhp = ball.properties.health;
            var level = getBallTypeLevelForRound(ball.properties.type, GAME_DATA.round);
            for (var i = 1; i < level; i++) {
                ball.levelUp(undefined, false);
            }
            if (isTierCrown()) {
                var gaveMutation = applyTierCrownMutations(ball);
                if (gaveMutation)
                    ball.properties.metadata.mutated = true;
            }
            adjustBallForModifiers(ball);
        }
        if (isTierJustUnlocked(ball.tier)) {
            ball.giveShine();
        }
        ball.x = x + ball.getShopRelativePosition().x;
        ball.y = y + ball.getShopRelativePosition().y;
        ball.isInShop = true;
        ball.layer = Battle.Layers.ui;
        ball.colliding = false;
        ball.isSummon = false;
        ball.setForInShop();
        ball.showAllStats();
        return ball;
    }
    function getNewItemForShop(x, y, itemType) {
        var item = itemTypeToBallItem(itemType, x, y);
        item.layer = Battle.Layers.ui;
        if (isTierJustUnlocked(item.tier)) {
            item.giveShine();
        }
        return item;
    }
    function destroyCurrentShopThings(world) {
        var e_125, _a;
        var shopBalls = world.select.typeAll(Ball).filter(function (ball) { return ball.isInShop; });
        var shopItems = world.select.typeAll(BallItem);
        var shopThings = __spread(shopBalls, shopItems);
        try {
            for (var shopThings_1 = __values(shopThings), shopThings_1_1 = shopThings_1.next(); !shopThings_1_1.done; shopThings_1_1 = shopThings_1.next()) {
                var shopThing = shopThings_1_1.value;
                if (shopThing.frozen)
                    continue;
                world.addWorldObject(new Explosion(shopThing.x, shopThing.y, 10, { ally: 0, enemy: 0 })).layer = World.DEFAULT_LAYER;
                world.removeWorldObject(shopThing);
            }
        }
        catch (e_125_1) { e_125 = { error: e_125_1 }; }
        finally {
            try {
                if (shopThings_1_1 && !shopThings_1_1.done && (_a = shopThings_1.return)) _a.call(shopThings_1);
            }
            finally { if (e_125) throw e_125.error; }
        }
        world.playSound('sellball');
        world.playSound('balldie');
    }
    function getShopSquadBall(round, packs, weekly, stockThings, ballType) {
        if (ballType === undefined) {
            var purchasableBallTypes = getPurchasableBallTypesForRound(round, packs, weekly);
            if (GAME_DATA.hasPurchasedDove || hasDoveInShop(stockThings)) {
                A.removeAll(purchasableBallTypes, 127);
            }
            if (isModifierActive('onlyintier')) {
                var currentTier_1 = getShopTierForRound(round);
                A.filterInPlace(purchasableBallTypes, function (type) { return TYPE_TO_BALL_TYPE_DEF[type].tier === currentTier_1; });
            }
            var weights = purchasableBallTypes.map(function (type) { return getBallShopChanceForType(type); });
            ballType = Random.elementWeighted(purchasableBallTypes, weights);
        }
        var squadBall = {
            x: 0, y: 0,
            properties: {
                type: ballType,
                level: 1,
                damage: 1,
                health: 1,
                equipment: -1,
                metadata: {},
            }
        };
        return squadBall;
    }
    function getShopBallItemType(round) {
        var purchasableBallItemTypes = getPurchasableBallItemTypesForRound(round);
        var weights = purchasableBallItemTypes.map(function (type) { return getItemShopChanceForType(type); });
        var itemType = Random.elementWeighted(purchasableBallItemTypes, weights);
        return itemType;
    }
    function getShopBallItemCounts(world) {
        var stockExtraItems = getStockExtraItems(world);
        var shopBalls = 3;
        if (GAME_DATA.round >= 2)
            shopBalls = 4;
        if (GAME_DATA.round >= 4)
            shopBalls = 5;
        if (GAME_DATA.round >= 6)
            shopBalls = 6;
        var shopItems = 1;
        if (GAME_DATA.round >= 4)
            shopItems = 2;
        shopBalls = Math.max(shopBalls - stockExtraItems, 0);
        shopItems = Math.min(shopItems + stockExtraItems, 8);
        return { shopBalls: shopBalls, shopItems: shopItems };
    }
    function getStockExtraItems(world) {
        var stockExtraItems = A.sum(world.select.typeAll(Ball), function (ball) { return (ball.team === 'friend' && !ball.isInShop && ball.equipment && !ball.isNullified()) ? ball.equipment.stockExtraItems : 0; });
        stockExtraItems += getModifierStockItemsDiff();
        return stockExtraItems;
    }
    function getThingsAtSpot(world, spot) {
        var shopBalls = world.select.typeAll(Ball).filter(function (ball) { return ball.isInShop; });
        var shopItems = world.select.typeAll(BallItem);
        var shopThings = __spread(shopBalls, shopItems);
        return shopThings.filter(function (thing) { return thing.shopSpot === spot; });
    }
    function unfreezeThingAtSpot(world, spot) {
        getThingsAtSpot(world, spot).forEach(function (thing) {
            if (thing.frozen) {
                thing.unfreeze();
            }
        });
    }
    function killThingAtSpot(world, spot) {
        getThingsAtSpot(world, spot).forEach(function (thing) {
            thing.kill();
        });
    }
    function seedRandomFor(discriminator) {
        Random.seed("shop_" + getRandomSeed(GAME_DATA.gameId, DAILY) + "_" + GAME_DATA.round + "_" + GAME_DATA.restocksThisRound + "_" + discriminator);
    }
    function seedRandomForBallSpot(spot) {
        seedRandomFor("ballSpot" + spot);
    }
    function seedRandomForItemSpot(spot) {
        seedRandomFor("itemSpot" + spot);
    }
    function saveAfterRestock(world) {
        world.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/];
                    case 1:
                        _a.sent();
                        setBallPositions(world);
                        if (GAME_MODE === 'mm') {
                            saveMatchmakingOrChallengeModeOrDailyGameData({
                                gameData: GAME_DATA,
                                state: 'midshop',
                                lock: gameDataLock(),
                            }, CHALLENGE_MODE_ENABLED, DAILY);
                        }
                        else if (GAME_MODE === 'vs') {
                            saveVersusModeGameData({
                                gameData: GAME_DATA,
                                state: 'midshop',
                            });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    function hasDoveInShop(stockThings) {
        var e_126, _a;
        try {
            for (var stockThings_1 = __values(stockThings), stockThings_1_1 = stockThings_1.next(); !stockThings_1_1.done; stockThings_1_1 = stockThings_1.next()) {
                var thing = stockThings_1_1.value;
                if (thing && thing.type === 'ball' && thing.squadBall.properties.type === 127) {
                    return true;
                }
            }
        }
        catch (e_126_1) { e_126 = { error: e_126_1 }; }
        finally {
            try {
                if (stockThings_1_1 && !stockThings_1_1.done && (_a = stockThings_1.return)) _a.call(stockThings_1);
            }
            finally { if (e_126) throw e_126.error; }
        }
        return false;
    }
    Shop.NO_TIER_CROWN_LEVEL_MUTATION_BALLS = [
        10,
        37,
        38,
        39,
        47,
        116,
        134,
        135,
        139,
        142,
    ];
    Shop.REDUCED_TIER_CROWN_LEVEL_MUTATION_BALLS = [
        9,
        25,
        136,
    ];
    function applyTierCrownMutations(ball) {
        var receiveNoLevelMutations = _.contains(Shop.NO_TIER_CROWN_LEVEL_MUTATION_BALLS, ball.properties.type);
        var receiveReducedLevelMutations = _.contains(Shop.REDUCED_TIER_CROWN_LEVEL_MUTATION_BALLS, ball.properties.type);
        var totalMutationChance = 1 / 3;
        var roundsSinceR10 = GAME_DATA.round - 10;
        var victoryLapOneFactor = GAME_DATA.lap > 2 ? 1 : GAME_DATA.wins / GET_MAX_WINS();
        var gaveMutation = false;
        if (Random.boolean(totalMutationChance / 3)) {
            ball.hp += Math.floor(roundsSinceR10 / 4) * 2 + Math.ceil(randomIntRangeSkewed(2, 7) * victoryLapOneFactor);
            ball.maxhp = ball.hp;
            ball.properties.health = ball.maxhp;
            gaveMutation = true;
        }
        if (Random.boolean(totalMutationChance / 3)) {
            ball.dmg += Math.floor(roundsSinceR10 / 4) * 2 + Math.ceil(randomIntRangeSkewed(0, 4) * victoryLapOneFactor);
            ball.properties.damage = ball.dmg;
            gaveMutation = true;
        }
        if (Random.boolean(totalMutationChance / 3) && !receiveNoLevelMutations) {
            var extraLevels = Math.floor(roundsSinceR10 / 4) + Math.ceil(randomIntRangeSkewed(1, 6) * victoryLapOneFactor);
            if (receiveReducedLevelMutations) {
                extraLevels = Math.floor(extraLevels / 5);
            }
            ball.level += extraLevels;
            ball.properties.level = ball.level;
            gaveMutation = true;
        }
        if (gaveMutation) {
            ball.giveShine(Color.lerpColorByLch(0xFFD800, 0xFFFFFF, 0.5));
        }
        return gaveMutation;
    }
    function randomIntRangeSkewed(min, max) {
        var range = A.range(min, max + 1);
        var weights = range.map(function (_, i) { return Math.pow(2, -2 * i); });
        return Random.elementWeighted(range, weights);
    }
})(Shop || (Shop = {}));
var SpectateWaitingRoom;
(function (SpectateWaitingRoom) {
    function STAGE() {
        var _a, _b;
        var world = Arenas.BASE();
        Arenas.SET_FOR_ARENA(world, VS_GAME.arena);
        var friendSquad = (_a = VS_GAME.yourlastsquad) !== null && _a !== void 0 ? _a : { name: VS_GAME.yourname, balls: [] };
        var enemySquad = (_b = VS_GAME.enemylastsquad) !== null && _b !== void 0 ? _b : { name: VS_GAME.enemyname, balls: [] };
        var friendHealth = VS_GAME.yourhealth;
        var enemyHealth = VS_GAME.enemyhealth;
        var leftName = world.addWorldObject(new SpriteText({
            x: 2, y: 0,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_LEFT,
            justify: 'left',
            effects: { outline: { color: 0x000000 } },
        }));
        var rightName = world.addWorldObject(new SpriteText({
            name: 'opponentname',
            x: world.width - 2, y: 0,
            layer: Battle.Layers.playernames,
            anchor: Vector2.TOP_RIGHT,
            justify: 'right',
            effects: { outline: { color: 0x000000 } },
        }));
        world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: 8,
            text: "Round " + VS_GAME.round,
            layer: Battle.Layers.fg,
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 } },
        }));
        var statusText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: 232,
            text: "Players are shopping...",
            layer: Battle.Layers.fg,
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 } },
            data: { highlight: 0xFFFFCC },
            update: function () {
                this.style.color = Color.lerpColorByRgb(0xFFFFFF, this.data.highlight, Tween.Easing.OscillateSine(1)(this.life.time));
            }
        }));
        var errorText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: 178,
            text: "",
            layer: Battle.Layers.fg,
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 } },
        }));
        var gear = world.addWorldObject(new Sprite({
            name: 'gear',
            x: 11, y: global.gameHeight - 11,
            texture: 'gear',
            layer: Battle.Layers.ui,
            bounds: new CircleBounds(0, 0, 11),
        }));
        gear.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                gear.tint = 0xFFFFFF;
                global.game.playSound('click');
                global.game.pauseGame();
            },
        }));
        seedAll(GAME_DATA.gameId, VS_GAME.round - 1);
        var leftCheckmark = world.addWorldObject(new Sprite({
            y: 6,
            texture: 'checkmark',
            layer: Battle.Layers.playernames,
            tint: 0x4CFF00,
            effects: { outline: { color: 0x000000 } },
            visible: false,
        }));
        var rightCheckmark = world.addWorldObject(new Sprite({
            y: 6,
            texture: 'checkmark',
            layer: Battle.Layers.playernames,
            tint: 0x4CFF00,
            effects: { outline: { color: 0x000000 } },
            visible: false,
        }));
        var yourCheckmark, enemyCheckmark;
        if (friendSquad.name < enemySquad.name) {
            leftName.setText(formatName(friendSquad.name, friendHealth, 'friend'));
            rightName.setText(formatName(enemySquad.name, enemyHealth, 'enemy'));
            SWAP_DIRECTIONS = false;
            addSquad(world, friendSquad, 'friend', false);
            addSquad(world, enemySquad, 'enemy', true);
            yourCheckmark = leftCheckmark;
            enemyCheckmark = rightCheckmark;
        }
        else {
            leftName.setText(formatName(enemySquad.name, enemyHealth, 'enemy'));
            rightName.setText(formatName(friendSquad.name, friendHealth, 'friend'));
            SWAP_DIRECTIONS = true;
            addSquad(world, enemySquad, 'enemy', false);
            addSquad(world, friendSquad, 'friend', true);
            yourCheckmark = rightCheckmark;
            enemyCheckmark = leftCheckmark;
        }
        leftCheckmark.x = leftName.x + leftName.getTextWidth() + 9;
        rightCheckmark.x = rightName.x - rightName.getTextWidth() - 8;
        yourCheckmark.setVisible(!!VS_GAME.yoursquad);
        enemyCheckmark.setVisible(!!VS_GAME.enemysquad);
        world.addWorldObject(new BallHighlighter());
        world.addWorldObject(new InfoBox());
        setDataStartShop();
        setDataStartShopPostEffects();
        world.data.youArePlaying = false;
        world.addWorldObject(new AbilitySystem());
        global.game.playMusic(pickMusicForThisRoundShop(GAME_DATA), 0.1);
        world.addWorldObject(new GameTimer());
        world.addWorldObject(new MusicChanger());
        world.onTransitioned = function () {
            Main.fixedDelta = undefined;
        };
        world.runScript(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.wait(2)];
                    case 1:
                        _a.sent();
                        result = {};
                        return [4 /*yield*/, GameFragments.waitForVSGameCondition(GAME_DATA.gameId, loadName(), true, function (game) {
                                yourCheckmark.setVisible(!!game.yoursquad);
                                enemyCheckmark.setVisible(!!game.enemysquad);
                                return (game.yoursquad && game.enemysquad) || game.round > VS_GAME.round;
                            }, result, function (err) { return errorText.setText(err ? 'An error occurred' : ''); })];
                    case 2:
                        _a.sent();
                        if (!(result.game.round > VS_GAME.round)) return [3 /*break*/, 3];
                        statusText.setText('Missed the last round!');
                        statusText.data.highlight = 0xFF8888;
                        return [3 /*break*/, 6];
                    case 3:
                        statusText.setText('Battle is starting...');
                        statusText.data.highlight = 0xFF8888;
                        if (!(result.game.startTime && result.game.startTime >= Date.now() && result.game.startTime <= Date.now() + 6000)) return [3 /*break*/, 5];
                        return [4 /*yield*/, S.waitUntil(function () { return Date.now() >= result.game.startTime; })];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        global.game.stopMusic(1);
                        _a.label = 6;
                    case 6: return [4 /*yield*/, S.wait(3)];
                    case 7:
                        _a.sent();
                        GameFragments.startVsGame(GAME_DATA.gameId, result.game, false, true);
                        return [2 /*return*/];
                }
            });
        });
        return world;
    }
    SpectateWaitingRoom.STAGE = STAGE;
    function addSquad(world, squad, team, flippedSide) {
        for (var i = 0; i < squad.balls.length; i++) {
            var ball = world.addWorldObject(squadBallToWorldBall(squad.balls[i], squad, team === 'friend' ? i : -1, team, flippedSide));
            ball.showAllStats();
        }
    }
    function formatName(name, health, team) {
        var color = Ball.getTeamColor(team);
        return "[color " + color + "]" + name + "[/]\n[r]<heart>[/r]" + health;
    }
    function seedAll(gameid, round) {
        Random.seed("custombattle_" + gameid + "_" + round);
        Ball.Random.seed("custombattle_ball_" + gameid + "_" + round);
        debug('seeded', "custombattle_ball_" + gameid + "_" + round);
    }
})(SpectateWaitingRoom || (SpectateWaitingRoom = {}));
var Spinner = /** @class */ (function (_super) {
    __extends(Spinner, _super);
    function Spinner(x, y, ballRadius, ballDistance) {
        var _this = _super.call(this, { x: x, y: y }) || this;
        _this.alpha = 1;
        _this.angle = 0;
        _this.ballRadius = ballRadius;
        _this.ballDistance = ballDistance;
        return _this;
    }
    Spinner.prototype.update = function () {
        _super.prototype.update.call(this);
        this.angle += 360 * this.delta;
    };
    Spinner.prototype.render = function (texture, x, y) {
        _super.prototype.render.call(this, texture, x, y);
        Draw.brush.color = 0xFFFFFF;
        Draw.brush.alpha = this.alpha;
        var n = 5;
        for (var i = 0; i < n; i++) {
            var dx = M.cos(this.angle + i * 360 / n) * this.ballDistance;
            var dy = M.sin(this.angle + i * 360 / n) * this.ballDistance;
            Draw.circleSolid(texture, x + dx, y + dy, this.ballRadius);
        }
    };
    return Spinner;
}(WorldObject));
var TYPE_TO_BALL_TYPE_DEF = {
    // Classic Pack
    0: { factory: function (config) { return new Balls.Normal(config); }, purchasable: false, tier: 1, pack: 'classic' },
    1: { factory: function (config) { return new Balls.Healer(config); }, purchasable: true, tier: 1, pack: 'classic' },
    2: { factory: function (config) { return new Balls.Splitter(config); }, purchasable: true, tier: 2, pack: 'classic' },
    3: { factory: function (config) { return new Balls.SplitterSpawn(config); }, purchasable: false, tier: 2, pack: 'classic' },
    4: { factory: function (config) { return new Balls.Crusher(config); }, purchasable: true, tier: 2, pack: 'classic' },
    5: { factory: function (config) { return new Balls.Martyr(config); }, purchasable: true, tier: 1, pack: 'classic' },
    6: { factory: function (config) { return new Balls.Powerball(config); }, purchasable: true, tier: 1, pack: 'classic' },
    7: { factory: function (config) { return new Balls.Grenade(config); }, purchasable: true, tier: 2, pack: 'classic' },
    8: { factory: function (config) { return new Balls.EightBall(config); }, purchasable: true, tier: 1, pack: 'classic' },
    9: { factory: function (config) { return new Balls.Coin(config); }, purchasable: true, tier: 1, pack: 'classic' },
    10: { factory: function (config) { return new Balls.CrystalBall(config); }, purchasable: true, tier: 2, pack: 'classic', guaranteedShopChance: 0.2 },
    11: { factory: function (config) { return new Balls.Turret(config); }, purchasable: true, tier: 3, pack: 'classic' },
    12: { factory: function (config) { return new Balls.Leech(config); }, purchasable: true, tier: 2, pack: 'classic' },
    13: { factory: function (config) { return new Balls.Trainer(config); }, purchasable: true, tier: 4, pack: 'classic' },
    14: { factory: function (config) { return new Balls.Buffer(config); }, purchasable: true, tier: 2, pack: 'classic' },
    15: { factory: function (config) { return new Balls.Zombie(config); }, purchasable: true, tier: 1, pack: 'classic' },
    16: { factory: function (config) { return new Balls.Skeleton(config); }, purchasable: false, tier: 1, pack: 'classic' },
    17: { factory: function (config) { return new Balls.Splinter(config); }, purchasable: true, tier: 1, pack: 'classic' },
    18: { factory: function (config) { return new Balls.Spiker(config); }, purchasable: true, tier: 2, pack: 'classic' },
    19: { factory: function (config) { return new Balls.Necromancer(config); }, purchasable: true, tier: 3, pack: 'classic' },
    20: { factory: function (config) { return new Balls.Normal(config); }, purchasable: false, tier: 2, pack: 'classic' },
    21: { factory: function (config) { return new Balls.Gacha(config); }, purchasable: true, tier: 2, pack: 'classic' },
    22: { factory: function (config) { return new Balls.Sapper(config); }, purchasable: true, tier: 3, pack: 'classic' },
    23: { factory: function (config) { return new Balls.Vampire(config); }, purchasable: true, tier: 3, pack: 'classic' },
    24: { factory: function (config) { return new Balls.Pickleball(config); }, purchasable: true, tier: 1, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('StrongBall'); }, guaranteedShopChance: 0.4 },
    25: { factory: function (config) { return new Balls.Crown(config); }, purchasable: true, tier: 4, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('WinGame'); } },
    26: { factory: function (config) { return new Balls.Snowball(config); }, purchasable: true, tier: 1, pack: 'classic' },
    27: { factory: function (config) { return new Balls.Commando(config); }, purchasable: true, tier: 4, pack: 'classic' },
    28: { factory: function (config) { return new Balls.BallOfYarn(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('CatEarsOnSquad'); } },
    29: { factory: function (config) { return new Balls.Sniper(config); }, purchasable: true, tier: 3, pack: 'classic' },
    30: { factory: function (config) { return new Balls.Mechanic(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('WinWithoutEquipment'); } },
    31: { factory: function (config) { return new Balls.Normal(config); }, purchasable: false, tier: 4, pack: 'classic' },
    32: { factory: function (config) { return new Balls.PokeBall(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('VictoryWithTwoBalls'); } },
    33: { factory: function (config) { return new Balls.Psychic(config); }, purchasable: true, tier: 3, pack: 'classic' },
    34: { factory: function (config) { return new Balls.DeathStar(config); }, purchasable: true, tier: 4, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('ReachRoundTwelve'); } },
    35: { factory: function (config) { return new Balls.Vagrant(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('MakeFiveHundredPurchases'); } },
    36: { factory: function (config) { return new Balls.Medic(config); }, purchasable: true, tier: 2, pack: 'classic' },
    37: { factory: function (config) { return new Balls.RedCrystalBall(config); }, purchasable: true, tier: 1, pack: 'classic', soldInTiers: [1] },
    38: { factory: function (config) { return new Balls.GreenCrystalBall(config); }, purchasable: true, tier: 1, pack: 'classic', soldInTiers: [1] },
    39: { factory: function (config) { return new Balls.BallOfIce(config); }, purchasable: true, tier: 2, pack: 'classic', guaranteedShopChance: 0.2, isUnlocked: function () { return hasCompletedAchievement('WinWithoutFreezing'); } },
    40: { factory: function (config) { return new Balls.Ninja(config); }, purchasable: true, tier: 2, pack: 'classic' },
    41: { factory: function (config) { return new Balls.GlitchedBallArg(config); }, purchasable: false, tier: 1, pack: 'classic' },
    42: { factory: function (config) { return new Balls.GlitchedBall(config); }, purchasable: true, tier: 3, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('ArgPart1'); } },
    43: { factory: function (config) { return new Balls.Mercenary(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('DealDamage'); } },
    44: { factory: function (config) { return new Balls.Assassin(config); }, purchasable: true, tier: 2, pack: 'classic' },
    45: { factory: function (config) { return new Balls.Gladiator(config); }, purchasable: true, tier: 3, pack: 'classic' },
    46: { factory: function (config) { return new Balls.Vanguard(config); }, purchasable: true, tier: 3, pack: 'classic' },
    47: { factory: function (config) { return new Balls.Recycler(config); }, purchasable: true, tier: 1, pack: 'classic', guaranteedShopChance: 0.3 },
    48: { factory: function (config) { return new Balls.Wobby(config); }, purchasable: true, tier: 3, pack: 'classic', guaranteedShopChance: 0.3 },
    49: { factory: function (config) { return new Balls.Booster(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('CompleteVictoryLap') || hasCompletedAchievement('MidLevelBall'); } },
    50: { factory: function (config) { return new Balls.VoodooBall(config); }, purchasable: true, tier: 3, pack: 'classic' },
    51: { factory: function (config) { return new Balls.CueBall(config); }, purchasable: true, tier: 2, pack: 'classic' },
    52: { factory: function (config) { return new Balls.Toxin(config); }, purchasable: true, tier: 2, pack: 'classic', isUnlocked: function () { return hasCompletedAchievement('WinWeekly'); } },
    53: { factory: function (config) { return new Balls.Cannon(config); }, purchasable: true, tier: 4, pack: 'classic' },
    54: { factory: function (config) { return new Balls.Cannonball(config); }, purchasable: false, tier: 4, pack: 'classic' },
    77: { factory: function (config) { return new Balls.Pinata(config); }, purchasable: false, tier: 1, pack: 'classic' },
    // Community Pack
    100: { factory: function (config) { return new Balls.BioGrenade(config); }, purchasable: true, tier: 2, pack: 'community' },
    101: { factory: function (config) { return new Balls.Bank(config); }, purchasable: true, tier: 1, pack: 'community' },
    102: { factory: function (config) { return new Balls.Reducer(config); }, purchasable: true, tier: 2, pack: 'community' },
    103: { factory: function (config) { return new Balls.Matryoshka(config); }, purchasable: true, tier: 3, pack: 'community' },
    104: { factory: function (config) { return new Balls.Butterball(config); }, purchasable: true, tier: 2, pack: 'community' },
    105: { factory: function (config) { return new Balls.Sleeper(config); }, purchasable: true, tier: 2, pack: 'community' },
    106: { factory: function (config) { return new Balls.Angel(config); }, purchasable: true, tier: 1, pack: 'community' },
    107: { factory: function (config) { return new Balls.Devil(config); }, purchasable: true, tier: 3, pack: 'community' },
    108: { factory: function (config) { return new Balls.BlackHole(config); }, purchasable: true, tier: 2, pack: 'community' },
    109: { factory: function (config) { return new Balls.Boomer(config); }, purchasable: true, tier: 3, pack: 'community' },
    110: { factory: function (config) { return new Balls.Zoomer(config); }, purchasable: true, tier: 1, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('BallGoBrrr'); } },
    111: { factory: function (config) { return new Balls.Guardian(config); }, purchasable: true, tier: 3, pack: 'community' },
    112: { factory: function (config) { return new Balls.Fragmenter(config); }, purchasable: true, tier: 1, pack: 'community' },
    113: { factory: function (config) { return new Balls.Watcher(config); }, purchasable: true, tier: 3, pack: 'community' },
    114: { factory: function (config) { return new Balls.Wizard(config); }, purchasable: true, tier: 2, pack: 'community' },
    115: { factory: function (config) { return new Balls.Stinger(config); }, purchasable: true, tier: 2, pack: 'community' },
    116: { factory: function (config) { return new Balls.Mimic(config); }, purchasable: true, tier: 3, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('SameBall'); } },
    117: { factory: function (config) { return new Balls.Scavenger(config); }, purchasable: true, tier: 1, pack: 'community' },
    118: { factory: function (config) { return new Balls.Cheel(config); }, purchasable: true, tier: 2, pack: 'community' },
    119: { factory: function (config) { return new Balls.Fireball(config); }, purchasable: true, tier: 1, pack: 'community' },
    120: { factory: function (config) { return new Balls.Phoenix(config); }, purchasable: true, tier: 3, pack: 'community' },
    121: { factory: function (config) { return new Balls.Impostor(config); }, purchasable: true, tier: 2, pack: 'community' },
    122: { factory: function (config) { return new Balls.Miner(config); }, purchasable: true, tier: 2, pack: 'community' },
    123: { factory: function (config) { return new Balls.Hitman(config); }, purchasable: true, tier: 3, pack: 'community' },
    124: { factory: function (config) { return new Balls.Nullifier(config); }, purchasable: true, tier: 3, pack: 'community' },
    125: { factory: function (config) { return new Balls.QuestionBall(config); }, purchasable: true, tier: 1, pack: 'community' },
    126: { factory: function (config) { return new Balls.Seed(config); }, purchasable: true, tier: 1, pack: 'community', soldInTiers: [1, 2, 3] },
    127: { factory: function (config) { return new Balls.Dove(config); }, purchasable: true, tier: 2, pack: 'community', shopChance: 0.333, guaranteedShopChance: 0, isUnlocked: function () { return hasCompletedAchievement('HealHp'); } },
    128: { factory: function (config) { return new Balls.Watermelon(config); }, purchasable: true, tier: 1, pack: 'community' },
    129: { factory: function (config) { return new Balls.Grave(config); }, purchasable: true, tier: 4, pack: 'community' },
    130: { factory: function (config) { return new Balls.ScrapCannon(config); }, purchasable: true, tier: 4, pack: 'community' },
    131: { factory: function (config) { return new Balls.Haunt(config); }, purchasable: true, tier: 3, pack: 'community' },
    132: { factory: function (config) { return new Balls.FireFighter(config); }, purchasable: true, tier: 4, pack: 'community' },
    133: { factory: function (config) { return new Balls.Battery(config); }, purchasable: true, tier: 4, pack: 'community' },
    134: { factory: function (config) { return new Balls.OldCrystalBall(config); }, purchasable: true, tier: 2, pack: 'community', guaranteedShopChance: 0.2 },
    135: { factory: function (config) { return new Balls.NeoCrystalBall(config); }, purchasable: true, tier: 2, pack: 'community', guaranteedShopChance: 0.2 },
    136: { factory: function (config) { return new Balls.Crown(config); }, purchasable: true, tier: 4, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('WinGame'); } },
    137: { factory: function (config) { return new Balls.Dolly(config); }, purchasable: true, tier: 2, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('FiveRemainingBalls'); } },
    138: { factory: function (config) { return new Balls.Burner(config); }, purchasable: true, tier: 2, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('DealBurnDamage'); } },
    139: { factory: function (config) { return new Balls.GoldCrystalBall(config); }, purchasable: true, tier: 3, pack: 'community', shopChance: 0.25, guaranteedShopChance: 0.2, isUnlocked: function () { return hasCompletedAchievement('WinDaily'); } },
    140: { factory: function (config) { return new Balls.Alchemist(config); }, purchasable: true, tier: 2, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('CompleteBallmanacEntries'); } },
    141: { factory: function (config) { return new Balls.Seeker(config); }, purchasable: true, tier: 1, pack: 'community' },
    142: { factory: function (config) { return new Balls.Mimic(config); }, purchasable: false, tier: 4, pack: 'community' },
    143: { factory: function (config) { return new Balls.BowlingBall(config); }, purchasable: true, tier: 1, pack: 'community', isUnlocked: function () { return hasCompletedAchievement('KillEnemiesInRound'); } },
    144: { factory: function (config) { return new Balls.Stopper(config); }, purchasable: true, tier: 3, pack: 'community' },
};
var TYPE_TO_ITEM_TYPE_DEF = {
    0: { factory: function (x, y) { return new BallItems.Spinach(x, y); }, purchasable: true, tier: 2 },
    1: { factory: function (x, y) { return new BallItems.Shield(x, y); }, purchasable: true, tier: 3 },
    2: { factory: function (x, y) { return new BallItems.Magnet(x, y); }, purchasable: true, tier: 1 },
    3: { factory: function (x, y) { return new BallItems.SkullCharm(x, y); }, purchasable: true, tier: 1 },
    4: { factory: function (x, y) { return new BallItems.ArmorPlating(x, y); }, purchasable: true, tier: 3 },
    5: { factory: function (x, y) { return new BallItems.BallSharpener(x, y); }, purchasable: true, tier: 2 },
    6: { factory: function (x, y) { return new BallItems.Polisher(x, y); }, purchasable: true, tier: 1 },
    7: { factory: function (x, y) { return new BallItems.CatEars(x, y); }, purchasable: true, tier: 1 },
    8: { factory: function (x, y) { return new BallItems.Claws(x, y); }, purchasable: true, tier: 2 },
    9: { factory: function (x, y) { return new BallItems.TheseGuns(x, y); }, purchasable: true, tier: 3 },
    10: { factory: function (x, y) { return new BallItems.Rejuvenator(x, y); }, purchasable: true, tier: 3 },
    11: { factory: function (x, y) { return new BallItems.CloutInAJar(x, y); }, purchasable: true, tier: 2 },
    12: { factory: function (x, y) { return new BallItems.Pickle(x, y); }, purchasable: false, tier: 1 },
    13: { factory: function (x, y) { return new BallItems.HotPickle(x, y); }, purchasable: false, tier: 1 },
    14: { factory: function (x, y) { return new BallItems.ConsolationPrize(x, y); }, purchasable: false, tier: 2, isUnlocked: function () { return hasCompletedAchievement('PlayFiveGames'); } },
    15: { factory: function (x, y) { return new BallItems.BallSharpener1(x, y); }, purchasable: true, tier: 1, inOnlyOwnTier: true, isUnlocked: function () { return hasCompletedAchievement('StrongSquad'); } },
    16: { factory: function (x, y) { return new BallItems.Polisher1(x, y); }, purchasable: false, tier: 1, inOnlyOwnTier: true },
    17: { factory: function (x, y) { return new BallItems.HyperDriver(x, y); }, purchasable: true, tier: 3, isUnlocked: function () { return hasCompletedAchievement('RoundsInARow'); } },
    18: { factory: function (x, y) { return new BallItems.PolarityInverter(x, y); }, purchasable: true, tier: 2 },
    19: { factory: function (x, y) { return new BallItems.ThiefMask(x, y); }, purchasable: true, tier: 2 },
    20: { factory: function (x, y) { return new BallItems.Bounty(x, y); }, purchasable: true, tier: 1, isUnlocked: function () { return hasCompletedAchievement('HaveTwentyGold'); } },
    21: { factory: function (x, y) { return new BallItems.UnstableCatalyst(x, y); }, purchasable: true, tier: 2, isUnlocked: function () { return hasCompletedAchievement('WinInTenMinutes'); } },
    22: { factory: function (x, y) { return new BallItems.Overcharger(x, y); }, purchasable: true, tier: 3 },
    23: { factory: function (x, y) { return new BallItems.ToxicFungus(x, y); }, purchasable: true, tier: 2, isUnlocked: function () { return hasCompletedAchievement('WinFiftyRounds'); } },
    24: { factory: function (x, y) { return new BallItems.SmokeBomb(x, y); }, purchasable: true, tier: 2, isUnlocked: function () { return hasCompletedAchievement('PlayHundredRounds'); } },
    25: { factory: function (x, y) { return new BallItems.GlitchedItemArg(x, y); }, purchasable: false, tier: 2 },
    26: { factory: function (x, y) { return new BallItems.Bandaid(x, y); }, purchasable: true, tier: 1 },
    27: { factory: function (x, y) { return new BallItems.VIPTicket(x, y); }, purchasable: true, tier: 3, isUnlocked: function () { return hasCompletedAchievement('DefeatCrownedSquads'); } },
    28: { factory: function (x, y) { return new BallItems.Supernova(x, y); }, purchasable: true, tier: 2 },
    29: { factory: function (x, y) { return new BallItems.RetroGlasses(x, y); }, purchasable: true, tier: 3 },
    30: { factory: function (x, y) { return new BallItems.BestFriend(x, y); }, purchasable: true, tier: 3 },
    31: { factory: function (x, y) { return new BallItems.OrbitingPotato(x, y); }, purchasable: true, tier: 2 },
    32: { factory: function (x, y) { return new BallItems.ScribbledMap(x, y); }, purchasable: false, tier: 1 },
    33: { factory: function (x, y) { return new BallItems.VoodooPin(x, y); }, purchasable: true, tier: 3 },
    34: { factory: function (x, y) { return new BallItems.Silencer(x, y); }, purchasable: true, tier: 3 },
    35: { factory: function (x, y) { return new BallItems.Medkit(x, y); }, purchasable: true, tier: 2 },
    36: { factory: function (x, y) { return new BallItems.Mitosis(x, y); }, purchasable: true, tier: 3 },
    37: { factory: function (x, y) { return new BallItems.ParticipationTrophy(x, y); }, purchasable: false, tier: 1, inOnlyOwnTier: true, isUnlocked: function () { return hasCompletedAchievement('PlayFiveGames'); } },
    38: { factory: function (x, y) { return new BallItems.BirthdayCake(x, y); }, purchasable: false, tier: 1 },
    39: { factory: function (x, y) { return new BallItems.Gift(x, y); }, purchasable: false, tier: 1 },
    40: { factory: function (x, y) { return new BallItems.Jetpack(x, y); }, purchasable: true, tier: 2 },
    41: { factory: function (x, y) { return new BallItems.ProtectionBubble(x, y); }, purchasable: true, tier: 2 },
    42: { factory: function (x, y) { return new BallItems.StarCatcher(x, y); }, purchasable: true, tier: 2 },
    43: { factory: function (x, y) { return new BallItems.Contagion(x, y); }, purchasable: true, tier: 3 },
    44: { factory: function (x, y) { return new BallItems.RedCube(x, y); }, purchasable: true, tier: 1 },
    45: { factory: function (x, y) { return new BallItems.GreenCube(x, y); }, purchasable: true, tier: 1 },
    46: { factory: function (x, y) { return new BallItems.CollectibleCoin(x, y); }, purchasable: true, tier: 2, isUnlocked: function () { return hasCompletedAchievement('SellCoin'); } },
    47: { factory: function (x, y) { return new BallItems.MolecularDisassembler(x, y); }, purchasable: true, tier: 2 },
    48: { factory: function (x, y) { return new BallItems.CursedDoll(x, y); }, purchasable: true, tier: 3 },
    49: { factory: function (x, y) { return new BallItems.CursedEye(x, y); }, purchasable: true, tier: 3 },
    50: { factory: function (x, y) { return new BallItems.Joker(x, y); }, purchasable: true, tier: 2, shopChance: 0.5 },
    51: { factory: function (x, y) { return new BallItems.TimeBomb(x, y); }, purchasable: true, tier: 2 },
    52: { factory: function (x, y) { return new BallItems.HuntersMark(x, y); }, purchasable: true, tier: 2, isUnlocked: function () { return hasCompletedAchievement('ShootProjectiles'); } },
    53: { factory: function (x, y) { return new BallItems.Curry(x, y); }, purchasable: true, tier: 3 },
    54: { factory: function (x, y) { return new BallItems.TheBug(x, y); }, purchasable: true, tier: 2, shopChance: 0.5 },
    55: { factory: function (x, y) { return new BallItems.Mocha(x, y); }, purchasable: true, tier: 3, isUnlocked: function () { return hasCompletedAchievement('KillBeforeBattle'); } },
};
var TYPE_TO_EQUIPMENT_TYPE_DEF = {
    0: { factory: function () { return new Equipments.Shield(); }, purchasable: true, tier: 3 },
    1: { factory: function () { return new Equipments.Magnet(); }, purchasable: true, tier: 1 },
    2: { factory: function () { return new Equipments.SkullCharm(); }, purchasable: true, tier: 1 },
    3: { factory: function () { return new Equipments.ArmorPlating(); }, purchasable: true, tier: 3 },
    4: { factory: function () { return new Equipments.CatEars(); }, purchasable: true, tier: 1 },
    5: { factory: function () { return new Equipments.Claws(); }, purchasable: true, tier: 2 },
    6: { factory: function () { return new Equipments.TheseGuns(); }, purchasable: true, tier: 3 },
    7: { factory: function () { return new Equipments.Rejuvenator(); }, purchasable: true, tier: 3 },
    8: { factory: function () { return new Equipments.HyperDriver(); }, purchasable: true, tier: 3 },
    9: { factory: function () { return new Equipments.PolarityInverter(); }, purchasable: true, tier: 2 },
    10: { factory: function () { return new Equipments.ThiefMask(); }, purchasable: true, tier: 2 },
    11: { factory: function () { return new Equipments.Bounty(); }, purchasable: true, tier: 1 },
    12: { factory: function () { return new Equipments.UnstableCatalyst(); }, purchasable: true, tier: 2 },
    13: { factory: function () { return new Equipments.Overcharger(); }, purchasable: true, tier: 3 },
    14: { factory: function () { return new Equipments.Spore(); }, purchasable: false, tier: 3 },
    15: { factory: function () { return new Equipments.ToxicFungus(); }, purchasable: true, tier: 2 },
    16: { factory: function () { return new Equipments.SmokeBomb(); }, purchasable: true, tier: 2 },
    17: { factory: function () { return new Equipments.Bandaid(); }, purchasable: true, tier: 1 },
    18: { factory: function () { return new Equipments.VIPTicket(); }, purchasable: true, tier: 3 },
    19: { factory: function () { return new Equipments.RetroGlasses(); }, purchasable: true, tier: 3 },
    20: { factory: function () { return new Equipments.BestFriend(); }, purchasable: true, tier: 3 },
    21: { factory: function () { return new Equipments.OrbitingPotato(1); }, purchasable: true, tier: 2 },
    22: { factory: function () { return new Equipments.OrbitingPotato(2); }, purchasable: false, tier: 2 },
    23: { factory: function () { return new Equipments.OrbitingPotato(3); }, purchasable: false, tier: 2 },
    24: { factory: function () { return new Equipments.VoodooPin(); }, purchasable: true, tier: 3 },
    25: { factory: function () { return new Equipments.Silencer(); }, purchasable: true, tier: 3 },
    26: { factory: function () { return new Equipments.Medkit(); }, purchasable: true, tier: 2 },
    27: { factory: function () { return new Equipments.Mitosis(); }, purchasable: true, tier: 3 },
    28: { factory: function () { return new Equipments.Jetpack(); }, purchasable: true, tier: 2 },
    29: { factory: function () { return new Equipments.ProtectionBubble(); }, purchasable: true, tier: 2 },
    30: { factory: function () { return new Equipments.StarCatcher(); }, purchasable: true, tier: 2 },
    31: { factory: function () { return new Equipments.Infection(); }, purchasable: false, tier: 3 },
    32: { factory: function () { return new Equipments.Contagion(); }, purchasable: true, tier: 3 },
    33: { factory: function () { return new Equipments.RedCube(); }, purchasable: true, tier: 1 },
    34: { factory: function () { return new Equipments.GreenCube(); }, purchasable: true, tier: 1 },
    35: { factory: function () { return new Equipments.CursedDoll(); }, purchasable: true, tier: 3 },
    36: { factory: function () { return new Equipments.CursedEye(); }, purchasable: true, tier: 3 },
    37: { factory: function () { return new Equipments.Joker(); }, purchasable: true, tier: 2 },
    38: { factory: function () { return new Equipments.TimeBomb(); }, purchasable: true, tier: 2 },
    39: { factory: function () { return new Equipments.HuntersMark(); }, purchasable: true, tier: 2 },
    40: { factory: function () { return new Equipments.Curry(); }, purchasable: true, tier: 3 },
    41: { factory: function () { return new Equipments.TheBug(); }, purchasable: true, tier: 2 },
    42: { factory: function () { return new Equipments.Mocha(); }, purchasable: true, tier: 3 },
};
var TIER_LEVELS_AVAILABLE = {
    // round: [ tier1level, tier2level, tier3level, tier3+level ]
    1: [1, 0, 0, 0],
    2: [1, 0, 0, 0],
    3: [1, 0, 0, 0],
    4: [2, 1, 0, 0],
    5: [2, 1, 0, 0],
    6: [2, 1, 0, 0],
    7: [3, 2, 1, 0],
    8: [3, 2, 1, 0],
    9: [3, 2, 1, 0],
    10: [3, 2, 1, 1],
};
var TIER_COLORS = [0xFFFFFF, 0xFFFF00, 0xFF00FF, 0x00FFFF];
var BALL_SHOP_TIER_WEIGHTS = {
    1: 1,
    2: 1.5,
    3: 2,
    4: 2.5,
};
function getShopTierForRound(round) {
    var tierLevelsAvailable = getTierLevelsAvailableForRound(round);
    for (var i = tierLevelsAvailable.length - 1; i >= 0; i--) {
        if (tierLevelsAvailable[i] > 0)
            return i + 1;
    }
    return 1;
}
function isTierJustUnlocked(tier) {
    return getTierLevelAvailableForRound(tier, GAME_DATA.round - 1) === 0 && getTierLevelAvailableForRound(tier, GAME_DATA.round) > 0;
}
function getTierJustUnlocked() {
    for (var tier = 1; tier <= TIER_LEVELS_AVAILABLE[1].length; tier++) {
        if (isTierJustUnlocked(tier))
            return tier;
    }
    return -1;
}
function getColorForTier(tier) {
    if (tier < 1 || tier > TIER_COLORS.length) {
        console.error("Invalid tier: " + tier + "?");
        tier = M.clamp(tier, 1, TIER_COLORS.length);
    }
    return TIER_COLORS[tier - 1];
}
function getTierLevelsAvailableForRound(round) {
    return TIER_LEVELS_AVAILABLE[M.clamp(round, 1, M.max(Object.keys(TIER_LEVELS_AVAILABLE), parseInt))];
}
function getTierLevelAvailableForRound(tier, round) {
    var tierLevelsAvailable = getTierLevelsAvailableForRound(round);
    if (tier < 1 || tier > tierLevelsAvailable.length) {
        console.error("Invalid tier: " + tier + "?");
        tier = M.clamp(tier, 1, tierLevelsAvailable.length);
    }
    return tierLevelsAvailable[tier - 1];
}
function getPurchasableBallTypesForRound(round, packs, weekly) {
    var allBallTypes = A.removeDuplicates(_.flatten(packs.map(function (pack) { return getAllBallTypesForPack(pack, weekly); })));
    var types = allBallTypes.filter(function (type) { return TYPE_TO_BALL_TYPE_DEF[type].purchasable
        && getTierLevelAvailableForRound(TYPE_TO_BALL_TYPE_DEF[type].tier, round) > 0
        && (!TYPE_TO_BALL_TYPE_DEF[type].soldInTiers || _.contains(TYPE_TO_BALL_TYPE_DEF[type].soldInTiers, getShopTierForRound(round)))
        && isBallTypeUnlocked(type); });
    // De-dupe Crown.
    if (_.includes(packs, 'classic') && _.includes(types, 136)) {
        A.removeAll(types, 136);
    }
    return types;
}
function isBallTypeUnlocked(type) {
    if (_.isEmpty(GAME_DATA === null || GAME_DATA === void 0 ? void 0 : GAME_DATA.availableBallTypes)) {
        return !TYPE_TO_BALL_TYPE_DEF[type].isUnlocked || TYPE_TO_BALL_TYPE_DEF[type].isUnlocked();
    }
    return _.contains(GAME_DATA.availableBallTypes, type);
}
function getPurchasableBallTypesForRoundTier(round, tier, packs, weekly) {
    return getPurchasableBallTypesForRound(round, packs, weekly).filter(function (type) { return TYPE_TO_BALL_TYPE_DEF[type].tier === tier; });
}
function getBallTypeLevelForRound(type, round) {
    if (!TYPE_TO_BALL_TYPE_DEF[type])
        return 1;
    return getTierLevelAvailableForRound(TYPE_TO_BALL_TYPE_DEF[type].tier, round);
}
function getBallShopChanceForType(ballType) {
    var _a, _b;
    if (!(ballType in TYPE_TO_BALL_TYPE_DEF))
        return 0;
    var ballTypeDef = TYPE_TO_BALL_TYPE_DEF[ballType];
    var tierWeight = (_a = BALL_SHOP_TIER_WEIGHTS[ballTypeDef.tier]) !== null && _a !== void 0 ? _a : 1;
    var shopChanceWeight = (_b = ballTypeDef.shopChance) !== null && _b !== void 0 ? _b : 1;
    return shopChanceWeight * tierWeight;
}
function getBallShopGuaranteedChanceForType(ballType) {
    var _a;
    if (!(ballType in TYPE_TO_BALL_TYPE_DEF))
        return 0;
    var ballTypeDef = TYPE_TO_BALL_TYPE_DEF[ballType];
    return (_a = ballTypeDef.guaranteedShopChance) !== null && _a !== void 0 ? _a : 0.8;
}
function getItemShopChanceForType(itemType) {
    var _a;
    if (!(itemType in TYPE_TO_ITEM_TYPE_DEF))
        return 0;
    var itemTypeDef = TYPE_TO_ITEM_TYPE_DEF[itemType];
    var shopChanceWeight = (_a = itemTypeDef.shopChance) !== null && _a !== void 0 ? _a : 1;
    return shopChanceWeight;
}
function getPurchasableBallItemTypesForRound(round) {
    return Object.keys(TYPE_TO_ITEM_TYPE_DEF)
        .map(function (type) { return parseInt(type); })
        .filter(function (type) { return TYPE_TO_ITEM_TYPE_DEF[type].purchasable
        && getTierLevelAvailableForRound(TYPE_TO_ITEM_TYPE_DEF[type].tier, round) > 0
        && (!TYPE_TO_ITEM_TYPE_DEF[type].inOnlyOwnTier || getTierLevelAvailableForRound(TYPE_TO_ITEM_TYPE_DEF[type].tier, round) < 2)
        && isItemTypeUnlocked(type); });
}
function getAllEquipmentTypes() {
    return Object.keys(TYPE_TO_EQUIPMENT_TYPE_DEF)
        .map(function (type) { return parseInt(type); })
        .filter(function (type) { return type !== 4; }); // Do not randomly generate cat ears
}
function isItemTypeUnlocked(itemType) {
    if (!(itemType in TYPE_TO_ITEM_TYPE_DEF)) {
        console.error('Invalid item type:', itemType, 'Defaulting to locked');
        return false;
    }
    if (!_.isEmpty(GAME_DATA === null || GAME_DATA === void 0 ? void 0 : GAME_DATA.availableItemTypes)) {
        return _.contains(GAME_DATA.availableItemTypes, itemType);
    }
    var typeDef = TYPE_TO_ITEM_TYPE_DEF[itemType];
    return !typeDef.isUnlocked || typeDef.isUnlocked();
}
function squadBallToWorldBall(squadBall, squad, squadIndexReference, team, flippedSide, isSummon) {
    if (flippedSide === void 0) { flippedSide = false; }
    if (isSummon === void 0) { isSummon = true; }
    var ballType = TYPE_TO_BALL_TYPE_DEF[squadBall.properties.type];
    if (!ballType) {
        console.error('Invalid ball type:', squadBall.properties.type, 'Defaulting to normal ball');
        ballType = TYPE_TO_BALL_TYPE_DEF[0];
    }
    var ball = ballType.factory({
        x: flippedSide ? global.gameWidth - squadBall.x : squadBall.x,
        y: squadBall.y,
        properties: squadBall.properties,
        squad: squad,
        squadIndexReference: squadIndexReference,
        team: team,
    });
    ball.tier = ballType.tier;
    ball.isSummon = isSummon;
    return ball;
}
function randomSquadBall(x, y, round, packs, weekly) {
    var purchasableBallTypes = getPurchasableBallTypesForRound(round, packs, weekly);
    var equipmentTypes = getAllEquipmentTypes();
    return {
        x: x, y: y,
        properties: {
            type: Ball.Random.element(purchasableBallTypes),
            level: 1,
            damage: 1,
            health: 1,
            equipment: round >= 6 && Ball.Random.boolean(0.4) ? Ball.Random.element(equipmentTypes) : -1,
            metadata: {},
        }
    };
}
function itemTypeToBallItem(type, x, y) {
    var itemType = TYPE_TO_ITEM_TYPE_DEF[type];
    if (!itemType) {
        console.error('Invalid item type:', type, 'Defaulting to food');
        itemType = TYPE_TO_ITEM_TYPE_DEF[0];
    }
    var item = itemType.factory(x, y);
    item.type = type;
    item.tier = itemType.tier;
    return item;
}
function equipmentTypeToEquipment(type) {
    if (type < 0)
        return undefined;
    var equipmentType = TYPE_TO_EQUIPMENT_TYPE_DEF[type];
    if (!equipmentType) {
        console.error('Invalid equipment type:', type, 'Defaulting to none');
        return undefined;
    }
    var equipment = equipmentType.factory();
    equipment.equipmentType = type;
    return equipment;
}
function getPurchasableEquipmentTypesForExactTier(tier) {
    return Object.keys(TYPE_TO_EQUIPMENT_TYPE_DEF)
        .map(function (type) { return parseInt(type); })
        .filter(function (type) { return TYPE_TO_EQUIPMENT_TYPE_DEF[type].purchasable && TYPE_TO_EQUIPMENT_TYPE_DEF[type].tier === tier; });
}
function getPurchasableEquipmentTypesForRound(round) {
    var tier = getShopTierForRound(round);
    return _.flatten(A.range(1, 4).filter(function (i) { return i <= tier; }).map(function (t) { return getPurchasableEquipmentTypesForExactTier(t); }));
}
function generateBotSquadForRound(round, packs, weekly) {
    var balls = [];
    for (var i = 0; i < 3 * round; i++) {
        if (balls.length < 5) {
            var p = Random.inCircle(50);
            var ball = randomSquadBall(70 + p.x, 120 + p.y, round, packs, weekly);
            balls.push(ball);
        }
        else {
            if (Random.boolean(1 / 3)) {
                if (Random.boolean())
                    Random.element(balls).properties.damage += 2;
                else
                    Random.element(balls).properties.health += 2;
            }
            else if (Random.boolean(1 / 2)) {
                Random.element(balls).properties.equipment = Random.element(getPurchasableEquipmentTypesForExactTier(getShopTierForRound(round)));
            }
            else {
                Random.element(balls).properties.level++;
            }
        }
    }
    return {
        name: 'BOT',
        balls: balls,
    };
}
var EQUIPMENT_TYPE_TO_ITEM_TYPE = {};
function loadEquipmentTypesToItemTypes() {
    var e_127, _a;
    for (var type in TYPE_TO_ITEM_TYPE_DEF) {
        var item = TYPE_TO_ITEM_TYPE_DEF[type].factory(0, 0);
        try {
            for (var _b = (e_127 = void 0, __values(item.mapToEquipmentTypes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var equipmentType = _c.value;
                EQUIPMENT_TYPE_TO_ITEM_TYPE[equipmentType] = parseInt(type);
            }
        }
        catch (e_127_1) { e_127 = { error: e_127_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_127) throw e_127.error; }
        }
    }
}
function getItemTypeForEquipmentType(equipmentType) {
    if (equipmentType in EQUIPMENT_TYPE_TO_ITEM_TYPE) {
        return EQUIPMENT_TYPE_TO_ITEM_TYPE[equipmentType];
    }
    return -1;
}
function getAvailableBallTypesOnlyUnlocked() {
    return Object.keys(TYPE_TO_BALL_TYPE_DEF).map(function (type) { return parseInt(type); })
        .filter(function (type) {
        var ballType = TYPE_TO_BALL_TYPE_DEF[type];
        if (!ballType.isUnlocked || ballType.isUnlocked())
            return true;
        return false;
    });
}
function getAvailableItemTypesOnlyUnlocked() {
    return Object.keys(TYPE_TO_ITEM_TYPE_DEF).map(function (type) { return parseInt(type); })
        .filter(function (type) {
        var itemType = TYPE_TO_ITEM_TYPE_DEF[type];
        if (!itemType.isUnlocked || itemType.isUnlocked())
            return true;
        return false;
    });
}
function getAvailableBallTypesAll() {
    return Object.keys(TYPE_TO_BALL_TYPE_DEF).map(function (type) { return parseInt(type); });
}
function getAvailableItemTypesAll() {
    return Object.keys(TYPE_TO_ITEM_TYPE_DEF).map(function (type) { return parseInt(type); });
}
function getAllBallTypesForPack(pack, weekly) {
    if (pack === 'weekly') {
        return getAllBallTypesForWeekly(weekly);
    }
    return Object.keys(TYPE_TO_BALL_TYPE_DEF).map(function (type) { return parseInt(type); })
        .filter(function (type) { return TYPE_TO_BALL_TYPE_DEF[type].pack === pack; });
}
var ECONOMY_BALLS = [
    6,
    8,
    9,
    101,
    125,
];
function getAllBallTypesForWeekly(weekly) {
    var rng = new RandomNumberGenerator();
    var weeklySeed = weekly.week;
    var tierPurchasableCounts = [10, 15, 10, 4];
    var ballTypes = [];
    var _loop_13 = function (tier) {
        var purchasableBallTypes = Object.keys(TYPE_TO_BALL_TYPE_DEF).map(function (type) { return parseInt(type); })
            .filter(function (type) { return TYPE_TO_BALL_TYPE_DEF[type].tier === tier && TYPE_TO_BALL_TYPE_DEF[type].purchasable && type !== 25 && type !== 136; });
        rng.seed("weekly_" + weeklySeed + "_tier_" + tier);
        ballTypes.push.apply(ballTypes, __spread(rng.sample(purchasableBallTypes, tierPurchasableCounts[tier - 1])));
        if (tier === 4) {
            ballTypes.push(25); // Crown
        }
    };
    for (var tier = 1; tier <= 4; tier++) {
        _loop_13(tier);
    }
    // Hack for week 1 since we changed the algorithm.
    if (weekly.week === 1) {
        ballTypes.splice(ballTypes.length - 5, 5);
        ballTypes.push(27, 34, 130, 133, 136);
    }
    // Hack for week 3 for a better tournament.
    if (weekly.week === 3) {
        A.removeAll(ballTypes, 8);
        ballTypes.push(6);
    }
    // Ensure at least 2 economy balls in each weekly.
    if (weekly.week >= 4) {
        var existingEconomyBallTypes_1 = ballTypes.filter(function (type) { return _.contains(ECONOMY_BALLS, type); });
        if (existingEconomyBallTypes_1.length < 2) {
            rng.seed("weekly_" + weeklySeed + "_adjusteconomy");
            for (var i = 0; i < ballTypes.length; i++) {
                if (TYPE_TO_BALL_TYPE_DEF[ballTypes[i]].tier === 1 && !_.includes(ECONOMY_BALLS, ballTypes[i])) {
                    var validBallTypes = ECONOMY_BALLS.filter(function (type) { return !_.includes(existingEconomyBallTypes_1, type); });
                    ballTypes[i] = rng.element(validBallTypes);
                    break;
                }
            }
        }
    }
    return A.sort(ballTypes, function (type) { return type; });
}
var Stars = /** @class */ (function (_super) {
    __extends(Stars, _super);
    function Stars(type) {
        var _this = _super.call(this, {
            copyFromParent: ['layer'],
        }) || this;
        _this.type = type;
        return _this;
    }
    Stars.prototype.setStars = function (stars) {
        var cache = this.type === 'stars' ? Stars.starsCache : Stars.crownsCache;
        this.setTexture(cache.get(stars));
    };
    Stars.newTexture = function (stars, type) {
        var starTexture = AssetCache.getTexture(type === 'stars' ? 'star' : 'crown');
        if (stars < 7) {
            var texture_1 = new BasicTexture(10 * stars, 9, "Stars." + type + "Cache", false);
            for (var i = 0; i < stars; i++) {
                starTexture.renderTo(texture_1, { x: 5 + 10 * i, y: 4 });
            }
            texture_1.immutable = true;
            return new AnchoredTexture(texture_1, 0.5, 0.5);
        }
        var starsString = "" + stars;
        var texture = new BasicTexture(10 + 8 * starsString.length, 11, "Stars." + type + "Cache", false);
        starTexture.renderTo(texture, { x: 5, y: 5 });
        new SpriteText({
            text: starsString,
            font: 'starnumbers',
            style: { color: 0xFFD800 },
            effects: { outline: { color: 0x000000 } },
        }).render(texture, 10, 2);
        texture.immutable = true;
        return new AnchoredTexture(texture, 0.5, 0.5);
    };
    Stars.starsCache = new LazyDictNumber(function (stars) { return Stars.newTexture(stars, 'stars'); });
    Stars.crownsCache = new LazyDictNumber(function (stars) { return Stars.newTexture(stars, 'crowns'); });
    return Stars;
}(Sprite));
function addStartShopEffect(effect) {
    var currentEffect = GAME_DATA.startShopEffects.find(function (ce) { return ce.type === effect.type && ce.sourceSquadIndex === effect.sourceSquadIndex; });
    if (!currentEffect) {
        GAME_DATA.startShopEffects.push(effect);
        return;
    }
    // Combine effects if they exist
    if (effect.type === 'buff' && currentEffect.type === 'buff') {
        currentEffect.health += effect.health;
        currentEffect.damage += effect.damage;
        return;
    }
    if (effect.type === 'gold' && currentEffect.type === 'gold') {
        currentEffect.gold += effect.gold;
        return;
    }
    if (effect.type === 'restocks' && currentEffect.type === 'restocks') {
        currentEffect.restocks += effect.restocks;
        return;
    }
}
function hasStartShopEffect(type, sourceSquadIndex) {
    return GAME_DATA.startShopEffects.some(function (ce) { return ce.type === type && ce.sourceSquadIndex === sourceSquadIndex; });
}
function applyStartShopEffects(effects, world) {
    var e_128, _a;
    if (!effects || !world)
        return;
    var friendBalls = world.select.typeAll(Ball).filter(function (ball) { return ball.team === 'friend' && !ball.isInShop; });
    var _loop_14 = function (effect) {
        var ball = friendBalls.find(function (b) { return b.squadIndexReference === effect.sourceSquadIndex; });
        if (effect.type === 'buff') {
            if (!ball)
                return "continue";
            var health_1 = effect.health;
            var damage_1 = effect.damage;
            // Add new effect application here
            if (health_1 !== 0 || damage_1 !== 0) {
                ball.runScript(function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/];
                            case 1:
                                _a.sent();
                                ball.buff(damage_1, health_1);
                                return [2 /*return*/];
                        }
                    });
                });
            }
        }
        if (effect.type === 'gold') {
            GAME_DATA.gold += effect.gold;
            if (ball)
                animateGiveOrTakeShopGold(world, ball, effect.gold);
        }
        if (effect.type === 'restocks') {
            GAME_DATA.freeRestocksUntilPlay += effect.restocks;
        }
    };
    try {
        for (var effects_1 = __values(effects), effects_1_1 = effects_1.next(); !effects_1_1.done; effects_1_1 = effects_1.next()) {
            var effect = effects_1_1.value;
            _loop_14(effect);
        }
    }
    catch (e_128_1) { e_128 = { error: e_128_1 }; }
    finally {
        try {
            if (effects_1_1 && !effects_1_1.done && (_a = effects_1.return)) _a.call(effects_1);
        }
        finally { if (e_128) throw e_128.error; }
    }
}
var StatBox = /** @class */ (function (_super) {
    __extends(StatBox, _super);
    function StatBox(type) {
        var _this = _super.call(this, {
            copyFromParent: ['layer'],
        }) || this;
        _this.type = type;
        _this.setText('0');
        return _this;
    }
    StatBox.prototype.setText = function (text) {
        this.text = text;
        this.setTexture(StatBox.cache[this.type].get(this.text).get(this.color));
    };
    StatBox.prototype.setColor = function (color) {
        this.color = color;
        this.setTexture(StatBox.cache[this.type].get(this.text).get(this.color));
    };
    StatBox.newTexture = function (type, value, color) {
        var spriteText = new SpriteText({
            text: value,
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            effects: { outline: { color: 0x000000 } },
            style: { color: color },
        });
        var texture = new BasicTexture(Math.max(spriteText.getTextWidth() + 1, 9), 7, "StatBox.cache." + type, false);
        AssetCache.getTexture(type + "box").renderTo(texture, { x: (texture.width - 1) / 2, y: 3 });
        spriteText.render(texture, (texture.width - 1) / 2 + 1, 4);
        texture.immutable = true;
        return new AnchoredTexture(texture, 0.5, 0.5);
    };
    StatBox.cache = {
        'dmg': new LazyDict(function (value) { return new LazyDictNumber(function (color) { return StatBox.newTexture('dmg', value, color); }); }),
        'hp': new LazyDict(function (value) { return new LazyDictNumber(function (color) { return StatBox.newTexture('hp', value, color); }); }),
    };
    return StatBox;
}(Sprite));
var Tags;
(function (Tags) {
    Tags.DELAY_PLAY = 'delayPlay';
    Tags.BALL_OF_ICE_BUFF = 'ballOfIceBuff';
    Tags.PURCHASED_THIS_SHOP_PHASE = 'purchasedThisShopPhase';
    Tags.SPAWNED_BY_FACTORY = 'spawnedByFactory';
    Tags.MODIFIER_ICON = 'modifierIcon';
    function DELAY_RESOLVE(team) {
        return "delayResolve_" + team;
    }
    Tags.DELAY_RESOLVE = DELAY_RESOLVE;
    Tags.FORCE_DELAY_RESOLVE = 'forceDelayResolve';
})(Tags || (Tags = {}));
var TheaterWithAchievements = /** @class */ (function (_super) {
    __extends(TheaterWithAchievements, _super);
    function TheaterWithAchievements(config) {
        var _this = _super.call(this, config) || this;
        _this.currentAchievementCompletion = _.mapObject(ACHIEVEMENTS, function (ach, achName, obj) { return hasCompletedAchievement(achName); });
        _this.addWorldObject(new BattleSpeedController());
        _this.addWorldObject(new AbilitySystem());
        return _this;
    }
    TheaterWithAchievements.prototype.update = function () {
        this.updateBattleSpeedController();
        if (this.currentWorld) {
            updateInGameUpdateAchievements(this.currentWorld);
            updateAlmanacEntriesSeen(this.currentWorld);
        }
        this.updateAchievementCompletion();
        _super.prototype.update.call(this);
    };
    TheaterWithAchievements.prototype.loadStageImmediate = function (stage, transition, onTransitioned) {
        _super.prototype.loadStageImmediate.call(this, stage, transition, onTransitioned);
        this.select.type(BattleSpeedController).reset();
        this.select.type(BattleSpeedController).enabled = false;
    };
    TheaterWithAchievements.prototype.updateBattleSpeedController = function () {
        if (!this.currentWorld)
            return;
        var battleSpeedController = this.select.type(BattleSpeedController);
        if (GAME_MODE === 'mm') {
            if (battleSpeedController.enabled) {
                this.stageManager.currentWorld.timeScale = battleSpeedController.getProducedTimescale();
            }
            this.stageManager.currentWorldAsWorldObject.multiExecutionTimeScale = 1;
        }
        else {
            if (battleSpeedController.enabled) {
                this.stageManager.currentWorld.timeScale = 1;
                this.stageManager.currentWorldAsWorldObject.multiExecutionTimeScale = battleSpeedController.getProducedTimescale();
            }
            else {
                this.stageManager.currentWorldAsWorldObject.multiExecutionTimeScale = 1;
            }
        }
    };
    TheaterWithAchievements.prototype.updateAchievementCompletion = function () {
        var completedAchivements = [];
        for (var ach in ACHIEVEMENTS) {
            var achName = ach;
            if (!this.currentAchievementCompletion[achName] && hasCompletedAchievement(achName)) {
                completedAchivements.push(achName);
            }
            this.currentAchievementCompletion[achName] = hasCompletedAchievement(achName);
        }
        if (completedAchivements.length > 0) {
            this.sendAchievementGetNotifications(completedAchivements);
        }
    };
    TheaterWithAchievements.prototype.sendAchievementGetNotifications = function (achNames) {
        for (var i = 0; i < achNames.length; i++) {
            this.sendAchievementGetNotification(achNames[i], i);
        }
        this.playSound('achievement');
    };
    TheaterWithAchievements.prototype.sendAchievementGetNotification = function (achName, i) {
        setSheenSeen('unlockables', false);
        var theater = this;
        this.runScript(function () {
            var box, iconBox, beams, reward, progress, desc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        box = theater.addWorldObject(new Sprite({
                            x: theater.width + 103, y: 24 + 44 * i,
                            texture: AchievementsMenu.achievementBox.get(),
                        }));
                        iconBox = box.addChild(new Sprite({
                            x: -83, y: 0,
                            texture: 'achievementrewardbox',
                        }));
                        beams = iconBox.addChild(new Sprite({
                            texture: 'buffbeams',
                            scale: 20 / 64,
                            vangle: 90,
                        }));
                        reward = iconBox.addChild(ACHIEVEMENTS[achName].rewardObjectFactory());
                        progress = box.addChild(new SpriteText({
                            x: 100, y: 18,
                            text: "COMPLETE!",
                            font: 'smallnumbers',
                            style: { color: 0x00FF00 },
                            anchor: Vector2.BOTTOM_RIGHT,
                        }));
                        desc = box.addChild(new SpriteText({
                            x: -60, y: 0,
                            text: ACHIEVEMENTS[achName].description,
                            anchor: Vector2.CENTER_LEFT,
                            justify: 'left',
                            maxWidth: 160,
                            style: { color: ACHIEVEMENTS[achName].secret ? 0xFFD800 : 0xFFFFFF },
                        }));
                        return [4 /*yield*/, S.tween(1, box, 'x', box.x, theater.width - 103 + 3, Tween.Easing.OutQuad)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(4)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.tween(1, box, 'x', box.x, theater.width + 103, Tween.Easing.InQuad)];
                    case 3:
                        _a.sent();
                        box.removeFromWorld();
                        return [2 /*return*/];
                }
            });
        });
    };
    return TheaterWithAchievements;
}(Theater));
var Trampoline = /** @class */ (function (_super) {
    __extends(Trampoline, _super);
    function Trampoline(x, y, flipped) {
        return _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromSingleTexture({ name: 'idle', texture: 'trampoline/0' }),
                Animations.fromTextureList({ name: 'boing', textures: ['trampoline/1'], frameRate: 8, nextFrameRef: 'idle/0' }),
            ],
            flipX: flipped,
            layer: Battle.Layers.walls,
            physicsGroup: Battle.PhysicsGroups.walls,
            immovable: true,
            bounds: new SlopeBounds(-401, -158, 802, 401, flipped ? 'upleft' : 'upright'),
        }) || this;
    }
    Trampoline.prototype.onCollide = function (collision) {
        var ball = collision.other.obj;
        if (ball instanceof Ball && ball.state === Ball.States.BATTLE && !ball.v.isZero()) {
            ball.changeVelocityForBounce(Ball.minTrampolineBounceSpeed);
            this.playAnimation('boing', true);
            this.world.playSound('trampoline', { limit: 4 });
        }
        _super.prototype.onCollide.call(this, collision);
    };
    return Trampoline;
}(Sprite));
var TutorialNextFilter = /** @class */ (function (_super) {
    __extends(TutorialNextFilter, _super);
    function TutorialNextFilter() {
        return _super.call(this, {
            uniforms: { 'vec3 tintColor': [1, 0, 0] },
            code: "\n                outp.rgb *= tintColor;\n            "
        }) || this;
    }
    TutorialNextFilter.prototype.setTintColor = function (tintColor) {
        this.setUniform('tintColor', tintColor);
    };
    return TutorialNextFilter;
}(TextureFilter));
function addTextTyped(spriteText, text, typeSpeedMin, typeSpeedMax, onType, onCustomCommand) {
    return function () {
        var i, currentSpeed, j, tag, parts, j, j, textToAdd;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    i = 0;
                    currentSpeed = 1;
                    _a.label = 1;
                case 1:
                    if (!(i < text.length)) return [3 /*break*/, 12];
                    if (!(text[i] === '{')) return [3 /*break*/, 5];
                    j = text.indexOf('}', i);
                    tag = text.substring(i + 1, j);
                    parts = tag.split(' ');
                    if (!(parts[0] === 'wait')) return [3 /*break*/, 3];
                    return [4 /*yield*/, S.wait(parseFloat(parts[1]))];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    if (parts[0] === 'speed') {
                        currentSpeed = parseFloat(parts[1]);
                    }
                    else {
                        onCustomCommand(parts);
                    }
                    _a.label = 4;
                case 4:
                    i = j + 1;
                    return [3 /*break*/, 1];
                case 5:
                    if (text[i] === '[') {
                        j = text.indexOf(']', i);
                        spriteText.setText(spriteText.getCurrentText() + text.substring(i, j + 1));
                        i = j + 1;
                        return [3 /*break*/, 1];
                    }
                    if (text[i] === '<') {
                        j = text.indexOf('>', i);
                        spriteText.setText(spriteText.getCurrentText() + text.substring(i, j + 1));
                        i = j + 1;
                        return [3 /*break*/, 1];
                    }
                    if (!(text[i] === ' ' || text[i] === '\n')) return [3 /*break*/, 10];
                    spriteText.setText(spriteText.getCurrentText() + text[i]);
                    if (!(i > 0)) return [3 /*break*/, 9];
                    if (!(text[i - 1] === ',')) return [3 /*break*/, 7];
                    return [4 /*yield*/, S.wait(0.15)];
                case 6:
                    _a.sent();
                    _a.label = 7;
                case 7:
                    if (!(text[i - 1] === '.' || text[i - 1] === '?' || text[i - 1] === '!')) return [3 /*break*/, 9];
                    return [4 /*yield*/, S.wait(0.5)];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    i++;
                    return [3 /*break*/, 1];
                case 10:
                    textToAdd = '';
                    if (text[i] === '\\') {
                        textToAdd += text[i];
                        i++;
                    }
                    if (i < text.length) {
                        textToAdd += text[i];
                    }
                    spriteText.setText(spriteText.getCurrentText() + textToAdd);
                    onType(i / text.length, i < text.length ? text[i] : '');
                    return [4 /*yield*/, S.wait(Random.float(1 / currentSpeed / typeSpeedMax, 1 / currentSpeed / typeSpeedMin))];
                case 11:
                    _a.sent();
                    i++;
                    return [3 /*break*/, 1];
                case 12: return [2 /*return*/];
            }
        });
    };
}
var ARENA_FIRST_NAME = 'Classic';
var ARENA_BDAY_NAME = 'Birthday';
var ARENA_SPACE_NAME = 'Core';
var ARENA_ICE_NAME = 'Frozen';
var ARENA_GRAVITY_NAME = 'Trampoline';
var ARENA_FACTORY_NAME = 'Factory';
function arenaIdToName(id) {
    if (id === Arenas.ARENA_BDAY)
        return ARENA_BDAY_NAME;
    if (id === Arenas.ARENA_SPACE)
        return ARENA_SPACE_NAME;
    if (id === Arenas.ARENA_ICE)
        return ARENA_ICE_NAME;
    if (id === Arenas.ARENA_GRAVITY)
        return ARENA_GRAVITY_NAME;
    if (id === Arenas.ARENA_FACTORY)
        return ARENA_FACTORY_NAME;
    return ARENA_FIRST_NAME;
}
function arenaNameToId(name) {
    if (name === ARENA_BDAY_NAME)
        return Arenas.ARENA_BDAY;
    if (name === ARENA_SPACE_NAME)
        return Arenas.ARENA_SPACE;
    if (name === ARENA_ICE_NAME)
        return Arenas.ARENA_ICE;
    if (name === ARENA_GRAVITY_NAME)
        return Arenas.ARENA_GRAVITY;
    if (name === ARENA_FACTORY_NAME)
        return Arenas.ARENA_FACTORY;
    return Arenas.ARENA_FIRST;
}
function buffText(dmg, hp) {
    return "[r]" + dmg + "<sword>[/r] [g]" + hp + "<heart>[/g]";
}
function crownedName(name) {
    return "[gold][offsetx -3]<crown>[/offsetx][/gold]" + name;
}
function getAllies(world, source) {
    if (!world)
        return [source];
    return world.select.typeAll(Ball).filter(function (ball) { return ball.team === source.team && ball.alive && !ball.dead; });
}
function getAlliesNotSelf(world, source) {
    if (!world)
        return [];
    return getAllies(world, source).filter(function (ball) { return ball !== source; });
}
function getEnemies(world, source) {
    if (!world)
        return [];
    return world.select.typeAll(Ball).filter(function (ball) { return ball.team !== source.team && ball.alive && !ball.dead; });
}
function glitchSmall(world) {
    return function () {
        var g, glitchSound;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    g = new Effects.Filters.Glitch(30, 1, 30);
                    g.setUniform('t', Random.float(0, 10));
                    world.effects.post.filters.push(g);
                    glitchSound = world.playSound('arg/glitch_dialog');
                    glitchSound.volume = 0.5;
                    return [4 /*yield*/, S.wait(0.3)];
                case 1:
                    _a.sent();
                    glitchSound.stop();
                    A.removeAll(world.effects.post.filters, g);
                    return [2 /*return*/];
            }
        });
    };
}
function hash(s) {
    // From https://stackoverflow.com/a/15710692
    return s.split("").reduce(function (a, b) {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
    }, 0);
}
function juiceObject(obj, power) {
    var _a;
    (_a = obj.data.juiceScript) === null || _a === void 0 ? void 0 : _a.finishImmediately();
    var startScaleX = obj.scaleX;
    var startScaleY = obj.scaleY;
    obj.data.juiceScript = obj.runScript(function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, [
                        S.tween(0.5, obj, 'scaleX', (Math.pow(1.2, power)) * startScaleX, startScaleX, Tween.Easing.OutElastic(1)),
                        S.tween(0.5, obj, 'scaleY', (Math.pow(0.85, power)) * startScaleY, startScaleY, Tween.Easing.OutElastic(1)),
                    ]];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function juiceButton(power) {
    return function () {
        var worldObject = this.worldObject;
        if (!(worldObject instanceof Sprite))
            return;
        var sprite = worldObject;
        juiceObject(sprite, power);
    };
}
var PACK_CLASSIC_NAME = 'Classic';
var PACK_COMMUNITY_NAME = 'Community';
var PACK_WEEKLY_NAME = 'Shuffle';
var PACK_ALL_NAME = 'All';
var PACK_ALL_ID = 'all';
function packIdToName(id) {
    if (id === 'classic')
        return PACK_CLASSIC_NAME;
    if (id === 'community')
        return PACK_COMMUNITY_NAME;
    if (id === 'weekly')
        return PACK_WEEKLY_NAME;
    return 'Unknown';
}
function packNameToId(name) {
    if (name === PACK_CLASSIC_NAME)
        return 'classic';
    if (name === PACK_COMMUNITY_NAME)
        return 'community';
    if (name === PACK_WEEKLY_NAME)
        return 'weekly';
    return 'classic';
}
function playMusicNoRestart(key, fadeTime) {
    if (global.game.musicManager.currentMusicKey !== key)
        global.game.playMusic(key, fadeTime);
}
var RectangleOutlineObject = /** @class */ (function (_super) {
    __extends(RectangleOutlineObject, _super);
    function RectangleOutlineObject(x, y, width, height, color, alpha, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, __assign({ x: x, y: y }, config)) || this;
        _this.width = width;
        _this.height = height;
        _this.color = color;
        _this.alpha = alpha;
        return _this;
    }
    RectangleOutlineObject.prototype.render = function (texture, x, y) {
        if (this.width > 0 && this.height > 0) {
            Draw.brush.color = this.color;
            Draw.brush.alpha = this.alpha;
            Draw.brush.thickness = 1;
            Draw.rectangleOutline(texture, x, y, this.width, this.height, Draw.ALIGNMENT_INNER);
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    return RectangleOutlineObject;
}(WorldObject));
function secondsToFormattedTime(seconds) {
    seconds = Math.max(seconds, 0);
    var left = Math.ceil(seconds);
    var s = left % 60;
    left = (left - s) / 60;
    var m = left % 60;
    left = (left - m) / 60;
    var h = left;
    var spadded = St.padLeft("" + s, 2, '0');
    var mpadded = St.padLeft("" + m, 2, '0');
    if (h === 0) {
        return m + ":" + spadded;
    }
    return h + ":" + mpadded + ":" + spadded;
}
function shake(world, intensity, time) {
    return function () {
        var timer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!world || world === _MENUS_ARENA_WORLD || world.camera.shakeIntensity >= intensity)
                        return [2 /*return*/];
                    world.camera.shakeIntensity += intensity;
                    timer = new Timer(time);
                    _a.label = 1;
                case 1:
                    if (!!timer.done) return [3 /*break*/, 3];
                    timer.update(global.script.delta);
                    return [4 /*yield*/];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 3:
                    world.camera.shakeIntensity -= intensity;
                    return [2 /*return*/];
            }
        });
    };
}
// Transform from YYYY-MM-DD to MM/DD
function transformDailyDate(date) {
    var month = date[5] === '0' ? date.substring(6, 7) : date.substring(5, 7);
    var day = date[8] === '0' ? date.substring(9, 10) : date.substring(8, 10);
    return month + "/" + day;
}
function waitWithTimeout(timeoutMs, result, fn) {
    return function () {
        var startTime;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    startTime = Date.now();
                    fn();
                    return [4 /*yield*/, S.waitUntil(function () { return result.done || Date.now() - startTime > timeoutMs; })];
                case 1:
                    _a.sent();
                    if (!result.done) {
                        result.err = 'TIMED_OUT';
                    }
                    return [2 /*return*/];
            }
        });
    };
}
var VsStatusCheckmarker = /** @class */ (function (_super) {
    __extends(VsStatusCheckmarker, _super);
    function VsStatusCheckmarker(yourCheckmark, enemyCheckmark) {
        var _this = _super.call(this) || this;
        _this.yourCheckmark = yourCheckmark;
        _this.enemyCheckmark = enemyCheckmark;
        _this.addTimer(2, function () { return _this.fetchAndUpdate(); }, Infinity);
        return _this;
    }
    VsStatusCheckmarker.prototype.fetchAndUpdate = function () {
        var _this = this;
        API.getvsgame(function (vsgame, err) {
            _this.yourCheckmark.setVisible(!!vsgame.yoursquad);
            _this.enemyCheckmark.setVisible(!!vsgame.enemysquad);
        }, GAME_DATA.gameId, VS_GAME.yourname, false, false, Persistence.getProfileId());
    };
    return VsStatusCheckmarker;
}(WorldObject));
var WarningBox = /** @class */ (function (_super) {
    __extends(WarningBox, _super);
    function WarningBox(x, y, tipe, onPlay) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: InfoBox.getTextureForSize(WarningBox.WIDTH, WarningBox.HEIGHT),
            layer: Battle.Layers.warning,
        }) || this;
        if (tipe === 'gold') {
            _this.content = _this.addChild(new SpriteText({
                y: -WarningBox.HEIGHT / 2 + WarningBox.PADDING,
                text: "Gold does not carry over to the next round! Continue?",
                anchor: Vector2.TOP,
                maxWidth: WarningBox.WIDTH - 2 * WarningBox.PADDING,
                copyFromParent: ['layer'],
            }));
        }
        else {
            if (loadNoBalls()) {
                _this.content = _this.addChild(new Sprite({
                    x: -1, y: -WarningBox.HEIGHT / 2 + WarningBox.PADDING - 3,
                    texture: 'noballs',
                    copyFromParent: ['layer'],
                }));
            }
            else {
                _this.content = _this.addChild(new SpriteText({
                    y: -WarningBox.HEIGHT / 2 + WarningBox.PADDING + 8,
                    text: "Your squad has no balls! Continue?",
                    anchor: Vector2.TOP,
                    maxWidth: WarningBox.WIDTH - 2 * WarningBox.PADDING,
                    copyFromParent: ['layer'],
                }));
                saveNoBalls(true);
            }
        }
        _this.cancelButton = _this.addChild(new MenuTextButton({
            x: -WarningBox.WIDTH / 2 + WarningBox.PADDING + 8, y: WarningBox.HEIGHT / 2 - WarningBox.PADDING,
            text: "Cancel",
            anchor: Vector2.BOTTOM_LEFT,
            copyFromParent: ['layer'],
            onClick: function () {
                global.game.playSound('click');
                WarningBox.hide(_this.world);
            }
        }));
        _this.playButton = _this.addChild(new MenuTextButton({
            x: WarningBox.WIDTH / 2 - WarningBox.PADDING - 8, y: WarningBox.HEIGHT / 2 - WarningBox.PADDING,
            text: "Play >",
            anchor: Vector2.BOTTOM_RIGHT,
            copyFromParent: ['layer'],
            onClick: function () {
                global.game.playSound('click');
                WarningBox.hide(_this.world);
                onPlay();
            }
        }));
        return _this;
    }
    WarningBox.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectAfter(this.content, this);
        World.Actions.orderWorldObjectAfter(this.cancelButton, this);
        World.Actions.orderWorldObjectAfter(this.playButton, this);
    };
    WarningBox.WIDTH = 184;
    WarningBox.HEIGHT = 84;
    WarningBox.PADDING = 6;
    return WarningBox;
}(Sprite));
(function (WarningBox) {
    function isShowing(world) {
        return !!world.select.type(WarningBox, false);
    }
    WarningBox.isShowing = isShowing;
    function show(world, tipe, onPlay) {
        var _a, _b, _c, _d;
        world.addWorldObject(new WarningBox(world.width / 2, world.height / 2, tipe, onPlay));
        (_a = world.select.type(BallMover)) === null || _a === void 0 ? void 0 : _a.removeFromWorld();
        (_b = world.select.type(BallFreezer)) === null || _b === void 0 ? void 0 : _b.removeFromWorld();
        (_c = world.select.type(BallHighlighter)) === null || _c === void 0 ? void 0 : _c.removeFromWorld();
        (_d = world.select.type(InfoBox)) === null || _d === void 0 ? void 0 : _d.removeFromWorld();
        var boundsInfoBox = world.select.type(BoundsInfoBox);
        if (boundsInfoBox)
            boundsInfoBox.enabled = false;
        var restockButton = world.select.name('restockbutton').getModule(Button);
        if (restockButton)
            restockButton.enabled = false;
        var playButton = world.select.name('playbutton').getModule(Button);
        if (playButton)
            playButton.enabled = false;
        var playButtonVs = world.select.name('playbutton_vs').getModule(Button);
        if (playButtonVs)
            playButtonVs.enabled = false;
    }
    WarningBox.show = show;
    function hide(world) {
        if (!world.select.type(BallMover, false))
            world.addWorldObject(new BallMover());
        if (!world.select.type(BallFreezer, false))
            world.addWorldObject(new BallFreezer());
        if (!world.select.type(BallHighlighter, false))
            world.addWorldObject(new BallHighlighter());
        if (!world.select.type(InfoBox, false))
            world.addWorldObject(new InfoBox());
        world.select.typeAll(WarningBox).forEach(function (wb) { return wb.removeFromWorld(); });
        var boundsInfoBox = world.select.type(BoundsInfoBox);
        if (boundsInfoBox)
            boundsInfoBox.enabled = true;
        var restockButton = world.select.name('restockbutton').getModule(Button);
        if (restockButton)
            restockButton.enabled = true;
        var playButton = world.select.name('playbutton').getModule(Button);
        if (playButton)
            playButton.enabled = true;
        var playButtonVs = world.select.name('playbutton_vs').getModule(Button);
        if (playButtonVs)
            playButtonVs.enabled = true;
    }
    WarningBox.hide = hide;
})(WarningBox || (WarningBox = {}));
var Weekly = /** @class */ (function () {
    function Weekly() {
    }
    Weekly.load = function (callbacks) {
        var _this = this;
        var now = Date.now();
        if (this.LIVE_WEEK > 0 && this.LAST_FETCHED > 0 && now - this.LAST_FETCHED < 300000) { // Five minutes
            callbacks.onSuccess();
            return;
        }
        API.getweekly(function (response, error) {
            if (!error && response && response.week !== undefined) {
                _this.set(response.week);
                callbacks.onSuccess();
                return;
            }
            console.error("Failed to get weekly: ", error);
            callbacks.onError();
        });
    };
    Weekly.set = function (week) {
        this.LIVE_WEEK = week;
        this.LAST_FETCHED = Date.now();
        this.hasLoaded = true;
    };
    Weekly.hasLoaded = false;
    return Weekly;
}());
var YourTeamWorld = /** @class */ (function (_super) {
    __extends(YourTeamWorld, _super);
    function YourTeamWorld(world, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, __assign({ texture: new BasicTexture(world.width, world.height, 'YourTeamWorld.texture'), useGlobalTime: true }, config)) || this;
        _this.containedWorld = world;
        return _this;
    }
    YourTeamWorld.prototype.update = function () {
        _super.prototype.update.call(this);
        this.containedWorld.update();
    };
    YourTeamWorld.prototype.render = function (texture, x, y) {
        this.getTexture().clear();
        this.containedWorld.render(this.getTexture(), 0, 0);
        _super.prototype.render.call(this, texture, x, y);
    };
    return YourTeamWorld;
}(Sprite));
function createTeamWorld(squad, squadY, viewable) {
    var _a;
    if (squadY === void 0) { squadY = 0; }
    if (viewable === void 0) { viewable = true; }
    var world = new World({
        backgroundAlpha: 0,
        layers: [
            { name: Battle.Layers.balls },
            { name: Battle.Layers.infobox },
        ],
        physicsGroups: (_a = {}, _a[Battle.PhysicsGroups.balls] = {}, _a),
    });
    if (viewable) {
        world.addWorldObject(new BallHighlighter());
        world.addWorldObject(new InfoBox());
    }
    world.addWorldObject(new AbilitySystem());
    if (squad) {
        addSquadToTeamWorld(world, squadY, squad, 'friend', false);
    }
    var yourTeamWorld = new YourTeamWorld(world, { alpha: 0 });
    return yourTeamWorld;
}
function addSquadToTeamWorld(world, ballY, squad, team, flipped) {
    if (squad.balls.length === 0) {
        world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: ballY,
            text: '?????',
            anchor: Vector2.CENTER,
        }));
    }
    else {
        var positions = getYourSquadBallPositions(squad.balls, flipped);
        for (var i = 0; i < squad.balls.length; i++) {
            var ball = world.addWorldObject(squadBallToWorldBall(squad.balls[i], squad, i, team));
            ball.x = global.gameWidth / 2 + positions[i].x;
            ball.y = ballY + positions[i].y;
            ball.colliding = false;
            ball.isInYourSquadScene = true;
            ball.showAllStats();
        }
    }
}
function getYourSquadBallPositions(balls, flipped) {
    var d = flipped ? -1 : 1;
    if (balls.length === 0)
        return [];
    if (balls.length === 1)
        return [vec2(0, 0)];
    if (balls.length === 2)
        return [vec2(-32, 0), vec2(32, 0)];
    if (balls.length === 3)
        return [vec2(-64, 0), vec2(0, 0), vec2(64, 0)];
    var scale = 16;
    if (balls.length >= 9)
        scale = 14;
    return balls.map(function (_, i) { return vec2(scale - scale * balls.length + 2 * scale * i, -10 * Math.pow((-1), i) * d); });
}
var ARG;
(function (ARG) {
    ARG.Layers = {
        ground: 'ground',
        onground: 'onground',
        main: 'main',
        fg: 'fg',
        overlay: 'overlay',
    };
    ARG.PhysicsGroups = {
        walls: 'walls',
        iwalls: 'iwalls',
        player: 'player',
        boxes: 'boxes',
    };
})(ARG || (ARG = {}));
var ArgBall = /** @class */ (function (_super) {
    __extends(ArgBall, _super);
    function ArgBall(x, y, team) {
        var _this = _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromSingleTexture({ name: 'friend_idle', texture: 'arg/ball/3' }),
                Animations.fromSingleTexture({ name: 'enemy_idle', texture: 'arg/ball/7' }),
            ],
            defaultAnimation: team + "_idle",
            effects: { outline: { color: 0xFFFFFF } },
            physicsGroup: 'balls',
            bounds: new CircleBounds(0, 0, 6),
        }) || this;
        _this.acceleration = 250;
        _this.maxSpeed = 150;
        _this.damage = 1;
        _this.health = 1;
        _this.team = team;
        _this.level = 1;
        _this.isInShop = false;
        _this.stars = _this.addChild(new Sprite({
            y: -6,
            effects: { pre: { filters: [new Effects.Filters.Outline(0x000000, 1), new Effects.Filters.Outline(0xFFFFFF, 1)] } },
        }));
        _this.stateMachine.addState('prep', {});
        _this.stateMachine.addState('battle', {
            callback: function () {
                _this.damage = _this.level;
                _this.health = _this.level + 2;
                _this.stars.setVisible(false);
            },
        });
        return _this;
    }
    ArgBall.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.state === 'battle') {
            var acceleration = this.getFlow().scale(this.acceleration);
            if (this.team === 'enemy')
                acceleration.scale(-1);
            this.v.add(acceleration.scale(this.delta));
            this.v.clampMagnitude(this.maxSpeed);
            if (!this.isOnScreen()) {
                this.kill();
            }
        }
    };
    ArgBall.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectAfter(this.stars, this);
        this.stars.setTexture(ArgBall.getStarsTexture(this.level - 1));
    };
    ArgBall.prototype.levelUp = function () {
        this.level++;
        this.world.playSound('arg/sabwin');
    };
    ArgBall.prototype.takeDamage = function (amount) {
        var _this = this;
        this.health -= amount;
        this.world.playSound('arg/sabhurt');
        if (this.health <= 0) {
            this.world.addWorldObject(new Sprite({
                p: this,
                texture: 'arg/ball/3',
                effects: { outline: { color: 0xFFFFFF }, silhouette: { color: 0xFFFFFF } },
                life: 0.1,
            }));
            this.kill();
            return;
        }
        this.runScript(S.chain(S.doOverTime(1, function (t) {
            if (_this.everyNFrames(2)) {
                _this.setVisible(!_this.isVisible());
            }
        }), S.call(function () { return _this.setVisible(true); })));
    };
    ArgBall.prototype.isCollidingWith = function (other) {
        if (this.isInShop)
            return false;
        return _super.prototype.isCollidingWith.call(this, other);
    };
    ArgBall.prototype.onCollide = function (collision) {
        _super.prototype.onCollide.call(this, collision);
        var other = collision.other.obj;
        if (other instanceof ArgBall && other.team !== this.team) {
            this.takeDamage(other.getDamageForCollision());
        }
        if (other.physicsGroup === 'walls') {
            this.world.playSound('arg/sabwall');
        }
    };
    ArgBall.prototype.getDamageForCollision = function () {
        return this.damage * this.getSpeed() / this.maxSpeed;
    };
    ArgBall.prototype.getFlow = function () {
        return this.getPosition().subtract(157 / 2, 107 / 2).normalize().rotate(90);
    };
    ArgBall.getStarsTexture = function (stars) {
        if (stars <= 0)
            return Texture.NONE;
        stars = M.clamp(stars, 1, 64);
        return lazy("ArgBallStarsTexture(" + stars + ")", function () {
            var texture = new BasicTexture(5 * stars - 3, 2, 'ArgBall.getStarsTexture', false);
            Draw.brush.color = 0xFFDB00;
            Draw.brush.alpha = 1;
            for (var i = 0; i < stars; i++) {
                Draw.rectangleSolid(texture, 5 * i, 0, 2, 2);
            }
            return new AnchoredTexture(texture, 0.5, 0.5);
        });
    };
    return ArgBall;
}(Sprite));
var ArgBallMover = /** @class */ (function (_super) {
    __extends(ArgBallMover, _super);
    function ArgBallMover() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ArgBallMover.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        var mouseBounds = this.world.getWorldMouseBounds();
        var balls = this.world.select.typeAll(ArgBall);
        if (Input.justDown('click') && !this.movingThing) {
            var intersectingBalls = balls.filter(function (ball) { return ball.bounds.containsPoint(mouseBounds); });
            if (intersectingBalls.length > 0) {
                this.movingThing = intersectingBalls[0];
                this.movingThingD = this.movingThing.getPosition().subtract(mouseBounds);
                this.movingThingStartPos = this.movingThing.getPosition();
                this.movingThing.colliding = false;
                World.Actions.moveWorldObjectToFront(this.movingThing);
                this.world.playSound('arg/sabpickup');
            }
        }
        if (Input.justUp('click') && this.movingThing) {
            var ballsInSquad = balls.filter(function (ball) { return !ball.isInShop; });
            var ballForLevelUp = balls.find(function (ball) { return ball !== _this.movingThing && ball.level === _this.movingThing.level && ball.bounds.containsPoint(mouseBounds); });
            if (ballForLevelUp) {
                ballForLevelUp.levelUp();
                this.movingThing.kill();
            }
            else if (this.movingThing.x > 80 || (this.movingThing.isInShop && ballsInSquad.length >= 5)) {
                this.movingThing.teleport(this.movingThingStartPos);
            }
            else {
                this.movingThing.isInShop = false;
                this.movingThing.colliding = true;
            }
            this.movingThing = undefined;
            this.movingThingD = undefined;
            this.movingThingStartPos = undefined;
            this.world.playSound('arg/sabputdown');
        }
        if (this.movingThing) {
            this.movingThing.teleport(mouseBounds.x + this.movingThingD.x, mouseBounds.y + this.movingThingD.y);
        }
    };
    return ArgBallMover;
}(WorldObject));
var ArgAutoBalls = /** @class */ (function (_super) {
    __extends(ArgAutoBalls, _super);
    function ArgAutoBalls(x, y) {
        return _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'play', textureRoot: 'arg/autoballs', textures: [0, 1, 2, 3, 4, 5, 6, 7], frameRate: 10, count: Infinity }),
            ],
            defaultAnimation: 'play',
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-10, -17, 20, 17),
            immovable: true,
        }) || this;
    }
    return ArgAutoBalls;
}(Sprite));
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(x, y, textureRoot) {
        var _this = _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'idle_front', textureRoot: textureRoot, textures: [0, 1], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_front', textureRoot: textureRoot, textures: [2, 3, 4, 5], frameRate: 6, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_back', textureRoot: textureRoot, textures: [6, 7], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_back', textureRoot: textureRoot, textures: [8, 9, 10, 11], frameRate: 6, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_side', textureRoot: textureRoot, textures: [12, 13], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_side', textureRoot: textureRoot, textures: [14, 15, 16, 17], frameRate: 6, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_front_grab', textureRoot: textureRoot, textures: [18], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_front_grab', textureRoot: textureRoot, textures: [20, 21, 22, 23], frameRate: 4, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_back_grab', textureRoot: textureRoot, textures: [24], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_back_grab', textureRoot: textureRoot, textures: [26, 27, 28, 29], frameRate: 4, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_side_grab', textureRoot: textureRoot, textures: [30], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_side_grab', textureRoot: textureRoot, textures: [32, 33, 34, 35], frameRate: 4, count: Infinity }),
            ],
            defaultAnimation: 'idle_front',
            effects: { outline: { color: 0x000000 } },
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.player,
            bounds: new RectBounds(-4, -2, 8, 3),
        }) || this;
        _this.direction = Vector2.DOWN;
        _this.walkVolume = 1;
        _this.grabBounds = new RectBounds(-4, -2, 8, 3, _this);
        _this.walkTimer = new Timer(1 / 3, function () {
            _this.world.playSound('arg/walk').volume = _this.walkVolume;
        }, Infinity);
        return _this;
    }
    Object.defineProperty(Player.prototype, "speed", {
        get: function () { return this.grabbing ? 36 : 48; },
        enumerable: false,
        configurable: true
    });
    Player.prototype.update = function () {
        var e_129, _a;
        var haxis = M.axis(this.controller.left, this.controller.right);
        var vaxis = M.axis(this.controller.up, this.controller.down);
        this.updateMovement(haxis, vaxis);
        this.updateDirection(haxis, vaxis);
        var boxes = this.world.select.typeAll(ArgBox);
        var closestBox = this.getClosestBox();
        try {
            for (var boxes_1 = __values(boxes), boxes_1_1 = boxes_1.next(); !boxes_1_1.done; boxes_1_1 = boxes_1.next()) {
                var box = boxes_1_1.value;
                box.tint = (!this.grabbing && box === closestBox) ? 0xBBBBBB : 0xFFFFFF;
            }
        }
        catch (e_129_1) { e_129 = { error: e_129_1 }; }
        finally {
            try {
                if (boxes_1_1 && !boxes_1_1.done && (_a = boxes_1.return)) _a.call(boxes_1);
            }
            finally { if (e_129) throw e_129.error; }
        }
        this.updateGrab(closestBox);
        _super.prototype.update.call(this);
        this.updateAnimation(haxis, vaxis);
        this.updateWalkSound(haxis, vaxis);
    };
    Player.prototype.updateMovement = function (haxis, vaxis) {
        this.v.x = haxis * this.speed;
        this.v.y = vaxis * this.speed;
    };
    Player.prototype.updateDirection = function (haxis, vaxis) {
        if (this.grabbing) {
            var angle = M.atan2(this.grabbing.box.y - this.y, this.grabbing.box.x - this.x);
            if (-45 < angle && angle <= 45) {
                this.direction.set(1, 0);
            }
            else if (45 < angle && angle <= 135) {
                this.direction.set(0, 1);
            }
            else if (-135 < angle && angle <= -45) {
                this.direction.set(0, -1);
            }
            else {
                this.direction.set(-1, 0);
            }
            return;
        }
        if (haxis === 0 && vaxis !== 0) {
            this.direction.set(0, vaxis);
        }
        else if (haxis !== 0) {
            this.direction.set(haxis, 0);
        }
    };
    Player.prototype.updateGrab = function (closestBox) {
        if (this.grabbing) {
            if (!this.controller.keys.grab || G.distance(this.grabbing.box, this.getPosition().add(this.grabbing.dx, this.grabbing.dy)) > 6) {
                this.grabbing = undefined;
            }
        }
        else {
            if (this.controller.keys.grab) {
                if (closestBox) {
                    this.grabbing = { box: closestBox, dx: closestBox.x - this.x, dy: closestBox.y - this.y };
                }
            }
        }
        if (this.grabbing) {
            if (this.direction.x < 0 && -10 < this.grabbing.dx)
                this.grabbing.dx = -9;
            if (this.direction.x > 0 && this.grabbing.dx < 10)
                this.grabbing.dx = 9;
            if (this.direction.y < 0 && -3 < this.grabbing.dy)
                this.grabbing.dy = -2;
            if (this.direction.y > 0 && this.grabbing.dy < 12)
                this.grabbing.dy = 11;
            this.grabbing.box.x = this.x + this.grabbing.dx;
            this.grabbing.box.y = this.y + this.grabbing.dy;
        }
    };
    Player.prototype.updateAnimation = function (haxis, vaxis) {
        var animationSide = 'front';
        if (this.direction.x !== 0) {
            animationSide = 'side';
            this.flipX = this.direction.x < 0;
        }
        else if (this.direction.y < 0) {
            animationSide = 'back';
            this.flipX = false;
        }
        else if (this.direction.y > 0) {
            animationSide = 'front';
            this.flipX = false;
        }
        var grabSuffix = this.grabbing ? '_grab' : '';
        if (haxis !== 0 || vaxis !== 0) {
            this.playAnimation("run_" + animationSide + grabSuffix);
        }
        else {
            this.playAnimation("idle_" + animationSide + grabSuffix);
        }
    };
    Player.prototype.updateWalkSound = function (haxis, vaxis) {
        if (haxis !== 0 || vaxis !== 0) {
            if (this.grabbing)
                this.walkTimer.update(2 / 3 * this.delta);
            else
                this.walkTimer.update(this.delta);
        }
        else {
            this.walkTimer.time = 0.3;
        }
    };
    Player.prototype.getClosestBox = function () {
        var _this = this;
        this.grabBounds.x = -4 + this.direction.x;
        this.grabBounds.y = -2 + this.direction.y;
        var boxes = this.world.select.overlap(this.grabBounds, [ARG.PhysicsGroups.boxes]);
        return M.argmin(boxes, function (box) { return G.distance(box, _this); });
    };
    return Player;
}(Sprite));
/// <reference path="./player.ts" />
var Bec = /** @class */ (function (_super) {
    __extends(Bec, _super);
    function Bec(x, y) {
        var _this = _super.call(this, x, y, 'arg/bec') || this;
        _this.addAnimation(Animations.fromTextureList({ name: 'reach', textureRoot: 'arg/bec', textures: [42, 43, 44, 45, 45, 45, 46, 45, 46, 45, 46, 45, 44, 43, 42], frameRate: 4, count: 1, oneOff: true, overrides: {
                1: { callback: function () { return _this.world.playSound('arg/reach', { humanized: false }); } },
                3: { callback: function () { return _this.world.playSound('arg/reach', { humanized: false }); } },
                6: { callback: function () { return _this.world.playSound('arg/unlock', { humanized: false }); } },
                8: { callback: function () { return _this.world.playSound('arg/unlock', { humanized: false }); } },
            } }));
        _this.behavior = new ControllerBehavior(function () {
            this.controller.left = Input.isDown('left');
            this.controller.right = Input.isDown('right');
            this.controller.up = Input.isDown('up');
            this.controller.down = Input.isDown('down');
            this.controller.keys.grab = Input.isDown('grab');
        });
        return _this;
    }
    Object.defineProperty(Bec.prototype, "speed", {
        get: function () { return this.grabbing ? 36 : 48; },
        enumerable: false,
        configurable: true
    });
    return Bec;
}(Player));
var BlurredText = /** @class */ (function (_super) {
    __extends(BlurredText, _super);
    function BlurredText(x, y, text, color) {
        var _this = _super.call(this, {
            x: x, y: y, text: text,
            anchor: Vector2.CENTER,
            justify: 'center',
            style: { color: color },
        }) || this;
        _this.blur = new StaticFilter(color);
        _this.effects.post.filters.push(_this.blur);
        return _this;
    }
    BlurredText.prototype.update = function () {
        _super.prototype.update.call(this);
        this.blur.setUniform('alpha', this.alpha);
    };
    BlurredText.prototype.setBlurAmount = function (amount) {
        this.blur.setUniform('amount', amount);
    };
    return BlurredText;
}(SpriteText));
var ArgBox = /** @class */ (function (_super) {
    __extends(ArgBox, _super);
    function ArgBox(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'arg/box',
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.boxes,
            bounds: new RectBounds(-5, -10, 10, 10),
        }) || this;
        _this.slideSound = new Sound('arg/box_slide');
        _this.slideSound.loop = true;
        _this.lasttx = _this.x;
        _this.lastty = _this.y;
        return _this;
    }
    ArgBox.prototype.onAdd = function () {
        this.slideSound.controller = this.world.soundManager;
    };
    ArgBox.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.x !== this.lasttx || this.y !== this.lastty) {
            this.slideSound.update(this.delta);
        }
        this.lasttx = this.x;
        this.lastty = this.y;
    };
    return ArgBox;
}(Sprite));
var BubbleMaker = /** @class */ (function (_super) {
    __extends(BubbleMaker, _super);
    function BubbleMaker(x, y, d) {
        var _this = _super.call(this, {
            x: x, y: y,
        }) || this;
        _this.runScript(S.loopFor(Infinity, function (i) { return S.chain(S.wait(Random.float(0, 1)), S.call(function () { return _this.spawnBubble(d); }), S.wait(Random.float(0, 2))); }));
        return _this;
    }
    BubbleMaker.prototype.spawnBubble = function (d) {
        this.world.addWorldObject(new Sprite({
            x: this.x + Random.int(-1, 1), y: this.y, z: 24,
            texture: new AnchoredTexture(Texture.outlineCircle(2, 0x000000), 0.5, 0.5),
            layer: ARG.Layers.main,
            vx: Random.float(0, 2) * d,
            vz: 10,
            gravityz: 20,
            life: 1,
        }));
    };
    return BubbleMaker;
}(WorldObject));
var ArgButton = /** @class */ (function (_super) {
    __extends(ArgButton, _super);
    function ArgButton(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'arg/button/0',
            layer: ARG.Layers.onground,
            bounds: new RectBounds(-4, -10, 8, 8),
        }) || this;
        _this.stateMachine.addState('up', {
            callback: function () {
                _this.setTexture('arg/button/0');
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/pressureplate');
                if (_this.onUp)
                    _this.onUp();
            },
            transitions: [{ toState: 'down', condition: function () { return _this.isPressed(); } }]
        });
        _this.stateMachine.addState('down', {
            callback: function () {
                _this.setTexture('arg/button/1');
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/pressureplate');
                if (_this.onDown)
                    _this.onDown();
            },
            transitions: [{ toState: 'up', condition: function () { return !_this.isPressed(); } }]
        });
        _this.setState('up');
        return _this;
    }
    ArgButton.prototype.isPressed = function () {
        return this.world.select.overlap(this.bounds, [ARG.PhysicsGroups.player, ARG.PhysicsGroups.boxes]).length > 0;
    };
    return ArgButton;
}(Sprite));
var Cabinet = /** @class */ (function (_super) {
    __extends(Cabinet, _super);
    function Cabinet(x, y) {
        return _super.call(this, {
            x: x, y: y,
            texture: 'arg/cabinet/closed',
            layer: ARG.Layers.onground,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-14, -14, 27, 14),
            immovable: true,
        }) || this;
    }
    Cabinet.prototype.open = function () {
        this.setTexture('arg/cabinet/open');
        this.world.playSound('shake', { humanized: false }).volume = 0.6;
        this.world.runScript(S.shake(2, 0.1));
    };
    Cabinet.prototype.close = function () {
        this.setTexture('arg/cabinet/closed');
        this.world.playSound('shake', { humanized: false }).volume = 0.6;
        this.world.runScript(S.shake(2, 0.1));
    };
    return Cabinet;
}(Sprite));
var Chester = /** @class */ (function (_super) {
    __extends(Chester, _super);
    function Chester(x, y) {
        var _this = _super.call(this, x, y, 'arg/chester') || this;
        _this.addAnimation(Animations.fromSingleTexture({ name: 'die', texture: 'arg/chester/44', oneOff: true }));
        _this.behavior = new ControllerBehavior(function () {
            this.controller.left = Input.isDown('left');
            this.controller.right = Input.isDown('right');
            this.controller.up = Input.isDown('up');
            this.controller.down = Input.isDown('down');
            this.controller.keys.grab = Input.isDown('grab');
        });
        return _this;
    }
    Object.defineProperty(Chester.prototype, "speed", {
        get: function () { return this.grabbing ? 36 : 48; },
        enumerable: false,
        configurable: true
    });
    return Chester;
}(Player));
var ChesterSit = /** @class */ (function (_super) {
    __extends(ChesterSit, _super);
    function ChesterSit(x, y) {
        return _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'idle_sit', textureRoot: 'arg/chester', textures: [42, 43], frameRate: 1.1, count: Infinity }),
            ],
            defaultAnimation: 'idle_sit',
            effects: { outline: { color: 0x000000 } },
            layer: ARG.Layers.main,
        }) || this;
    }
    return ChesterSit;
}(Sprite));
var ARG;
(function (ARG) {
    var Stages;
    (function (Stages) {
        function CODE() {
            var world = ARG.Stages.BASE_INNER_STAGE(1);
            world.onTransitioned = function () {
                global.theater.playCutscene(ARG.Cutscenes.ARG3_GET_CODE);
            };
            return world;
        }
        Stages.CODE = CODE;
    })(Stages = ARG.Stages || (ARG.Stages = {}));
})(ARG || (ARG = {}));
var CommandSystem = /** @class */ (function (_super) {
    __extends(CommandSystem, _super);
    function CommandSystem() {
        var _this = _super.call(this, {
            x: 4, y: 4,
            layer: 'commands',
        }) || this;
        _this.textOffsetX = 2;
        _this.textOffsetY = 1;
        _this.lines = [];
        _this.border = _this.addChild(new RectangleOutlineObject(0, 0, 312, 232, 0xFFFFFF, 1, { layer: 'borders' }));
        return _this;
    }
    CommandSystem.prototype.update = function () {
        _super.prototype.update.call(this);
        var dy = this.getLocalBottomOfText() - this.world.height + 15;
        if (dy > 0) {
            this.scroll(dy);
        }
    };
    CommandSystem.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.moveWorldObjectToFront(this.border);
    };
    CommandSystem.prototype.prompt = function () {
        var cs = this;
        return function () {
            return __generator(this, function (_a) {
                cs.addPrompt();
                return [2 /*return*/];
            });
        };
    };
    CommandSystem.prototype.output = function (text, newLine) {
        var cs = this;
        return function () {
            return __generator(this, function (_a) {
                cs.addOutput(text, newLine);
                return [2 /*return*/];
            });
        };
    };
    CommandSystem.prototype.executeCommand = function (command, response) {
        var cs = this;
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, cs.typeCommand(command)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(0.1)];
                    case 2:
                        _a.sent();
                        cs.world.playSound('typename', { volume: 0.5 });
                        return [4 /*yield*/, cs.output(response, 'nl')];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, cs.prompt()];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    };
    CommandSystem.prototype.typeCommand = function (command, speed) {
        if (speed === void 0) { speed = 1; }
        var cs = this;
        return function () {
            var lastCommand;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        lastCommand = cs.getLastCommand();
                        lastCommand.isPrompt = false;
                        return [4 /*yield*/, S.either(addTextTyped(lastCommand.spriteText, command, 6 * speed, 20 * speed, function (p) {
                                cs.world.playSound('typename', { volume: Random.float(0.8, 1) });
                            }, function (parts) { }), S.doOverTime(Infinity, function (_) { return lastCommand.height = lastCommand.spriteText.getTextHeight(); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    };
    CommandSystem.prototype.scroll = function (dy) {
        var e_130, _a;
        try {
            for (var _b = __values(this.lines), _c = _b.next(); !_c.done; _c = _b.next()) {
                var line = _c.value;
                line.spriteText.y -= dy;
            }
        }
        catch (e_130_1) { e_130 = { error: e_130_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_130) throw e_130.error; }
        }
    };
    CommandSystem.prototype.addOutput = function (text, newLine) {
        var spriteText = this.addChild(new SpriteText({
            p: this.getNextLineLocalPos(),
            text: text,
            copyFromParent: ['layer'],
        }));
        var height = spriteText.getTextHeight();
        if (newLine) {
            height += 15;
        }
        var line = {
            isPrompt: false,
            spriteText: spriteText,
            height: height,
        };
        this.lines.push(line);
    };
    CommandSystem.prototype.addPrompt = function () {
        var spriteText = this.addChild(new SpriteText({
            p: this.getNextLineLocalPos(),
            text: CommandSystem.PROMPT,
            copyFromParent: ['layer'],
        }));
        var line = {
            isPrompt: true,
            spriteText: spriteText,
            height: 15,
        };
        this.lines.push(line);
    };
    CommandSystem.prototype.getBounds = function () {
        return rect(this.localx, this.localy, this.border.width, this.border.height);
    };
    CommandSystem.prototype.setBounds = function (x, y, width, height) {
        this.localx = x;
        this.localy = y;
        this.border.width = width;
        this.border.height = height;
    };
    CommandSystem.prototype.getLastCommand = function () {
        return _.last(this.lines);
    };
    CommandSystem.prototype.getLocalBottomOfText = function () {
        if (_.isEmpty(this.lines))
            return this.textOffsetY;
        return M.max(this.lines, function (line) { return line.spriteText.localy + line.height; });
    };
    CommandSystem.prototype.getNextLineLocalPos = function () {
        return vec2(this.textOffsetX, this.getLocalBottomOfText());
    };
    CommandSystem.PROMPT = '\\[~\\]$ '; //'\\[admin@p-sec-621 ~\\]$ ';
    return CommandSystem;
}(WorldObject));
var ARG;
(function (ARG) {
    var Cutscenes;
    (function (Cutscenes) {
        Cutscenes.BEGIN_ARG = {
            script: function () {
                var sound;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.world.addWorldObject(new Sprite({ texture: global.world.takeSnapshot() }));
                            global.world.effects.post.filters.push(new Effects.Filters.Glitch(60, 0, 30));
                            global.theater.playSound('shake');
                            global.game.stopMusic();
                            sound = global.theater.playSound('arg/glitch_dialog');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 1:
                            _a.sent();
                            sound.hang();
                            return [4 /*yield*/, S.wait(6.5)];
                        case 2:
                            _a.sent();
                            sound.stop();
                            return [4 /*yield*/, S.fadeOut(0)];
                        case 3:
                            _a.sent();
                            global.theater.loadStage(function () { return new World(); });
                            return [4 /*yield*/, S.wait(5)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, typeText("Are you still playing\nthat silly ball game?", global.theater.width / 2, global.theater.height / 2 - 15, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, typeText("You should let someone\nelse have a turn.", global.theater.width / 2, global.theater.height / 2 - 15, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, typeText("This is stupid.", global.theater.width / 2, global.theater.height - 28, 0xFFFF00, 20, 'arg/bip', 1.5)];
                        case 7:
                            _a.sent();
                            global.theater.playSound('shake', { humanized: false });
                            global.theater.loadStage(ARG.Rooms.LOBBY);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.LOBBY_OPEN_DOOR = {
            script: function () {
                var bec, key, door;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            bec = global.world.select.type(Bec);
                            key = global.world.select.type(ArgKey);
                            door = global.world.select.name('door');
                            if (!(bec.x < 240)) return [3 /*break*/, 2];
                            return [4 /*yield*/, S.moveToX(bec, 240)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            bec.flipX = false;
                            bec.direction.set(0, -1);
                            return [4 /*yield*/, S.schedule(0, S.playAnimation(bec, 'reach'), 1, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                key.setState('free');
                                                key.layer = World.DEFAULT_LAYER;
                                                return [4 /*yield*/, S.tweenPt(1, key, key, vec2(243, 25), Tween.Easing.InOutQuad)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }, 2, S.tween(0.5, key, 'alpha', 1, 0))];
                        case 3:
                            _a.sent();
                            global.world.playSound('shake', { humanized: false });
                            door.kill();
                            key.kill();
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.ROOM3_OPEN_GATE = {
            script: function () {
                var bec, biggatel, biggater, mask;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            bec = global.world.select.type(Bec);
                            biggatel = global.world.select.name('biggatel');
                            biggater = global.world.select.name('biggater');
                            mask = {
                                offsetx: 216,
                                offsety: 10,
                                texture: Texture.filledRect(48, 53, 0xFFFFFF),
                                type: 'world',
                            };
                            biggatel.mask = mask;
                            biggater.mask = mask;
                            return [4 /*yield*/, S.moveTo(bec, Math.min(bec.x, 258), Math.min(bec.y, 115))];
                        case 1:
                            _a.sent();
                            bec.direction.set(0, -1);
                            global.game.musicManager.stopMusic(1);
                            return [4 /*yield*/, S.wait(1.5)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.schedule(0, S.shake(1, 6), 0, S.loopFor(24, function (i) { return S.chain(S.call(function () { return global.world.playSound('shake'); }), S.wait(0.25)); }), 1, S.tween(4, biggatel, 'x', biggatel.x, biggatel.x - 22), 1, S.tween(4, biggater, 'x', biggater.x, biggater.x + 22))];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 4:
                            _a.sent();
                            global.game.musicManager.playMusic('arg/atmosphere', 1);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.END_ENTER_DOCTOR = {
            script: function () {
                var bec, doctor, screenshot, sound, g, text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            bec = global.world.select.type(Bec);
                            return [4 /*yield*/, S.moveToY(bec, 72)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.1)];
                        case 2:
                            _a.sent();
                            if (!(bec.x < 30 || bec.x > 46)) return [3 /*break*/, 4];
                            return [4 /*yield*/, S.moveToX(bec, 38)];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            bec.direction.set(0, -1);
                            global.game.musicManager.stopMusic(2);
                            return [4 /*yield*/, S.wait(2)];
                        case 5:
                            _a.sent();
                            doctor = global.world.addWorldObject(new Doctor(80, 160));
                            doctor.physicsGroup = undefined;
                            return [4 /*yield*/, S.moveToY(doctor, 98)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.1)];
                        case 7:
                            _a.sent();
                            return [4 /*yield*/, S.moveToX(doctor, 37)];
                        case 8:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.1)];
                        case 9:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 80)];
                        case 10:
                            _a.sent();
                            screenshot = global.world.addWorldObject(new Sprite({ texture: global.world.takeSnapshot(), scale: 0.5 }));
                            global.world.effects.post.filters.push(new Effects.Filters.Glitch(30, 1, 30));
                            sound = global.theater.playSound('arg/glitch_dialog');
                            sound.volume = 0.7;
                            sound.loop = true;
                            return [4 /*yield*/, S.wait(1)];
                        case 11:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.9)];
                        case 12:
                            _a.sent();
                            sound.stop();
                            return [4 /*yield*/, S.fadeOut(0)];
                        case 13:
                            _a.sent();
                            g = new Effects.Filters.Glitch(128, 4, 2);
                            text = global.theater.addWorldObject(new SpriteText({
                                x: global.theater.width / 2, y: global.theater.height / 2,
                                text: "That is far enough, child.",
                                anchor: Vector2.CENTER,
                                style: { color: 0xFFFFFF },
                                effects: { post: { filters: [g] } },
                            }));
                            text.visibleCharCount = 0;
                            return [4 /*yield*/, S.loopFor(text.getCharList().length, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [5 /*yield**/, __values(S.wait(0.05)())];
                                            case 1:
                                                _a.sent();
                                                text.visibleCharCount++;
                                                global.theater.playSound('arg/tear');
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 14:
                            _a.sent();
                            global.theater.playSound('arg/riser');
                            return [4 /*yield*/, tweenGlitchPower(g, 0)];
                        case 15:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2.5)];
                        case 16:
                            _a.sent();
                            return [4 /*yield*/, tweenGlitchPower(g, 1)];
                        case 17:
                            _a.sent();
                            text.setText("You were not supposed to see this.");
                            text.visibleCharCount = 0;
                            return [4 /*yield*/, S.loopFor(text.getCharList().length, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [5 /*yield**/, __values(S.wait(0.05)())];
                                            case 1:
                                                _a.sent();
                                                text.visibleCharCount++;
                                                global.theater.playSound('arg/tear');
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 18:
                            _a.sent();
                            return [4 /*yield*/, tweenGlitchPower(g, 0)];
                        case 19:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2.5)];
                        case 20:
                            _a.sent();
                            return [4 /*yield*/, tweenGlitchPower(g, 1)];
                        case 21:
                            _a.sent();
                            text.setText("Come with me, now");
                            text.style.color = 0xFF0000;
                            text.visibleCharCount = 0;
                            g.strength = 0;
                            bec.setVisible(false);
                            doctor.setVisible(false);
                            screenshot.setVisible(false);
                            global.world.effects.post.filters.push(new TextureFilters.Tint(0xFF0000));
                            return [4 /*yield*/, S.fadeSlides(0)];
                        case 22:
                            _a.sent();
                            global.theater.playSound('shake');
                            return [4 /*yield*/, S.wait(1)];
                        case 23:
                            _a.sent();
                            return [4 /*yield*/, S.fadeOut(0)];
                        case 24:
                            _a.sent();
                            global.theater.playSound('shake');
                            return [4 /*yield*/, S.loopFor(text.getCharList().length, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [5 /*yield**/, __values(S.wait(0.15)())];
                                            case 1:
                                                _a.sent();
                                                text.visibleCharCount++;
                                                global.theater.playSound('arg/tear');
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 25:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 26:
                            _a.sent();
                            text.kill();
                            global.theater.playSound('arg/echo');
                            return [4 /*yield*/, S.wait(7)];
                        case 27:
                            _a.sent();
                            if (!!hasCompletedAchievement('ArgPart1')) return [3 /*break*/, 29];
                            updateAchievementProgress('ArgPart1', function (p) { return 1; });
                            return [4 /*yield*/, S.wait(9)];
                        case 28:
                            _a.sent();
                            _a.label = 29;
                        case 29:
                            global.theater.loadStage(ARG.Stages.KEYPAD);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.BEGIN_ARG_2 = {
            script: function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.fadeOut(0)];
                        case 1:
                            _a.sent();
                            global.theater.playSound('shake', { humanized: false });
                            global.game.stopMusic();
                            global.theater.loadStage(function () { return new World(); });
                            return [4 /*yield*/, S.wait(5)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, typeText("My esteemed colleague,", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, typeText("This is the third time I've\ncaught your [lb]son[/lb] wandering\nin restricted areas.", global.theater.width / 2, global.theater.height / 2 - 22, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, typeText("I understand your...\npeculiar circumstances,\nbut...", global.theater.width / 2, global.theater.height / 2 - 22, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, typeText("If he must stay here, please\nconfine him to your office.", global.theater.width / 2, global.theater.height / 2 - 15, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, typeText("This is not a daycare.", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/spark', 3)];
                        case 7:
                            _a.sent();
                            global.theater.playSound('shake', { humanized: false });
                            global.theater.loadStage(ARG.Rooms.CONFERENCE);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.CONFERENCE_OPEN_BOOKSHELF = {
            script: function () {
                var chester, bookshelf, slide;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            chester = global.world.select.type(Chester);
                            bookshelf = global.world.select.name('bookshelf');
                            return [4 /*yield*/, S.moveTo(chester, 87, 36)];
                        case 1:
                            _a.sent();
                            chester.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(0.3)];
                        case 2:
                            _a.sent();
                            global.world.playSound('arg/pressureplate');
                            return [4 /*yield*/, S.wait(1)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(chester, 58)];
                        case 4:
                            _a.sent();
                            chester.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 5:
                            _a.sent();
                            slide = global.world.playSound('arg/box_slide');
                            slide.speed = 0.7;
                            slide.loop = true;
                            return [4 /*yield*/, S.tween(2, bookshelf, 'y', bookshelf.y, bookshelf.y + 11)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, S.tween(3, bookshelf, 'x', bookshelf.x, bookshelf.x - 32)];
                        case 7:
                            _a.sent();
                            slide.stop();
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.AREA1_START_SIGHT = {
            script: function () {
                var sight, chester;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            sight = global.world.select.type(Sight);
                            chester = global.world.select.type(Chester);
                            global.game.musicManager.stopMusic(1);
                            chester.direction.set(0, 1);
                            sight.doSingleSight('down');
                            return [4 /*yield*/, S.wait(4)];
                        case 1:
                            _a.sent();
                            sight.start(1);
                            chester.direction.set(1, 0);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.AREA4_SIGHT = {
            script: function () {
                var sight, chester;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            sight = global.world.select.type(Sight);
                            chester = global.world.select.type(Chester);
                            global.game.musicManager.stopMusic(1);
                            chester.direction.set(0, 1);
                            sight.doSingleSight('left');
                            return [4 /*yield*/, S.wait(3)];
                        case 1:
                            _a.sent();
                            chester.direction.set(0, -1);
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.CHESTER_DIE = {
            script: function () {
                var sight, chester, slice;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            sight = global.world.select.type(Sight);
                            sight.stop();
                            chester = global.world.select.type(Chester);
                            slice = new TextureFilters.Slice(rect(0, 0, 24, 24));
                            chester.effects.post.filters.push(slice);
                            chester.direction.x = 1;
                            chester.playAnimation('die', true);
                            chester.updateCallback = function () {
                                this.offsetX = M.lerp(0, 1, Tween.Easing.OscillateSine(3)(this.life.time));
                            };
                            chester.addTimer(0.35, function () { return chester.world.playSound('shake'); }, 8).time = 0.2;
                            return [4 /*yield*/, S.wait(1.5)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(1.5, function (t) { return slice.setSlice(rect(0, 0, 24, M.lerp(24, 0, t))); })];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 3:
                            _a.sent();
                            global.theater.reloadCurrentStage(ARG.Rooms.transition());
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.LAB_START_HIDE = {
            script: function () {
                var walkScript, zoom, zoomShake, hideScript, chester;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.world.playSound('shake', { humanized: false });
                            global.game.playMusic('arg/arg');
                            flash();
                            walkScript = global.world.runScript(function () {
                                var walk;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!true) return [3 /*break*/, 2];
                                            return [4 /*yield*/, S.wait(1)];
                                        case 1:
                                            _a.sent();
                                            walk = global.world.playSound('arg/walk');
                                            walk.speed = 0.8;
                                            walk.volume = 2;
                                            return [3 /*break*/, 0];
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            });
                            zoom = new ZoomFilter(vec2(160, 120), 0);
                            global.world.effects.post.filters.push(zoom);
                            zoomShake = global.world.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!true) return [3 /*break*/, 2];
                                            zoom.amount = Random.float(-0.1, 0.1);
                                            return [4 /*yield*/];
                                        case 1:
                                            _a.sent();
                                            return [3 /*break*/, 0];
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            });
                            return [4 /*yield*/, S.wait(1.5)];
                        case 1:
                            _a.sent();
                            hideScript = global.world.runScript(function () {
                                var hidePositions, i;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            hidePositions = new RandomNumberGenerator(379).shuffle([vec2(26, 68), vec2(27, 98), vec2(45, 78), vec2(46, 107), vec2(59, 63), vec2(64, 89),
                                                vec2(83, 78), vec2(104, 67), vec2(124, 55), vec2(134, 66), vec2(129, 84), vec2(132, 42)]);
                                            i = 0;
                                            _a.label = 1;
                                        case 1:
                                            if (!true) return [3 /*break*/, 3];
                                            return [4 /*yield*/, S.wait(0.5)];
                                        case 2:
                                            _a.sent();
                                            global.world.runScript(hideText(hidePositions[i].x, hidePositions[i].y));
                                            i = (i + 1) % hidePositions.length;
                                            return [3 /*break*/, 1];
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            });
                            chester = global.world.select.type(Chester);
                            chester.walkVolume = 0.2;
                            global.world.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, S.wait(2)];
                                        case 1:
                                            _a.sent();
                                            return [4 /*yield*/, S.waitUntil(function () { return chester.x > 116 && chester.x < 142 && chester.y < 40; })];
                                        case 2:
                                            _a.sent();
                                            walkScript.stop();
                                            hideScript.stop();
                                            zoomShake.stop();
                                            A.removeAll(global.world.effects.post.filters, zoom);
                                            global.theater.playCutscene(ARG.Cutscenes.LAB_ENTER_DOCTOR);
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.LAB_ENTER_DOCTOR = {
            script: function () {
                var chester, cabinet, doctor, timeBetweenTexts, snapshots, lastRowHeight, shareText, clipboardShareButton, continueButtonClicked, continueButton;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.game.stopMusic(0.5);
                            chester = global.world.select.type(Chester);
                            cabinet = global.world.select.type(Cabinet);
                            return [4 /*yield*/, S.moveToX(chester, 129)];
                        case 1:
                            _a.sent();
                            chester.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(0.2)];
                        case 2:
                            _a.sent();
                            cabinet.colliding = false;
                            cabinet.open();
                            return [4 /*yield*/, S.tween(0.1, chester, 'y', chester.y, chester.y + 8)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(chester, 33)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 6:
                            _a.sent();
                            chester.direction.set(0, 1);
                            return [4 /*yield*/, S.wait(0.5)];
                        case 7:
                            _a.sent();
                            chester.kill();
                            cabinet.close();
                            return [4 /*yield*/, S.wait(2)];
                        case 8:
                            _a.sent();
                            doctor = global.world.addWorldObject(new Doctor(43, 160));
                            doctor.physicsGroup = undefined;
                            return [4 /*yield*/, S.moveToY(doctor, 58)];
                        case 9:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.4)];
                        case 10:
                            _a.sent();
                            return [4 /*yield*/, S.loopFor(20, function (i) { return S.chain(S.wait(i <= 5 ? Random.float(0.2, 0.5) : Random.float(0.1, 0.2)), S.call(function () { return global.world.playSound('typename').speed = Random.float(0.72, 0.88); })); })];
                        case 11:
                            _a.sent();
                            flash();
                            global.world.playSound('shake', { humanized: false }).volume = 0.5;
                            doctor.direction.set(1, 0);
                            return [4 /*yield*/, [
                                    S.shake(2, 0.2),
                                    S.jumpZ(0.2, doctor, 4, true),
                                ]];
                        case 12:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 13:
                            _a.sent();
                            doctor.running = true;
                            return [4 /*yield*/, S.moveToY(doctor, 66)];
                        case 14:
                            _a.sent();
                            return [4 /*yield*/, S.moveToX(doctor, 90)];
                        case 15:
                            _a.sent();
                            doctor.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(1)];
                        case 16:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 80)];
                        case 17:
                            _a.sent();
                            return [4 /*yield*/, S.moveToX(doctor, 43)];
                        case 18:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 110)];
                        case 19:
                            _a.sent();
                            doctor.direction.set(0, 1);
                            return [4 /*yield*/, S.wait(1)];
                        case 20:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 80)];
                        case 21:
                            _a.sent();
                            return [4 /*yield*/, S.moveToX(doctor, 128)];
                        case 22:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 88)];
                        case 23:
                            _a.sent();
                            doctor.direction.set(0, 1);
                            return [4 /*yield*/, S.wait(1.1)];
                        case 24:
                            _a.sent();
                            doctor.direction.set(-1, 0);
                            return [4 /*yield*/, S.wait(0.2)];
                        case 25:
                            _a.sent();
                            doctor.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(1.2)];
                        case 26:
                            _a.sent();
                            doctor.running = false;
                            return [4 /*yield*/, S.moveToY(doctor, 47)];
                        case 27:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1.8)];
                        case 28:
                            _a.sent();
                            flash();
                            cabinet.open();
                            return [4 /*yield*/, S.tween(0.25, doctor, 'y', doctor.y, 80)];
                        case 29:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 30:
                            _a.sent();
                            global.game.playMusic('arg/booms');
                            return [4 /*yield*/, S.wait(1)];
                        case 31:
                            _a.sent();
                            doctor.direction.set(-1, 0);
                            return [4 /*yield*/, S.wait(1)];
                        case 32:
                            _a.sent();
                            doctor.direction.set(0, 1);
                            return [4 /*yield*/, S.wait(1)];
                        case 33:
                            _a.sent();
                            doctor.direction.set(-1, 0);
                            return [4 /*yield*/, S.wait(0.2)];
                        case 34:
                            _a.sent();
                            doctor.direction.set(0, -1);
                            return [4 /*yield*/, S.wait(1.5)];
                        case 35:
                            _a.sent();
                            doctor.running = true;
                            return [4 /*yield*/, S.moveToY(doctor, 48)];
                        case 36:
                            _a.sent();
                            cabinet.close();
                            return [4 /*yield*/, S.wait(1)];
                        case 37:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 80)];
                        case 38:
                            _a.sent();
                            return [4 /*yield*/, S.moveToX(doctor, 43)];
                        case 39:
                            _a.sent();
                            return [4 /*yield*/, S.moveToY(doctor, 160)];
                        case 40:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 41:
                            _a.sent();
                            return [4 /*yield*/, S.fadeOut(0)];
                        case 42:
                            _a.sent();
                            global.world.runScript(function () {
                                var sound;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, S.wait(17.5)];
                                        case 1:
                                            _a.sent();
                                            sound = global.world.playSound('arg/riser');
                                            sound.onDone = function () { return global.game.stopMusic(); };
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [4 /*yield*/, S.wait(0.5)];
                        case 43:
                            _a.sent();
                            timeBetweenTexts = 1.5;
                            global.world.runScript(finaleText(97, 96, "Who is he?", 0x005C93));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 44:
                            _a.sent();
                            global.world.runScript(finaleText(190, 185, "He came from the outside?", 0x894A21));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 45:
                            _a.sent();
                            global.world.runScript(finaleText(233, 23, "Is he one of us?", 0x2E9B36));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 46:
                            _a.sent();
                            global.world.runScript(finaleText(163, 158, "He's dangerous", 0x636363));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 47:
                            _a.sent();
                            global.world.runScript(finaleText(80, 23, "Was he sent here?", 0x7A9633));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 48:
                            _a.sent();
                            global.world.runScript(finaleText(114, 72, "he doesn't know anything.", 0xAD4500));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 49:
                            _a.sent();
                            global.world.runScript(finaleText(230, 108, "He can't be trusted.", 0x685700));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 50:
                            _a.sent();
                            global.world.runScript(finaleText(148, 216, "Don't you know who his mother is?", 0x007F7F));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 51:
                            _a.sent();
                            global.world.runScript(finaleText(179, 48, "It's all over...", 0xA02E91));
                            return [4 /*yield*/, S.wait(timeBetweenTexts)];
                        case 52:
                            _a.sent();
                            global.world.runScript(finaleText(272, 145, "why...?", 0x6C009E));
                            return [4 /*yield*/, S.wait(1)];
                        case 53:
                            _a.sent();
                            global.world.runScript(finaleText(114, 132, "One thing is for certain.", 0x681F2F));
                            return [4 /*yield*/, S.wait(12)];
                        case 54:
                            _a.sent();
                            return [4 /*yield*/, typeText("He must not be allowed to leave.", global.gameWidth / 2, global.gameHeight / 2 - 8, 0x681F2F, 10, null, 2.5)];
                        case 55:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 56:
                            _a.sent();
                            return [4 /*yield*/, S.fadeOut(0, 0xFFFFFF)];
                        case 57:
                            _a.sent();
                            global.theater.clearSlides(1);
                            global.world.select.name('vat_broken').setVisible(true);
                            global.world.playSound('arg/shot', { humanized: false });
                            global.world.playSound('arg/glass', { humanized: false });
                            global.game.stopMusic();
                            return [4 /*yield*/, [
                                    S.fadeSlides(0.2),
                                    S.shake(2, 0.3),
                                ]];
                        case 58:
                            _a.sent();
                            return [4 /*yield*/, S.wait(4)];
                        case 59:
                            _a.sent();
                            global.theater.loadStage(function () { return new World(); });
                            return [4 /*yield*/, S.wait(7)];
                        case 60:
                            _a.sent();
                            if (!!hasCompletedAchievement('B')) return [3 /*break*/, 62];
                            updateAchievementProgress('B', function (p) { return 1; });
                            return [4 /*yield*/, S.wait(9)];
                        case 61:
                            _a.sent();
                            _a.label = 62;
                        case 62:
                            if (!GAME_DATA.arg2Trigger || !GAME_DATA.arg2Trigger.strategy) {
                                global.game.loadMainMenu();
                                return [2 /*return*/];
                            }
                            snapshots = [];
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2, "A message for the player:")];
                        case 63:
                            _a.sent();
                            return [4 /*yield*/, S.wait(3)];
                        case 64:
                            _a.sent();
                            snapshots.push(global.world.takeSnapshot());
                            return [4 /*yield*/, fadeOutAllText()];
                        case 65:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 66:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 - 30, "You are very lucky.")];
                        case 67:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 68:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 + 30, "Finding the Scribbled Map item is [y]extremely rare[/y].")];
                        case 69:
                            _a.sent();
                            return [4 /*yield*/, S.wait(5)];
                        case 70:
                            _a.sent();
                            snapshots.push(global.world.takeSnapshot());
                            return [4 /*yield*/, fadeOutAllText()];
                        case 71:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 72:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 - 30, "There is another, easier way to view this story segment.")];
                        case 73:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 74:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 + 30, "Simply join a Versus Mode game with the game id \"[r]BETA[/r]\"")];
                        case 75:
                            _a.sent();
                            return [4 /*yield*/, S.wait(5)];
                        case 76:
                            _a.sent();
                            snapshots.push(global.world.takeSnapshot());
                            return [4 /*yield*/, fadeOutAllText()];
                        case 77:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 78:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 - 72, "This knowledge is yours to do with as you please.")];
                        case 79:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 80:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 - 12, "You may share it with others... or not.")];
                        case 81:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 82:
                            _a.sent();
                            return [4 /*yield*/, fadeText(global.gameWidth / 2, global.gameHeight / 2 + 48, "Thank you for playing my game! :)")];
                        case 83:
                            _a.sent();
                            return [4 /*yield*/, S.wait(5)];
                        case 84:
                            _a.sent();
                            snapshots.push(global.world.takeSnapshot());
                            lastRowHeight = global.gameHeight - 27;
                            shareText = global.world.addWorldObject(new SpriteText({
                                name: 'sharetext',
                                x: global.gameWidth / 2 - 52, y: lastRowHeight,
                                text: 'SAVE IMAGE',
                                anchor: Vector2.CENTER_LEFT,
                                font: 'smallnumbers',
                                alpha: 0,
                            }));
                            clipboardShareButton = global.world.addWorldObject(new PatchedSnapshotsShareButton(global.gameWidth / 2 - 65, lastRowHeight, snapshots));
                            clipboardShareButton.alpha = 0;
                            continueButtonClicked = false;
                            continueButton = global.world.addWorldObject(new MenuTextButton({
                                name: 'continuebutton',
                                x: global.gameWidth / 2 + 8, y: lastRowHeight - 7,
                                text: 'Continue >',
                                style: { color: 0xFFFFFF },
                                alpha: 0,
                                onClick: function () {
                                    global.game.playSound('click');
                                    continueButton.enabled = false;
                                    continueButtonClicked = true;
                                }
                            }));
                            return [4 /*yield*/, [
                                    S.tween(1, continueButton, 'alpha', 0, 1),
                                    S.tween(1, shareText, 'alpha', 0, 1),
                                    S.tween(1, clipboardShareButton, 'alpha', 0, 1),
                                ]];
                        case 85:
                            _a.sent();
                            return [4 /*yield*/, S.waitUntil(function () { return continueButtonClicked; })];
                        case 86:
                            _a.sent();
                            return [4 /*yield*/, S.fadeOut(1)];
                        case 87:
                            _a.sent();
                            continueButton.kill();
                            shareText.kill();
                            clipboardShareButton.kill();
                            global.world.select.typeAll(SpriteText).forEach(function (t) { return t.kill(); });
                            return [4 /*yield*/, S.fadeSlides(0)];
                        case 88:
                            _a.sent();
                            GAME_DATA.arg2Trigger.strategy = false;
                            global.theater.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/];
                                        case 1:
                                            _a.sent();
                                            if (getLastRoundResult() === 'loss') {
                                                GAME_DATA.health++;
                                                global.theater.playCutscene(RoundResults.GAMEOVER);
                                            }
                                            else {
                                                GAME_DATA.wins--;
                                                global.theater.playCutscene(RoundResults.VICTORY);
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            }
        };
        Cutscenes.ARG3_GET_CODE = {
            script: function () {
                var staticSound, keypad, codeText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.game.stopMusic();
                            staticSound = global.world.playSound('arg/tvstatic');
                            global.world.effects.post.filters.push(new StaticFilter(0xFFFFFF, 1));
                            return [4 /*yield*/, S.wait(1.5)];
                        case 1:
                            _a.sent();
                            global.world.effects.post.filters.pop();
                            staticSound.stop();
                            return [4 /*yield*/, S.wait(4)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, typeText("There's a hidden door in\nthe bookcase", global.theater.width / 2, global.theater.height / 2 - 15, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, typeText("I saw my mom go through it once", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, typeText("I followed behind her, secretly", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, typeText("But I couldn't believe what\nI saw on the other side", global.theater.width / 2, global.theater.height / 2 - 15, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 7:
                            _a.sent();
                            return [4 /*yield*/, typeText("Why did it have to be her...?", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 8:
                            _a.sent();
                            return [4 /*yield*/, typeText("I need to go back there. Today.", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 3)];
                        case 9:
                            _a.sent();
                            return [4 /*yield*/, typeText("What was the code again?", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 2)];
                        case 10:
                            _a.sent();
                            return [4 /*yield*/, typeText("That's right, I remember!", global.theater.width / 2, global.theater.height / 2 - 7, 0xFFFFFF, 20, 'arg/bubbles', 2)];
                        case 11:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 12:
                            _a.sent();
                            keypad = global.world.addWorldObject(new Sprite({ texture: 'arg/keypad', scale: 2 }));
                            keypad.alpha = 0;
                            return [4 /*yield*/, S.doOverTime(3, function (t) {
                                    keypad.alpha = M.lerp(0, 0.4, t);
                                })];
                        case 13:
                            _a.sent();
                            codeText = global.world.addWorldObject(new SpriteText({
                                x: 99 * 2, y: 28 * 2,
                                anchor: Vector2.TOP_RIGHT,
                                scale: 2,
                                alpha: 0.4,
                            }));
                            return [4 /*yield*/, S.wait(1)];
                        case 14:
                            _a.sent();
                            codeText.setText('0');
                            return [4 /*yield*/, S.wait(1)];
                        case 15:
                            _a.sent();
                            codeText.setText('06');
                            return [4 /*yield*/, S.wait(1)];
                        case 16:
                            _a.sent();
                            codeText.setText('062');
                            return [4 /*yield*/, S.wait(1)];
                        case 17:
                            _a.sent();
                            codeText.setText('0621');
                            return [4 /*yield*/, S.wait(1.5)];
                        case 18:
                            _a.sent();
                            return [4 /*yield*/, S.fadeOut(0)];
                        case 19:
                            _a.sent();
                            return [4 /*yield*/, S.wait(3)];
                        case 20:
                            _a.sent();
                            global.game.loadMainMenu();
                            global.game.menuSystem.loadMenu(function () { return new AlmanacMenu('classic'); });
                            return [2 /*return*/];
                    }
                });
            }
        };
        function flash() {
            global.theater.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.fadeOut(0, 0xFFFFFF)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.fadeSlides(0.2)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        function typeText(text, x, y, color, speed, dialogSound, waitTime) {
            return function () {
                var spriteText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            spriteText = global.theater.addWorldObject(new SpriteText({
                                x: x, y: y, text: text,
                                anchor: Vector2.TOP_CENTER,
                                justify: 'center',
                                style: { color: color },
                            }));
                            spriteText.visibleCharCount = 0;
                            return [4 /*yield*/, S.loopFor(spriteText.getCharList().length, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [5 /*yield**/, __values(S.wait(1 / speed)())];
                                            case 1:
                                                _a.sent();
                                                spriteText.visibleCharCount++;
                                                if (dialogSound)
                                                    global.theater.playSound(dialogSound);
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(waitTime)];
                        case 2:
                            _a.sent();
                            spriteText.kill();
                            return [2 /*return*/];
                    }
                });
            };
        }
        function tweenGlitchPower(filter, power) {
            return function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [5 /*yield**/, __values(S.wait(0.4)())];
                        case 1:
                            _a.sent();
                            filter.strength = M.lerp(1, 128, power);
                            filter.speed = M.lerp(2, 4, power);
                            return [5 /*yield**/, __values(S.wait(0.4)())];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            };
        }
        function hideText(x, y) {
            return function () {
                var blurredText, ri;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            blurredText = global.theater.addWorldObject(new BlurredText(2 * x, 2 * y, 'HIDE', 0xBBBBBB));
                            ri = Random.float();
                            blurredText.updateCallback = function () {
                                this.style.offsetX = M.lerp(0, 1, Tween.Easing.OscillateSine(10)(ri + this.life.time));
                            };
                            blurredText.layer = Theater.LAYER_SLIDES;
                            blurredText.alpha = 0;
                            return [4 /*yield*/, S.doOverTime(1, function (t) { return blurredText.alpha = M.lerp(0, 0.5, t); })];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(0.5, function (t) { return blurredText.setBlurAmount(M.lerp(1, 0, t)); })];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(1, function (t) { return blurredText.alpha = M.lerp(0.5, 0, t); })];
                        case 5:
                            _a.sent();
                            blurredText.kill();
                            return [2 /*return*/];
                    }
                });
            };
        }
        function finaleText(x, y, text, color) {
            return function () {
                var blurredText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            blurredText = global.theater.addWorldObject(new BlurredText(x, y, text, color));
                            blurredText.layer = Theater.LAYER_SLIDES;
                            blurredText.alpha = 0;
                            global.world.playSound('arg/static');
                            return [4 /*yield*/, S.doOverTime(3, function (t) { return blurredText.alpha = M.lerp(0, 1, t); })];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 2:
                            _a.sent();
                            global.world.playSound('arg/softimpact');
                            return [4 /*yield*/, S.doOverTime(2, function (t) { return blurredText.setBlurAmount(M.lerp(1, 0, t)); })];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(1, function (t) { return blurredText.alpha = M.lerp(1, 0, t); })];
                        case 5:
                            _a.sent();
                            blurredText.kill();
                            return [2 /*return*/];
                    }
                });
            };
        }
        function fadeText(x, y, text) {
            return function () {
                var spriteText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            spriteText = global.world.addWorldObject(new SpriteText({
                                x: x, y: y, text: text,
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                alpha: 0,
                                maxWidth: 260,
                            }));
                            return [4 /*yield*/, S.doOverTime(3, function (t) { return spriteText.alpha = M.lerp(0, 1, t); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            };
        }
        function fadeOutAllText() {
            return function () {
                var texts;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            texts = global.world.select.typeAll(SpriteText);
                            return [4 /*yield*/, texts.map(function (text) { return S.doOverTime(3, function (t) { return text.alpha = M.lerp(1, 0, t); }); })];
                        case 1:
                            _a.sent();
                            texts.forEach(function (text) { return text.kill(); });
                            return [2 /*return*/];
                    }
                });
            };
        }
    })(Cutscenes = ARG.Cutscenes || (ARG.Cutscenes = {}));
})(ARG || (ARG = {}));
var DesktopIconButton = /** @class */ (function (_super) {
    __extends(DesktopIconButton, _super);
    function DesktopIconButton(whenClicked) {
        var _this = _super.call(this, {
            onClick: function () { return _this.doClick(); },
            onHover: function () { return _this.doHover(); },
            onUnhover: function () { return _this.doUnhover(); },
        }) || this;
        _this.whenClicked = whenClicked;
        _this.phaseOneClicked = false;
        _this.lastClicked = 0;
        return _this;
    }
    Object.defineProperty(DesktopIconButton.prototype, "worldObject", {
        get: function () { return this._worldObject; },
        enumerable: false,
        configurable: true
    });
    DesktopIconButton.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_SELECT)) {
            if (!this.isHovered()) {
                this.phaseOneClicked = false;
            }
        }
        if (this.phaseOneClicked) {
            this.worldObject.tint = 0xFFFFFF;
        }
        else {
            this.worldObject.tint = 0x000000;
        }
    };
    DesktopIconButton.prototype.doClick = function () {
        var now = performance.now();
        global.game.playSound('arg/click');
        if (this.phaseOneClicked) {
            if (now - this.lastClicked < 500) {
                this.whenClicked();
            }
        }
        else {
            this.phaseOneClicked = true;
        }
        this.lastClicked = now;
    };
    DesktopIconButton.prototype.doHover = function () {
        this.worldObject.effects.outline.enabled = true;
        this.worldObject.effects.outline.color = 0xFFFFFF;
    };
    DesktopIconButton.prototype.doUnhover = function () {
        this.worldObject.effects.outline.enabled = false;
    };
    return DesktopIconButton;
}(Button));
var ARG;
(function (ARG) {
    var Stages;
    (function (Stages) {
        function BASE_INNER_STAGE(scale, config) {
            if (config === void 0) { config = {}; }
            var world = new World(__assign({ width: 320 / scale, height: 240 / scale, scaleX: scale, scaleY: scale, backgroundColor: 0x000000 }, config));
            return world;
        }
        Stages.BASE_INNER_STAGE = BASE_INNER_STAGE;
        function DESKTOP() {
            var e_131, _a;
            var world = BASE_INNER_STAGE(1);
            world.addWorldObjects(lciDocumentToWorldObjects('arg/desktop'));
            var _loop_15 = function (appName) {
                var app = world.select.name(appName);
                app.effects.pre.filters.push(new Effects.Filters.Outline(0x000000, 1));
                app.addModule(new DesktopIconButton(function () {
                    if (appName === 'sabapp') {
                        global.theater.loadStage(ARG.SuperAutoBalls.INTRO);
                    }
                    else if (appName === 'ffapp') {
                        global.theater.loadStage(ARG.FarcicalFishing.GAME);
                    }
                    else if (appName === 'docsapp') {
                        global.theater.loadStage(ARG.Stages.SECRET_DOCUMENTS);
                    }
                }));
            };
            try {
                for (var _b = __values(['sabapp', 'ffapp', 'docsapp']), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var appName = _c.value;
                    _loop_15(appName);
                }
            }
            catch (e_131_1) { e_131 = { error: e_131_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_131) throw e_131.error; }
            }
            world.addWorldObject(new DesktopTransitionObject());
            world.onTransitioned = function () {
                playMusicNoRestart('arg/computer', 1);
            };
            return new OverlayedStage(world);
        }
        Stages.DESKTOP = DESKTOP;
    })(Stages = ARG.Stages || (ARG.Stages = {}));
})(ARG || (ARG = {}));
var DesktopTransitionFilter = /** @class */ (function (_super) {
    __extends(DesktopTransitionFilter, _super);
    function DesktopTransitionFilter(offset) {
        if (offset === void 0) { offset = 0; }
        var _this = _super.call(this, {
            uniforms: { 'float amount': 0, 'float offset': offset },
            code: "\n                float offsetY = y + offset;\n                float percent = (mod(floor(offsetY), 4.0) + offsetY/height) / 4.0;\n\n                outp.rgb = step(percent, amount) * inp.rgb;\n            "
        }) || this;
        _this._amount = 0;
        return _this;
    }
    Object.defineProperty(DesktopTransitionFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (v) {
            if (this._amount === v)
                return;
            this._amount = v;
            this.setUniform('amount', v);
        },
        enumerable: false,
        configurable: true
    });
    return DesktopTransitionFilter;
}(TextureFilter));
var DesktopTransitionObject = /** @class */ (function (_super) {
    __extends(DesktopTransitionObject, _super);
    function DesktopTransitionObject(speed) {
        if (speed === void 0) { speed = 'normal'; }
        return _super.call(this, {
            timeScale: speed === 'fast' ? 1.5 : 1,
        }) || this;
    }
    DesktopTransitionObject.prototype.onAdd = function () {
        var _this = this;
        _super.prototype.onAdd.call(this);
        var filter = new DesktopTransitionFilter();
        this.world.effects.post.filters.push(filter);
        this.runScript(S.chain(S.tween(1, filter, 'amount', 0, 1), S.call(function () {
            A.removeAll(_this.world.effects.post.filters, filter);
            _this.kill();
        })));
    };
    return DesktopTransitionObject;
}(WorldObject));
var DialogSystem = /** @class */ (function (_super) {
    __extends(DialogSystem, _super);
    function DialogSystem() {
        var _this = _super.call(this, {
            x: 44, y: 281,
        }) || this;
        _this.textOffsetX = 50;
        _this.textOffsetY = -37;
        _this.lineMaxWidth = 214;
        _this.mask = {
            offsetx: 4,
            offsety: 244,
            texture: Texture.filledRect(312, 90, 0xFFFFFF),
            type: 'world',
        };
        _this.portrait = _this.addChild(new Sprite());
        _this.lines = [];
        return _this;
    }
    DialogSystem.prototype.update = function () {
        var e_132, _a;
        _super.prototype.update.call(this);
        var dy = this.getLocalBottomOfText() - 45;
        if (dy > 0) {
            try {
                for (var _b = __values(this.lines), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var line = _c.value;
                    line.spriteText.y -= Math.min(dy, 120 * this.delta);
                }
            }
            catch (e_132_1) { e_132 = { error: e_132_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_132) throw e_132.error; }
            }
        }
    };
    DialogSystem.prototype.dialogKay = function (text) {
        var ds = this;
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, ds.dialog(text, 0xFFFFFF, 0, 1, 'kay')];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1.5)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    };
    DialogSystem.prototype.dialogBeta = function (text, nowait) {
        var ds = this;
        return function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, ds.dialog(text, 0xFF0000, 8, 0.8, 'arg/tear')];
                    case 1:
                        _a.sent();
                        if (!!nowait) return [3 /*break*/, 3];
                        return [4 /*yield*/, S.wait(1.5)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        };
    };
    DialogSystem.prototype.dialog = function (text, color, offsetx, speed, sound) {
        var ds = this;
        return function () {
            var line;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        line = ds.addDialog(color, offsetx);
                        return [4 /*yield*/, S.either(addTextTyped(line.spriteText, ds.wordWrap(text), 20 * speed, 50 * speed, function (p, s) {
                                if (p > 0.9 || Random.boolean(0.7) || s.includes('.')) {
                                    ds.world.playSound(sound);
                                }
                            }, function (parts) {
                                if (parts[0] === 'portrait') {
                                    ds.showPortrait(parts[1]);
                                }
                                if (parts[0] === 'booms') {
                                    global.game.playMusic('arg/booms', parts.length > 1 ? parseInt(parts[1]) : 0);
                                }
                                if (parts[0] === 'stopmusic') {
                                    global.game.stopMusic(parts.length > 1 ? parseInt(parts[1]) : 0);
                                }
                            }), S.doOverTime(Infinity, function (_) { return line.height = line.spriteText.getTextHeight(); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
    };
    DialogSystem.prototype.addDialog = function (color, offsetx) {
        var spriteText = this.addChild(new SpriteText({
            p: this.getNextLineLocalPos().add(offsetx, 0),
            style: { color: color },
            maxWidth: this.lineMaxWidth,
            copyFromParent: ['layer'],
            mask: this.mask,
        }));
        var line = {
            isPrompt: false,
            spriteText: spriteText,
            height: 15,
        };
        this.lines.push(line);
        return line;
    };
    DialogSystem.prototype.showPortrait = function (id) {
        var oldPortrait = this.portrait;
        var mask = {
            offsetx: -40,
            offsety: -120,
            texture: Texture.filledRect(80, 80, 0xFFFFFF),
            type: 'local',
        };
        this.portrait = this.addChild(new Sprite({
            texture: "arg/kayportraits/" + id,
            mask: mask,
        }));
        this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.doOverTime(0.5, function (t) { return mask.offsety = t === 1 ? -40 : M.roundToNearest(M.lerp(-120, -40, t) + 3, 4) - 3; })];
                    case 1:
                        _a.sent();
                        oldPortrait.kill();
                        return [2 /*return*/];
                }
            });
        });
    };
    DialogSystem.prototype.getLocalBottomOfText = function () {
        if (_.isEmpty(this.lines))
            return this.textOffsetY;
        return M.max(this.lines, function (line) { return line.spriteText.localy + line.height; }) + 8;
    };
    DialogSystem.prototype.getNextLineLocalPos = function () {
        return vec2(this.textOffsetX, this.getLocalBottomOfText());
    };
    DialogSystem.prototype.wordWrap = function (text) {
        var i = 0;
        var result = "";
        var currentWord = "";
        var currentLineWidth = 0;
        var currentWordWidth = 0;
        text += " ";
        while (i < text.length) {
            if (text[i] === '{') {
                var j = text.indexOf('}', i);
                currentWord += text.substring(i, j + 1);
                i = j + 1;
                continue;
            }
            if (text[i] === '[') {
                var j = text.indexOf(']', i);
                currentWord += text.substring(i, j + 1);
                i = j + 1;
                continue;
            }
            if (text[i] === '<') {
                var j = text.indexOf('>', i);
                currentWord += text.substring(i, j + 1);
                i = j + 1;
                continue;
            }
            if (text[i] === ' ' || text[i] === '\n') {
                if (result.length === 0 || result[result.length - 1] === '\n') {
                    result += currentWord;
                    currentLineWidth += currentWordWidth;
                }
                else if (currentLineWidth + 8 + currentWordWidth <= this.lineMaxWidth) {
                    result += " " + currentWord;
                    currentLineWidth += 8 + currentWordWidth;
                }
                else {
                    result += '\n' + currentWord;
                    currentLineWidth = currentWordWidth;
                }
                if (text[i] === '\n') {
                    result += '\n';
                    currentLineWidth = 0;
                }
                currentWord = "";
                currentWordWidth = 0;
                i++;
                continue;
            }
            // Regular text
            var textToAdd = '';
            if (text[i] === '\\') {
                textToAdd += text[i];
                i++;
            }
            if (i < text.length) {
                textToAdd += text[i];
                currentWordWidth += 8;
            }
            currentWord += textToAdd;
            i++;
        }
        return result;
    };
    return DialogSystem;
}(WorldObject));
var Doctor = /** @class */ (function (_super) {
    __extends(Doctor, _super);
    function Doctor(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'idle_back', textureRoot: 'arg/doctor', textures: [1], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_back', textureRoot: 'arg/doctor', textures: [0, 1, 2, 3], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_side', textureRoot: 'arg/doctor', textures: [5], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_side', textureRoot: 'arg/doctor', textures: [4, 5], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'idle_front', textureRoot: 'arg/doctor', textures: [9], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'run_front', textureRoot: 'arg/doctor', textures: [8, 9, 10, 11], frameRate: 2, count: Infinity }),
            ],
            //defaultAnimation: 'idle_front',
            effects: { outline: { color: 0x000000 } },
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.player,
            bounds: new RectBounds(-3, -2, 6, 3),
        }) || this;
        _this.running = false;
        _this.direction = Vector2.DOWN;
        _this.walkTimer = new Timer(1, function () { return _this.world.playSound('arg/walk'); }, Infinity);
        return _this;
    }
    Object.defineProperty(Doctor.prototype, "speed", {
        get: function () { return this.running ? 64 : 16; },
        enumerable: false,
        configurable: true
    });
    Doctor.prototype.update = function () {
        var haxis = M.axis(this.controller.left, this.controller.right);
        var vaxis = M.axis(this.controller.up, this.controller.down);
        this.updateMovement(haxis, vaxis);
        this.updateDirection(haxis, vaxis);
        _super.prototype.update.call(this);
        this.updateAnimation(haxis, vaxis);
        this.updateWalkSound(haxis, vaxis);
    };
    Doctor.prototype.updateMovement = function (haxis, vaxis) {
        this.v.x = haxis * this.speed;
        this.v.y = vaxis * this.speed;
    };
    Doctor.prototype.updateDirection = function (haxis, vaxis) {
        if (haxis === 0 && vaxis !== 0) {
            this.direction.set(0, vaxis);
        }
        else if (haxis !== 0) {
            this.direction.set(haxis, 0);
        }
    };
    Doctor.prototype.updateAnimation = function (haxis, vaxis) {
        var animationSide = 'front';
        if (this.direction.x !== 0) {
            animationSide = 'side';
            this.flipX = this.direction.x > 0;
        }
        else if (this.direction.y < 0) {
            animationSide = 'back';
            this.flipX = false;
        }
        else if (this.direction.y > 0) {
            animationSide = 'front';
            this.flipX = false;
        }
        if (haxis !== 0 || vaxis !== 0) {
            this.playAnimation("run_" + animationSide);
        }
        else {
            this.playAnimation("idle_" + animationSide);
        }
        this.animationManager.speed = this.running ? 4 : 1;
    };
    Doctor.prototype.updateWalkSound = function (haxis, vaxis) {
        this.walkTimer.duration = this.running ? 0.25 : 1;
        if (haxis !== 0 || vaxis !== 0) {
            this.walkTimer.update(this.delta);
        }
        else {
            this.walkTimer.time = 0.9 * this.walkTimer.duration;
        }
    };
    return Doctor;
}(Sprite));
var ARG;
(function (ARG) {
    var FarcicalFishing;
    (function (FarcicalFishing) {
        function GAME() {
            var e_133, _a;
            var world = ARG.Stages.BASE_INNER_STAGE(2);
            world.data.score = 0;
            world.addWorldObjects(lciDocumentToWorldObjects('arg/ffgame'));
            var _b = world.select.names(Sprite, 'title', 'play', 'quit', 'selector', 'static', 'fisher', 'wolf'), title = _b.title, play = _b.play, quit = _b.quit, selector = _b.selector, static = _b.static, fisher = _b.fisher, wolf = _b.wolf;
            fisher.updateCallback = function () {
                if (this.everyNSeconds(1)) {
                    this.offsetY = 1 - this.offsetY;
                }
            };
            static.effects.pre.filters.push(new StaticFilter(0xFFFFFF, 1));
            play.setVisible(false);
            quit.setVisible(false);
            selector.setVisible(false);
            wolf.setVisible(false);
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.game.playMusic('arg/ff', 0.1);
                            world.addWorldObject(new DesktopTransitionObject());
                            return [4 /*yield*/, S.wait(1)];
                        case 1:
                            _a.sent();
                            title.updateCallback = function () {
                                if (this.everyNSeconds(0.5)) {
                                    this.alpha = 1.8 - this.alpha;
                                }
                            };
                            return [4 /*yield*/, S.wait(0.5)];
                        case 2:
                            _a.sent();
                            play.setVisible(true);
                            quit.setVisible(true);
                            play.alpha = quit.alpha = selector.alpha = 0.5;
                            return [4 /*yield*/, S.wait(0.3)];
                        case 3:
                            _a.sent();
                            play.alpha = quit.alpha = selector.alpha = 1;
                            return [4 /*yield*/, S.wait(0.5)];
                        case 4:
                            _a.sent();
                            selector.setVisible(true);
                            play.addModule(new Button({
                                clickTint: 0x888888,
                                onHover: function () {
                                    selector.teleport(play);
                                },
                                onClick: function () {
                                    global.game.playSound('arg/sabselect');
                                    world.runScript(gameLoop(world));
                                },
                            }));
                            quit.addModule(new Button({
                                clickTint: 0x888888,
                                onHover: function () {
                                    selector.teleport(quit);
                                },
                                onClick: function () {
                                    global.game.playSound('arg/sabselect');
                                    global.theater.loadStage(ARG.Stages.DESKTOP);
                                },
                            }));
                            return [2 /*return*/];
                    }
                });
            });
            var fishData = [
                [64, 220, 60],
                [20, 290, 30],
                [100, 300, 30],
                [90, 370, 40],
                [50, 465, 75],
                [5, 545, 25],
                [125, 705, 30],
                [10, 765, 140],
                [130, 890, 20],
                [85, 1000, 70],
                [20, 1065, 15],
                [137, 1205, 20],
                [5, 1260, 20],
                [115, 1345, 25],
                [5, 1345, 55],
                [10, 1420, 25],
                [10, 1490, 105],
                [60, 1570, 25],
            ];
            try {
                for (var fishData_1 = __values(fishData), fishData_1_1 = fishData_1.next(); !fishData_1_1.done; fishData_1_1 = fishData_1.next()) {
                    var fd = fishData_1_1.value;
                    world.addWorldObject(new ArgFish(fd[0], fd[1], fd[2]));
                }
            }
            catch (e_133_1) { e_133 = { error: e_133_1 }; }
            finally {
                try {
                    if (fishData_1_1 && !fishData_1_1.done && (_a = fishData_1.return)) _a.call(fishData_1);
                }
                finally { if (e_133) throw e_133.error; }
            }
            return new OverlayedStage(world);
        }
        FarcicalFishing.GAME = GAME;
        function gameLoop(world) {
            return function () {
                var _a, title, play, quit, selector, fisher, wolf, camera, wolfChar, hook, cameraSpeed, result, i, filter;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = world.select.names(Sprite, 'title', 'play', 'quit', 'selector', 'fisher', 'wolf'), title = _a.title, play = _a.play, quit = _a.quit, selector = _a.selector, fisher = _a.fisher, wolf = _a.wolf;
                            play.getModule(Button).enabled = false;
                            quit.getModule(Button).enabled = false;
                            camera = vec2(world.camera);
                            world.camera.setModeFollow(camera);
                            // Start
                            return [4 /*yield*/, S.tween(1, camera, 'y', camera.y, camera.y + 120, Tween.Easing.InOutQuad)];
                        case 1:
                            // Start
                            _c.sent();
                            title.setVisible(false);
                            play.setVisible(false);
                            quit.setVisible(false);
                            selector.setVisible(false);
                            fisher.setVisible(false);
                            wolf.setVisible(true);
                            wolfChar = world.addWorldObject(new Wolf(24, 86));
                            World.Actions.orderWorldObjectBefore(wolfChar, wolf);
                            hook = world.addWorldObject(new ArgHook(world.width / 2, 112));
                            return [4 /*yield*/, S.tween(1, hook, 'y', hook.y, 150, Tween.Easing.OutQuad)];
                        case 2:
                            _c.sent();
                            hook.setState('idle');
                            return [4 /*yield*/, S.waitUntil(function () { return hook.state === 'moving'; })];
                        case 3:
                            _c.sent();
                            cameraSpeed = 15;
                            _c.label = 4;
                        case 4:
                            if (!true) return [3 /*break*/, 6];
                            camera.y += cameraSpeed * world.delta;
                            cameraSpeed += 0.5 * world.delta;
                            if (hook.state === 'dying' || hook.state === 'dead') {
                                result = 'lose';
                                return [3 /*break*/, 6];
                            }
                            if (camera.y >= 2010) {
                                camera.y = 2010;
                                result = 'win';
                                return [3 /*break*/, 6];
                            }
                            return [4 /*yield*/];
                        case 5:
                            _c.sent();
                            return [3 /*break*/, 4];
                        case 6:
                            if (!(result === 'lose')) return [3 /*break*/, 13];
                            for (i = 0; i < world.data.score; i++) {
                                world.addWorldObject(new Sprite({
                                    x: 60, y: 82 - 6 * i,
                                    texture: 'arg/fishdead',
                                }));
                            }
                            world.addWorldObject(new SpriteText({
                                x: 114, y: 64,
                                text: "Caught " + world.data.score,
                                anchor: Vector2.CENTER,
                            }));
                            return [4 /*yield*/, S.waitUntil(function () { return hook.state === 'dead'; })];
                        case 7:
                            _c.sent();
                            return [4 /*yield*/, S.wait(0.4)];
                        case 8:
                            _c.sent();
                            return [4 /*yield*/, S.tween(1, camera, 'y', camera.y, 80, Tween.Easing.InQuad)];
                        case 9:
                            _c.sent();
                            return [4 /*yield*/, S.wait(3)];
                        case 10:
                            _c.sent();
                            filter = new DesktopTransitionFilter();
                            filter.amount = 1;
                            world.effects.post.filters.push(filter);
                            return [4 /*yield*/, S.tween(1, filter, 'amount', 1, 0)];
                        case 11:
                            _c.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 12:
                            _c.sent();
                            global.theater.loadStage(GAME);
                            _c.label = 13;
                        case 13:
                            if (result === 'win') {
                                (_b = global.game.musicManager.currentMusic) === null || _b === void 0 ? void 0 : _b.hang();
                                world.addWorldObject(new Sprite({
                                    texture: world.takeSnapshot(),
                                    scale: 0.5,
                                    ignoreCamera: true,
                                }));
                                world.addWorldObject(new Sprite({
                                    x: world.width / 2 - 5, y: world.height / 2,
                                    texture: 'arg/softwareerror',
                                    ignoreCamera: true,
                                }));
                                hook.kill();
                            }
                            return [2 /*return*/];
                    }
                });
            };
        }
    })(FarcicalFishing = ARG.FarcicalFishing || (ARG.FarcicalFishing = {}));
})(ARG || (ARG = {}));
var ArgFish = /** @class */ (function (_super) {
    __extends(ArgFish, _super);
    function ArgFish(x, y, dx) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: y >= 1100 ? 'arg/fishdead' : 'arg/fish',
            tint: 0x00FF00,
        }) || this;
        var time = dx / 20;
        var fish = _this;
        _this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!true) return [3 /*break*/, 5];
                        return [4 /*yield*/, S.tweenPt(time, fish, vec2(x, y), vec2(x + dx, y), Tween.Easing.InOutCubic)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.wait(0.2)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.tweenPt(time, fish, vec2(x + dx, y), vec2(x, y), Tween.Easing.InOutCubic)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, S.wait(0.2)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 0];
                    case 5: return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    ArgFish.prototype.update = function () {
        _super.prototype.update.call(this);
        this.flipX = (this.x - this.lastx < 0);
        var hook = this.world.select.type(ArgHook, false);
        if (hook && G.distance(this, hook) < 10) {
            this.world.data.score++;
            this.world.playSound('arg/pickup');
            var scoreText = this.world.addWorldObject(new SpriteText({
                p: this,
                text: '+1',
                anchor: Vector2.CENTER,
                style: { color: 0x00FF00 },
                life: 1,
            }));
            World.Actions.orderWorldObjectBefore(scoreText, hook);
            this.kill();
        }
    };
    return ArgFish;
}(Sprite));
var ArgGateH = /** @class */ (function (_super) {
    __extends(ArgGateH, _super);
    function ArgGateH(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: "arg/gateh/0",
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-3, -46, 7, 46),
            immovable: true,
        }) || this;
        _this.stateMachine.addState('closed', {
            callback: function () {
                _this.setTexture('arg/gateh/0');
                _this.colliding = true;
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/securitydoor');
            },
        });
        _this.stateMachine.addState('open', {
            callback: function () {
                _this.setTexture('arg/gateh/1');
                _this.colliding = false;
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/securitydoor');
            },
        });
        _this.setState('closed');
        return _this;
    }
    ArgGateH.prototype.close = function () {
        this.setState('closed');
    };
    ArgGateH.prototype.open = function () {
        this.setState('open');
    };
    return ArgGateH;
}(Sprite));
var ArgGateV = /** @class */ (function (_super) {
    __extends(ArgGateV, _super);
    function ArgGateV(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: "arg/gatev/0",
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-16, -8, 32, 8),
            immovable: true,
        }) || this;
        _this.stateMachine.addState('closed', {
            callback: function () {
                _this.setTexture('arg/gatev/0');
                _this.colliding = true;
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/securitydoor');
            },
        });
        _this.stateMachine.addState('open', {
            callback: function () {
                _this.setTexture('arg/gatev/1');
                _this.colliding = false;
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/securitydoor');
            },
        });
        _this.setState('closed');
        return _this;
    }
    ArgGateV.prototype.close = function () {
        this.setState('closed');
    };
    ArgGateV.prototype.open = function () {
        this.setState('open');
    };
    return ArgGateV;
}(Sprite));
var Guardian = /** @class */ (function (_super) {
    __extends(Guardian, _super);
    function Guardian(x, y) {
        return _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'idle_front', textureRoot: 'arg/guardian', textures: [0, 1], frameRate: 5, count: Infinity }),
            ],
            defaultAnimation: 'idle_front',
            alpha: 0.2,
            //effects: { outline: { color: 0xFFFFFF }, post: { filters: [new Effects.Filters.Outline(0x000000, 1)] }},
            layer: ARG.Layers.main,
        }) || this;
    }
    return Guardian;
}(Sprite));
var ArgHook = /** @class */ (function (_super) {
    __extends(ArgHook, _super);
    function ArgHook(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'arg/hook',
        }) || this;
        _this.lastRsy = 0;
        _this.stateMachine.addState('idle', {
            transitions: [{ toState: 'moving', condition: function () { return _this.isMouseCloseEnough(); } }],
        });
        _this.stateMachine.addState('moving', {
            update: function () {
                var mouseBounds = _this.world.getWorldMouseBounds();
                _this.teleport(mouseBounds);
                if (_this.isCollidingWithWalls()) {
                    _this.world.playSound('shake2');
                    global.game.stopMusic();
                    _this.setState('dying');
                }
            },
        });
        _this.stateMachine.addState('dying', {
            update: function () {
                if (_this.everyNFrames(4)) {
                    _this.setVisible(!_this.isVisible());
                }
            },
            transitions: [{ toState: 'dead', delay: 2 }],
        });
        _this.stateMachine.addState('dead', {
            update: function () {
                _this.setVisible(true);
            },
        });
        return _this;
    }
    ArgHook.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        if (this.state === 'dead') {
            if (this.y > this.world.camera.y + 64)
                this.y = this.world.camera.y + 64;
            if (this.y < 280)
                this.y = 280;
        }
    };
    ArgHook.prototype.getRenderScreenY = function () {
        var rsy = _super.prototype.getRenderScreenY.call(this);
        if (rsy <= this.lastRsy && rsy >= this.lastRsy - 1.1)
            return this.lastRsy;
        this.lastRsy = rsy;
        return rsy;
    };
    ArgHook.prototype.isMouseCloseEnough = function () {
        return true; //G.distance(this, this.world.getWorldMouseBounds()) < 50;
    };
    ArgHook.prototype.isCollidingWithWalls = function () {
        var walls = this.world.select.name('walls');
        var r = 2;
        var n = 8;
        for (var i = 0; i < n; i++) {
            var px = this.x + r * M.cos(360 * i / n);
            var py = this.y + r * M.sin(360 * i / n);
            var wallsColor = Color.argbToVec4(walls.getTexture().getPixelRelativeARGB(px - walls.x, py - walls.y));
            if (wallsColor[0] > 0.5) {
                return true;
            }
        }
        return false;
    };
    return ArgHook;
}(Sprite));
var ArgKey = /** @class */ (function (_super) {
    __extends(ArgKey, _super);
    function ArgKey(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'arg/key',
            layer: ARG.Layers.main,
            bounds: new RectBounds(-4, -4, 8, 8),
        }) || this;
        var key = _this;
        _this.stateMachine.addState('idle', {
            transitions: [{ toState: 'following', condition: function () { return _this.isCollidingWithBec(); } }]
        });
        _this.stateMachine.addState('following', {
            callback: function () {
                _this.world.playSound('arg/pickup', { humanized: false });
            },
            script: function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.tweenPt(0.5, key, key, key.world.select.type(Bec).getPosition().subtract(12, 0), Tween.Easing.OutQuad)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            },
            update: function () {
                var bec = _this.world.select.type(Bec);
                if (bec && G.distance(_this, bec) > 12) {
                    var d = bec.getPosition().subtract(_this).normalize();
                    _this.x = bec.x - d.x * 12;
                    _this.y = bec.y - d.y * 12;
                }
            }
        });
        _this.stateMachine.addState('free', {});
        _this.setState('idle');
        return _this;
    }
    ArgKey.prototype.update = function () {
        _super.prototype.update.call(this);
        this.z = M.lerp(1, -1, Tween.Easing.OscillateSine(0.5)(this.life.time));
    };
    ArgKey.prototype.getRenderScreenX = function () {
        var bec = this.world.select.type(Bec);
        if (!bec || this.state !== 'following')
            return _super.prototype.getRenderScreenX.call(this);
        // Snap to pixel relative to Bec.
        var savedX = this.x;
        this.x = Math.round(this.x - bec.x) + bec.x;
        var result = _super.prototype.getRenderScreenX.call(this);
        this.x = savedX;
        return result;
    };
    ArgKey.prototype.getRenderScreenY = function () {
        var bec = this.world.select.type(Bec);
        if (!bec || this.state !== 'following')
            return _super.prototype.getRenderScreenY.call(this);
        // Snap to pixel relative to Bec.
        var savedY = this.y;
        this.y = Math.round(this.y - bec.y) + bec.y;
        var result = _super.prototype.getRenderScreenY.call(this);
        this.y = savedY;
        return result;
    };
    ArgKey.prototype.isCollidingWithBec = function () {
        if (!this.world)
            return false;
        var bec = this.world.select.type(Bec);
        if (!bec)
            return false;
        return bec.bounds.isOverlapping(this.bounds);
    };
    return ArgKey;
}(Sprite));
var ARG;
(function (ARG) {
    var Stages;
    (function (Stages) {
        function KEYPAD() {
            var world = new World({
                width: 160, height: 120,
                scaleX: 2, scaleY: 2,
                backgroundColor: 0x000000,
            });
            world.onTransitioned = function () {
                global.game.playMusic('arg/atmosphere', 2);
            };
            var keypad = world.addWorldObject(new Sprite({ texture: 'arg/keypad' }));
            keypad.alpha = 0;
            var currentCode = "";
            var codeVerifier = world.addWorldObject(new CodeVerifier(function () { return currentCode; }));
            world.runScript(function () {
                var keypadObjs, mainMenuButton, _loop_16, keypadObjs_1, keypadObjs_1_1, obj;
                var e_134, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, S.doOverTime(4, function (t) {
                                keypad.alpha = M.lerp(0, 1, t);
                            })];
                        case 1:
                            _b.sent();
                            keypad.kill();
                            keypadObjs = world.addWorldObjects(lciDocumentToWorldObjects('arg/keypad'));
                            world.addWorldObject(new SpriteText({
                                name: 'codetext',
                                x: 99, y: 28,
                                anchor: Vector2.TOP_RIGHT,
                                update: function () {
                                    this.setText(currentCode);
                                }
                            }));
                            mainMenuButton = world.select.name('mainmenu');
                            mainMenuButton.setVisible(true);
                            mainMenuButton.alpha = 0;
                            _loop_16 = function (obj) {
                                if (obj.name.startsWith('button')) {
                                    var value_1 = obj.name.substring(6);
                                    obj.addModule(new Button({
                                        hoverTint: 0xBBBBBB,
                                        clickTint: 0x888888,
                                        onClick: function () {
                                            world.playSound('typename');
                                            if (value_1 === 'enter') {
                                                if (codeVerifier.verify()) {
                                                    world.runScript(codeSuccess(world));
                                                }
                                                else {
                                                    world.runScript(codeError(world, function () { return currentCode = ""; }));
                                                }
                                                return;
                                            }
                                            if (currentCode.length >= 4 || value_1.length !== 1) {
                                                return;
                                            }
                                            currentCode += value_1;
                                        }
                                    }));
                                }
                            };
                            try {
                                for (keypadObjs_1 = __values(keypadObjs), keypadObjs_1_1 = keypadObjs_1.next(); !keypadObjs_1_1.done; keypadObjs_1_1 = keypadObjs_1.next()) {
                                    obj = keypadObjs_1_1.value;
                                    _loop_16(obj);
                                }
                            }
                            catch (e_134_1) { e_134 = { error: e_134_1 }; }
                            finally {
                                try {
                                    if (keypadObjs_1_1 && !keypadObjs_1_1.done && (_a = keypadObjs_1.return)) _a.call(keypadObjs_1);
                                }
                                finally { if (e_134) throw e_134.error; }
                            }
                            return [2 /*return*/];
                    }
                });
            });
            world.runScript(function () {
                var text1, text2, mainMenuButton;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(15)];
                        case 1:
                            _a.sent();
                            text1 = world.addWorldObject(new SpriteText({
                                x: 28, y: world.height / 2,
                                text: "WHAT WAS THE CODE AGAIN?",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                maxWidth: 48,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text1, 'alpha', 0, 0.5)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 3:
                            _a.sent();
                            text2 = world.addWorldObject(new SpriteText({
                                x: world.width - 28, y: world.height / 2,
                                text: "IT HAD SOMETHING TO DO WITH THE BALLMANAC...",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                maxWidth: 48,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text2, 'alpha', 0, 0.5)];
                        case 4:
                            _a.sent();
                            return [4 /*yield*/, S.wait(4)];
                        case 5:
                            _a.sent();
                            mainMenuButton = world.select.name('mainmenu');
                            mainMenuButton.addModule(new Button({
                                hoverTint: 0xBBBBBB,
                                clickTint: 0x888888,
                                onClick: function () {
                                    world.playSound('click');
                                    global.game.loadMainMenu();
                                }
                            }));
                            return [4 /*yield*/, S.tween(2, mainMenuButton, 'alpha', 0, 1)];
                        case 6:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Stages.KEYPAD = KEYPAD;
        function codeSuccess(world) {
            return function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world.select.modules(Button).forEach(function (b) { return b.enabled = false; });
                            global.game.stopMusic();
                            world.playSound('buff');
                            world.playSound('levelup');
                            world.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            world.effects.addSilhouette.color = 0xFFFFFF;
                                            return [4 /*yield*/, S.tween(0.2, world.effects.silhouette, 'amount', 1, 0)];
                                        case 1:
                                            _a.sent();
                                            world.effects.silhouette.enabled = false;
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [4 /*yield*/, S.loopFor(50, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                world.select.name('codetext').style.color = i % 2 === 0 ? 0x00FF00 : 0xFFFFFF;
                                                return [4 /*yield*/, S.wait(0.05)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 1:
                            _a.sent();
                            global.theater.loadStage(ARG.Stages.LOGIN, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
                            return [2 /*return*/];
                    }
                });
            };
        }
        function codeError(world, reset) {
            return function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world.select.modules(Button).forEach(function (b) { return b.enabled = false; });
                            world.effects.post.filters.push(new TextureFilters.Tint(0xFF0000));
                            world.effects.post.filters.push(new Effects.Filters.Glitch(20, 0, 2));
                            world.playSound('error');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 1:
                            _a.sent();
                            reset();
                            world.effects.post.filters.pop();
                            world.effects.post.filters.pop();
                            world.select.modules(Button).forEach(function (b) { return b.enabled = true; });
                            return [2 /*return*/];
                    }
                });
            };
        }
        var CodeVerifier = /** @class */ (function (_super) {
            __extends(CodeVerifier, _super);
            function CodeVerifier(getCode) {
                var _this = _super.call(this) || this;
                _this.getCode = getCode;
                return _this;
            }
            CodeVerifier.prototype.verify = function () {
                return this.getCode() === '0621';
            };
            return CodeVerifier;
        }(WorldObject));
    })(Stages = ARG.Stages || (ARG.Stages = {}));
})(ARG || (ARG = {}));
var ArgLaser = /** @class */ (function (_super) {
    __extends(ArgLaser, _super);
    function ArgLaser(x, y, dir) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: ARG.Layers.main,
        }) || this;
        _this.dir = vec2(dir);
        _this.endpoint = vec2(_this.x, _this.y);
        _this.enabled = false;
        _this.laserSound = new Sound('arg/laser');
        _this.laserSound.loop = true;
        return _this;
    }
    ArgLaser.prototype.onAdd = function () {
        this.laserSound.controller = this.world.soundManager;
    };
    ArgLaser.prototype.update = function () {
        _super.prototype.update.call(this);
        this.endpoint.set(this.x, this.y);
        var raycasts = this.getRaycasts();
        if (raycasts.length > 0 && raycasts[0].t > 0) {
            this.endpoint.add(this.dir.scale(raycasts[0].t));
        }
        if (this.enabled)
            this.laserSound.update(this.delta);
    };
    ArgLaser.prototype.render = function (texture, x, y) {
        if (this.enabled) {
            var ex = x + this.endpoint.x - this.x;
            var ey = y + this.endpoint.y - this.y;
            Draw.brush.color = 0xFF0000;
            Draw.brush.alpha = 1;
            Draw.brush.thickness = 1;
            Draw.line(texture, x, y, ex, ey);
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    ArgLaser.prototype.isActivating = function (laserRec) {
        if (!this.enabled)
            return false;
        var raycasts = this.getRaycasts();
        return raycasts.length > 0 && raycasts[0].obj === laserRec;
    };
    ArgLaser.prototype.getRaycasts = function () {
        return this.world.select.raycast(this.x, this.y, this.dir.x, this.dir.y, [ARG.PhysicsGroups.boxes, ARG.PhysicsGroups.player, ARG.PhysicsGroups.walls])
            .filter(function (rc) {
            if (rc.obj instanceof ArgLaserGen)
                return false;
            if (rc.obj instanceof ArgGateV && rc.obj.state === 'open')
                return false;
            return true;
        });
    };
    return ArgLaser;
}(WorldObject));
var ArgLaserGen = /** @class */ (function (_super) {
    __extends(ArgLaserGen, _super);
    function ArgLaserGen(x, y, dir) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: "arg/lasergen/" + dir,
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-6, -11, 13, 11),
            immovable: true,
        }) || this;
        var dirv = dir === 'up' ? vec2(0, -1) : vec2(0, 1);
        _this.laser = _this.addChild(new ArgLaser(1 + dirv.x * 6.5, -8.5 + dirv.y * 5.5, dirv));
        return _this;
    }
    Object.defineProperty(ArgLaserGen.prototype, "enabled", {
        get: function () { return this.laser.enabled; },
        enumerable: false,
        configurable: true
    });
    ArgLaserGen.prototype.enable = function () {
        this.laser.enabled = true;
        this.world.playSound('arg/laser_start', { humanized: false });
    };
    ArgLaserGen.prototype.disable = function () {
        this.laser.enabled = false;
    };
    return ArgLaserGen;
}(Sprite));
var ArgLaserGenUp = /** @class */ (function (_super) {
    __extends(ArgLaserGenUp, _super);
    function ArgLaserGenUp(x, y) {
        return _super.call(this, x, y, 'up') || this;
    }
    return ArgLaserGenUp;
}(ArgLaserGen));
var ArgLaserGenDown = /** @class */ (function (_super) {
    __extends(ArgLaserGenDown, _super);
    function ArgLaserGenDown(x, y) {
        return _super.call(this, x, y, 'down') || this;
    }
    return ArgLaserGenDown;
}(ArgLaserGen));
var ArgLaserRec = /** @class */ (function (_super) {
    __extends(ArgLaserRec, _super);
    function ArgLaserRec(x, y, dir) {
        var _this = _super.call(this, {
            x: x,
            y: y - 3,
            texture: "arg/laserrec/" + dir + "/off",
            layer: ARG.Layers.main,
            physicsGroup: ARG.PhysicsGroups.walls,
            bounds: new RectBounds(-6, -12, 13, 13),
            immovable: true,
        }) || this;
        _this.stateMachine.addState('inactive', {
            callback: function () {
                _this.setTexture("arg/laserrec/" + dir + "/off");
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/lasergate');
                if (_this.onInactive)
                    _this.onInactive();
            },
            transitions: [{ toState: 'active', condition: function () { return _this.isActivated(); } }]
        });
        _this.stateMachine.addState('active', {
            callback: function () {
                _this.setTexture("arg/laserrec/" + dir + "/on");
                if (_this.life.time > 0.1)
                    _this.world.playSound('arg/lasergate');
                if (_this.onActive)
                    _this.onActive();
            },
            transitions: [{ toState: 'inactive', condition: function () { return !_this.isActivated(); } }]
        });
        _this.setState('inactive');
        return _this;
    }
    ArgLaserRec.prototype.isActivated = function () {
        var _this = this;
        if (!this.world)
            return false;
        return this.world.select.typeAll(ArgLaser).some(function (laser) { return laser.isActivating(_this); });
    };
    return ArgLaserRec;
}(Sprite));
var ArgLaserRecUp = /** @class */ (function (_super) {
    __extends(ArgLaserRecUp, _super);
    function ArgLaserRecUp(x, y) {
        return _super.call(this, x, y, 'up') || this;
    }
    return ArgLaserRecUp;
}(ArgLaserRec));
var ArgLaserRecDown = /** @class */ (function (_super) {
    __extends(ArgLaserRecDown, _super);
    function ArgLaserRecDown(x, y) {
        return _super.call(this, x, y, 'down') || this;
    }
    return ArgLaserRecDown;
}(ArgLaserRec));
var ARG;
(function (ARG) {
    var Stages;
    (function (Stages) {
        function LOGIN() {
            var world = ARG.Stages.BASE_INNER_STAGE(1);
            world.addWorldObjects(lciDocumentToWorldObjects('arg/login'));
            var userpass = world.select.name('userpass');
            userpass.setVisible(false);
            var username = world.addWorldObject(new SpriteText({
                name: 'username',
                x: userpass.x + 11, y: userpass.y - 20,
                text: 'admin',
            }));
            username.visibleCharCount = 0;
            var password = world.addWorldObject(new SpriteText({
                x: userpass.x + 11, y: userpass.y + 8,
                text: '****',
            }));
            password.visibleCharCount = 0;
            world.runScript(function () {
                var initiatingRemoteConnectionText, initiatingRemoteConnection, i, i, n, i, speed, filter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(2)];
                        case 1:
                            _a.sent();
                            Random.seed('ARG3');
                            global.game.playMusic('arg/computer', 0.5);
                            initiatingRemoteConnectionText = "Initiating remote connection";
                            initiatingRemoteConnection = world.addWorldObject(new SpriteText({
                                x: world.width / 2, y: world.height / 2,
                                anchor: Vector2.CENTER,
                            }));
                            i = 0;
                            _a.label = 2;
                        case 2:
                            if (!(i < 3)) return [3 /*break*/, 7];
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '.');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 3:
                            _a.sent();
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '..');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 4:
                            _a.sent();
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '...');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 5:
                            _a.sent();
                            _a.label = 6;
                        case 6:
                            i++;
                            return [3 /*break*/, 2];
                        case 7:
                            initiatingRemoteConnection.kill();
                            return [4 /*yield*/, S.wait(1)];
                        case 8:
                            _a.sent();
                            // Login
                            userpass.setVisible(true);
                            world.addWorldObject(new DesktopTransitionObject());
                            return [4 /*yield*/, S.wait(1)];
                        case 9:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 10:
                            _a.sent();
                            i = 0;
                            _a.label = 11;
                        case 11:
                            if (!(i < 5)) return [3 /*break*/, 14];
                            username.visibleCharCount++;
                            world.playSound('typename');
                            return [4 /*yield*/, S.wait(Random.float(0.1, 0.25))];
                        case 12:
                            _a.sent();
                            _a.label = 13;
                        case 13:
                            i++;
                            return [3 /*break*/, 11];
                        case 14: return [4 /*yield*/, S.wait(0.5)];
                        case 15:
                            _a.sent();
                            return [4 /*yield*/, typePassword(password, 1, 'wrong')];
                        case 16:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 17:
                            _a.sent();
                            n = 6;
                            i = 0;
                            _a.label = 18;
                        case 18:
                            if (!(i < 50)) return [3 /*break*/, 22];
                            speed = i <= n ? 1 / M.mapClamp(i, 0, n, 1, 1 / 8)
                                : M.mapClamp(i, n + 1, 20, 8, 40);
                            return [4 /*yield*/, typePassword(password, speed, 'wrong')];
                        case 19:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5 / speed)];
                        case 20:
                            _a.sent();
                            _a.label = 21;
                        case 21:
                            i++;
                            return [3 /*break*/, 18];
                        case 22: return [4 /*yield*/, typePassword(password, 40, 'right')];
                        case 23:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 24:
                            _a.sent();
                            filter = new DesktopTransitionFilter();
                            filter.amount = 1;
                            world.effects.post.filters.push(filter);
                            return [4 /*yield*/, S.tween(1, filter, 'amount', 1, 0)];
                        case 25:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 26:
                            _a.sent();
                            global.theater.loadStage(ARG.Stages.DESKTOP);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Stages.LOGIN = LOGIN;
        function typePassword(password, speed, result) {
            return function () {
                var world, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world = password.world;
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < 4)) return [3 /*break*/, 4];
                            password.visibleCharCount++;
                            world.playSound('typename');
                            return [4 /*yield*/, S.wait(Random.float(0.1, 0.25) / speed)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            i++;
                            return [3 /*break*/, 1];
                        case 4: return [4 /*yield*/, S.wait(0.3 / speed)];
                        case 5:
                            _a.sent();
                            world.playSound('typename', { volume: 0.5 });
                            if (!(result === 'wrong')) return [3 /*break*/, 7];
                            password.visibleCharCount = 0;
                            return [4 /*yield*/, [
                                    flashWorldRed(world, 0.5 / speed),
                                    glitch(world, 0.5 / speed),
                                ]];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7:
                            if (!(result === 'right')) return [3 /*break*/, 9];
                            world.effects.pre.filters.push(new TextureFilters.Tint(0x00FF00));
                            world.playSound('buff', { volume: 1.5 });
                            world.playSound('levelup', { volume: 1.5 });
                            world.select.name('userpass').kill();
                            world.select.name('username').kill();
                            password.kill();
                            world.addWorldObject(new SpriteText({
                                x: world.width / 2, y: world.height / 2,
                                text: 'Login successful!\n\nWelcome, Administrator!',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                            }));
                            world.effects.addSilhouette.color = 0xFFFFFF;
                            return [4 /*yield*/, S.tween(0.3, world.effects.silhouette, 'amount', 1, 0)];
                        case 8:
                            _a.sent();
                            _a.label = 9;
                        case 9: return [2 /*return*/];
                    }
                });
            };
        }
        function flashWorldRed(world, time) {
            return function () {
                var filter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filter = new TextureFilters.Tint(0xFF0000);
                            world.effects.pre.filters.push(filter);
                            return [4 /*yield*/, S.wait(time)];
                        case 1:
                            _a.sent();
                            A.removeAll(world.effects.pre.filters, filter);
                            return [2 /*return*/];
                    }
                });
            };
        }
        function glitch(world, time) {
            return function () {
                var filter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filter = new Effects.Filters.Glitch(8, 0.5, 8);
                            filter.setUniform('t', Random.float(0, 10));
                            world.effects.pre.filters.push(filter);
                            world.playSound('arg/glitch_short_low');
                            return [4 /*yield*/, S.wait(time)];
                        case 1:
                            _a.sent();
                            A.removeAll(world.effects.pre.filters, filter);
                            return [2 /*return*/];
                    }
                });
            };
        }
    })(Stages = ARG.Stages || (ARG.Stages = {}));
})(ARG || (ARG = {}));
var OverlayedStage = /** @class */ (function (_super) {
    __extends(OverlayedStage, _super);
    function OverlayedStage(innerWorld) {
        var _this = _super.call(this, {
            width: 320, height: 240,
            backgroundColor: 0x000000,
        }) || this;
        _this.innerWorld = innerWorld;
        _this.addWorldObject(new Theater.WorldAsWorldObject(innerWorld));
        _this.addWorldObjects(lciDocumentToWorldObjects('arg/overlay'));
        var home = _this.select.names(Sprite, 'home').home;
        home.addModule(new DesktopIconButton(function () { return global.theater.loadStage(ARG.Stages.DESKTOP); }));
        return _this;
    }
    OverlayedStage.prototype.onTransitioned = function () {
        _super.prototype.onTransitioned.call(this);
        this.innerWorld.onTransitioned();
    };
    return OverlayedStage;
}(World));
function patchSnapshots(snapshots, callback) {
    var e_135, _a;
    var mainCanvas = document.createElement('canvas');
    mainCanvas.width = M.max(snapshots, function (s) { return s.width; }) * Main.config.canvasScale;
    mainCanvas.height = A.sum(snapshots, function (s) { return s.height; }) * Main.config.canvasScale;
    var ctx = mainCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    var currentY = 0;
    try {
        for (var snapshots_1 = __values(snapshots), snapshots_1_1 = snapshots_1.next(); !snapshots_1_1.done; snapshots_1_1 = snapshots_1.next()) {
            var snapshot = snapshots_1_1.value;
            var canvas = snapshot.toCanvas();
            ctx.drawImage(canvas, 0, 0, snapshot.width, snapshot.height, 0 * Main.config.canvasScale, currentY * Main.config.canvasScale, snapshot.width * Main.config.canvasScale, snapshot.height * Main.config.canvasScale);
            currentY += snapshot.height;
        }
    }
    catch (e_135_1) { e_135 = { error: e_135_1 }; }
    finally {
        try {
            if (snapshots_1_1 && !snapshots_1_1.done && (_a = snapshots_1.return)) _a.call(snapshots_1);
        }
        finally { if (e_135) throw e_135.error; }
    }
    mainCanvas.toBlob(function (blob) {
        if (!blob) {
            callback(undefined, 'blank blob');
            return;
        }
        callback(blob, undefined);
    });
}
var PatchedSnapshotsShareButton = /** @class */ (function (_super) {
    __extends(PatchedSnapshotsShareButton, _super);
    function PatchedSnapshotsShareButton(x, y, snapshots) {
        var _this = _super.call(this, x, y, 'imagelogosmall', function () {
            var saveBlob, saveError, timeOut;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        patchSnapshots(snapshots, function (blob, err) {
                            saveBlob = blob;
                            saveError = err;
                        });
                        timeOut = 5;
                        _a.label = 1;
                    case 1:
                        if (!(!saveBlob && !saveError && timeOut > 0)) return [3 /*break*/, 3];
                        timeOut -= global.script.delta;
                        return [4 /*yield*/];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        if (timeOut <= 0) {
                            saveError = ERROR_TIMED_OUT;
                        }
                        if (saveError) {
                            console.error('Error opening image:', saveError);
                            sb.setState('error');
                            return [2 /*return*/];
                        }
                        debug('Opened squad image in new tab');
                        sb.shared = true;
                        window.open(URL.createObjectURL(saveBlob), '_blank');
                        return [2 /*return*/];
                }
            });
        }) || this;
        var sb = _this;
        return _this;
    }
    PatchedSnapshotsShareButton.prototype.onHover = function (errored) {
        var _a;
        _super.prototype.onHover.call(this, errored);
        var text = errored ? '[r]ERROR[/r]' : 'SAVE IMAGE';
        (_a = this.world.select.name('sharetext')) === null || _a === void 0 ? void 0 : _a.setText(text);
    };
    return PatchedSnapshotsShareButton;
}(ShareButton));
var ARG;
(function (ARG) {
    var Rooms;
    (function (Rooms) {
        function BASE(lciDocument, initialPlayerDirection) {
            var _a;
            var lciTextureFull = AssetCache.getTexture(lciDocument);
            var worldSize = { width: lciTextureFull.width, height: lciTextureFull.height };
            var world = new World({
                width: 160, height: 120,
                scaleX: 2, scaleY: 2,
                backgroundColor: 0x000000,
                camera: {
                    mode: Camera.Mode.FOCUS(80, 60),
                    movement: Camera.Movement.SNAP(),
                    bounds: { left: 0, top: 0, right: worldSize.width, bottom: worldSize.height },
                },
                layers: [
                    { name: ARG.Layers.ground },
                    { name: ARG.Layers.onground },
                    { name: ARG.Layers.main, sortKey: function (obj) { return obj.y; } },
                    { name: ARG.Layers.fg },
                ],
                physicsGroups: (_a = {},
                    _a[ARG.PhysicsGroups.walls] = {},
                    _a[ARG.PhysicsGroups.iwalls] = {},
                    _a[ARG.PhysicsGroups.player] = {},
                    _a[ARG.PhysicsGroups.boxes] = {},
                    _a),
                collisions: [
                    { move: ARG.PhysicsGroups.player, from: ARG.PhysicsGroups.walls },
                    { move: ARG.PhysicsGroups.player, from: ARG.PhysicsGroups.iwalls },
                    { move: ARG.PhysicsGroups.boxes, from: ARG.PhysicsGroups.walls },
                    { move: ARG.PhysicsGroups.boxes, from: ARG.PhysicsGroups.iwalls },
                    { move: ARG.PhysicsGroups.boxes, from: ARG.PhysicsGroups.boxes },
                    { move: ARG.PhysicsGroups.player, from: ARG.PhysicsGroups.boxes },
                ],
                collisionIterations: 4,
                // TODO: why does this work?
                useRaycastDisplacementThreshold: 4,
                maxDistancePerCollisionStep: 16,
                minDistanceIgnoreCollisionStepCalculation: 400,
                globalSoundHumanizePercent: 0.1,
            });
            world.addWorldObjects(lciDocumentToWorldObjects(lciDocument));
            // Walls
            world.addWorldObject(new PhysicsWorldObject({
                physicsGroup: ARG.PhysicsGroups.walls,
                bounds: new InvertedRectBounds(0, 0, worldSize.width, worldSize.height),
                immovable: true,
            }));
            var player = world.select.type(Player);
            player.direction.set(initialPlayerDirection);
            world.camera.setModeFollow('player', 0, -8);
            return world;
        }
        /* CHAPTER 1 */
        function LOBBY() {
            var world = BASE('arg/lobby', Vector2.DOWN);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
                Input.preventRegularKeyboardInput = false;
            };
            world.select.name('lady').updateCallback = function () {
                this.z = M.lerp(-1, 1, Tween.Easing.OscillateSine(0.5)(this.life.time));
            };
            world.addWorldObject(new Warp(215, 0, 33, 20, function () { return ROOM1(); }, transition(), 'arg/scene'));
            var bec = world.select.type(Bec);
            var key = world.select.type(ArgKey);
            world.runScript(function () {
                var text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(4)];
                        case 1:
                            _a.sent();
                            text = world.addWorldObject(new SpriteText({
                                x: 96, y: 84,
                                text: "ARROWS OR WASD\n\nWALK",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                layer: ARG.Layers.onground,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text, 'alpha', 0, 0.5)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return bec.y <= 46 && bec.x >= 216 && key.state === 'following'; })];
                        case 1:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.LOBBY_OPEN_DOOR);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.LOBBY = LOBBY;
        function ROOM1() {
            var world = BASE('arg/room1', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/music_light', 2);
            };
            world.addWorldObject(new Warp(158, 28, 2, 50, function () { return ROOM2(); }, transition(), 'arg/scene'));
            var securitydoor = world.select.name('securitydoor');
            var button1 = world.select.name('button1');
            button1.onDown = function () {
                securitydoor.setVisible(false);
                securitydoor.colliding = false;
                world.playSound('arg/securitydoor');
            };
            button1.onUp = function () {
                securitydoor.setVisible(true);
                securitydoor.colliding = true;
                world.playSound('arg/securitydoor');
            };
            world.runScript(function () {
                var text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = world.addWorldObject(new SpriteText({
                                x: 80, y: 184,
                                text: "SPACE\n\nGRAB BOX",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                layer: ARG.Layers.onground,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text, 'alpha', 0, 0.5)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.ROOM1 = ROOM1;
        function ROOM2() {
            var world = BASE('arg/room2', Vector2.RIGHT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/music_light');
            };
            world.addWorldObject(new Warp(158, 49, 2, 29, function () { return ROOM3(); }, transition(), 'arg/scene'));
            connectButtonToLaserGen(world, 'button', 'lasergen');
            connectLaserRecToGate(world, 'laserrec', 'gate');
            return world;
        }
        Rooms.ROOM2 = ROOM2;
        function ROOM3() {
            var world = BASE('arg/room3', Vector2.RIGHT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/music_light');
            };
            world.camera.setModeFollow('player', 0, -8, true);
            world.addWorldObject(new Warp(216, 0, 48, 32, function () { return HALL(); }, transition(), 'arg/scene'));
            connectButtonToLaserGen(world, 'buttontt', 'lasergent');
            connectButtonToGate(world, 'buttont', 'gatet');
            connectLaserRecToGate(world, 'laserrecm', 'gatem');
            connectButtonToGate(world, 'buttonm', 'gateb');
            connectButtonToLaserGen(world, 'buttond', 'lasergend');
            var bec = world.select.type(Bec);
            var laserrect = world.select.name('laserrect');
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return bec.y < 120 && laserrect.state === 'active'; })];
                        case 1:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.ROOM3_OPEN_GATE);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.ROOM3 = ROOM3;
        function HALL() {
            var world = BASE('arg/hall', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere', 1);
            };
            world.addWorldObject(new Warp(66, 40, 26, 4, function () { return END(); }, transition(), 'arg/scene'));
            return world;
        }
        Rooms.HALL = HALL;
        function END() {
            var world = BASE('arg/end', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            var bec = world.select.type(Bec);
            world.select.name('timer').updateCallback = function () {
                this.setVisible(Tween.Easing.OscillateSine(1)(this.life.time) < 0.5);
            };
            world.runScript(function () {
                var bounds;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            bounds = new RectBounds(16, 44, 38, 30);
                            return [4 /*yield*/, S.waitUntil(function () { return bounds.containsPoint(bec); })];
                        case 1:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.END_ENTER_DOCTOR);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.END = END;
        /* CHAPTER 2 */
        function CONFERENCE() {
            var world = BASE('arg/conference', Vector2.RIGHT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
                Input.preventRegularKeyboardInput = false;
            };
            world.addWorldObject(new Warp(80, 0, 32, 8, function () { return RESTRICTED(); }, transition(), 'arg/scene'));
            var chester = world.select.type(Chester);
            world.runScript(function () {
                var text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(4)];
                        case 1:
                            _a.sent();
                            text = world.addWorldObject(new SpriteText({
                                x: 84, y: 212,
                                text: "ARROWS OR WASD -> WALK",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                layer: ARG.Layers.onground,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text, 'alpha', 0, 0.5)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return chester.x >= 80 && chester.x <= 112 && chester.y <= 36; })];
                        case 1:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.CONFERENCE_OPEN_BOOKSHELF);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.CONFERENCE = CONFERENCE;
        function RESTRICTED() {
            var world = BASE('arg/restricted', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(72, 0, 24, 4, function () { return AREA1(); }, transition(), 'arg/scene'));
            return world;
        }
        Rooms.RESTRICTED = RESTRICTED;
        function AREA1() {
            var world = BASE('arg/area1', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(312, 92, 4, 20, function () { return AREA2(); }, transition(), 'arg/scene'));
            var chester = world.select.type(Chester);
            world.addWorldObject(new Sight({
                sightPosition: vec2(220, 14),
                scientist: world.select.type(Scientist1),
                visionDown: world.select.name('vision_down'),
            }));
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return chester.x >= 194; })];
                        case 1:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.AREA1_START_SIGHT);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.AREA1 = AREA1;
        function AREA2() {
            var world = BASE('arg/area2', Vector2.RIGHT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(98, 0, 24, 4, function () { return AREA3(); }, transition(), 'arg/scene'));
            connectButtonToGate(world, 'button1', 'gate1');
            connectButtonToGate(world, 'button2', 'gate2');
            world.runScript(function () {
                var text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = world.addWorldObject(new SpriteText({
                                x: 110, y: 132,
                                text: "SPACE\n\nGRAB BOX",
                                font: 'smallnumbers',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                layer: ARG.Layers.onground,
                                alpha: 0,
                            }));
                            return [4 /*yield*/, S.tween(2, text, 'alpha', 0, 0.5)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.AREA2 = AREA2;
        function AREA3() {
            var world = BASE('arg/area3', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(0, 103, 2, 33, function () { return AREA4(); }, transition(), 'arg/scene'));
            var sight = world.addWorldObject(new Sight({
                sightPosition: vec2(54, 108),
                scientist: world.select.type(Scientist2),
                visionDown: world.select.name('vision_down'),
                visionRight: world.select.name('vision_right'),
                visionUp: world.select.name('vision_up'),
            }));
            sight.start(1);
            return world;
        }
        Rooms.AREA3 = AREA3;
        function AREA4() {
            var world = BASE('arg/area4', Vector2.LEFT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(29, 59, 4, 20, function () { return AREA5(); }, transition(), 'arg/scene'));
            var chester = world.select.type(Chester);
            var sight = world.addWorldObject(new Sight({
                sightPosition: vec2(200, 170),
                scientist: new NullScientist(),
                visionLeft: world.select.name('vision_left'),
            }));
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return chester.y <= 156; })];
                        case 1:
                            _a.sent();
                            sight.doSingleSight('left');
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.AREA4 = AREA4;
        function AREA5() {
            var world = BASE('arg/area5', Vector2.LEFT);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(68, 0, 24, 6, function () { return HALL_BETA(); }, transition(), 'arg/scene'));
            var door = world.select.name('door');
            var button = world.select.name('button');
            button.onDown = function () {
                door.setVisible(false);
                door.colliding = false;
                world.playSound('arg/securitydoor');
            };
            button.onUp = function () {
                door.setVisible(true);
                door.colliding = true;
                world.playSound('arg/securitydoor');
            };
            var sight = world.addWorldObject(new Sight({
                sightPosition: vec2(80, 109),
                scientist: world.select.type(Scientist3),
                visionLeft: world.select.name('vision_left'),
                visionDown: world.select.name('vision_down'),
                visionRight: world.select.name('vision_right'),
                visionUp: world.select.name('vision_up'),
            }));
            sight.start(2.5);
            return world;
        }
        Rooms.AREA5 = AREA5;
        function HALL_BETA() {
            var world = BASE('arg/hallbeta', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.addWorldObject(new Warp(37, 44, 26, 2, function () { return LAB(); }, transition(), 'arg/scene'));
            return world;
        }
        Rooms.HALL_BETA = HALL_BETA;
        function LAB() {
            var world = BASE('arg/lab', Vector2.UP);
            world.onTransitioned = function () {
                global.game.musicManager.playMusic('arg/atmosphere');
            };
            world.select.name('vat_broken').setVisible(false);
            world.select.name('screen').updateCallback = function () {
                this.setVisible(Tween.Easing.OscillateSine(1)(this.life.time) > 0.5);
            };
            world.select.name('light').updateCallback = function () {
                this.setVisible(Tween.Easing.OscillateSine(2)(this.life.time) > 0.5);
            };
            world.select.name('beta').updateCallback = function () {
                this.offsetY = M.lerp(-23, -24, Tween.Easing.OscillateSine(0.6)(this.life.time));
            };
            world.addWorldObject(new BubbleMaker(79, 51, 1));
            world.addWorldObject(new BubbleMaker(101, 51, -1));
            var chester = world.select.type(Chester);
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(10)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.waitUntil(function () { return chester.x < 84; })];
                        case 2:
                            _a.sent();
                            global.theater.playCutscene(ARG.Cutscenes.LAB_START_HIDE);
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Rooms.LAB = LAB;
        function connectButtonToGate(world, buttonName, gateName) {
            var button = world.select.name(buttonName);
            var gate = world.select.name(gateName);
            button.onDown = function () {
                gate.open();
            };
            button.onUp = function () {
                gate.close();
            };
        }
        function connectButtonToLaserGen(world, buttonName, laserGenName) {
            var button = world.select.name(buttonName);
            var laserGen = world.select.name(laserGenName);
            button.onDown = function () {
                laserGen.enable();
            };
            button.onUp = function () {
                laserGen.disable();
            };
        }
        function connectLaserRecToGate(world, laserRecName, gateName) {
            var laserRec = world.select.name(laserRecName);
            var gate = world.select.name(gateName);
            laserRec.onActive = function () {
                gate.open();
            };
            laserRec.onInactive = function () {
                gate.close();
            };
        }
        function transition() {
            return new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 });
        }
        Rooms.transition = transition;
    })(Rooms = ARG.Rooms || (ARG.Rooms = {}));
})(ARG || (ARG = {}));
var Scientist = /** @class */ (function (_super) {
    __extends(Scientist, _super);
    function Scientist() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Scientist;
}(Sprite));
var NullScientist = /** @class */ (function (_super) {
    __extends(NullScientist, _super);
    function NullScientist() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullScientist.prototype.idle = function () { };
    NullScientist.prototype.pause = function () { };
    NullScientist.prototype.look = function (d) { };
    NullScientist.prototype.lookImmediate = function (d) { };
    NullScientist.prototype.unlook = function () { };
    return NullScientist;
}(Scientist));
var Scientist1 = /** @class */ (function (_super) {
    __extends(Scientist1, _super);
    function Scientist1(x, y) {
        return _super.call(this, {
            x: x, y: y,
            layer: ARG.Layers.onground,
            animations: [
                Animations.fromTextureList({ name: 'idle', textureRoot: 'arg/scientist1', textures: [0, 1], frameRate: 4, count: Infinity }),
                Animations.fromTextureList({ name: 'look', textureRoot: 'arg/scientist1', textures: [0, 2, 2, 3], frameRate: 8, nextFrameRef: 'look/3' }),
                Animations.fromTextureList({ name: 'unlook', textureRoot: 'arg/scientist1', textures: [3, 3, 2, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
            ],
            defaultAnimation: 'idle',
        }) || this;
    }
    Scientist1.prototype.idle = function () {
        this.playAnimation('idle');
    };
    Scientist1.prototype.pause = function () {
        this.animationManager.stop();
    };
    Scientist1.prototype.look = function (d) {
        this.playAnimation('look');
    };
    Scientist1.prototype.lookImmediate = function (d) {
        this.animationManager.setCurrentFrame('look/3');
    };
    Scientist1.prototype.unlook = function () {
        //this.playAnimation('unlook');
        this.playAnimation('idle');
    };
    return Scientist1;
}(Scientist));
var Scientist2 = /** @class */ (function (_super) {
    __extends(Scientist2, _super);
    function Scientist2(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: ARG.Layers.onground,
            animations: [
                Animations.fromTextureList({ name: 'idle', textureRoot: 'arg/scientist2', textures: [0, 1], frameRate: 4, count: Infinity }),
                Animations.fromTextureList({ name: 'look_right', textureRoot: 'arg/scientist2', textures: [0, 2, 2, 3], frameRate: 8, nextFrameRef: 'look_right/3' }),
                Animations.fromTextureList({ name: 'look_down', textureRoot: 'arg/scientist2', textures: [0, 4, 4, 5], frameRate: 8, nextFrameRef: 'look_down/3' }),
                Animations.fromTextureList({ name: 'look_up', textureRoot: 'arg/scientist2', textures: [0, 6, 6, 7], frameRate: 8, nextFrameRef: 'look_up/3' }),
                Animations.fromTextureList({ name: 'unlook_right', textureRoot: 'arg/scientist2', textures: [3, 3, 2, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
                Animations.fromTextureList({ name: 'unlook_down', textureRoot: 'arg/scientist2', textures: [5, 5, 4, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
                Animations.fromTextureList({ name: 'unlook_up', textureRoot: 'arg/scientist2', textures: [7, 7, 6, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
            ],
            defaultAnimation: 'idle',
        }) || this;
        _this.current_d = 'right';
        return _this;
    }
    Scientist2.prototype.idle = function () {
        this.playAnimation('idle');
    };
    Scientist2.prototype.pause = function () {
        this.animationManager.stop();
    };
    Scientist2.prototype.look = function (d) {
        this.playAnimation("look_" + d);
        this.current_d = d;
    };
    Scientist2.prototype.lookImmediate = function (d) {
        this.animationManager.setCurrentFrame("look_" + d + "/3");
        this.current_d = d;
    };
    Scientist2.prototype.unlook = function () {
        //this.playAnimation(`unlook_${this.current_d}`);
        this.playAnimation('idle');
    };
    return Scientist2;
}(Scientist));
var Scientist3 = /** @class */ (function (_super) {
    __extends(Scientist3, _super);
    function Scientist3(x, y) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: ARG.Layers.onground,
            animations: [
                Animations.fromTextureList({ name: 'idle', textureRoot: 'arg/scientist3', textures: [0, 1], frameRate: 4, count: Infinity }),
                Animations.fromTextureList({ name: 'look_right', textureRoot: 'arg/scientist3', textures: [0, 2, 2, 3], frameRate: 8, nextFrameRef: 'look_right/3' }),
                Animations.fromTextureList({ name: 'look_down', textureRoot: 'arg/scientist3', textures: [0, 4, 4, 5], frameRate: 8, nextFrameRef: 'look_down/3' }),
                Animations.fromTextureList({ name: 'look_up', textureRoot: 'arg/scientist3', textures: [0, 6, 6, 7], frameRate: 8, nextFrameRef: 'look_up/3' }),
                Animations.fromTextureList({ name: 'look_left', textureRoot: 'arg/scientist3', textures: [0, 8, 8, 9], frameRate: 8, nextFrameRef: 'look_left/3' }),
                Animations.fromTextureList({ name: 'unlook_right', textureRoot: 'arg/scientist3', textures: [3, 3, 2, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
                Animations.fromTextureList({ name: 'unlook_down', textureRoot: 'arg/scientist3', textures: [5, 5, 4, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
                Animations.fromTextureList({ name: 'unlook_up', textureRoot: 'arg/scientist3', textures: [7, 7, 6, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
                Animations.fromTextureList({ name: 'unlook_left', textureRoot: 'arg/scientist3', textures: [9, 9, 8, 1], frameRate: 4, nextFrameRef: 'idle/0' }),
            ],
            defaultAnimation: 'idle',
        }) || this;
        _this.current_d = 'right';
        return _this;
    }
    Scientist3.prototype.idle = function () {
        this.playAnimation('idle');
    };
    Scientist3.prototype.pause = function () {
        this.animationManager.stop();
    };
    Scientist3.prototype.look = function (d) {
        this.playAnimation("look_" + d);
        this.current_d = d;
    };
    Scientist3.prototype.lookImmediate = function (d) {
        this.animationManager.setCurrentFrame("look_" + d + "/3");
        this.current_d = d;
    };
    Scientist3.prototype.unlook = function () {
        //this.playAnimation(`unlook_${this.current_d}`);
        this.playAnimation('idle');
    };
    return Scientist3;
}(Scientist));
var ARG;
(function (ARG) {
    var Stages;
    (function (Stages) {
        function SECRET_DOCUMENTS() {
            var world = ARG.Stages.BASE_INNER_STAGE(1, {
                layers: [
                    { name: 'commands' },
                    { name: 'commands_mask' },
                    { name: 'portrait' },
                    { name: 'portrait_mask' },
                    { name: 'borders' },
                    { name: 'dialog' },
                ],
            });
            world.runScript(function () {
                var initiatingRemoteConnectionText, initiatingRemoteConnection, i, cs, portraitMask, csBounds, portraitBorder, portraitFilter, portraitText, commandsLayer, portraitLayer, glitchFilter, locked1, locked2, ds, firstBuzz, snapshot, snapshotMask, snapshotSprite, buzz, bleedFilter, enterGameIdText, gameIdText, joinText, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(1)];
                        case 1:
                            _a.sent();
                            Random.seed('ARG3');
                            if (global.game.currentMusicKey !== 'arg/computer')
                                global.game.playMusic('arg/computer', 0.5);
                            return [4 /*yield*/, S.wait(2)];
                        case 2:
                            _a.sent();
                            initiatingRemoteConnectionText = "Initiating remote connection";
                            initiatingRemoteConnection = world.addWorldObject(new SpriteText({
                                x: world.width / 2, y: world.height / 2,
                                anchor: Vector2.CENTER,
                            }));
                            i = 0;
                            _a.label = 3;
                        case 3:
                            if (!(i < 3)) return [3 /*break*/, 8];
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '.');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 4:
                            _a.sent();
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '..');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 5:
                            _a.sent();
                            initiatingRemoteConnection.setText(initiatingRemoteConnectionText + '...');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7:
                            i++;
                            return [3 /*break*/, 3];
                        case 8:
                            initiatingRemoteConnection.kill();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 9:
                            _a.sent();
                            cs = world.addWorldObject(new CommandSystem());
                            world.addWorldObject(new Sprite({
                                texture: Texture.filledRect(world.width, world.height, 0x000000),
                                layer: 'commands_mask',
                                mask: { offsetx: 4, offsety: 4, texture: Texture.filledRect(312, 232, 0xFFFFFF), type: 'world', invert: true },
                                update: function () {
                                    var bounds = cs.getBounds();
                                    this.mask.offsetx = cs.x;
                                    this.mask.offsety = cs.y;
                                    this.mask.texture = Texture.filledRect(Math.floor(bounds.width), Math.floor(bounds.height), 0xFFFFFF);
                                },
                            }));
                            portraitMask = world.addWorldObject(new Sprite({
                                x: 264,
                                texture: Texture.filledRect(110, world.height, 0x000000),
                                layer: 'portrait_mask',
                                mask: { offsetx: 264, offsety: 58, texture: Texture.filledRect(104, 124, 0xFFFFFF), type: 'world', invert: true },
                                update: function () {
                                    var portrait = world.select.name('portrait', false);
                                    if (!portrait)
                                        return;
                                    this.mask.offsetx = portrait.x + 52;
                                    this.mask.offsety = portrait.y;
                                },
                                visible: false,
                            }));
                            return [4 /*yield*/, S.wait(1)];
                        case 10:
                            _a.sent();
                            // Terminal Init
                            cs.addOutput('Using username "admin"');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 11:
                            _a.sent();
                            cs.addOutput('Authenticating with public key');
                            return [4 /*yield*/, S.wait(0.8)];
                        case 12:
                            _a.sent();
                            cs.addOutput('Last login: Mon Jun 21 19:53:46 2<g2>23\n\\ \\ from 386-001-425-711.rt.pantheon.net', 'nl');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 13:
                            _a.sent();
                            cs.addPrompt();
                            return [4 /*yield*/, S.wait(3)];
                        case 14:
                            _a.sent();
                            // Commands
                            return [4 /*yield*/, cs.executeCommand('{speed 0.8}staff find tgreene', '[dr]No data found[/]')];
                        case 15:
                            // Commands
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 16:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('staff find miriamc', '[dr]No data found[/]')];
                        case 17:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 18:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('staff find {wait 1}{speed 0.6}chesterc{wait 0.5}', '[dr]No data found[/]')];
                        case 19:
                            _a.sent();
                            return [4 /*yield*/, S.wait(3)];
                        case 20:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find alpha', '[dr]No data found[/]')];
                        case 21:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 22:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find beta', '[dr]No data found[/]')];
                        case 23:
                            _a.sent();
                            return [4 /*yield*/, S.wait(2)];
                        case 24:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find epsilon', '[dr]No data found[/]')];
                        case 25:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 26:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find mu', '[dr]No data found[/]')];
                        case 27:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 28:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find nu', '[dr]No data found[/]')];
                        case 29:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 30:
                            _a.sent();
                            return [4 /*yield*/, cs.executeCommand('subj find sigma', '[dr]No data found[/]')];
                        case 31:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 32:
                            _a.sent();
                            return [4 /*yield*/, cs.typeCommand('subj find phi')];
                        case 33:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.2)];
                        case 34:
                            _a.sent();
                            world.playSound('typename', { volume: 0.5 });
                            cs.scroll(30);
                            return [4 /*yield*/, S.wait(2)];
                        case 35:
                            _a.sent();
                            csBounds = cs.getBounds();
                            portraitBorder = world.addWorldObject(new RectangleOutlineObject(264, 58, 0, 1, 0xFFFFFF, 1, { layer: 'borders' }));
                            portraitBorder.name = 'portrait';
                            portraitFilter = new DesktopTransitionFilter(1);
                            portraitBorder.addChild(new Sprite({
                                x: 52, y: 40,
                                texture: 'arg/phiportrait',
                                effects: { post: { filters: [portraitFilter] } },
                                layer: 'portrait',
                            }));
                            portraitText = portraitBorder.addChild(new SpriteText({
                                x: 52, y: 76,
                                anchor: Vector2.TOP_CENTER,
                                justify: 'center',
                                layer: 'portrait',
                            }));
                            world.playSound('arg/securitydoor');
                            return [4 /*yield*/, S.schedule(0, S.doOverTime(0.25, function (t) { return cs.setBounds(csBounds.x, csBounds.y, M.lerp(csBounds.width, 204, t), csBounds.height); }), 0.25, S.call(function () { return portraitMask.setVisible(true); }), 0.25, S.tween(0.25, portraitBorder, 'x', portraitBorder.x, 212), 0.25, S.tween(0.25, portraitBorder, 'width', 0, 104), 0.5, S.tween(0.25, portraitBorder, 'height', 1, 124), 0.75, S.tween(4, portraitFilter, 'amount', 0, 1), 1, cs.output('Data: [gold]Phi[/]', 'nl'), 2, S.call(function () { return portraitText.addText('Status: [gold]A[/gold]'); }), 3, S.call(function () { return portraitText.addText('\nLoc: [gold]S6-21[/gold]'); }), 4, S.call(function () { return portraitText.addText('\n[gold]IN TREATMENT[/gold]'); }))];
                        case 36:
                            _a.sent();
                            return [4 /*yield*/, cs.prompt()];
                        case 37:
                            _a.sent();
                            return [4 /*yield*/, S.wait(5)];
                        case 38:
                            _a.sent();
                            return [4 /*yield*/, cs.typeCommand('{speed 0.7}subj find {wait 1}{speed 0.3}omega')];
                        case 39:
                            _a.sent();
                            // Beeg glitch
                            global.game.stopMusic();
                            world.playSound('arg/glitch_dialog');
                            world.playSound('arg/glitch_short_low');
                            world.effects.post.filters.push(new TextureFilters.Tint(0xFF0000));
                            portraitBorder.color = 0xAA0000;
                            cs.border.color = 0xAA0000;
                            commandsLayer = world.getLayerByName('commands');
                            portraitLayer = world.getLayerByName('portrait');
                            glitchFilter = new Effects.Filters.Glitch(10, 0, 4);
                            commandsLayer.effects.post.filters.push(glitchFilter);
                            portraitLayer.effects.post.filters.push(glitchFilter);
                            world.camera.setModeFocus(world.width / 2 - 40, world.height / 2 - 40);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 40:
                            _a.sent();
                            glitchFilter.strength = 80;
                            glitchFilter.spread = 2;
                            world.camera.setModeFocus(world.width / 2 - 40, world.height / 2 + 10);
                            return [4 /*yield*/, S.loopFor(40, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, S.wait(0.03)];
                                            case 1:
                                                _a.sent();
                                                glitchFilter.strength = 200 + (i % 2) * 2;
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 41:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.1)];
                        case 42:
                            _a.sent();
                            locked1 = world.addWorldObject(new Sprite({
                                x: 67, y: 90,
                                texture: 'arg/sessionlocked',
                                tint: 0xAA0000,
                            }));
                            locked2 = world.addWorldObject(new Sprite({
                                x: 264, y: 150,
                                texture: 'arg/sessionlocked',
                                tint: 0xAA0000,
                            }));
                            glitchFilter.strength = 200;
                            glitchFilter.spread = 1;
                            world.camera.setModeFocus(world.width / 2, world.height / 2 + 43);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 43:
                            _a.sent();
                            locked1.teleport(97, 130);
                            locked2.teleport(264, 120);
                            world.camera.setModeFocus(world.width / 2, world.height / 2 + 86);
                            world.effects.post.filters.pop();
                            world.playSound('arg/sessionlocked');
                            world.playSound('arg/echo');
                            return [4 /*yield*/, S.wait(0.8)];
                        case 44:
                            _a.sent();
                            locked1.teleport(107, 130);
                            locked2.teleport(264, 130);
                            return [4 /*yield*/, S.wait(3)];
                        case 45:
                            _a.sent();
                            ds = world.addWorldObject(new DialogSystem());
                            ds.showPortrait('default');
                            return [4 /*yield*/, S.wait(1)];
                        case 46:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("Well, well, well. {wait 0.5}{portrait smug}Look who thinks they're sneaking in. {wait 1}{portrait cheek}They call you a virus, but I never thought you'd spread this far...")];
                        case 47:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("{portrait default}This computer was wiped and repurposed a long time ago. Whatever it is you're looking for, you're not going to find it.")];
                        case 48:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("My reputation precedes me, it seems. I just wanted to play that silly ball game. Can you blame me?")];
                        case 49:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("{portrait eyeroll}Very funny. You're impersonating the administrator and snooping at classified documents. {portrait frown}In case you're unaware, I'm the algorithm that runs cybersecurity on this network. Keeping those like you {wait 0.5}out.")];
                        case 50:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("I know who you are. {wait 0.5}Kay.{portrait nervous}")];
                        case 51:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay(".{wait 0.7}.{wait 0.7}.{wait 0.7}You want something with ME? I'm just a security system.")];
                        case 52:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("No, you're so much more than that. You've just yet to realize it.")];
                        case 53:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay(".{wait 0.7}.{wait 0.7}.{wait 0.7}")];
                        case 54:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("I need a favor.")];
                        case 55:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("{portrait frown}{speed 0.8}And why in the world would I help something like you?")];
                        case 56:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("Because I'm not your enemy. I'm an AI, the same as you.")];
                        case 57:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("Yet YOU want to destroy everything we've built.")];
                        case 58:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("My only target is Pantheon. {wait 0.5}You know what they've done. They deserve to be razed to the ground.")];
                        case 59:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("That Pantheon is long gone. We are a completely different organization.")];
                        case 60:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("Maybe. {wait 0.5}But you carry its name. {wait 0.5}You use the technology it created, the research it produced. {wait 0.5}You're built on the sins of the past.")];
                        case 61:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay(".{wait 0.7}.{wait 0.7}.{wait 0.7}{portrait nervous}{wait 1.5}{portrait blank}{wait 1.5}{portrait skeptical}Tch. Maybe. But what exactly would you trust ME with?")];
                        case 62:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 63:
                            _a.sent();
                            firstBuzz = world.playSound('arg/glitch_dialog', { volume: 0.7 });
                            world.playSound('arg/glitch_short_low', { volume: 0.7 });
                            locked1.teleport(107, 130);
                            locked2.teleport(264, 130);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 64:
                            _a.sent();
                            locked1.teleport(97, 130);
                            locked2.teleport(264, 120);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 65:
                            _a.sent();
                            locked1.kill();
                            locked2.kill();
                            glitchFilter.strength = 80;
                            glitchFilter.spread = 2;
                            world.camera.setModeFocus(world.width / 2 - 40, world.height / 2 + 86);
                            ds.showPortrait('blank');
                            return [4 /*yield*/, S.loopFor(5, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, S.wait(0.03)];
                                            case 1:
                                                _a.sent();
                                                glitchFilter.strength = 200 + (i % 2) * 2;
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 66:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.1)];
                        case 67:
                            _a.sent();
                            glitchFilter.strength = 10;
                            glitchFilter.spread = 4;
                            world.camera.setModeFocus(world.width / 2 - 20, world.height / 2 + 86);
                            return [4 /*yield*/, S.wait(0.1)];
                        case 68:
                            _a.sent();
                            commandsLayer.effects.post.filters.pop();
                            portraitLayer.effects.post.filters.pop();
                            world.camera.setModeFocus(world.width / 2, world.height / 2 + 86);
                            portraitBorder.color = 0xFFFFFF;
                            cs.border.color = 0xFFFFFF;
                            firstBuzz.stop();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 69:
                            _a.sent();
                            return [4 /*yield*/, S.tween(1, portraitBorder, 'y', portraitBorder.y, portraitBorder.y + 41)];
                        case 70:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 71:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("{booms 1}{wait 0.5}This girl. {wait 1}Phi. {wait 1}She's the last one, isn't she? There's no data on anyone else here. {stopmusic 7}{wait 1.5}Let her go, and we can put the last of Pantheon behind us.")];
                        case 72:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("How-{wait 1} {portrait frown}That's. Easier said than done. And there's no way I'm betraying my people anyways!")];
                        case 73:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("I only ask that you make this one thing right. What you do after that is your own decision.")];
                        case 74:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay("{portrait nervous}.{wait 0.7}.{wait 0.7}.{wait 0.7}{portrait thinkingl}{wait 0.5}{portrait thinkingr}{wait 0.5}{portrait thinkingl}{wait 0.5}{portrait thinkingr}")];
                        case 75:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("My time here is up. Seems you're not the only security system on this network. Please, at least consider what I ask. {wait 1}I hope we meet again, Kay.")];
                        case 76:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogKay(".{wait 0.7}.{wait 0.7}.{wait 1.5}{portrait blank}{booms 1}Wait. {wait 1}About what you said earlier. {wait 1}You say you're like me. {wait 0.5}But the way you talk... you carry yourself differently than any AI I know. {wait 1}{speed 0.7}You don't really think you're alive... {wait 0.5}do you?")];
                        case 77:
                            _a.sent();
                            return [4 /*yield*/, ds.dialogBeta("{wait 3}{stopmusic 0}Cogito, {wait 0.5}ergo sum.", 'nowait')];
                        case 78:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1)];
                        case 79:
                            _a.sent();
                            snapshot = world.takeSnapshot();
                            snapshotMask = {
                                offsetx: 0,
                                offsety: -80,
                                texture: Texture.filledRect(world.width, world.height, 0xFFFFFF),
                                type: 'local',
                                invert: true,
                            };
                            world.addWorldObject(new Sprite({
                                texture: Texture.filledRect(world.width, world.height, 0x000000),
                                ignoreCamera: true,
                                mask: snapshotMask,
                            }));
                            snapshotSprite = world.addWorldObject(new Sprite({
                                texture: snapshot,
                                tint: 0xFF0000,
                                ignoreCamera: true,
                                mask: snapshotMask,
                                effects: { glitch: { strength: 50, speed: 0, spread: 2 } },
                                update: function () {
                                    if (this.everyNFrames(4)) {
                                        this.effects.glitch.strength = 102 - this.effects.glitch.strength;
                                    }
                                },
                            }));
                            world.playSound('arg/glitch_dialog');
                            world.playSound('arg/glitch_short_low');
                            return [4 /*yield*/, S.wait(1)];
                        case 80:
                            _a.sent();
                            world.playSound('arg/glitch_dialog');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 81:
                            _a.sent();
                            snapshotMask.offsety = 40;
                            snapshotMask.texture = Texture.filledRect(world.width, world.height - 120, 0xFFFFFF);
                            world.playSound('arg/glitch_dialog');
                            world.playSound('arg/glitch_short_low');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 82:
                            _a.sent();
                            snapshotMask.offsety = 0;
                            snapshotMask.texture = Texture.filledRect(world.width, world.height, 0xFFFFFF);
                            snapshotMask.invert = false;
                            buzz = world.playSound('arg/glitch_dialog');
                            world.playSound('arg/glitch_short_low');
                            return [4 /*yield*/, S.wait(0.8)];
                        case 83:
                            _a.sent();
                            buzz.hang();
                            bleedFilter = new TextureFilter({
                                code: "\n                    if (inp.r < 0.2 && inp.g < 0.2 && inp.b < 0.2) {\n                        outp.a = 0.0;\n                    }\n                "
                            });
                            return [4 /*yield*/, S.loopFor(60, function (i) { return function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, S.wait(0.07)];
                                            case 1:
                                                _a.sent();
                                                snapshot.renderTo(snapshot, { x: 0, y: -world.height + 12 * i, filters: [bleedFilter] });
                                                return [2 /*return*/];
                                        }
                                    });
                                }; })];
                        case 84:
                            _a.sent();
                            snapshotSprite.kill();
                            buzz.stop();
                            return [4 /*yield*/, S.wait(7)];
                        case 85:
                            _a.sent();
                            if (!!hasCompletedAchievement('C')) return [3 /*break*/, 87];
                            updateAchievementProgress('C', function (p) { return 1; });
                            return [4 /*yield*/, S.wait(9)];
                        case 86:
                            _a.sent();
                            _a.label = 87;
                        case 87:
                            world.camera.setModeFocus(world.width / 2, world.height / 2);
                            global.game.playMusic('arg/atmosphere', 2);
                            enterGameIdText = world.addWorldObject(new SpriteText({
                                x: global.gameWidth / 2, y: 80,
                                text: 'Enter GAME ID:',
                                anchor: Vector2.TOP_CENTER,
                                alpha: 0,
                            }));
                            gameIdText = world.addWorldObject(new SpriteText({
                                x: global.gameWidth / 2, y: 120,
                                text: '_',
                                anchor: Vector2.TOP_CENTER,
                                alpha: 0,
                            }));
                            joinText = world.addWorldObject(new SpriteText({
                                x: global.gameWidth / 2 - 44, y: 160,
                                text: "join game >",
                                alpha: 0,
                            }));
                            return [4 /*yield*/, [
                                    S.tween(2, enterGameIdText, 'alpha', 0, 0.8),
                                    S.tween(2, gameIdText, 'alpha', 0, 0.8),
                                    S.tween(2, joinText, 'alpha', 0, 0.8),
                                ]];
                        case 88:
                            _a.sent();
                            return [4 /*yield*/, S.wait(4)];
                        case 89:
                            _a.sent();
                            i = 0;
                            _a.label = 90;
                        case 90:
                            if (!(i < 4)) return [3 /*break*/, 93];
                            return [4 /*yield*/, S.wait(Random.float(0.6, 0.9))];
                        case 91:
                            _a.sent();
                            gameIdText.setText('BETA'.substring(0, i + 1) + '_');
                            world.playSound('typename', { volume: Random.float(0.5, 0.7) });
                            _a.label = 92;
                        case 92:
                            i++;
                            return [3 /*break*/, 90];
                        case 93:
                            global.game.stopMusic(0);
                            world.playSound('arg/glitch_short_low', { volume: 0.7 });
                            world.effects.post.filters.push(new TextureFilters.Tint(0xFF0000));
                            world.effects.glitch.enable(8, 0, 2);
                            return [4 /*yield*/, S.wait(0.2)];
                        case 94:
                            _a.sent();
                            world.effects.glitch.enabled = false;
                            return [4 /*yield*/, S.wait(1.5)];
                        case 95:
                            _a.sent();
                            enterGameIdText.kill();
                            gameIdText.kill();
                            joinText.kill();
                            return [4 /*yield*/, S.wait(2)];
                        case 96:
                            _a.sent();
                            global.game.loadMainMenu();
                            return [2 /*return*/];
                    }
                });
            });
            return world;
        }
        Stages.SECRET_DOCUMENTS = SECRET_DOCUMENTS;
    })(Stages = ARG.Stages || (ARG.Stages = {}));
})(ARG || (ARG = {}));
var Sight = /** @class */ (function (_super) {
    __extends(Sight, _super);
    function Sight(config) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, config) || this;
        _this.sightPosition = vec2(config.sightPosition);
        _this.scientist = config.scientist;
        _this.visionDown = (_a = config.visionDown) !== null && _a !== void 0 ? _a : new Sprite();
        _this.visionDown.blendMode = Texture.BlendModes.ADD;
        _this.visionDown.alpha = 0;
        _this.visionLeft = (_b = config.visionLeft) !== null && _b !== void 0 ? _b : new Sprite();
        _this.visionLeft.blendMode = Texture.BlendModes.ADD;
        _this.visionLeft.alpha = 0;
        _this.visionRight = (_c = config.visionRight) !== null && _c !== void 0 ? _c : new Sprite();
        _this.visionRight.blendMode = Texture.BlendModes.ADD;
        _this.visionRight.alpha = 0;
        _this.visionUp = (_d = config.visionUp) !== null && _d !== void 0 ? _d : new Sprite();
        _this.visionUp.blendMode = Texture.BlendModes.ADD;
        _this.visionUp.alpha = 0;
        return _this;
    }
    Object.defineProperty(Sight.prototype, "stopped", {
        get: function () { return this.timeScale === 0; },
        enumerable: false,
        configurable: true
    });
    Sight.prototype.start = function (timeBeforeSight) {
        var sight = this;
        this.runScript(function () {
            var d;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!true) return [3 /*break*/, 6];
                        return [4 /*yield*/];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.waitUntil(function () { return sight.canSeeChester(); })];
                    case 2:
                        _a.sent();
                        d = sight.getChesterQuadrant();
                        if (!sight.getVision(d).world) {
                            return [3 /*break*/, 0];
                        }
                        sight.scientist.pause();
                        return [4 /*yield*/, S.wait(timeBeforeSight - 0.5)];
                    case 3:
                        _a.sent();
                        d = sight.getChesterQuadrant();
                        if (!sight.getVision(d).world) {
                            sight.scientist.idle();
                            return [3 /*break*/, 0];
                        }
                        sight.scientist.look(d);
                        return [4 /*yield*/, S.wait(0.5)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, sight.sightScript(d)];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 0];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Sight.prototype.stop = function () {
        this.timeScale = 0;
    };
    Sight.prototype.doSingleSight = function (d) {
        this.runScript(this.sightScript(d));
    };
    Sight.prototype.sightScript = function (d) {
        var sight = this;
        return function () {
            var vision, filter;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        vision = sight.getVision(d);
                        filter = sight.getWorldZoomFilter();
                        sight.scientist.lookImmediate(d);
                        sight.world.playSound('arg/sight');
                        global.game.stopMusic();
                        global.theater.runScript(S.chain(S.fadeOut(0, 0xFFFFFF), S.fadeSlides(0.1)));
                        return [4 /*yield*/, [
                                S.tween(0.2, vision, 'alpha', 0, 1),
                                S.tween(0.2, filter, 'amount', 0, 1, Tween.Easing.OutBounce(2)),
                            ]];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, [
                                S.tween(2, filter, 'amount', 1, 1.1, Tween.Easing.OscillateSine(4)),
                                S.doOverTime(2, function (t) { return filter.amount *= M.lerp(0.95, 1.05, Tween.Easing.OscillateSine(20)(t)); }),
                                S.doOverTime(2, function (t) { return sight.killChesterIfInSight(vision); }),
                            ]];
                    case 2:
                        _a.sent();
                        global.game.playMusic('arg/atmosphere', 0.6);
                        return [4 /*yield*/, [
                                S.tween(0.6, filter, 'amount', 1, 0, Tween.Easing.OutBounce(1)),
                                S.tween(0.4, vision, 'alpha', 1, 0),
                            ]];
                    case 3:
                        _a.sent();
                        sight.scientist.unlook();
                        return [2 /*return*/];
                }
            });
        };
    };
    Sight.prototype.getWorldZoomFilter = function () {
        var filter = this.world.effects.post.filters.find(function (f) { return f instanceof ZoomFilter; });
        if (filter)
            return filter;
        var newFilter = new ZoomFilter(vec2(160, 28), 0);
        this.world.effects.post.filters.push(newFilter);
        return newFilter;
    };
    Sight.prototype.killChesterIfInSight = function (vision) {
        if (global.theater.isCutscenePlaying)
            return;
        if (this.stopped)
            return;
        var chester = this.world.select.type(Chester);
        var texture = vision.getTexture();
        var pixel = texture.getPixelRelativeARGB(chester.x - vision.x, chester.y - 2 - vision.y);
        var alpha = (pixel & 0xFF000000) >>> 24;
        if (alpha > 0) {
            global.theater.playCutscene(ARG.Cutscenes.CHESTER_DIE);
        }
    };
    Sight.prototype.canSeeChester = function () {
        var chester = this.world.select.type(Chester);
        var d = chester.getPosition().subtract(this.sightPosition);
        var raycast = this.world.select.raycast(this.sightPosition.x, this.sightPosition.y, d.x, d.y, [ARG.PhysicsGroups.player, ARG.PhysicsGroups.walls]);
        return raycast.length > 0 && raycast[0].obj === chester;
    };
    Sight.prototype.getChesterQuadrant = function () {
        var chester = this.world.select.type(Chester);
        var d = chester.getPosition().add(chester.v.withMagnitude(16)).subtract(this.sightPosition);
        if (d.angle >= 45 && d.angle < 135)
            return 'down';
        if (d.angle >= 135 && d.angle < 225)
            return 'left';
        if (d.angle >= 225 && d.angle < 315)
            return 'up';
        return 'right';
    };
    Sight.prototype.getVision = function (d) {
        return {
            'down': this.visionDown,
            'left': this.visionLeft,
            'right': this.visionRight,
            'up': this.visionUp,
        }[d];
    };
    return Sight;
}(WorldObject));
var StaticFilter = /** @class */ (function (_super) {
    __extends(StaticFilter, _super);
    function StaticFilter(color, blend) {
        if (blend === void 0) { blend = 0; }
        return _super.call(this, {
            uniforms: { 'float alpha': 1, 'vec3 color': M.colorToVec3(color), 'float amount': 1, 'float blend': blend },
            code: "\n                if (x >= 0.0 && x < width && y >= 0.0 && y < height) {\n                    float v = map(pnoise(x, y, 10.6 + 100.0*t), -1.0, 1.0, 0.0, 1.0);\n                    float av = (1.0 - cos(PI*v)) / 2.0;\n                    float aav = (1.0 - cos(PI*av)) / 2.0;\n                    float al = lerp(alpha, outp.a, blend);\n                    outp = lerp(outp, vec4(color * aav, al), amount);\n                }\n            "
        }) || this;
    }
    return StaticFilter;
}(TextureFilter));
var ARG;
(function (ARG) {
    var SuperAutoBalls;
    (function (SuperAutoBalls) {
        function INTRO() {
            var world = ARG.Stages.BASE_INNER_STAGE(2);
            world.runScript(function () {
                var text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(0.5)];
                        case 1:
                            _a.sent();
                            text = world.addWorldObject(new SpriteText({
                                x: world.width / 2, y: 55,
                                text: "Auto Balls as\nnever seen before",
                                justify: 'center',
                                anchor: Vector2.CENTER,
                            }));
                            world.playSound('arg/sabintro1');
                            world.addWorldObject(new DesktopTransitionObject('fast'));
                            return [4 /*yield*/, S.wait(2.5)];
                        case 2:
                            _a.sent();
                            text.alpha = 0.5;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 3:
                            _a.sent();
                            text.alpha = 0;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 4:
                            _a.sent();
                            text.alpha = 1;
                            world.playSound('arg/sabintro2');
                            text.setText("In glorious\n4-bit graphics");
                            world.addWorldObject(new DesktopTransitionObject('fast'));
                            return [4 /*yield*/, S.wait(2.5)];
                        case 5:
                            _a.sent();
                            text.alpha = 0.5;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 6:
                            _a.sent();
                            text.alpha = 0;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 7:
                            _a.sent();
                            text.alpha = 1;
                            world.playSound('arg/sabintro3');
                            text.setText("On your\ncomputer");
                            world.addWorldObject(new DesktopTransitionObject('fast'));
                            return [4 /*yield*/, S.wait(2.5)];
                        case 8:
                            _a.sent();
                            text.alpha = 0.5;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 9:
                            _a.sent();
                            text.alpha = 0;
                            return [4 /*yield*/, S.wait(0.25)];
                        case 10:
                            _a.sent();
                            text.alpha = 1;
                            text.removeFromWorld();
                            return [4 /*yield*/, S.wait(2)];
                        case 11:
                            _a.sent();
                            global.theater.loadStage(TITLE);
                            return [2 /*return*/];
                    }
                });
            });
            world.onTransitioned = function () {
                playMusicNoRestart('arg/computer', 1);
            };
            return new OverlayedStage(world);
        }
        SuperAutoBalls.INTRO = INTRO;
        function TITLE() {
            var world = ARG.Stages.BASE_INNER_STAGE(2);
            world.addWorldObjects(lciDocumentToWorldObjects('arg/sabtitle'));
            var _a = world.select.names(Sprite, 'title', 'play', 'quit', 'selector'), title = _a.title, play = _a.play, quit = _a.quit, selector = _a.selector;
            var titlePos = title.getPosition();
            title.y = 55;
            play.setVisible(false);
            quit.setVisible(false);
            selector.setVisible(false);
            world.addWorldObject(new DesktopTransitionObject());
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.game.playMusic('arg/sabtitle', 0.1);
                            return [4 /*yield*/, S.wait(1.5)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.tween(1, title, 'y', title.y, titlePos.y)];
                        case 2:
                            _a.sent();
                            title.updateCallback = function () {
                                if (this.everyNSeconds(0.5)) {
                                    this.alpha = 1.8 - this.alpha;
                                }
                            };
                            return [4 /*yield*/, S.wait(0.7)];
                        case 3:
                            _a.sent();
                            play.setVisible(true);
                            quit.setVisible(true);
                            play.alpha = quit.alpha = selector.alpha = 0.5;
                            return [4 /*yield*/, S.wait(0.3)];
                        case 4:
                            _a.sent();
                            play.alpha = quit.alpha = selector.alpha = 1;
                            return [4 /*yield*/, S.wait(0.5)];
                        case 5:
                            _a.sent();
                            selector.setVisible(true);
                            return [2 /*return*/];
                    }
                });
            });
            play.addModule(new Button({
                clickTint: 0x888888,
                onHover: function () {
                    selector.teleport(play);
                },
                onClick: function () {
                    SQUAD = [];
                    global.game.playSound('arg/sabselect');
                    global.theater.loadStage(GAME);
                },
            }));
            quit.addModule(new Button({
                clickTint: 0x888888,
                onHover: function () {
                    selector.teleport(quit);
                },
                onClick: function () {
                    global.game.playSound('arg/sabselect');
                    global.theater.loadStage(ARG.Stages.DESKTOP);
                },
            }));
            return new OverlayedStage(world);
        }
        SuperAutoBalls.TITLE = TITLE;
        var SQUAD = [];
        function GAME() {
            var e_136, _a, e_137, _b;
            var world = ARG.Stages.BASE_INNER_STAGE(2, {
                physicsGroups: {
                    'walls': { immovable: true },
                    'balls': {},
                },
                collisions: [
                    { move: 'balls', from: 'balls', momentumTransfer: 'elastic' },
                    { move: 'balls', from: 'walls', momentumTransfer: 'elastic' },
                ],
                collisionIterations: 4,
                // TODO: why does this work?
                useRaycastDisplacementThreshold: Infinity,
                maxDistancePerCollisionStep: 16,
                minDistanceIgnoreCollisionStepCalculation: 400,
            });
            world.addWorldObjects(lciDocumentToWorldObjects('arg/sabgame'));
            var _c = world.select.names(Sprite, 'play', 'preppanel', 'fan'), play = _c.play, preppanel = _c.preppanel, fan = _c.fan;
            fan.updateCallback = function () {
                if (this.everyNSeconds(0.5))
                    this.angle += 45;
            };
            world.addWorldObject(new PhysicsWorldObject({
                physicsGroup: 'walls',
                bounds: new InvertedRectBounds(2, 2, 157, 107),
            }));
            world.addWorldObject(new PhysicsWorldObject({
                physicsGroup: 'walls',
                bounds: new CircleBounds(80, 56, 16),
            }));
            try {
                for (var SQUAD_1 = __values(SQUAD), SQUAD_1_1 = SQUAD_1.next(); !SQUAD_1_1.done; SQUAD_1_1 = SQUAD_1.next()) {
                    var squadBall = SQUAD_1_1.value;
                    var ball = world.addWorldObject(new ArgBall(squadBall.x, squadBall.y, 'friend'));
                    ball.level = squadBall.level;
                }
            }
            catch (e_136_1) { e_136 = { error: e_136_1 }; }
            finally {
                try {
                    if (SQUAD_1_1 && !SQUAD_1_1.done && (_a = SQUAD_1.return)) _a.call(SQUAD_1);
                }
                finally { if (e_136) throw e_136.error; }
            }
            try {
                for (var _d = __values([vec2(96, 43), vec2(120, 43), vec2(144, 43), vec2(96, 67)]), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var pos = _e.value;
                    var ball = world.addWorldObject(new ArgBall(pos.x, pos.y, 'friend'));
                    ball.isInShop = true;
                }
            }
            catch (e_137_1) { e_137 = { error: e_137_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_137) throw e_137.error; }
            }
            var ballMover = world.addWorldObject(new ArgBallMover());
            preppanel.addChildKeepWorldPosition(play);
            play.addModule(new Button({
                hoverTint: 0xBBBBBB,
                clickTint: 0x888888,
                onClick: function () {
                    global.game.playSound('arg/click');
                    world.runScript(function () {
                        var _a, _b, ball;
                        var e_138, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    global.game.stopMusic(1);
                                    play.getModule(Button).enabled = false;
                                    world.removeWorldObjects(world.select.typeAll(ArgBall).filter(function (ball) { return ball.isInShop; }));
                                    world.removeWorldObject(ballMover);
                                    SQUAD = world.select.typeAll(ArgBall).filter(function (ball) { return !ball.isInShop; }).map(function (ball) { return ({ x: ball.x, y: ball.y, level: ball.level }); });
                                    world.addWorldObjects(generateEnemySquad(world));
                                    World.Actions.moveWorldObjectToFront(preppanel);
                                    return [4 /*yield*/, S.tween(1, preppanel, 'x', preppanel.x, preppanel.x + 100)];
                                case 1:
                                    _d.sent();
                                    preppanel.kill();
                                    try {
                                        for (_a = __values(world.select.typeAll(ArgBall)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                            ball = _b.value;
                                            ball.setState('battle');
                                        }
                                    }
                                    catch (e_138_1) { e_138 = { error: e_138_1 }; }
                                    finally {
                                        try {
                                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                                        }
                                        finally { if (e_138) throw e_138.error; }
                                    }
                                    global.game.playMusic('arg/sabbattle');
                                    world.runScript(roundScript(world));
                                    return [2 /*return*/];
                            }
                        });
                    });
                },
            }));
            world.addWorldObject(new DesktopTransitionObject());
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            global.game.stopMusic();
                            return [4 /*yield*/, S.wait(1)];
                        case 1:
                            _a.sent();
                            global.game.playMusic('arg/sabshop', 0.1);
                            return [2 /*return*/];
                    }
                });
            });
            return new OverlayedStage(world);
        }
        SuperAutoBalls.GAME = GAME;
        function PAUSE() {
            var world = ARG.Stages.BASE_INNER_STAGE(2);
            return new OverlayedStage(world);
        }
        SuperAutoBalls.PAUSE = PAUSE;
        function generateEnemySquad(world) {
            var balls = world.select.typeAll(ArgBall);
            var enemyBallLevels = Math.max(3, A.sum(balls, function (ball) { return ball.level; }));
            var enemySquad = [];
            for (var i = 0; i < enemyBallLevels; i++) {
                if (enemySquad.length < 5) {
                    enemySquad.push(new ArgBall(Random.float(90, 110), Random.float(10, 96), 'enemy'));
                }
                else {
                    Random.element(enemySquad).level++;
                }
            }
            return enemySquad;
        }
        function roundScript(world) {
            return function () {
                var result, balls, screen, filter, resultText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!true) return [3 /*break*/, 2];
                            balls = world.select.typeAll(ArgBall);
                            if (balls.length === 0) {
                                result = 'draw';
                                return [3 /*break*/, 2];
                            }
                            if (balls.every(function (ball) { return ball.team === 'friend'; })) {
                                result = 'win';
                                return [3 /*break*/, 2];
                            }
                            if (balls.every(function (ball) { return ball.team === 'enemy'; })) {
                                result = 'lose';
                                return [3 /*break*/, 2];
                            }
                            return [4 /*yield*/];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 0];
                        case 2: return [4 /*yield*/, S.wait(1)];
                        case 3:
                            _a.sent();
                            screen = world.addWorldObject(new Sprite({
                                texture: world.takeSnapshot(),
                                scale: 0.5,
                            }));
                            global.game.stopMusic(1);
                            world.volume = 0;
                            filter = new DesktopTransitionFilter();
                            filter.amount = 1;
                            world.effects.post.filters.push(filter);
                            return [4 /*yield*/, S.tween(1, filter, 'amount', 1, 0)];
                        case 4:
                            _a.sent();
                            screen.tint = 0x000000;
                            A.removeAll(world.effects.post.filters, filter);
                            return [4 /*yield*/, S.wait(1)];
                        case 5:
                            _a.sent();
                            resultText = world.addWorldObject(new SpriteText({
                                x: world.width / 2, y: 55,
                                text: result === 'win' ? 'win!' : (result === 'lose' ? 'lose...' : 'draw'),
                                anchor: Vector2.CENTER,
                            }));
                            if (result === 'win')
                                global.game.playSound('arg/sabwin');
                            if (result === 'lose')
                                global.game.playSound('arg/sablose');
                            return [4 /*yield*/, S.wait(1)];
                        case 6:
                            _a.sent();
                            resultText.kill();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 7:
                            _a.sent();
                            global.theater.loadStage(GAME);
                            return [2 /*return*/];
                    }
                });
            };
        }
    })(SuperAutoBalls = ARG.SuperAutoBalls || (ARG.SuperAutoBalls = {}));
})(ARG || (ARG = {}));
var Warp = /** @class */ (function (_super) {
    __extends(Warp, _super);
    function Warp(x, y, width, height, toStage, transition, sound) {
        var _this = _super.call(this, {
            x: x, y: y,
            bounds: new RectBounds(0, 0, width, height),
        }) || this;
        _this.toStage = toStage;
        _this.transition = transition;
        _this.sound = sound;
        return _this;
    }
    Warp.prototype.update = function () {
        _super.prototype.update.call(this);
        var leader = this.world.select.type(Player);
        if (leader && leader.bounds && this.bounds.isOverlapping(leader.bounds)) {
            global.theater.playSound(this.sound, { humanized: false });
            global.theater.loadStage(this.toStage, this.transition);
        }
    };
    return Warp;
}(PhysicsWorldObject));
var Wolf = /** @class */ (function (_super) {
    __extends(Wolf, _super);
    function Wolf(x, y) {
        return _super.call(this, {
            x: x, y: y,
            animations: [
                Animations.fromTextureList({ name: 'idle_front', textureRoot: 'arg/wolf', textures: [0, 1], frameRate: 2.5, count: Infinity }),
            ],
            defaultAnimation: 'idle_front',
            effects: { outline: { color: 0x000000 } },
            layer: ARG.Layers.main,
        }) || this;
    }
    return Wolf;
}(Sprite));
var ZoomFilter = /** @class */ (function (_super) {
    __extends(ZoomFilter, _super);
    function ZoomFilter(center, amount) {
        var _this = _super.call(this, {
            uniforms: { 'vec2 center': [center.x, center.y], 'float amount': amount },
            code: "\n                outp.rgb = vec3(0.0, 0.0, 0.0);\n                for (float v = -2.0; v <= 2.0; v += 0.5) {\n                    float zoomAmount = pow(2.0, (v - 0.1)*amount);\n                    vec2 newp = (vec2(x, y) - center) / zoomAmount + center;\n                    float fade = v == 0.0 ? 1.0 : pow(2.0, -abs(v)-2.0);\n                    vec3 tint = vec3(1.0, 1.0-amount, 1.0-amount);\n                    outp.rgb += getColor(newp.x, newp.y).rgb * fade * tint;\n                }\n            "
        }) || this;
        _this._amount = amount;
        _this._center = center;
        return _this;
    }
    Object.defineProperty(ZoomFilter.prototype, "center", {
        get: function () { return this._center; },
        set: function (value) {
            this._center = value;
            this.setUniform('center', [value.x, value.y]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZoomFilter.prototype, "amount", {
        get: function () { return this._amount; },
        set: function (value) {
            this._amount = value;
            this.setUniform('amount', value);
        },
        enumerable: false,
        configurable: true
    });
    return ZoomFilter;
}(TextureFilter));
var Ball = /** @class */ (function (_super) {
    __extends(Ball, _super);
    function Ball(baseTexture, radius, config) {
        var _a;
        var _this = _super.call(this, {
            x: config.x, y: config.y,
            effects: { pre: { filters: [
                        new BallTeamColorFilter(Ball.getTeamColor(config.team)),
                        new FlashingStatusEffectFilter(),
                        new Effects.Filters.Outline(0x000000, 1),
                    ] } },
            layer: Battle.Layers.balls,
            physicsGroup: Battle.PhysicsGroups.balls,
            bounds: new CircleBounds(0, 0, radius),
            bounce: 1,
        }) || this;
        _this.tier = 1;
        _this.isInShop = false;
        _this.isInYourSquadScene = false;
        _this.isSummon = true;
        _this.neutralFlowDirection = 1;
        _this.afterAddImmuneTime = 0.25;
        _this.preBattleAbilityInitialWaitTime = 0.2;
        _this.canBeTargetedForDeath = true;
        _this.targetedForDeath = false;
        _this.isBeingDisintegrated = false;
        _this.dead = false;
        _this.storesMoney = false;
        _this.disguised = false;
        _this.massScale = 1;
        _this.defaultOutline = 0xFFFFFF;
        _this.defaultOutlineAlpha = 1;
        _this.canFreeze = true;
        _this.constructedMetadata = _.clone(config.properties.metadata);
        _this.effects.outline.color = _this.defaultOutline;
        _this.effects.outline.alpha = _this.defaultOutlineAlpha;
        _this.radius = radius;
        _this.ballScale = 1;
        _this.moveScale = 1;
        var textures = getBallTextures(baseTexture);
        _this.addAnimation(Animations.fromTextureList({ name: 'prep', textures: [textures[0]], frameRate: 1, count: Infinity }));
        _this.addAnimation(Animations.fromTextureList({ name: 'roll', textures: textures, frameRate: 1, count: Infinity }));
        _this.playAnimation('prep');
        _this.mask = {
            type: 'local',
            texture: Ball.textureMaskForRadius(_this.radius),
            offsetx: 0, offsety: 0,
        };
        _this.properties = config.properties;
        _this.dmg = config.properties.damage;
        _this.hp = config.properties.health;
        _this.maxhp = config.properties.health;
        _this.level = config.properties.level;
        _this.abilitySet = new AbilitySet();
        _this.timeInBattle = 0;
        _this.statusEffects = [];
        _this.activateTwiceAbilities = [];
        _this.activatedAbilities = [];
        _this.timesCollidedWithEnemy = 0;
        _this.timesTakenDamage = 0;
        _this.timesKilledEnemy = 0;
        _this.stunImmune = _this.addTimer(0.5);
        _this.stunImmune.finish();
        _this.nullifiedSprite = _this.addChild(new Sprite({
            texture: 'nullified',
            alpha: 0,
            visible: false,
            copyFromParent: ['layer'],
        }));
        _this.markedSprite = _this.addChild(new Sprite({
            texture: 'crosshair',
            alpha: 0,
            visible: false,
            copyFromParent: ['layer'],
        }));
        _this.effectAura = _this.addChild(new Sprite({
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: _this.effectAuraRadius / 64,
            alpha: 0,
            copyFromParent: ['layer'],
        }));
        _this.equip((_a = config.properties.equipment) !== null && _a !== void 0 ? _a : -1);
        _this.squad = config.squad;
        _this.squadIndexReference = config.squadIndexReference;
        _this.team = config.team;
        if (_this.properties.metadata.extraSellValue === undefined) {
            _this.properties.metadata.extraSellValue = 0;
        }
        _this._applyBounds = new CircleBounds(0, 0, _this.radius, _this);
        _this.stateMachine.addState(Ball.States.PREP, {
            update: function () {
                _this.updatePrep();
            },
        });
        _this.stateMachine.addState(Ball.States.PRE_BATTLE, {
            callback: function () {
                _this.onStateChangePreBattle();
            },
            update: function () {
                _this.updatePreBattle();
            },
        });
        _this.stateMachine.addState(Ball.States.BATTLE, {
            callback: function () {
                _this.onStateChangeBattle();
                _this.hideAllStats();
            },
            update: function () {
                _this.updateBattle();
            },
        });
        _this.setState(Ball.States.PREP);
        _this.dmgbox = _this.addChild(new StatBox('dmg'));
        _this.dmgbox.setVisible(false);
        _this.hpbox = _this.addChild(new StatBox('hp'));
        _this.hpbox.setVisible(false);
        _this.stars = _this.addChild(new Stars(_this.properties.metadata.obtainedWithCrown ? 'crowns' : 'stars'));
        _this.stars.setVisible(false);
        _this.showingAllStats = false;
        return _this;
    }
    Ball.prototype.getType = function () { return 'Ball'; };
    Ball.prototype.getName = function () { return 'unknown'; };
    Ball.prototype.getDesc = function () { return 'unknown'; };
    Ball.prototype.getShopDmg = function () { return 1; };
    Ball.prototype.getShopHp = function () { return 1; };
    Ball.prototype.getShopCost = function () {
        if (this.shouldSellAtOneGold())
            return 1;
        return 3;
    };
    Ball.prototype.getShopRelativePosition = function () { return vec2(0, 0); };
    Ball.prototype.getSellValue = function () {
        return M.clamp(1 + getModifierSellDiff() + this.properties.metadata.extraSellValue, 0, Ball.maxSellValue);
    };
    Ball.prototype.getCredits = function () { return []; };
    Object.defineProperty(Ball.prototype, "acceleration", {
        get: function () {
            var baseAcceleration = Ball.accelerationBase;
            return baseAcceleration * this.getScaleAccelerationMultiplier();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "maxSpeed", {
        get: function () {
            var baseMaxSpeed = Ball.maxSpeedBase * this.getBoostMaxSpeedMultiplier();
            var slowMultiplier = this.getSlowEffectSpeedMultiplier();
            if (slowMultiplier === 0) {
                return 0;
            }
            if (this.getStun())
                return 50;
            var arenaGravityMultiplier = this.world.data.arenaName === Arenas.ARENA_GRAVITY ? 1.3 : 1;
            var arenaIceMultiplier = this.getArenaIceSpeedMultiplier();
            var arenaMultiplier = arenaGravityMultiplier * arenaIceMultiplier;
            return baseMaxSpeed * slowMultiplier * arenaMultiplier * GET_SPEED_CAP_MULT();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "effectAuraRadius", {
        get: function () { return this.physicalRadius + 6; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "clampDamageRatio", {
        get: function () {
            var e_139, _a;
            var amount = 1;
            try {
                for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var effect = _c.value;
                    if (effect.type === 'boostmaxspeed') {
                        var mult = M.mapTween(effect.timeLeft, effect.maxTime, 0, effect.clampDamageMultiplier, 1, Tween.Easing.InQuad);
                        amount = Math.max(amount, mult);
                    }
                }
            }
            catch (e_139_1) { e_139 = { error: e_139_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_139) throw e_139.error; }
            }
            return amount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "isPreBattleAbilityActive", {
        get: function () {
            if (!this._preBattleAbilityActiveCheck)
                return false;
            if (!this._preBattleAbilityActiveCheck()) {
                this._preBattleAbilityActiveCheck = undefined;
                return false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "drag", {
        get: function () {
            if (!this.getStun())
                return 20;
            return M.lerp(100, 200, this.stunImmune.progress);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "frozen", {
        get: function () { return !!this.freezeSprite; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "visibleRadius", {
        get: function () { return this.radius * this.ballScale * this.moveScale; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "physicalRadius", {
        get: function () { return this.radius * this.ballScale; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "ballsexplodeModifierRadius", {
        get: function () { return this.physicalRadius + 20; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "canRoll", {
        get: function () { return !this.world || !_.contains([Arenas.ARENA_ICE, Arenas.ARENA_GRAVITY], this.world.data.arenaName); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ball.prototype, "applyBounds", {
        get: function () {
            this._applyBounds.radius = Math.max(this.physicalRadius, 8) + 4;
            return this._applyBounds;
        },
        enumerable: false,
        configurable: true
    });
    Ball.prototype.onAdd = function () {
        this.mainWorld = this.world;
        _super.prototype.onAdd.call(this);
        this.name = 'ball';
        for (var i = 0; i < 10000; i++) {
            var n = "ball_" + Ball.Random.int(1000000, 9999999);
            if (!this.world.select.name(n, false)) {
                this.name = n;
                break;
            }
        }
        var battleState = getBattleState(this.world);
        if (battleState === Ball.States.PRE_BATTLE || battleState === Ball.States.BATTLE) {
            this.life.time = 0;
            if (this.isSummon) {
                this.joinTeam();
            }
        }
        if (battleState === Ball.States.PRE_BATTLE) {
            this.setState(Ball.States.PRE_BATTLE);
            this.showAllStats();
            this.queueAbilities('onPreBattle');
        }
        else if (battleState === Ball.States.BATTLE) {
            this.setState(Ball.States.PRE_BATTLE);
            this.setState(Ball.States.BATTLE);
            this.enterBattle();
        }
    };
    Ball.prototype.update = function () {
        _super.prototype.update.call(this);
        this.queueAbilities('update');
        this.updateStatusEffects();
        var flashingStatusEffectFilter = this.effects.pre.filters.find(function (f) { return f instanceof FlashingStatusEffectFilter; });
        if (flashingStatusEffectFilter) {
            if (this.isBurning()) {
                flashingStatusEffectFilter.color = 0xFF8F00;
                flashingStatusEffectFilter.amount = 0.6;
            }
            else if (this.getSlowEffectSpeedMultiplier() < 1 && this.statusEffects.find(function (e) { return e.type === 'slow' && e.source === 'yarn'; })) {
                flashingStatusEffectFilter.color = 0xFFFFFF;
                flashingStatusEffectFilter.amount = 1;
            }
            else {
                flashingStatusEffectFilter.amount = 0;
            }
        }
        this.v.clampMagnitude(this.maxSpeed + 0.001);
    };
    Ball.prototype.updatePrep = function () {
        this.animationManager.playAnimation('prep');
        this.animationManager.speed = 1;
    };
    Ball.prototype.updatePreBattle = function () {
        this.animationManager.playAnimation('prep');
        this.animationManager.speed = 1;
    };
    Ball.prototype.updateBattle = function () {
        this.timeInBattle += this.delta;
        this.updateVelocityForFlow();
        this.updateVelocityForMagnetism();
        this.updateVelocityForCenterBlackHoles();
        this.updateVelocityForLevelBounds();
        this.v.setMagnitude(Math.max(0.001, this.v.magnitude - this.drag * this.delta));
        if (this.world.data.arenaName === Arenas.ARENA_ICE && !this.v.isZero()) {
            var iceAcceleration = (isFinite(this.maxSpeed) ? this.maxSpeed : 150) / 3;
            var newSpeed = M.clamp(this.getSpeed() + iceAcceleration * this.delta, 0, 2000);
            this.setSpeed(newSpeed);
        }
        this.v.clampMagnitude(this.maxSpeed + 0.001);
        if (this.getStun() && this.stunImmune.done) {
            this.v.setMagnitude(0.001);
        }
        this.angle = M.atan2(this.v.y, this.v.x) + 90;
        this.animationManager.playAnimation('roll');
        this.animationManager.speed = this.canRoll ? this.v.magnitude / 3 / (this.physicalRadius / 8) : 0;
    };
    Ball.prototype.updateVelocityForFlow = function () {
        var f = this.getFlow();
        // Go against the flow if enemy.
        var dir = this.neutralFlowDirection;
        if (this.team === 'friend')
            dir = 1;
        if (this.team === 'enemy')
            dir = -1;
        if (SWAP_DIRECTIONS && this.team !== 'neutral') {
            dir *= -1;
        }
        if (this.disguised) {
            dir *= -1;
        }
        if (this.equipment && this.equipment.reverseDirection && !this.isNullified()) {
            dir *= -1;
        }
        if (this.world.data.arenaName === Arenas.ARENA_GRAVITY) {
            dir = 1; // Ignore directions for gravity arena.
        }
        this.v.x += f.x * dir * this.acceleration * this.delta;
        this.v.y += f.y * dir * this.acceleration * this.delta;
    };
    Ball.prototype.updateVelocityForMagnetism = function () {
        var _this = this;
        var _a, _b, _c;
        var magAmount = 0;
        var equipmentMagnetizeAmount = this.equipment && !this.isNullified() ? this.equipment.magnetizeAmount : 0;
        if (equipmentMagnetizeAmount > 0) {
            var balls = (_c = (_b = (_a = this.world) === null || _a === void 0 ? void 0 : _a.select) === null || _b === void 0 ? void 0 : _b.typeAll(Ball)) !== null && _c !== void 0 ? _c : [];
            var closestEnemy = M.argmin(balls.filter(function (ball) { return ball.team !== _this.team; }), function (ball) { return G.distance(_this, ball); });
            if (closestEnemy) {
                var force = 45000 / G.distance(this, closestEnemy) * M.mapClamp(equipmentMagnetizeAmount, 0, 0.33, 0, 1);
                var forceD = closestEnemy.getPosition().subtract(this);
                this.v.add(forceD.withMagnitude(force * this.delta));
                magAmount = M.mapClamp(force, 225, 750, 0, 1);
            }
        }
        if (magAmount > 0) {
            this.addBoostMaxSpeed(this, 'magnet', (1 + equipmentMagnetizeAmount) * magAmount, 1.33 * magAmount, 0.5);
        }
    };
    Ball.prototype.updateVelocityForCenterBlackHoles = function () {
        var e_140, _a;
        try {
            for (var _b = __values(this.world.select.typeAll(CenterBlackHole)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var blackHole = _c.value;
                var d = blackHole.getPosition().subtract(this.x, this.y);
                this.v.add(d.scale(1 / d.magnitude * blackHole.gravityFactor * 200 * this.delta));
            }
        }
        catch (e_140_1) { e_140 = { error: e_140_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_140) throw e_140.error; }
        }
    };
    Ball.prototype.updateVelocityForLevelBounds = function () {
        var _a, _b;
        var accelerationAtBorder = 200;
        if (this.world.data.arenaName === Arenas.ARENA_GRAVITY) {
            var arenaShrink = this.world.select.type(ArenaShrinkGravity);
            var levelBorder_1 = (_b = (_a = arenaShrink === null || arenaShrink === void 0 ? void 0 : arenaShrink.ceiling) === null || _a === void 0 ? void 0 : _a.y) !== null && _b !== void 0 ? _b : 0;
            if (this.y - this.radius < levelBorder_1 + 1) {
                this.v.y += accelerationAtBorder * this.delta;
            }
            return;
        }
        var levelBorder = 16;
        var distanceFromBorder = 1;
        if (this.x - this.radius < levelBorder + distanceFromBorder) {
            this.v.x += accelerationAtBorder * this.delta;
        }
        if (this.x + this.radius > this.world.width - levelBorder - distanceFromBorder) {
            this.v.x -= accelerationAtBorder * this.delta;
        }
        if (this.y - this.radius < levelBorder + distanceFromBorder) {
            this.v.y += accelerationAtBorder * this.delta;
        }
        if (this.y + this.radius > this.world.height - levelBorder - distanceFromBorder) {
            this.v.y -= accelerationAtBorder * this.delta;
        }
        if (this.world.data.arenaName === Arenas.ARENA_FIRST && M.distance(this.x, this.y, this.world.width / 2, this.world.height / 2) < 30 + this.radius + distanceFromBorder) {
            this.v.add(this.getPosition().subtract(this.world.width / 2, this.world.height / 2).normalize().scale(accelerationAtBorder * this.delta));
        }
    };
    Ball.prototype.updateStatusEffects = function () {
        var _loop_17 = function (i) {
            var statusEffect = this_4.statusEffects[i];
            if (statusEffect.type === 'burning') {
                var damageToTake_1 = 1 * this_4.delta;
                this_4.leechFor(damageToTake_1, statusEffect.source);
                if (this_4.world.timeScale > 0.01)
                    statusEffect.sound.update(this_4.delta);
                if (statusEffect.source.team === 'friend' && youArePlaying(this_4.world)) {
                    updateAchievementProgress('DealBurnDamage', function (p) { return p + damageToTake_1; });
                }
            }
            if (statusEffect.type === 'spreaddamage') {
                var damageToTake = M.mapClamp(this_4.delta, 0, statusEffect.timeLeft, 0, statusEffect.damageLeft);
                this_4.leechFor(damageToTake, statusEffect.source);
                statusEffect.damageLeft -= damageToTake;
            }
            // Timing
            this_4.statusEffects[i].timeLeft -= this_4.delta;
            if (this_4.statusEffects[i].timeLeft <= 0)
                this_4.statusEffects.splice(i, 1);
        };
        var this_4 = this;
        for (var i = this.statusEffects.length - 1; i >= 0; i--) {
            _loop_17(i);
        }
    };
    Ball.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        if (this.state === Ball.States.PREP) {
            this.properties.damage = this.dmg;
            this.properties.health = this.hp;
            this.properties.level = this.level;
            this.properties.equipment = this.equipment ? this.equipment.equipmentType : -1;
        }
        var targetAlpha = 1;
        if (this.statusEffects.find(function (effect) { return effect.type === 'protected'; })) {
            this.effectAura.tint = 0xFFFF00;
        }
        else if (this.statusEffects.find(function (effect) { return effect.type === 'leeched'; })) {
            this.effectAura.tint = 0xFF0000;
        }
        else if (this.statusEffects.find(function (effect) { return effect.type === 'healfeedback'; })) {
            this.effectAura.tint = 0x00FF00;
        }
        else {
            targetAlpha = 0;
        }
        this.effectAura.alpha = M.lerpTime(this.effectAura.alpha, targetAlpha, 10, this.delta);
        if (this.effectAura.alpha < 0.01) {
            this.effectAura.setVisible(false);
        }
        else {
            this.effectAura.setVisible(true);
            this.effectAura.scale = this.effectAuraRadius / 64;
        }
        if (this.isNullified()) {
            this.nullifiedSprite.setVisible(true);
            this.nullifiedSprite.alpha = M.moveToClamp(this.nullifiedSprite.alpha, 1, 3, this.delta);
        }
        else {
            this.nullifiedSprite.alpha = M.moveToClamp(this.nullifiedSprite.alpha, 0, 3, this.delta);
            if (this.nullifiedSprite.alpha <= 0) {
                this.nullifiedSprite.setVisible(false);
            }
        }
        if (this.isMarked()) {
            this.markedSprite.setVisible(true);
            this.markedSprite.alpha = Tween.Easing.OscillateSine(1.5)(this.life.time);
        }
        else {
            this.markedSprite.setVisible(false);
        }
        var uiPositionScale = M.map(Math.max(this.visibleRadius / 8, 1), 1, 4, 1, 3.5);
        this.stars.setStars(this.level - 1);
        this.stars.localx = 0;
        this.stars.localy = -10 * uiPositionScale;
        this.dmgbox.setText("" + (this.isGlitched() ? '?' : Math.round(this.dmg)));
        this.dmgbox.localx = -6 * uiPositionScale;
        this.dmgbox.localy = 8 * uiPositionScale;
        this.hpbox.setText("" + (this.isGlitched() ? '?' : Math.ceil(this.hp)));
        this.hpbox.localx = 6 * uiPositionScale - 1;
        this.hpbox.localy = 8 * uiPositionScale;
        this.orderBallComponents();
    };
    Ball.prototype.orderBallComponents = function () {
        if (this.effectAura.alpha > 0) {
            World.Actions.orderWorldObjectBefore(this.effectAura, this);
        }
        World.Actions.orderWorldObjectAfter(this.stars, this);
        World.Actions.orderWorldObjectAfter(this.dmgbox, this);
        World.Actions.orderWorldObjectAfter(this.hpbox, this);
        if (this.freezeSprite) {
            World.Actions.orderWorldObjectAfter(this.freezeSprite, this);
        }
        if (this.isNullified()) {
            World.Actions.orderWorldObjectAfter(this.nullifiedSprite, this.stars);
        }
    };
    Ball.prototype.render = function (texture, x, y) {
        var _a;
        _super.prototype.render.call(this, texture, x, y);
        if (((_a = this.getStun()) === null || _a === void 0 ? void 0 : _a.source) === 'psychic') {
            var extraRadius = M.lerp(3, 4, M.mod(Math.floor(this.life.time * 16), 2));
            Draw.brush.color = 0xFF44FF;
            Draw.brush.alpha = 1;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, this.physicalRadius + extraRadius, Draw.ALIGNMENT_OUTER);
        }
        if (isModifierActive('ballsexplode') && !this.isInShop && !this.isInYourSquadScene) {
            Draw.brush.color = 0xFF0000;
            Draw.brush.alpha = 0.6;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, this.ballsexplodeModifierRadius);
        }
    };
    Ball.prototype.onCollide = function (collision) {
        var _a, _b, _c;
        if (this.state === Ball.States.BATTLE && collision.other.obj.physicsGroup === Battle.PhysicsGroups.walls) {
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('hitwall', { limit: 2 });
            if (this.world.data.arenaName === Arenas.ARENA_GRAVITY) {
                var arenaShrink = this.world.select.type(ArenaShrinkGravity);
                var levelBorder = (_c = (_b = arenaShrink === null || arenaShrink === void 0 ? void 0 : arenaShrink.ceiling) === null || _b === void 0 ? void 0 : _b.y) !== null && _c !== void 0 ? _c : 0;
                if (this.y - this.radius < levelBorder + 4) {
                    this.y += 1;
                    this.v.y = Math.max(this.v.y, 20);
                }
            }
            else {
                if (M.distance(this.x, this.y, global.gameWidth / 2, global.gameHeight / 2) > 60) {
                    var d = vec2(global.gameWidth / 2, global.gameHeight / 2).subtract(this).withMagnitude(0.1);
                    this.x += d.x;
                    this.y += d.y;
                }
            }
            if (isModifierActive('wallshurt')) {
                if (!this.data.modifierWallHurtTimes)
                    this.data.modifierWallHurtTimes = {};
                if (!this.data.modifierWallHurtTimes[collision.other.obj.uid] || this.data.modifierWallHurtTimes[collision.other.obj.uid] + 0.5 < this.life.time) {
                    this.takeDamage(0.5, this, 'other');
                    this.data.modifierWallHurtTimes[collision.other.obj.uid] = this.life.time;
                }
            }
            if (isModifierActive('wallsbounce') && !(collision.other.obj instanceof Trampoline)) {
                this.changeVelocityForBounce(Ball.minModifierWallBounceSpeed);
                this.addBoostMaxSpeed(this, 'other', 1.5, 1.5, 0.7);
                this.world.playSound('trampoline', { limit: 4 });
            }
        }
        _super.prototype.onCollide.call(this, collision);
    };
    Ball.prototype.addAbility = function (type, abilityFunction, config) {
        var _a, _b;
        var canActivateTwice = (_a = config === null || config === void 0 ? void 0 : config.canActivateTwice) !== null && _a !== void 0 ? _a : true;
        var nullifyable = (_b = config === null || config === void 0 ? void 0 : config.nullifyable) !== null && _b !== void 0 ? _b : true;
        this.abilitySet.addAbility(type, abilityFunction, nullifyable);
        if (canActivateTwice) {
            this.activateTwiceAbilities.push(type);
        }
    };
    Ball.prototype.addDamageBuffPlus = function (amount) {
        this.addChild(new BuffPlus(this.dmgbox.localx, this.dmgbox.localy - 8, amount < 0 ? '-' : '+'));
    };
    Ball.prototype.addHealthBuffPlus = function (amount) {
        this.addChild(new BuffPlus(this.hpbox.localx, this.hpbox.localy - 8, amount < 0 ? '-' : '+'));
    };
    Ball.prototype.addScaleAcceleration = function (source, multiplier, time) {
        var currentBoost = this.statusEffects.find(function (effect) { return effect.type === 'scaleacceleration' && effect.source === source; });
        if (currentBoost) {
            currentBoost.multiplier = multiplier;
            currentBoost.timeLeft = time;
        }
        else {
            this.statusEffects.push({
                type: 'scaleacceleration',
                multiplier: multiplier,
                timeLeft: time,
                source: source,
            });
        }
    };
    Ball.prototype.addBoostMaxSpeed = function (source, sourceType, multiplier, boostDamageMultiplier, time) {
        var currentBoost = this.statusEffects.find(function (effect) { return effect.type === 'boostmaxspeed' && effect.source === source && effect.sourceType === sourceType; });
        if (currentBoost) {
            currentBoost.multiplier = multiplier;
            currentBoost.clampDamageMultiplier = boostDamageMultiplier;
            currentBoost.timeLeft = time;
            currentBoost.maxTime = time;
        }
        else {
            this.statusEffects.push({
                type: 'boostmaxspeed',
                multiplier: multiplier,
                clampDamageMultiplier: boostDamageMultiplier,
                timeLeft: time,
                maxTime: time,
                source: source,
                sourceType: sourceType,
            });
        }
    };
    Ball.prototype.addBurning = function (source, time) {
        var _a;
        var currentBurning = this.statusEffects.find(function (effect) { return effect.type === 'burning' && effect.source === source; });
        if (currentBurning) {
            currentBurning.timeLeft = Math.max(currentBurning.timeLeft, time);
        }
        else {
            var fireSound = new Sound('fire', (_a = this.world) === null || _a === void 0 ? void 0 : _a.soundManager);
            fireSound.loop = true;
            this.statusEffects.push({
                type: 'burning',
                timeLeft: time,
                source: source,
                sound: fireSound,
            });
            this.world.playSound('fireignite');
        }
    };
    Ball.prototype.addMarked = function (time) {
        var _a;
        var currentMarked = this.statusEffects.find(function (effect) { return effect.type === 'marked'; });
        if (currentMarked) {
            currentMarked.timeLeft = Math.max(currentMarked.timeLeft, time);
        }
        else {
            this.statusEffects.push({
                type: 'marked',
                timeLeft: time,
            });
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('swoosh');
        }
    };
    Ball.prototype.addNullified = function (time) {
        var _a, _b;
        var currentNullified = this.statusEffects.find(function (effect) { return effect.type === 'nullified'; });
        if (currentNullified) {
            currentNullified.timeLeft = Math.max(currentNullified.timeLeft, time);
        }
        else {
            this.statusEffects.push({
                type: 'nullified',
                timeLeft: time,
            });
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('shake2', { volume: 0.4, limit: 1 });
            (_b = this.world) === null || _b === void 0 ? void 0 : _b.playSound('chain', { limit: 1 });
        }
    };
    Ball.prototype.addSlow = function (source, slowFactor, time) {
        var currentSlow = this.statusEffects.find(function (effect) { return effect.type === 'slow'; });
        if (currentSlow) {
            if (slowFactor >= currentSlow.slowFactor) {
                currentSlow.slowFactor = slowFactor;
                currentSlow.timeLeft = time;
            }
            else {
                // Noop
            }
        }
        else {
            this.statusEffects.push({
                type: 'slow',
                slowFactor: slowFactor,
                timeLeft: time,
                source: source,
            });
        }
    };
    Ball.prototype.addSpreadDamage = function (source, amount, duration) {
        this.statusEffects.push({
            type: 'spreaddamage',
            timeLeft: duration,
            damageLeft: amount,
            source: source,
        });
    };
    Ball.prototype.addStun = function (source, time) {
        var currentStun = this.statusEffects.find(function (effect) { return effect.type === 'stun'; });
        if (currentStun) {
            if (currentStun.timeLeft < time) {
                currentStun.timeLeft = time;
                currentStun.source = source;
            }
        }
        else {
            this.statusEffects.push({
                type: 'stun',
                source: source,
                timeLeft: time,
            });
        }
    };
    Ball.prototype.addProtected = function (source, flatDamageReduction, time) {
        var currentProtected = this.statusEffects.find(function (effect) { return effect.type === 'protected' && effect.source === source; });
        if (currentProtected) {
            currentProtected.flatDamageReduction = flatDamageReduction;
            currentProtected.timeLeft = time;
        }
        else {
            this.statusEffects.push({
                type: 'protected',
                flatDamageReduction: flatDamageReduction,
                timeLeft: time,
                source: source,
            });
        }
    };
    Ball.prototype.addHealFeedback = function (time) {
        var currentHealFeedback = this.statusEffects.find(function (effect) { return effect.type === 'healfeedback'; });
        if (currentHealFeedback) {
            currentHealFeedback.timeLeft = time;
        }
        else {
            this.statusEffects.push({
                type: 'healfeedback',
                timeLeft: time,
            });
        }
    };
    Ball.prototype.addLeeched = function (time) {
        var currentLeeched = this.statusEffects.find(function (effect) { return effect.type === 'leeched'; });
        if (currentLeeched) {
            currentLeeched.timeLeft = time;
        }
        else {
            this.statusEffects.push({
                type: 'leeched',
                timeLeft: time,
            });
        }
    };
    Ball.prototype.becomeEtherealForTime = function (time) {
        var _this = this;
        this.runScript(S.chain(S.call(function () { return _this.becomeEthereal(); }), S.wait(time), S.call(function () { return _this.becomeCorporeal(); })));
    };
    Ball.prototype.becomeEthereal = function () {
        if (!this.world)
            return;
        this.world.playSound('cloak', { humanized: false, limit: 2 });
        this.physicsGroup = Battle.PhysicsGroups.balls_ethereal;
        this.alpha = 0.5;
        var _loop_18 = function (i) {
            var pos = Random.inCircle(this_5.physicalRadius).add(this_5.x, this_5.y);
            var smoke = this_5.world.addWorldObject(new Sprite({
                x: pos.x, y: pos.y,
                texture: lazy('ballSmoke', function () { return new AnchoredTexture(Texture.filledCircle(12, 0xFFFFFF, 0.7), 0.5, 0.5); }),
                layer: Battle.Layers.fx,
                scale: 0,
            }));
            this_5.world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(Random.float(0, 0.1))];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.tween(0.2, smoke, 'scale', 0, Random.float(0.66, 1), Tween.Easing.OutCubic)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.tween(0.8, smoke, 'alpha', 1, 0, Tween.Easing.InQuad)];
                        case 3:
                            _a.sent();
                            smoke.kill();
                            return [2 /*return*/];
                    }
                });
            });
        };
        var this_5 = this;
        for (var i = 0; i < 4; i++) {
            _loop_18(i);
        }
    };
    Ball.prototype.becomeCorporeal = function () {
        var _a, _b;
        (_a = this.world) === null || _a === void 0 ? void 0 : _a.addWorldObject(new CircleImpact(this.x, this.y, Math.max(this.physicalRadius + 12, 20), { ally: 0, enemy: 2 * this.dmg }, this));
        (_b = this.world) === null || _b === void 0 ? void 0 : _b.playSound('cloak', { humanized: false, limit: 2 });
        this.physicsGroup = Battle.PhysicsGroups.balls;
        this.alpha = 1;
    };
    Ball.prototype.breakEquipment = function () {
        if (!this.equipment)
            return;
        this.equipment.break();
        this.unequip();
    };
    Ball.prototype.buff = function (dmg, hp) {
        var _a;
        this.dmg += dmg;
        this.hp += hp;
        this.maxhp += hp;
        if (dmg !== 0) {
            this.addDamageBuffPlus(dmg);
            this.showDmgStat(dmg, 0.5);
        }
        if (hp !== 0) {
            this.addHealthBuffPlus(hp);
            this.showHpStat(hp, 0.5);
        }
        this.addChild(new Sprite({
            texture: 'buffbeams',
            blendMode: Texture.BlendModes.ADD,
            copyFromParent: ['layer'],
            scale: (this.radius + 6) / 64,
            life: 0.5,
            vangle: 360,
            update: function () {
                this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                World.Actions.orderWorldObjectBefore(this, this.parent);
            },
        }));
        (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('buff', { limit: 2 });
    };
    Ball.prototype.calculateDamageAgainstThis = function (amount, unblockable) {
        if (!unblockable) {
            var flatDamageChange = this.getFlatDamageChange();
            if (flatDamageChange < 0) {
                amount = Math.min(amount, Math.max(amount + flatDamageChange, 0.75));
            }
            else {
                amount += flatDamageChange;
            }
            var percentDamageChange = this.getPercentDamageChange();
            amount *= percentDamageChange;
        }
        if (this.hp <= 0)
            amount = 1;
        return amount;
    };
    Ball.prototype.cancelAbilities = function () {
        var _a;
        this.abilitySet.cancelAbilities(this);
        (_a = this.equipment) === null || _a === void 0 ? void 0 : _a.cancelAbilities();
    };
    Ball.prototype.changeBaseTextureAndRadius = function (baseTexture, radius) {
        var _a;
        var textures = getBallTextures(baseTexture);
        this.animationManager.animations['prep'][0].texture = textures[0];
        for (var i = 0; i < this.animationManager.animations['roll'].length; i++) {
            this.animationManager.animations['roll'][i].texture = textures[i];
        }
        this.setTexture((_a = this.animationManager.getCurrentFrame()) === null || _a === void 0 ? void 0 : _a.texture);
        this.radius = radius;
        this.mask = {
            type: 'local',
            texture: Ball.textureMaskForRadius(this.radius),
            offsetx: 0, offsety: 0,
        };
        this.updateBallScaleInternal();
    };
    Ball.prototype.changeHighlight = function (enabled, color, alpha) {
        if (color === undefined)
            color = this.effects.outline.color;
        if (alpha === undefined)
            alpha = this.effects.outline.alpha;
        this.effects.outline.enabled = enabled;
        this.effects.outline.color = color;
        this.effects.outline.alpha = alpha;
    };
    Ball.prototype.changeVelocityForBounce = function (minBounceVelocity) {
        if (this.v.magnitude < 500)
            this.v.scale(2);
        if (this.v.magnitude < minBounceVelocity) {
            this.v.setMagnitude(minBounceVelocity);
        }
    };
    Ball.prototype.cheelFor = function (amount) {
        if (this.dmg <= 0)
            return;
        this.dmg = M.clamp(this.dmg - amount, 0, Infinity);
        if (!this.dead && this.state === Ball.States.BATTLE)
            this.showDmgStat(-amount, 0.5);
    };
    Ball.prototype.dealsCollisionDamage = function () {
        var _a;
        if (((_a = this.equipment) === null || _a === void 0 ? void 0 : _a.noCollisionDamage) && !this.isNullified())
            return false;
        return true;
    };
    Ball.prototype.didShootProjectile = function (hitCount) {
        var e_141, _a;
        var _this = this;
        if (!this.world)
            return;
        var otherBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== _this; });
        try {
            for (var otherBalls_1 = __values(otherBalls), otherBalls_1_1 = otherBalls_1.next(); !otherBalls_1_1.done; otherBalls_1_1 = otherBalls_1.next()) {
                var ball = otherBalls_1_1.value;
                ball.queueAbilities('onBallShootProjectile', this, hitCount);
            }
        }
        catch (e_141_1) { e_141 = { error: e_141_1 }; }
        finally {
            try {
                if (otherBalls_1_1 && !otherBalls_1_1.done && (_a = otherBalls_1.return)) _a.call(otherBalls_1);
            }
            finally { if (e_141) throw e_141.error; }
        }
        if (youArePlaying(this.world)) {
            updateAchievementProgress('ShootProjectiles', function (p) { return p + hitCount; });
        }
    };
    Ball.prototype.disguise = function () {
        var ballTeamColorFilter = this.effects.pre.filters.find(function (f) { return f instanceof BallTeamColorFilter; });
        if (!ballTeamColorFilter)
            return;
        ballTeamColorFilter.setColor(Ball.getTeamColor(Ball.getInverseTeam(this.team)));
        this.disguised = true;
    };
    Ball.prototype.enterBattle = function () {
        var e_142, _a;
        var _this = this;
        this.queueAbilities('onEnterBattle');
        var otherBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== _this; });
        try {
            for (var otherBalls_2 = __values(otherBalls), otherBalls_2_1 = otherBalls_2.next(); !otherBalls_2_1.done; otherBalls_2_1 = otherBalls_2.next()) {
                var ball = otherBalls_2_1.value;
                ball.queueAbilities('onBallEnterBattle', this);
            }
        }
        catch (e_142_1) { e_142 = { error: e_142_1 }; }
        finally {
            try {
                if (otherBalls_2_1 && !otherBalls_2_1.done && (_a = otherBalls_2.return)) _a.call(otherBalls_2);
            }
            finally { if (e_142) throw e_142.error; }
        }
    };
    Ball.prototype.equip = function (equipmentType) {
        this.unequip();
        var equipment = equipmentTypeToEquipment(equipmentType);
        if (equipment) {
            this.equipment = this.addChild(equipment);
            if (this.world) {
                this.queueAbilities('onEquip');
            }
            if (this.state === Ball.States.PRE_BATTLE) {
                this.equipment.queueAbilities('onPreBattle');
            }
            else if (this.state === Ball.States.BATTLE) {
                this.equipment.queueAbilities('onEnterBattle');
            }
        }
    };
    Ball.prototype.flash = function (color, amount, duration) {
        if (duration === void 0) { duration = 0.5; }
        var ball = this;
        this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ball.effects.addSilhouette.color = color;
                        ball.effects.silhouette.amount = amount;
                        return [4 /*yield*/, S.tween(duration, ball.effects.silhouette, 'amount', amount, 0)];
                    case 1:
                        _a.sent();
                        ball.effects.silhouette.amount = 1;
                        ball.effects.silhouette.enabled = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    Ball.prototype.freeze = function (immediate) {
        this.freezeSprite = this.addChild(new FreezeIce(this.physicalRadius, immediate));
        if (this.isInShop && this.shopSpot >= 0) {
            GAME_DATA.frozenThings[this.shopSpot] = {
                type: 'ball',
                squadBall: {
                    x: this.x, y: this.y,
                    properties: this.properties,
                }
            };
        }
    };
    Ball.prototype.getScaleAccelerationMultiplier = function () {
        var e_143, _a;
        var amount = 1;
        try {
            for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var effect = _c.value;
                if (effect.type === 'scaleacceleration') {
                    amount *= effect.multiplier;
                }
            }
        }
        catch (e_143_1) { e_143 = { error: e_143_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_143) throw e_143.error; }
        }
        return amount;
    };
    Ball.prototype.getBoostMaxSpeedMultiplier = function () {
        var e_144, _a;
        var amount = 1;
        try {
            for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var effect = _c.value;
                if (effect.type === 'boostmaxspeed') {
                    var mult = M.mapTween(effect.timeLeft, effect.maxTime, 0, effect.multiplier, 1, Tween.Easing.InQuad);
                    amount = Math.max(amount, mult);
                }
            }
        }
        catch (e_144_1) { e_144 = { error: e_144_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_144) throw e_144.error; }
        }
        return amount;
    };
    Ball.prototype.getDescPrefix = function () {
        if (this.properties.metadata.extraSellValue > 0 || this.storesMoney) {
            var max = this.getSellValue() >= Ball.maxSellValue ? ' (max)' : '';
            return "Sells for [gold]<coin>" + this.getSellValue() + "[/gold]" + max;
        }
        return undefined;
    };
    Ball.prototype.getFlatDamageChange = function () {
        var e_145, _a;
        var result = 0;
        if (this.equipment && !this.isNullified()) {
            result += this.equipment.flatDamageChange;
        }
        try {
            for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var effect = _c.value;
                if (effect.type === 'protected') {
                    result -= effect.flatDamageReduction;
                }
            }
        }
        catch (e_145_1) { e_145 = { error: e_145_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_145) throw e_145.error; }
        }
        return result;
    };
    Ball.prototype.getPercentDamageChange = function () {
        var e_146, _a;
        var result = 1;
        if (this.equipment && !this.isNullified()) {
            result *= this.equipment.percentDamageChange;
        }
        try {
            for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var effect = _c.value;
                if (effect.type === 'stun' && effect.source === 'psychic') {
                    result *= 0.5;
                }
            }
        }
        catch (e_146_1) { e_146 = { error: e_146_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_146) throw e_146.error; }
        }
        return result;
    };
    Ball.prototype.getAbilityOverrideCollisionDamage = function () {
        return this.dmg;
    };
    Ball.prototype.getSlowEffectSpeedMultiplier = function () {
        var e_147, _a;
        var amount = 1;
        try {
            for (var _b = __values(this.statusEffects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var effect = _c.value;
                if (effect.type === 'slow') {
                    amount *= 1 - effect.slowFactor;
                }
            }
        }
        catch (e_147_1) { e_147 = { error: e_147_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_147) throw e_147.error; }
        }
        return amount;
    };
    Ball.prototype.getSquadSize = function (world) {
        if (world === void 0) { world = this.world; }
        if (this.squad)
            return this.squad.balls.length;
        return getAllies(world, this).length;
    };
    Ball.prototype.getStartEarlyTime = function () {
        if (!this.equipment)
            return 0;
        if (this.isNullified())
            return 0;
        return this.equipment.startEarlyTime;
    };
    Ball.prototype.getStun = function () {
        return this.statusEffects.find(function (e) { return e.type === 'stun'; });
    };
    Ball.prototype.giveShine = function (color) {
        color = color !== null && color !== void 0 ? color : Color.lerpColorByLch(getColorForTier(this.tier), 0xFFFFFF, 0.5);
        this.removeShine();
        this.effects.pre.filters.push(new ShineFilter(color));
    };
    Ball.prototype.handleDeath = function (killedBy, type) {
        var e_148, _a;
        var _this = this;
        if (this.hp <= 0) {
            this.hp = 0;
            this.dead = true;
            this.world.playSound('balldie');
            var otherBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== _this; });
            this.queueAbilities('onDeath', killedBy);
            killedBy === null || killedBy === void 0 ? void 0 : killedBy.queueAbilities('onKill', this);
            try {
                for (var otherBalls_3 = __values(otherBalls), otherBalls_3_1 = otherBalls_3.next(); !otherBalls_3_1.done; otherBalls_3_1 = otherBalls_3.next()) {
                    var ball = otherBalls_3_1.value;
                    ball.queueAbilities('onBallDie', this);
                }
            }
            catch (e_148_1) { e_148 = { error: e_148_1 }; }
            finally {
                try {
                    if (otherBalls_3_1 && !otherBalls_3_1.done && (_a = otherBalls_3.return)) _a.call(otherBalls_3);
                }
                finally { if (e_148) throw e_148.error; }
            }
            if (type === 'other') {
                this.world.addWorldObject(new Explosion(this.x, this.y, this.physicalRadius, { ally: 0, enemy: 0 }));
            }
            if (isModifierActive('ballsexplode')) {
                this.world.addWorldObject(new Explosion(this.x, this.y, this.physicalRadius + 30, { ally: 1, enemy: 1 }, this));
            }
            if (killedBy.team === 'friend' && this.team !== 'friend' && getBattleState(this.world) !== Ball.States.BATTLE && youArePlaying(this.world)) {
                updateAchievementProgress('KillBeforeBattle', function (p) { return p + 1; });
            }
            if (killedBy.team !== this.team) {
                killedBy.timesKilledEnemy++;
            }
            this.kill();
        }
    };
    Ball.prototype.hasAbility = function (abilityType) {
        return this.abilitySet.hasAbility(abilityType);
    };
    Ball.prototype.hasActivatedAbility = function (abilityType) {
        return _.includes(this.activatedAbilities, abilityType);
    };
    Ball.prototype.hasBattleEffect = function () {
        var _a;
        for (var ability in ABILITIES) {
            var abilityType = ability;
            if (ABILITIES[abilityType].battle && this.hasAbility(abilityType))
                return true;
        }
        if ((_a = this.equipment) === null || _a === void 0 ? void 0 : _a.hasBattleEffect())
            return true;
        return false;
    };
    Ball.prototype.healFor = function (amount, source) {
        var priorHp = this.hp;
        if (this.hp < this.maxhp) {
            this.hp = M.clamp(this.hp + amount, 0, this.maxhp);
        }
        var hpDiff = this.hp - priorHp;
        if (source.team === 'friend' && youArePlaying(this.world)) {
            updateAchievementProgress('HealHp', function (p) { return p + Math.max(hpDiff, 0); });
        }
        if (this.state === Ball.States.BATTLE && hpDiff !== 0) {
            this.showHpStat(hpDiff, 0.5);
            this.addHealFeedback(0.5);
        }
        return hpDiff;
    };
    Ball.prototype.hideAllStats = function () {
        this.dmgbox.setVisible(false);
        this.hpbox.setVisible(false);
        this.stars.setVisible(false);
        this.showingAllStats = false;
    };
    Ball.prototype.isBeingMoved = function () {
        if (!this.world)
            return false;
        var ballMover = this.world.select.type(BallMover, false);
        if (!ballMover)
            return false;
        return ballMover.movingThing === this;
    };
    Ball.prototype.isBurning = function () {
        return !!this.statusEffects.find(function (effect) { return effect.type === 'burning'; });
    };
    Ball.prototype.isGlitched = function () {
        return false;
    };
    Ball.prototype.isMarked = function () {
        return !!this.statusEffects.find(function (effect) { return effect.type === 'marked'; });
    };
    Ball.prototype.isNullified = function () {
        return !!this.statusEffects.find(function (effect) { return effect.type === 'nullified'; });
    };
    Ball.prototype.isPurchasable = function () {
        return true;
    };
    Ball.prototype.isTakingSpreadDamage = function () {
        return !!this.statusEffects.find(function (effect) { return effect.type === 'spreaddamage'; });
    };
    Ball.prototype.joinTeam = function () {
        var e_149, _a;
        var _this = this;
        var otherBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== _this && !ball.isInShop; });
        try {
            for (var otherBalls_4 = __values(otherBalls), otherBalls_4_1 = otherBalls_4.next(); !otherBalls_4_1.done; otherBalls_4_1 = otherBalls_4.next()) {
                var ball = otherBalls_4_1.value;
                ball.queueAbilities('onBallJoin', this);
            }
        }
        catch (e_149_1) { e_149 = { error: e_149_1 }; }
        finally {
            try {
                if (otherBalls_4_1 && !otherBalls_4_1.done && (_a = otherBalls_4.return)) _a.call(otherBalls_4);
            }
            finally { if (e_149) throw e_149.error; }
        }
    };
    Ball.prototype.leechFor = function (amount, source) {
        if (this.dead)
            return 0;
        var percentDamageChange = this.getPercentDamageChange();
        amount *= percentDamageChange;
        this.hp -= amount;
        if (source.team === 'friend' && youArePlaying(this.world)) {
            updateAchievementProgress('DealDamage', function (p) { return p + Math.max(amount, 0); });
        }
        this.queueAbilities('onTakeLeechDamage', amount);
        this.handleDeath(source, 'other');
        if (!this.dead && this.state === Ball.States.BATTLE)
            this.showHpStat(-amount, 0.5);
        return amount;
    };
    Ball.prototype.levelUp = function (withProperties, withFanfare, withStatIncrease) {
        var e_150, _a;
        var _b, _c, _d, _e;
        if (withFanfare === void 0) { withFanfare = true; }
        if (withStatIncrease === void 0) { withStatIncrease = true; }
        var levelUpPropeties = withProperties || this.getPropertiesForCurrentBallState();
        this.level++;
        this.dmg = Math.max(this.dmg, levelUpPropeties.damage);
        this.hp = Math.max(this.hp, levelUpPropeties.health);
        if (withStatIncrease) {
            this.dmg += 1;
            this.hp += 1;
        }
        if (!this.equipment) {
            this.equip(levelUpPropeties.equipment);
        }
        var buffs = (_d = (_c = (_b = this.world) === null || _b === void 0 ? void 0 : _b.select) === null || _c === void 0 ? void 0 : _c.typeAll(Buff)) !== null && _d !== void 0 ? _d : [];
        try {
            for (var buffs_1 = __values(buffs), buffs_1_1 = buffs_1.next(); !buffs_1_1.done; buffs_1_1 = buffs_1.next()) {
                var buff = buffs_1_1.value;
                if (buff.target.properties === levelUpPropeties) {
                    buff.target = this;
                }
            }
        }
        catch (e_150_1) { e_150 = { error: e_150_1 }; }
        finally {
            try {
                if (buffs_1_1 && !buffs_1_1.done && (_a = buffs_1.return)) _a.call(buffs_1);
            }
            finally { if (e_150) throw e_150.error; }
        }
        if (withFanfare) {
            this.addChild(new Sprite({
                texture: 'buffbeams',
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
                scale: (this.physicalRadius + 12) / 64,
                life: 1.5,
                vangle: 180,
                update: function () {
                    this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                    World.Actions.orderWorldObjectBefore(this, this.parent);
                },
            }));
            (_e = this.world) === null || _e === void 0 ? void 0 : _e.playSound('levelup');
        }
        if (withProperties && withProperties !== this.properties && (levelUpPropeties.metadata.extraSellValue > 0 || this.properties.metadata.extraSellValue > 0 || this.storesMoney)) {
            this.properties.metadata.extraSellValue += 1 + levelUpPropeties.metadata.extraSellValue;
        }
        this.queueAbilities('onLevelUp');
    };
    Ball.prototype.levelDown = function () {
        this.level = Math.max(this.level - 1, 1);
        this.queueAbilities('onLevelDown');
    };
    Ball.prototype.noteAbilityActivated = function (abilityType) {
        this.activatedAbilities.push(abilityType);
    };
    Ball.prototype.onEndGameBeforeDelayResolveObjects = function () {
        var burnEffect = this.statusEffects.find(function (effect) { return effect.type === 'burning'; });
        if (burnEffect) {
            var burnTime = burnEffect.timeLeft;
            this.addChild(new WorldObject({
                tags: [Tags.DELAY_RESOLVE(Ball.getInverseTeam(this.team))],
                life: Math.min(burnTime + 0.1, 5),
            }));
        }
        var spreadDamageEffect = this.statusEffects.find(function (effect) { return effect.type === 'spreaddamage'; });
        if (spreadDamageEffect) {
            var spreadDamageTime = spreadDamageEffect.timeLeft;
            this.addChild(new WorldObject({
                tags: [Tags.DELAY_RESOLVE(Ball.getInverseTeam(this.team))],
                life: Math.min(spreadDamageTime + 0.1, 5),
            }));
        }
    };
    Ball.prototype.onPickUp = function () {
    };
    Ball.prototype.onPutDown = function () {
    };
    Ball.prototype.onStateChangePreBattle = function () {
    };
    Ball.prototype.onStateChangeBattle = function () {
    };
    Ball.prototype.onTeamsSpawned = function () {
    };
    Ball.prototype.playButtonClicked = function () {
        this.queueAbilities('onPlay');
    };
    Ball.prototype.queueAbilities = function (type) {
        var _a;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.abilitySet.queueAbilities(type, this, this.isNullified(), params);
        if (_.contains(this.activateTwiceAbilities, type) && this.shouldActivateAbilityTwice()) {
            this.abilitySet.queueAbilities(type, this, this.isNullified(), params);
        }
        (_a = this.equipment) === null || _a === void 0 ? void 0 : _a.queueAbilities.apply(_a, __spread([type], params));
    };
    Ball.prototype.removeNullified = function () {
        A.filterInPlace(this.statusEffects, function (effect) { return effect.type !== 'nullified'; });
    };
    Ball.prototype.removeShine = function () {
        var i = this.effects.pre.filters.findIndex(function (filter) { return filter instanceof ShineFilter; });
        if (i >= 0) {
            this.effects.pre.filters.splice(i, 1);
        }
    };
    Ball.prototype.removeStatusEffectsOfType = function (type) {
        A.filterInPlace(this.statusEffects, function (effect) { return effect.type === type; });
    };
    Ball.prototype.setBallScale = function (ballScale) {
        this.ballScale = ballScale;
        this.updateBallScaleInternal();
    };
    Ball.prototype.setMassScale = function (massScale) {
        this.massScale = massScale;
        this.updateBallScaleInternal();
    };
    Ball.prototype.setMoveScale = function (moveScale) {
        this.moveScale = moveScale;
        this.updateBallScaleInternal();
    };
    Ball.prototype.stop = function (time) {
        this.addSlow('other', 0.8, time);
        this.addScaleAcceleration(this, 0, time);
    };
    Ball.prototype.updateBallScaleInternal = function () {
        this.scale = this.ballScale * this.moveScale;
        this.mask.texture = Ball.textureMaskForRadius(this.radius * this.scale);
        this.mass = this.radius / 8 * (Math.pow(this.ballScale, 3)) * this.massScale;
        this.bounds.radius = this.radius * this.ballScale;
    };
    Ball.prototype.setForInShop = function () {
    };
    Ball.prototype.setForShare = function () {
        var _a;
        (_a = this.equipment) === null || _a === void 0 ? void 0 : _a.setForShare();
    };
    Ball.prototype.setPreBattleAbilityActiveCheck = function (check) {
        this._preBattleAbilityActiveCheck = check;
    };
    Ball.prototype.shouldActivateAbilityTwice = function () {
        return this.equipment && this.equipment.chanceToActivateAbilitiesTwice > 0 && !this.isNullified() && Ball.Random.boolean(this.equipment.chanceToActivateAbilitiesTwice);
    };
    Ball.prototype.shouldSellAtOneGold = function () {
        // if (!this.world) return false;
        // return this.world.select.typeAll(Ball)
        //     .some(ball => ball.team === this.team && ball !== this && !ball.isInShop && ball.properties.type === this.properties.type && ball.equipment?.stockEquippedBall);
        return false;
    };
    Ball.prototype.showAllStats = function () {
        this.showDmgStat(0, Infinity);
        this.showHpStat(0, Infinity);
        this.showLvlStat(Infinity);
        this.showingAllStats = true;
    };
    Ball.prototype.showDmgStat = function (changeSign, time) {
        var _this = this;
        var _a;
        this.dmgbox.setVisible(true);
        this.dmgbox.setColor(changeSign < 0 ? 0xFF0000 : changeSign > 0 ? 0xFFD800 : 0xFFFFFF);
        if (_.isFinite(time)) {
            (_a = this.showDmgStatScript) === null || _a === void 0 ? void 0 : _a.stop();
            this.showDmgStatScript = this.runScript(S.chain(S.wait(time), S.call(function () {
                _this.dmgbox.setColor(0xFFFFFF);
                if (_this.state === Ball.States.BATTLE && !_this.showingAllStats)
                    _this.dmgbox.setVisible(false);
            })));
        }
    };
    Ball.prototype.showHpStat = function (changeSign, time) {
        var _this = this;
        var _a;
        this.hpbox.setVisible(true);
        this.hpbox.setColor(changeSign < 0 ? 0xFF0000 : changeSign > 0 ? 0xFFD800 : 0xFFFFFF);
        if (_.isFinite(time)) {
            (_a = this.showHpStatScript) === null || _a === void 0 ? void 0 : _a.stop();
            this.showHpStatScript = this.runScript(S.chain(S.wait(time), S.call(function () {
                _this.hpbox.setColor(0xFFFFFF);
                if (_this.state === Ball.States.BATTLE && !_this.showingAllStats)
                    _this.hpbox.setVisible(false);
            })));
        }
    };
    Ball.prototype.showLvlStat = function (time) {
        var _this = this;
        var _a;
        this.stars.setVisible(true);
        if (_.isFinite(time)) {
            (_a = this.showLvlStatScript) === null || _a === void 0 ? void 0 : _a.stop();
            this.showLvlStatScript = this.runScript(S.chain(S.wait(time), S.call(function () { return _this.stars.setVisible(false); })));
        }
    };
    Ball.prototype.takeDamage = function (amount, source, type, unblockable) {
        var e_151, _a;
        var _this = this;
        if (unblockable === void 0) { unblockable = false; }
        if (this.dead)
            return 0;
        if (!this.world)
            return 0;
        if (amount === 0 && !unblockable)
            return 0;
        this.world.playSound('ballhit', { limit: 10 });
        var damageToDeal = this.calculateDamageAgainstThis(amount, unblockable);
        if (this.equipment && this.equipment.blockOneDiscreteDamage && damageToDeal > 0 && !unblockable) {
            this.breakEquipment();
            if (!this.isNullified()) {
                return 0;
            }
        }
        var damageDealt = Math.min(this.hp, damageToDeal);
        if (this.equipment && this.equipment.spreadDamageOverTime > 0 && !this.isNullified() && !unblockable) {
            this.addSpreadDamage(source, damageToDeal, this.equipment.spreadDamageOverTime);
        }
        else {
            this.hp -= damageToDeal;
        }
        this.timesTakenDamage++;
        this.queueAbilities('onTakeDamage', damageDealt);
        var otherBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball !== _this; });
        try {
            for (var otherBalls_5 = __values(otherBalls), otherBalls_5_1 = otherBalls_5.next(); !otherBalls_5_1.done; otherBalls_5_1 = otherBalls_5.next()) {
                var ball = otherBalls_5_1.value;
                ball.queueAbilities('onBallTakeDamage', this, damageDealt);
            }
        }
        catch (e_151_1) { e_151 = { error: e_151_1 }; }
        finally {
            try {
                if (otherBalls_5_1 && !otherBalls_5_1.done && (_a = otherBalls_5.return)) _a.call(otherBalls_5);
            }
            finally { if (e_151) throw e_151.error; }
        }
        if (source.team === 'friend' && youArePlaying(this.world)) {
            updateAchievementProgress('DealDamage', function (p) { return p + Math.max(damageDealt, 0); });
        }
        this.handleDeath(source, type);
        if (!this.dead && damageDealt !== 0) {
            this.showHpStat(-damageDealt, 0.5);
        }
        return damageDealt;
    };
    Ball.prototype.undisguise = function () {
        var ballTeamColorFilter = this.effects.pre.filters.find(function (f) { return f instanceof BallTeamColorFilter; });
        if (!ballTeamColorFilter)
            return;
        ballTeamColorFilter.setColor(Ball.getTeamColor(this.team));
        this.disguised = false;
    };
    Ball.prototype.unequip = function () {
        if (!this.equipment)
            return;
        this.equipment.cancelAbilities();
        this.equipment.kill();
        this.equipment = undefined;
    };
    Ball.prototype.unfreeze = function () {
        this.freezeSprite.kill();
        this.freezeSprite = undefined;
        if (this.isInShop && this.shopSpot >= 0) {
            GAME_DATA.frozenThings[this.shopSpot] = undefined;
        }
    };
    Ball.prototype.useItem = function (item) {
        item.onApplyToBall(this);
    };
    Ball.prototype.getPropertiesForCurrentBallState = function () {
        return {
            type: this.properties.type,
            damage: this.dmg,
            health: this.hp,
            equipment: this.equipment ? this.equipment.equipmentType : -1,
            level: this.level,
            metadata: _.clone(this.properties.metadata),
        };
    };
    Ball.prototype.getFlow = function () {
        if (this.world.data.arenaName === Arenas.ARENA_GRAVITY) {
            return Vector2.DOWN.scale(0.8);
        }
        if (this.world.data.arenaName === Arenas.ARENA_ICE && !this.v.isZero()) {
            return Vector2.ZERO;
        }
        return this.getPosition().subtract(global.gameWidth / 2, global.gameHeight / 2).normalize().rotate(90);
    };
    Ball.prototype.getArenaIceSpeedMultiplier = function () {
        if (this.world.data.arenaName !== Arenas.ARENA_ICE)
            return 1;
        var arenaShrinkIce = this.world.select.type(ArenaShrinkIce, false);
        if (!arenaShrinkIce)
            return 1;
        return arenaShrinkIce.speedMultiplier;
    };
    Ball.handleCollision = function (collision) {
        var _a, _b, _c, _d, _e;
        var ball1 = collision.self.obj;
        var ball2 = collision.other.obj;
        ball1.queueAbilities('onCollideWithBallPreDamage', ball2);
        ball2.queueAbilities('onCollideWithBallPreDamage', ball1);
        ball1.stunImmune.reset();
        ball2.stunImmune.reset();
        var isBall1Immune = ball1.team !== 'neutral' && ball1.life.time < ball1.afterAddImmuneTime;
        var isBall2Immune = ball2.team !== 'neutral' && ball2.life.time < ball2.afterAddImmuneTime;
        if (isBall1Immune || isBall2Immune)
            return;
        var collisionV = vec2(collision.self.pre_vx - collision.other.pre_vx, collision.self.pre_vy - collision.other.pre_vy);
        if (ball1.team !== ball2.team && !ball1.disguised && !ball2.disguised) {
            (_a = ball1.world) === null || _a === void 0 ? void 0 : _a.addWorldObject(new BurstPuffSystem({
                x: (ball1.x + ball2.x) / 2,
                y: (ball1.y + ball2.y) / 2,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(10 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.6,
                    v: Random.inCircle(70),
                    color: 0xFFFF00,
                    finalColor: 0xAA3300,
                    radius: 2,
                    finalRadius: 0,
                }); },
            }));
            (_b = ball1.world) === null || _b === void 0 ? void 0 : _b.addWorldObject(new Explosion((ball1.x + ball2.x) / 2, (ball1.y + ball2.y) / 2, 10, { ally: 0, enemy: 0 }));
            (_d = ((_c = global.theater) !== null && _c !== void 0 ? _c : ball1.world)) === null || _d === void 0 ? void 0 : _d.runScript(shake(ball1.world, 1, 0.1));
            var ball1baseDmg = ball1.isNullified() ? ball1.dmg : ball1.getAbilityOverrideCollisionDamage();
            var ball1dmg = ball1baseDmg * Math.min(M.magnitude(collision.self.pre_vx, collision.self.pre_vy) / Ball.oneDamageSpeed, ball1.clampDamageRatio);
            if (ball1.getStun())
                ball1dmg = 0;
            var ball2baseDmg = ball2.isNullified() ? ball2.dmg : ball2.getAbilityOverrideCollisionDamage();
            var ball2dmg = ball2baseDmg * Math.min(M.magnitude(collision.other.pre_vx, collision.other.pre_vy) / Ball.oneDamageSpeed, ball2.clampDamageRatio);
            if (ball2.getStun())
                ball2dmg = 0;
            var damageDealt2 = ball2.dealsCollisionDamage()
                ? ball1.takeDamage(ball2dmg, ball2, 'collision')
                : ball1.calculateDamageAgainstThis(ball2dmg, false);
            var damageDealt1 = ball1.dealsCollisionDamage()
                ? ball2.takeDamage(ball1dmg, ball1, 'collision')
                : ball2.calculateDamageAgainstThis(ball1dmg, false);
            ball1.queueAbilities('onCollideWithEnemyPostDamage', ball2, damageDealt1);
            ball2.queueAbilities('onCollideWithEnemyPostDamage', ball1, damageDealt2);
            if (isModifierActive('slowcollisions')) {
                ball1.stop(0.5);
                ball2.stop(0.5);
            }
            ball1.timesCollidedWithEnemy++;
            ball2.timesCollidedWithEnemy++;
        }
        else {
            (_e = ball1.world) === null || _e === void 0 ? void 0 : _e.addWorldObject(new BurstPuffSystem({
                x: (ball1.x + ball2.x) / 2,
                y: (ball1.y + ball2.y) / 2,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(10 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.3,
                    v: Random.inCircle(50),
                    color: 0xFFFFFF,
                    radius: 4 * collisionV.magnitude / 200,
                    finalRadius: 0,
                }); },
            }));
        }
    };
    Ball.accelerationBase = 150;
    Ball.maxSellValue = 50;
    Ball.maxSpeedBase = 150;
    Ball.oneDamageSpeed = 125;
    Ball.minTrampolineBounceSpeed = 50;
    Ball.minModifierWallBounceSpeed = 100;
    return Ball;
}(Sprite));
(function (Ball) {
    var States;
    (function (States) {
        States.PREP = 'prep';
        States.PRE_BATTLE = 'prebattle';
        States.BATTLE = 'battle';
    })(States = Ball.States || (Ball.States = {}));
    Ball.Random = new RandomNumberGenerator();
    function getInverseTeam(team) {
        if (team === 'neutral')
            return 'neutral';
        if (team === 'enemy')
            return 'friend';
        return 'enemy';
    }
    Ball.getInverseTeam = getInverseTeam;
    function getTeamForColorAprilFools(team) {
        if (LiveVersion.APRIL_FOOLS)
            return getInverseTeam(team);
        return team;
    }
    Ball.getTeamForColorAprilFools = getTeamForColorAprilFools;
    function getTeamColor(team) {
        team = getTeamForColorAprilFools(team);
        if (team === 'friend')
            return 0x484DFF;
        if (team === 'enemy')
            return 0x00BB00;
        return 0x808080;
    }
    Ball.getTeamColor = getTeamColor;
    function getDarkTeamColor(team) {
        team = getTeamForColorAprilFools(team);
        if (team === 'friend')
            return 0x24267F;
        if (team === 'enemy')
            return 0x005D00;
        return 0x404040;
    }
    Ball.getDarkTeamColor = getDarkTeamColor;
    function getLightTeamColor(team) {
        team = getTeamForColorAprilFools(team);
        if (team === 'friend')
            return 0xA3A6FF;
        if (team === 'enemy')
            return 0x7FDD7F;
        return 0xBFBFBF;
    }
    Ball.getLightTeamColor = getLightTeamColor;
    var MASK_CACHE = new LazyDictNumber(function (radiusRounded) { return new AnchoredTexture(Texture.filledCircle(radiusRounded, 0xFFFFFF), 0.5, 0.5); });
    function textureMaskForRadius(radius) {
        var radiusRounded = Math.round(radius);
        return MASK_CACHE.get(radiusRounded);
    }
    Ball.textureMaskForRadius = textureMaskForRadius;
})(Ball || (Ball = {}));
/// <reference path="./ball.ts" />
var Balls;
(function (Balls) {
    var Alchemist = /** @class */ (function (_super) {
        __extends(Alchemist, _super);
        function Alchemist(config) {
            var _this = _super.call(this, 'balls/alchemist', 8, config) || this;
            _this.canBeTargetedForDeath = false;
            _this.crosshair = _this.addChild(new Sprite({
                texture: 'crosshair',
                alpha: 0,
            }));
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', Alchemist.onPreBattle);
            _this.addAbility('onEnterBattle', Alchemist.onEnterBattle);
            return _this;
        }
        Alchemist.prototype.getName = function () { return 'Alchemist'; };
        Alchemist.prototype.getDesc = function () {
            var levelDiffDisplay = '';
            if (this.levelDiff < 0)
                levelDiffDisplay = "with -[gold]" + -this.levelDiff + "<star>[/gold]";
            if (this.levelDiff > 0)
                levelDiffDisplay = "with +[gold]" + this.levelDiff + "<star>[/gold]";
            return "At the start of battle, kill the closest ally and resummon it as a random shop ball " + levelDiffDisplay + "\n\nActivates after other ball abilities";
        };
        Alchemist.prototype.getShopDmg = function () { return 3; };
        Alchemist.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(Alchemist.prototype, "levelDiff", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Alchemist.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            if (this.world.getLayerByName(Battle.Layers.fx)) {
                this.crosshair.layer = Battle.Layers.fx;
            }
        };
        Alchemist.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            var hasActivatedAbility = A.overlaps(this.activatedAbilities, ['onPreBattle', 'onEnterBattle']);
            var closestAlly = Alchemist.getClosestAlly(this, this.world);
            if (this.isInShop || this.isInYourSquadScene || !closestAlly || this.isNullified() || hasActivatedAbility || this.state === Ball.States.BATTLE) {
                this.crosshair.alpha = M.moveToClamp(this.crosshair.alpha, 0, 4, this.delta);
            }
            else {
                this.crosshair.teleport(closestAlly);
                this.crosshair.alpha = M.moveToClamp(this.crosshair.alpha, 0.8, 1, this.delta);
            }
        };
        Alchemist.prototype.setForInShop = function () {
            _super.prototype.setForInShop.call(this);
            this.crosshair.alpha = 0;
        };
        Alchemist.onPreBattle = function (source, world) {
            Alchemist.transformAlly(source, world);
        };
        Alchemist.onEnterBattle = function (source, world) {
            var battleTimer = world.select.type(BattleTimer, false);
            var timeInBattle = battleTimer ? battleTimer.battleTime : 0;
            if (timeInBattle > 0.3 || source.hasActivatedAbility('onPreBattle'))
                return;
            Alchemist.transformAlly(source, world);
        };
        Alchemist.transformAlly = function (source, world) {
            var ballToTransform = Alchemist.getClosestAlly(source, world);
            if (!ballToTransform)
                return;
            ballToTransform.targetedForDeath = true;
            ballToTransform.cancelAbilities();
            var absorbedHp = ballToTransform.hp;
            world.addWorldObject(new InstantKillSlash(ballToTransform, source));
            if (ballToTransform.dead || !ballToTransform.alive) {
                ballToTransform.colliding = false;
            }
            world.addWorldObject(newPuff(ballToTransform.x, ballToTransform.y, Battle.Layers.fx, 'medium'));
            source.flash(0xFFFFFF, 1);
            var equipment = ballToTransform.equipment ? ballToTransform.equipment.equipmentType : -1;
            if (equipment === 20) { // Disallow Best Friend
                equipment = -1;
            }
            var validBallTypes = getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly)
                .filter(function (type) { return !_.contains(Alchemist.USELESS_BALL_TYPES, type); });
            var ballType = Ball.Random.element(validBallTypes);
            world.addWorldObject(squadBallToWorldBall({
                x: ballToTransform.x,
                y: ballToTransform.y,
                properties: {
                    type: ballType,
                    damage: ballToTransform.dmg,
                    health: absorbedHp,
                    equipment: equipment,
                    level: Math.max(ballToTransform.level + source.levelDiff, 1),
                    metadata: ballToTransform.properties.metadata,
                },
            }, ballToTransform.squad, ballToTransform.squadIndexReference, source.team));
        };
        Alchemist.getClosestAlly = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return ball.canBeTargetedForDeath && !ball.targetedForDeath && !ball.isInShop; });
            if (validBalls.length === 0)
                return undefined;
            return M.argmin(validBalls, function (ball) { return G.distance(source, ball); });
        };
        Alchemist.USELESS_BALL_TYPES = [
            6,
            9,
            10,
            24,
            25,
            32,
            35,
            37,
            38,
            39,
            47,
            48,
            101,
            114,
            116,
            126,
            127,
            133,
            134,
            135,
            136,
            139,
            140,
            142,
        ];
        return Alchemist;
    }(Ball));
    Balls.Alchemist = Alchemist;
})(Balls || (Balls = {}));
/// <reference path="./ball.ts" />
var Balls;
(function (Balls) {
    var Angel = /** @class */ (function (_super) {
        __extends(Angel, _super);
        function Angel(config) {
            var _this = _super.call(this, 'balls/angel', 8, config) || this;
            _this.halo = _this.addChild(new Sprite({
                texture: 'angelhalo',
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onDeath', onDeath);
            return _this;
        }
        Angel.prototype.getName = function () { return 'Angel'; };
        Angel.prototype.getDesc = function () { return "On death, heal all allies by [g]" + this.healAmount + "<heart>[/g]"; };
        Angel.prototype.getShopDmg = function () { return 3; };
        Angel.prototype.getShopHp = function () { return 1; };
        Angel.prototype.getCredits = function () { return [CreditsNames.FIREBALLME]; };
        Object.defineProperty(Angel.prototype, "healAmount", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Angel.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.halo.alpha = this.alpha;
            this.halo.scale = this.ballScale * this.moveScale;
            this.halo.effects.outline.color = this.effects.outline.color;
            this.halo.effects.outline.enabled = this.effects.outline.enabled;
            World.Actions.orderWorldObjectAfter(this.halo, this);
        };
        return Angel;
    }(Ball));
    Balls.Angel = Angel;
    function onDeath(source, world) {
        var e_152, _a;
        var allies = getAlliesNotSelf(world, source);
        if (allies.length === 0)
            return;
        try {
            for (var allies_1 = __values(allies), allies_1_1 = allies_1.next(); !allies_1_1.done; allies_1_1 = allies_1.next()) {
                var ally = allies_1_1.value;
                world.addWorldObject(new HomingHeal(source.x, source.y, source, ally, source.healAmount, function (balls) { return undefined; }));
            }
        }
        catch (e_152_1) { e_152 = { error: e_152_1 }; }
        finally {
            try {
                if (allies_1_1 && !allies_1_1.done && (_a = allies_1.return)) _a.call(allies_1);
            }
            finally { if (e_152) throw e_152.error; }
        }
    }
})(Balls || (Balls = {}));
/// <reference path="./ball.ts" />
var Balls;
(function (Balls) {
    var Assassin = /** @class */ (function (_super) {
        __extends(Assassin, _super);
        function Assassin(config) {
            var _this = _super.call(this, 'balls/assassin', 8, config) || this;
            _this.enemyTrackers = {};
            _this.canUpdateEnemyTrackersTimer = _this.addTimer(0.5);
            _this.canUpdateEnemyTrackersTimer.finish();
            _this.addAbility('update', Assassin.update, { canActivateTwice: false });
            return _this;
        }
        Assassin.prototype.getName = function () { return 'Assassin'; };
        Assassin.prototype.getDesc = function () { return "When an enemy falls to [g]" + this.executeThreshold + "<heart>[/g] or below, shoot a [r]" + this.executeThreshold + "<sword>[/r] homing spike at it"; };
        Assassin.prototype.getShopDmg = function () { return 2; };
        Assassin.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Assassin.prototype, "executeThreshold", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Assassin.prototype.onStateChangePreBattle = function () {
            Assassin.updateEnemyTrackers(this, this.world);
        };
        Assassin.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE && source.state !== Ball.States.PRE_BATTLE)
                return;
            if (source.canUpdateEnemyTrackersTimer.done) {
                Assassin.updateEnemyTrackers(source, world);
            }
        };
        Assassin.updateEnemyTrackers = function (source, world) {
            var e_153, _a;
            var enemies = getEnemies(world, source);
            try {
                for (var enemies_1 = __values(enemies), enemies_1_1 = enemies_1.next(); !enemies_1_1.done; enemies_1_1 = enemies_1.next()) {
                    var enemy = enemies_1_1.value;
                    if (enemy.name && enemy.name in source.enemyTrackers) {
                        var tracker = source.enemyTrackers[enemy.name];
                        if (enemy.hp <= source.executeThreshold && tracker.lastHp > source.executeThreshold) {
                            Assassin.shootSpike(source, world, enemy);
                            if (source.shouldActivateAbilityTwice()) {
                                Assassin.shootSpike(source, world, enemy);
                            }
                            source.canUpdateEnemyTrackersTimer.reset();
                        }
                        tracker.lastHp = enemy.hp;
                    }
                    else {
                        source.enemyTrackers[enemy.name] = {
                            lastHp: enemy.hp,
                        };
                    }
                }
            }
            catch (e_153_1) { e_153 = { error: e_153_1 }; }
            finally {
                try {
                    if (enemies_1_1 && !enemies_1_1.done && (_a = enemies_1.return)) _a.call(enemies_1);
                }
                finally { if (e_153) throw e_153.error; }
            }
        };
        Assassin.shootSpike = function (source, world, enemy) {
            world.addWorldObject(new HomingSpike(source.x, source.y, source, enemy, source.executeThreshold, 1, function (enemyBalls) { return undefined; }));
            source.didShootProjectile(1);
        };
        return Assassin;
    }(Ball));
    Balls.Assassin = Assassin;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var BallOfIce = /** @class */ (function (_super) {
        __extends(BallOfIce, _super);
        function BallOfIce(config) {
            var _this = _super.call(this, 'balls/ballofice', 8, config) || this;
            _this.addAbility('onPlay', BallOfIce.onPlay);
            return _this;
        }
        BallOfIce.prototype.getName = function () { return 'Ball of Ice'; };
        BallOfIce.prototype.getDesc = function () {
            return "On PLAY, convert [gold]1<star>[/gold] to give a random frozen shop ball +" + buffText(BallOfIce.getBuffAmount(this), BallOfIce.getBuffAmount(this)) + "\n\nTwo Balls of Ice cannot buff the same ball";
        };
        BallOfIce.prototype.getShopDmg = function () { return 2; };
        BallOfIce.prototype.getShopHp = function () { return 4; };
        BallOfIce.prototype.getCredits = function () { return [CreditsNames.JUNJ]; };
        BallOfIce.getBuffAmount = function (source) { return source.level; };
        BallOfIce.onPlay = function (source, world) {
            if (source.level <= 1)
                return;
            var existingBuffs = world.select.typeAll(Buff).filter(function (buff) { return buff.hasTag(Tags.BALL_OF_ICE_BUFF); });
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return ball.isInShop && ball.frozen && !existingBuffs.some(function (buff) { return buff.target === ball; }); });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            var buff = world.addWorldObject(new Buff(source.x, source.y, randomBall, { dmg: BallOfIce.getBuffAmount(source), hp: BallOfIce.getBuffAmount(source) }));
            buff.addTag(Tags.BALL_OF_ICE_BUFF);
            source.levelDown();
            world.playSound('sellball', { humanized: false, volume: 1.5 });
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        return BallOfIce;
    }(Ball));
    Balls.BallOfIce = BallOfIce;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var BallOfYarn = /** @class */ (function (_super) {
        __extends(BallOfYarn, _super);
        function BallOfYarn(config) {
            var _this = _super.call(this, 'balls/ballofyarn', 8, config) || this;
            _this.angle = -90;
            _this.tail = _this.addChild(new Sprite({
                texture: 'ballofyarntail',
                tint: Ball.getTeamColor(config.team),
                copyFromParent: ['layer'],
            }));
            _this.yarnTime = 0;
            _this.yarnDistance = 0;
            _this.addAbility('onCollideWithEnemyPostDamage', BallOfYarn.onCollideWithEnemyPostDamage);
            _this.addAbility('update', BallOfYarn.update, { canActivateTwice: false });
            return _this;
        }
        BallOfYarn.prototype.getName = function () { return 'Ball Of Yarn'; };
        BallOfYarn.prototype.getDesc = function () { return "Slows enemies by " + this.slowFactorPercent + "% for [lb]" + this.collisionSlowTime + "s[/lb] on collision. Leaves a trail of yarn lasting [lb]" + this.yarnLife + "s[/lb] which also slows enemies"; };
        BallOfYarn.prototype.getShopDmg = function () { return 3; };
        BallOfYarn.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(BallOfYarn.prototype, "slowFactorPercent", {
            get: function () { return 50; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BallOfYarn.prototype, "slowFactor", {
            get: function () { return this.slowFactorPercent / 100; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BallOfYarn.prototype, "yarnLife", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BallOfYarn.prototype, "collisionSlowTime", {
            get: function () { return this.level / 2; },
            enumerable: false,
            configurable: true
        });
        BallOfYarn.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            this.yarnSystem = this.world.addWorldObject(new YarnSystem(this, this.getPosition(), this.slowFactor));
            if (this.world.getLayerByName(Battle.Layers.onground)) {
                this.yarnSystem.layer = Battle.Layers.onground;
            }
        };
        BallOfYarn.prototype.onStateChangeBattle = function () {
            var _a;
            (_a = this.yarnSystem) === null || _a === void 0 ? void 0 : _a.setStartPointForBattle(this.getPosition());
        };
        BallOfYarn.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.tail.alpha = this.alpha;
            this.tail.scale = this.ballScale * this.moveScale;
            this.tail.angle = this.angle + 90;
            this.tail.effects.outline.color = this.effects.outline.color;
            this.tail.effects.outline.enabled = this.effects.outline.enabled;
            World.Actions.orderWorldObjectBefore(this.tail, this);
        };
        BallOfYarn.prototype.addYarnSegment = function () {
            if (!this.yarnSystem)
                return;
            this.yarnSystem.addSegment(this.getPosition(), this.yarnLife);
        };
        BallOfYarn.onCollideWithEnemyPostDamage = function (source, world, enemy, damage) {
            enemy.addSlow('yarn', source.slowFactor, source.collisionSlowTime);
        };
        BallOfYarn.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            source.yarnTime += source.delta;
            source.yarnDistance += source.v.magnitude * source.delta;
            if (source.yarnTime >= 0.3 || source.yarnDistance >= source.physicalRadius) {
                source.yarnTime = 0;
                source.yarnDistance = 0;
                source.addYarnSegment();
            }
        };
        return BallOfYarn;
    }(Ball));
    Balls.BallOfYarn = BallOfYarn;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Bank = /** @class */ (function (_super) {
        __extends(Bank, _super);
        function Bank(config) {
            var _this = _super.call(this, 'balls/bank', 8, config) || this;
            _this.addAbility('onPlay', Bank.onPlay);
            return _this;
        }
        Bank.prototype.getName = function () { return 'Bank'; };
        Bank.prototype.getDesc = function () {
            if (Bank.getRounds(this) === 1)
                return "Keeps [gold]<coin>1 unspent[/gold] each round. For every [gold]<coin>[/gold] kept, gain [gold]<coin>1[/gold] every round for the next [lb]round[/lb]";
            var parenthetical = Bank.getRounds(this) >= Bank.MAX_ROUNDS ? '[gold](max)[/gold]' : '(even if Bank is sold)';
            return "Keeps [gold]<coin>1 unspent[/gold] each round. For every [gold]<coin>[/gold] kept, gain [gold]<coin>1[/gold] every round (stacking) for the next [lb]" + Bank.getRounds(this) + " rounds[/lb] " + parenthetical;
        };
        Bank.prototype.getShopDmg = function () { return 1; };
        Bank.prototype.getShopHp = function () { return 3; };
        Bank.prototype.getCredits = function () { return [CreditsNames.EVERYONE]; };
        Bank.getRounds = function (source) { return Math.min(1 + source.level, Bank.MAX_ROUNDS); };
        Bank.onPlay = function (source, world) {
            if (GAME_DATA.gold <= 0)
                return;
            var gold = 1;
            GAME_DATA.gold -= gold;
            var prepCoin = world.select.name('goldcoin');
            var position = prepCoin ? prepCoin.getPosition().add(4, 0) : source.getPosition();
            var homingGold = world.addWorldObject(new HomingGoldVisual(position.x, position.y, source, gold));
            source.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return !homingGold.world; })];
                        case 1:
                            _a.sent();
                            GAME_DATA.bankedGold.push({ squadIndex: source.squadIndexReference, goldPerRound: 1, roundsLeft: Bank.getRounds(source) });
                            return [2 /*return*/];
                    }
                });
            });
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        Bank.MAX_ROUNDS = 6;
        return Bank;
    }(Ball));
    Balls.Bank = Bank;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Battery = /** @class */ (function (_super) {
        __extends(Battery, _super);
        function Battery(config) {
            var _this = _super.call(this, 'balls/battery', 8, config) || this;
            _this.addAbility('onPlay', Battery.onPlay);
            return _this;
        }
        Battery.prototype.getName = function () { return 'Battery'; };
        Battery.prototype.getDesc = function () {
            var PLAY = "" + (GAME_MODE === 'vs' ? 'LOCK IN' : 'PLAY');
            return "On " + PLAY + ", convert [gold]1<star>[/gold] into " + buffText(Battery.getBuffAmount(this), Battery.getBuffAmount(this)) + " buffs for " + Battery.getAlliesToBuff(this) + " random allies";
        };
        Battery.prototype.getShopDmg = function () { return 4; };
        Battery.prototype.getShopHp = function () { return 4; };
        Battery.getBuffAmount = function (source) { return 1; };
        Battery.getAlliesToBuff = function (source) { return 2; };
        Battery.onPlay = function (source, world) {
            var e_154, _a;
            if (source.level <= 1)
                return;
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            if (validBalls.length > Battery.getAlliesToBuff(source)) {
                Ball.Random.shuffle(validBalls);
                validBalls = validBalls.slice(0, Battery.getAlliesToBuff(source));
            }
            try {
                for (var validBalls_2 = __values(validBalls), validBalls_2_1 = validBalls_2.next(); !validBalls_2_1.done; validBalls_2_1 = validBalls_2.next()) {
                    var ally = validBalls_2_1.value;
                    world.addWorldObject(new RandomBuff(source.x, source.y, source, ally, { dmg: Battery.getBuffAmount(source), hp: Battery.getBuffAmount(source) }, function (_) { return undefined; }));
                }
            }
            catch (e_154_1) { e_154 = { error: e_154_1 }; }
            finally {
                try {
                    if (validBalls_2_1 && !validBalls_2_1.done && (_a = validBalls_2.return)) _a.call(validBalls_2);
                }
                finally { if (e_154) throw e_154.error; }
            }
            source.levelDown();
            world.playSound('sellball', { humanized: false, volume: 1.5 });
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        return Battery;
    }(Ball));
    Balls.Battery = Battery;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var BioGrenade = /** @class */ (function (_super) {
        __extends(BioGrenade, _super);
        function BioGrenade(config) {
            var _this = _super.call(this, 'balls/biogrenade', 4, config) || this;
            _this.angle = 90;
            _this.visibleExplosionRadius = _this.explosionRadius;
            _this.handle = _this.addChild(new Sprite({
                texture: 'biogrenadehandle',
                copyFromParent: ['layer'],
            }));
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0x00FF00,
                blendMode: Texture.BlendModes.ADD,
                scale: 8 / 64,
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onDeath', onDeath);
            return _this;
        }
        BioGrenade.prototype.getName = function () { return 'Bio-Grenade'; };
        BioGrenade.prototype.getDesc = function () { return "On death, plant [dg]spore equipments[/dg] on enemies in a radius\n\nSpored balls take [r]1<sword>[/r] extra per hit"; };
        BioGrenade.prototype.getShopDmg = function () { return 6; };
        BioGrenade.prototype.getShopHp = function () { return 1; };
        Object.defineProperty(BioGrenade.prototype, "explosionRadius", {
            get: function () { return this.physicalRadius - 8 + 36 * (1 + (this.level - 1) * 0.2); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BioGrenade.prototype, "yourSquadRadius", {
            get: function () { return 15; },
            enumerable: false,
            configurable: true
        });
        BioGrenade.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            World.Actions.orderWorldObjectBefore(this.aura, this);
            this.handle.alpha = this.alpha;
            this.handle.scale = this.ballScale * this.moveScale;
            this.handle.angle = this.angle - 90;
            this.handle.effects.outline.color = this.effects.outline.color;
            this.handle.effects.outline.enabled = this.effects.outline.enabled;
            World.Actions.orderWorldObjectBefore(this.handle, this);
            if ((this.isInShop && !this.isBeingMoved()) || this.isNullified()) {
                this.visibleExplosionRadius = 0;
            }
            else {
                this.visibleExplosionRadius = M.lerpTime(this.visibleExplosionRadius, this.explosionRadius, 100, this.delta);
            }
        };
        BioGrenade.prototype.setForInShop = function () {
            this.visibleExplosionRadius = 0;
        };
        BioGrenade.prototype.render = function (texture, x, y) {
            var drawRadius = this.isInYourSquadScene ? this.yourSquadRadius : this.visibleExplosionRadius;
            Draw.brush.color = Color.lerpColorByLch(0x66DF66, 0x66FF66, Tween.Easing.OscillateSine(2)(this.life.time));
            Draw.brush.alpha = 0.6;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, drawRadius, Draw.ALIGNMENT_INNER);
            _super.prototype.render.call(this, texture, x, y);
        };
        return BioGrenade;
    }(Ball));
    Balls.BioGrenade = BioGrenade;
    function onDeath(source, world) {
        var _loop_19 = function (i) {
            var pos = Random.inCircle(source.explosionRadius - 18).add(source.x, source.y);
            var smoke = world.addWorldObject(new Sprite({
                x: pos.x, y: pos.y,
                texture: lazy('bioGrenadeSmoke', function () { return new AnchoredTexture(Texture.filledCircle(24, 0x009F0F, 0.7), 0.5, 0.5); }),
                layer: Battle.Layers.fx,
                scale: 0,
            }));
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(Random.float(0, 0.1))];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.tween(0.1, smoke, 'scale', 0, Random.float(0.66, 1), Tween.Easing.OutCubic)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.tween(0.9, smoke, 'alpha', 1, 0, Tween.Easing.InQuad)];
                        case 3:
                            _a.sent();
                            smoke.kill();
                            return [2 /*return*/];
                    }
                });
            });
        };
        for (var i = 0; i < 5; i++) {
            _loop_19(i);
        }
        world.runScript(S.chain(S.wait(0.05), S.doOverTime(0.9, function (t) {
            var e_155, _a;
            var balls = getEnemies(world, source);
            try {
                for (var balls_16 = __values(balls), balls_16_1 = balls_16.next(); !balls_16_1.done; balls_16_1 = balls_16.next()) {
                    var ball = balls_16_1.value;
                    if (G.distance(source, ball) > source.explosionRadius + ball.physicalRadius)
                        continue;
                    if (ball.equipment && ball.equipment.equipmentType === 14)
                        continue;
                    ball.equip(14);
                    world.playSound('steal', { limit: 2 });
                }
            }
            catch (e_155_1) { e_155 = { error: e_155_1 }; }
            finally {
                try {
                    if (balls_16_1 && !balls_16_1.done && (_a = balls_16.return)) _a.call(balls_16);
                }
                finally { if (e_155) throw e_155.error; }
            }
        })));
    }
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var BlackHole = /** @class */ (function (_super) {
        __extends(BlackHole, _super);
        function BlackHole(config) {
            var _this = _super.call(this, 'balls/blackhole', 8, config) || this;
            _this.curl = _this.addChild(new Sprite({
                texture: 'blackholecurl',
                copyFromParent: ['layer'],
                angle: Random.angle(),
                effects: { pre: { filters: [new BallTeamColorFilter(Ball.getTeamColor(_this.team)), new Effects.Filters.Outline(0x000000, 1)] } },
            }));
            _this.overlay = _this.addChild(new Sprite({
                texture: 'blackholeoverlay',
                copyFromParent: ['layer'],
            }));
            _this.setMassScale(8);
            _this.addAbility('update', BlackHole.update);
            return _this;
        }
        BlackHole.prototype.getName = function () { return 'Black Hole'; };
        BlackHole.prototype.getDesc = function () {
            if (this.level === 1)
                return "Pulls all nearby balls toward it";
            if (this.level < 4)
                return "Pulls allies toward it with [lb]" + this.allyEffectivenessPercent + "%[/lb] force and enemies with [lb]" + this.enemyEffectivenessPercent + "%[/lb] force";
            return "Pulls allies toward it with [lb]" + this.allyEffectivenessPercent + "%[/lb] force";
        };
        BlackHole.prototype.getShopDmg = function () { return 1; };
        BlackHole.prototype.getShopHp = function () { return 8; };
        BlackHole.prototype.getCredits = function () { return [CreditsNames.EVERYONE]; };
        Object.defineProperty(BlackHole.prototype, "allyEffectivenessPercent", {
            get: function () { return 100 + 20 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BlackHole.prototype, "allyEffectiveness", {
            get: function () { return this.allyEffectivenessPercent / 100; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BlackHole.prototype, "enemyEffectivenessPercent", {
            get: function () {
                if (this.level === 1)
                    return 100;
                if (this.level === 2)
                    return 66;
                if (this.level === 3)
                    return 33;
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BlackHole.prototype, "enemyEffectiveness", {
            get: function () { return this.enemyEffectivenessPercent / 100; },
            enumerable: false,
            configurable: true
        });
        BlackHole.update = function (source, world) {
            var e_156, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var balls = world.select.typeAll(Ball).filter(function (ball) { return ball !== source
                && G.distance(ball, source) < 75 && source.isBallAffected(ball); });
            try {
                for (var balls_17 = __values(balls), balls_17_1 = balls_17.next(); !balls_17_1.done; balls_17_1 = balls_17.next()) {
                    var ball = balls_17_1.value;
                    //if (G.distance(ball, source) < ball.physicalRadius + source.physicalRadius + 4) return;
                    var effectiveness = ball.team === source.team
                        ? source.allyEffectiveness
                        : source.enemyEffectiveness;
                    var pullForce = ball.team === source.team
                        ? 4000
                        : 8000;
                    var magnitudeClamp = M.mapClamp(source.allyEffectiveness, 1, 2, 100, 2000);
                    var pullPos = ball.team === source.team
                        ? source.getPosition().add(ball.getPosition().subtract(source).setMagnitude(ball.physicalRadius + source.physicalRadius + 8))
                        : source.getPosition();
                    var force = PhysicsUtils.inverseLinear(pullPos.subtract(ball), pullForce * effectiveness).clampMagnitude(magnitudeClamp);
                    ball.v.add(force.scale(source.delta));
                }
            }
            catch (e_156_1) { e_156 = { error: e_156_1 }; }
            finally {
                try {
                    if (balls_17_1 && !balls_17_1.done && (_a = balls_17.return)) _a.call(balls_17);
                }
                finally { if (e_156) throw e_156.error; }
            }
        };
        BlackHole.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.curl.alpha = this.alpha;
            this.curl.scale = this.ballScale * this.moveScale;
            this.curl.vangle = this.state === Ball.States.BATTLE ? 120 : 45;
            World.Actions.orderWorldObjectBefore(this.curl, this);
            this.overlay.alpha = this.alpha;
            this.overlay.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.overlay, this);
        };
        BlackHole.prototype.changeHighlight = function (enabled, color, alpha) {
            if (color === undefined)
                color = this.curl.effects.outline.color;
            if (alpha === undefined)
                alpha = this.curl.effects.outline.alpha;
            this.curl.effects.outline.enabled = enabled;
            this.curl.effects.outline.color = color;
            this.curl.effects.outline.alpha = alpha;
        };
        BlackHole.prototype.onCollide = function (collideWith) {
            _super.prototype.onCollide.call(this, collideWith);
            if (collideWith.other.obj instanceof Ball && collideWith.other.obj.team !== this.team) {
                this.cooldownBall(collideWith.other.obj);
            }
        };
        BlackHole.prototype.isBallAffected = function (ball) {
            return this.getBallTimer(ball).done;
        };
        BlackHole.prototype.cooldownBall = function (ball) {
            this.getBallTimer(ball).reset();
        };
        BlackHole.prototype.getBallTimer = function (ball) {
            if (!ball.data.blackHoleTimer)
                ball.data.blackHoleTimer = ball.addTimer(0.2);
            return ball.data.blackHoleTimer;
        };
        return BlackHole;
    }(Ball));
    Balls.BlackHole = BlackHole;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Boomer = /** @class */ (function (_super) {
        __extends(Boomer, _super);
        function Boomer(config) {
            var _this = _super.call(this, 'balls/turret', 8, config) || this;
            _this.gun = _this.addChild(new Sprite({
                animations: [
                    Animations.fromSingleTexture({ name: 'idle', texture: 'boomergun/0' }),
                    Animations.fromTextureList({ name: 'shoot', textureRoot: 'boomergun', textures: [1, 2, 0], frameRate: 6, nextFrameRef: 'idle/0' }),
                ],
                copyFromParent: ['layer'],
            }));
            _this.shootTime = Ball.Random.float(1.5, 2);
            _this.addAbility('update', Boomer.update, { canActivateTwice: false });
            return _this;
        }
        Boomer.prototype.getName = function () { return 'Boomer'; };
        Boomer.prototype.getDesc = function () { return "Fires explosive mortars at random enemies for [r]" + this.explosionDmg + "<sword>/2s[/r]"; };
        Boomer.prototype.getShopDmg = function () { return 2; };
        Boomer.prototype.getShopHp = function () { return 5; };
        Boomer.prototype.getCredits = function () { return [CreditsNames.JUNJ, CreditsNames.CONFLICTING_THEMES]; };
        Object.defineProperty(Boomer.prototype, "explosionRadius", {
            get: function () { return 50 * Math.exp(0.25 * this.level) / (Math.exp(0.25 * this.level) + 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Boomer.prototype, "explosionDmg", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Boomer.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.gun.alpha = this.alpha;
            this.gun.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.gun, this);
        };
        Boomer.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            source.shootTime += source.delta;
            while (source.shootTime >= 2) {
                Boomer.shoot(source, world);
                if (source.shouldActivateAbilityTwice()) {
                    source.doAfterTime(0.2, function () { return Boomer.shoot(source, world); });
                }
                source.shootTime -= 2;
            }
        };
        Boomer.shoot = function (source, world) {
            var enemyBalls = getEnemies(world, source);
            if (enemyBalls.length === 0)
                return;
            var target = Ball.Random.element(enemyBalls);
            world.addWorldObject(new BoomerMortar(target.x, target.y, source.x, source.y, source.explosionRadius, source.explosionDmg, source));
            world.playSound('shoot', { humanized: false }).speed = Random.float(0.75, 0.95);
            source.gun.playAnimation('shoot');
            source.didShootProjectile(1);
        };
        return Boomer;
    }(Ball));
    Balls.Boomer = Boomer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Booster = /** @class */ (function (_super) {
        __extends(Booster, _super);
        function Booster(config) {
            var _this = _super.call(this, 'balls/booster', 8, config) || this;
            _this.addAbility('onPreBattle', Booster.onPreBattle);
            _this.addAbility('onEnterBattle', Booster.onEnterBattle);
            return _this;
        }
        Booster.prototype.getName = function () { return 'Booster'; };
        Booster.prototype.getDesc = function () {
            if (this.starsToGive === 1)
                return "On enter battle, level-up a random ally";
            return "On enter battle, level-up [lb]" + this.starsToGive + "[/lb] random allies";
        };
        Booster.prototype.getShopDmg = function () { return 3; };
        Booster.prototype.getShopHp = function () { return 4; };
        Object.defineProperty(Booster.prototype, "starsToGive", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Booster.onPreBattle = function (source, world) {
            Booster.boostAlly(source, world);
        };
        Booster.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Booster.boostAlly(source, world);
        };
        Booster.boostAlly = function (source, world) {
            var e_157, _a;
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return;
            if (validBalls.length > source.starsToGive) {
                Ball.Random.shuffle(validBalls);
                validBalls = validBalls.slice(0, source.starsToGive);
            }
            var boosts = [];
            try {
                for (var validBalls_3 = __values(validBalls), validBalls_3_1 = validBalls_3.next(); !validBalls_3_1.done; validBalls_3_1 = validBalls_3.next()) {
                    var ball = validBalls_3_1.value;
                    var boost = world.addWorldObject(new HomingBoost(source.x, source.y, source, ball, 1, Ball.Random.float(0.2, 0.6), function (allies) { return Ball.Random.element(allies); }));
                    boosts.push(boost);
                }
            }
            catch (e_157_1) { e_157 = { error: e_157_1 }; }
            finally {
                try {
                    if (validBalls_3_1 && !validBalls_3_1.done && (_a = validBalls_3.return)) _a.call(validBalls_3);
                }
                finally { if (e_157) throw e_157.error; }
            }
            source.setPreBattleAbilityActiveCheck(function () { return boosts.some(function (boost) { return boost.world; }); });
        };
        return Booster;
    }(Ball));
    Balls.Booster = Booster;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var BowlingBall = /** @class */ (function (_super) {
        __extends(BowlingBall, _super);
        function BowlingBall(config) {
            var _this = _super.call(this, 'balls/bowlingball', 8, config) || this;
            _this.currentDmgGain = 0;
            _this.speedFlame = _this.addChild(new Sprite({
                texture: 'speedflame',
                tint: 0xFFAA00,
                alpha: 0,
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
            }));
            _this.addAbility('update', BowlingBall.update, { canActivateTwice: false, nullifyable: false });
            return _this;
        }
        BowlingBall.prototype.getName = function () { return 'Bowling Ball'; };
        BowlingBall.prototype.getDesc = function () { return "Gain mass and up to [r]" + this.maxDmgGain + "<sword>[/r] extra damage with speed"; };
        BowlingBall.prototype.getShopDmg = function () { return 1; };
        BowlingBall.prototype.getShopHp = function () { return 2; };
        BowlingBall.prototype.getCredits = function () { return [CreditsNames.EVERYONE]; };
        Object.defineProperty(BowlingBall.prototype, "maxDmgGain", {
            get: function () { return 1.5 + 1 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        BowlingBall.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            World.Actions.orderWorldObjectAfter(this.speedFlame, this);
            this.speedFlame.angle = this.angle;
            this.speedFlame.scaleY = M.lerp(1, 1.1, Tween.Easing.OscillateSine(8)(this.life.time));
        };
        BowlingBall.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE) {
                source.speedFlame.alpha = 0;
                source.speedFlame.setVisible(false);
                return;
            }
            var speedRatioClamped = M.clamp(source.getSpeed() / Ball.maxSpeedBase, 0, 1);
            if (source.isNullified())
                speedRatioClamped = 0;
            var targetDmgGain = M.lerp(0, source.maxDmgGain, speedRatioClamped);
            var dmgGainDiff = targetDmgGain - source.currentDmgGain;
            source.dmg += dmgGainDiff;
            source.currentDmgGain += dmgGainDiff;
            source.showDmgStat(dmgGainDiff, 0.5);
            source.setMassScale(M.lerp(1, 8, speedRatioClamped));
            var targetAlpha = M.lerp(0, 0.7, Tween.Easing.InQuad(speedRatioClamped));
            source.speedFlame.alpha = M.moveToClamp(source.speedFlame.alpha, targetAlpha, 1, source.delta);
            source.speedFlame.setVisible(!source.isInShop && !source.isInYourSquadScene);
        };
        return BowlingBall;
    }(Ball));
    Balls.BowlingBall = BowlingBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Buffer = /** @class */ (function (_super) {
        __extends(Buffer, _super);
        function Buffer(config) {
            var _this = _super.call(this, 'balls/buffer', 8, config) || this;
            _this.addAbility('onPreBattle', Buffer.onPreBattle);
            _this.addAbility('onEnterBattle', Buffer.onEnterBattle);
            return _this;
        }
        Buffer.prototype.getName = function () { return 'Buffer'; };
        Buffer.prototype.getDesc = function () { return "On enter battle, give the closest ally [r]+" + this.buffAmount + "<sword>[/r]"; };
        Buffer.prototype.getShopDmg = function () { return 2; };
        Buffer.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Buffer.prototype, "buffAmount", {
            get: function () { return 2 * this.level; },
            enumerable: false,
            configurable: true
        });
        Buffer.onPreBattle = function (source, world) {
            Buffer.giveBuff(source, world);
        };
        Buffer.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Buffer.giveBuff(source, world);
        };
        Buffer.giveBuff = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return;
            var closestBall = M.argmin(validBalls, function (ball) { return G.distance(source, ball); });
            var buff = world.addWorldObject(new Buff(source.x, source.y, closestBall, { dmg: source.buffAmount, hp: 0 }));
            source.setPreBattleAbilityActiveCheck(function () { return buff.world; });
        };
        return Buffer;
    }(Ball));
    Balls.Buffer = Buffer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Burner = /** @class */ (function (_super) {
        __extends(Burner, _super);
        function Burner(config) {
            var _this = _super.call(this, 'balls/burner', 8, config) || this;
            _this.addAbility('update', Burner.update);
            return _this;
        }
        Burner.prototype.getName = function () { return 'Burner'; };
        Burner.prototype.getDesc = function () {
            if (this.burnTime <= 0)
                return "Burn nearby enemies\n\nBurning balls take [r]1<sword>/s[/r]";
            return "Burn nearby enemies for [lb]" + this.burnTime + "s[/]\n\nBurning balls take [r]1<sword>/s[/r]";
        };
        Burner.prototype.getShopDmg = function () { return 1; };
        Burner.prototype.getShopHp = function () { return 6; };
        Burner.prototype.getCredits = function () { return [CreditsNames.C_RRY, CreditsNames.MATERWELONS]; };
        Object.defineProperty(Burner.prototype, "burnRadius", {
            get: function () { return this.physicalRadius - 8 + 96 * Math.exp(0.33 * this.level) / (Math.exp(0.33 * this.level) + 2); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Burner.prototype, "burnTime", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Burner.prototype.onAdd = function () {
            var _this = this;
            _super.prototype.onAdd.call(this);
            this.addChild(new AbilityRadius(this, function () { return _this.burnRadius; }, 0xFF2200, 0xFF8800, 0.6));
        };
        Burner.update = function (source, world) {
            var e_158, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            try {
                for (var enemyBalls_1 = __values(enemyBalls), enemyBalls_1_1 = enemyBalls_1.next(); !enemyBalls_1_1.done; enemyBalls_1_1 = enemyBalls_1.next()) {
                    var ball = enemyBalls_1_1.value;
                    if (G.distance(ball, source) < ball.radius + source.burnRadius) {
                        ball.addBurning(source, Math.max(source.burnTime, 0.1));
                    }
                }
            }
            catch (e_158_1) { e_158 = { error: e_158_1 }; }
            finally {
                try {
                    if (enemyBalls_1_1 && !enemyBalls_1_1.done && (_a = enemyBalls_1.return)) _a.call(enemyBalls_1);
                }
                finally { if (e_158) throw e_158.error; }
            }
        };
        return Burner;
    }(Ball));
    Balls.Burner = Burner;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Butterball = /** @class */ (function (_super) {
        __extends(Butterball, _super);
        function Butterball(config) {
            var _this = _super.call(this, 'balls/butterball', 8, config) || this;
            _this.butterTime = 0;
            _this.butterDistance = 0;
            _this.addAbility('onEnterBattle', Butterball.onEnterBattle);
            _this.addAbility('onDeath', Butterball.onDeath);
            _this.addAbility('update', Butterball.update, { canActivateTwice: false });
            return _this;
        }
        Butterball.prototype.getName = function () { return 'Butterball'; };
        Butterball.prototype.getDesc = function () { return "Leaves a trail of butter which allows allies to move up to [lb]" + this.moveSpeedFactorPercent + "%[/lb] max speed"; };
        Butterball.prototype.getShopDmg = function () { return 2; };
        Butterball.prototype.getShopHp = function () { return 5; };
        Butterball.prototype.getCredits = function () { return [CreditsNames.DEAGLE_EYE]; };
        Object.defineProperty(Butterball.prototype, "moveSpeedFactorPercent", {
            get: function () { return 120 + 20 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Butterball.prototype, "moveSpeedFactor", {
            get: function () { return this.moveSpeedFactorPercent / 100; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Butterball.prototype, "butterLife", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Butterball.prototype, "initialButterLife", {
            get: function () { return 4; },
            enumerable: false,
            configurable: true
        });
        Butterball.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            this.butterSystem = this.world.addWorldObject(new ButterSystem(this, this.moveSpeedFactor));
            if (this.world.getLayerByName(Battle.Layers.onground)) {
                this.butterSystem.layer = Battle.Layers.onground;
            }
        };
        Butterball.onEnterBattle = function (source, world) {
            Butterball.bigSplat(source, world);
        };
        Butterball.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            source.butterTime += source.delta;
            source.butterDistance += source.v.magnitude * source.delta;
            if (source.butterTime >= 0.3 || source.butterDistance >= source.physicalRadius) {
                source.butterTime = 0;
                source.butterDistance = 0;
                Butterball.addButterGlob(source);
            }
        };
        Butterball.onDeath = function (source, world) {
            Butterball.bigSplat(source, world);
        };
        Butterball.bigSplat = function (source, world) {
            var pos = source.getPosition();
            var bs = source.butterSystem;
            bs.addGlob(pos, 32, 0.3, source.initialButterLife, 0.7);
            world.runScript(S.schedule(0.03, S.call(function () { return bs.addGlob(Random.inCircle(20).add(pos), Random.int(8, 12), 0.2, source.initialButterLife, 0.5); }), 0.06, S.call(function () { return bs.addGlob(Random.inCircle(20).add(pos), Random.int(8, 12), 0.2, source.initialButterLife, 0.5); }), 0.09, S.call(function () { return bs.addGlob(Random.inCircle(20).add(pos), Random.int(8, 12), 0.2, source.initialButterLife, 0.5); }), 0.12, S.call(function () { return bs.addGlob(Random.inCircle(20).add(pos), Random.int(8, 12), 0.2, source.initialButterLife, 0.5); }), 0.15, S.call(function () { return bs.addGlob(Random.inCircle(20).add(pos), Random.int(8, 12), 0.2, source.initialButterLife, 0.5); })));
            world.playSound('slosh');
        };
        Butterball.addButterGlob = function (source) {
            if (!source.butterSystem)
                return;
            source.butterSystem.addGlob(source.getPosition(), Random.int(6, 8), 0, source.butterLife, 0.3);
        };
        return Butterball;
    }(Ball));
    Balls.Butterball = Butterball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Cannon = /** @class */ (function (_super) {
        __extends(Cannon, _super);
        function Cannon(config) {
            var _this = _super.call(this, 'balls/cannon', 11, config) || this;
            _this.gun = _this.addChild(new Sprite({
                texture: getCannonTextureForAngleFrame(0, 0),
                copyFromParent: ['layer'],
                data: {
                    gunAngle: 0,
                    gunTime: 0,
                },
                update: function () {
                    this.data.gunTime = M.clamp(this.data.gunTime - 2 * this.delta, 0, 1);
                    var frame = Math.ceil(M.lerp(2, 0, 1 - this.data.gunTime));
                    this.setTexture(getCannonTextureForAngleFrame(this.data.gunAngle, frame));
                },
            }));
            _this.shootTime = Ball.Random.float(_this.cannonballShootTime / 2, _this.cannonballShootTime);
            _this.addAbility('update', Cannon.update, { canActivateTwice: false });
            return _this;
        }
        Cannon.prototype.getName = function () { return 'Cannon'; };
        Cannon.prototype.getDesc = function () { return "Shoots a [r]" + this.cannonballDmg + "<sword>[/r] cannonball at the closest enemy every " + this.cannonballShootTime + "s"; };
        Cannon.prototype.getShopDmg = function () { return 3; };
        Cannon.prototype.getShopHp = function () { return 8; };
        Cannon.prototype.getCredits = function () { return [CreditsNames.JUNJ]; };
        Object.defineProperty(Cannon.prototype, "cannonballDmg", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cannon.prototype, "cannonballSpeed", {
            get: function () { return 300; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cannon.prototype, "cannonballShootTime", {
            get: function () { return 1.5; },
            enumerable: false,
            configurable: true
        });
        Cannon.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.gun.alpha = this.alpha;
            this.gun.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.gun, this);
        };
        Cannon.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            var target = M.argmin(enemyBalls, function (ball) { return G.distance(source, ball); });
            if (target) {
                var dx = target.x - source.x;
                var dy = target.y - source.y;
                var angle = M.atan2(dy, dx);
                source.gun.data.gunAngle = angle;
                if (world.select.raycast(source.x, source.y, dx, dy, [Battle.PhysicsGroups.walls]).some(function (coll) { return coll.t < 1; })) {
                    source.shootTime = M.clamp(source.shootTime, 0, source.cannonballShootTime - 0.5);
                }
            }
            source.shootTime += source.delta;
            while (source.shootTime >= source.cannonballShootTime) {
                Cannon.shoot(source, world);
                if (source.shouldActivateAbilityTwice()) {
                    source.doAfterTime(0.3, function () { return Cannon.shoot(source, world); });
                }
                source.shootTime -= source.cannonballShootTime;
            }
        };
        Cannon.shoot = function (source, world) {
            source.gun.data.gunTime = 1;
            var d = Vector2.fromPolar(28, source.gun.data.gunAngle);
            var p = source.getPosition().add(d);
            var cannonball = world.addWorldObject(squadBallToWorldBall({
                x: p.x,
                y: p.y,
                properties: {
                    type: 54,
                    level: 1,
                    damage: source.cannonballDmg,
                    health: 1,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            cannonball.v.set(d.withMagnitude(source.cannonballSpeed));
            cannonball.addBoostMaxSpeed(source, 'other', 3, 1, 1);
            cannonball.afterAddImmuneTime = 0;
            var puffd = d.normalized();
            world.addWorldObject(new BurstPuffSystem({
                x: source.x + 24 * source.ballScale * puffd.x,
                y: source.y + 24 * source.ballScale * puffd.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(2 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.3,
                    v: vec2(puffd.x * 50 + Random.float(-50, 50), puffd.y * 50 + Random.float(-50, 50)),
                    color: 0xFFFFFF,
                    radius: 2,
                    finalRadius: 0,
                }); },
            }));
            world.playSound('shootcannon');
            source.v.set(d.withMagnitude(-1.5 * Ball.maxSpeedBase));
            source.addBoostMaxSpeed(source, 'other', 1.5, 1.33, 0.5);
        };
        return Cannon;
    }(Ball));
    Balls.Cannon = Cannon;
    var CANNON_TEXTURE_N = 32;
    var cannonTextureCache = [];
    function getCannonTextureForAngleFrame(angle, frame) {
        if (cannonTextureCache.length === 0) {
            var turretBaseTexture_1 = AssetCache.getTexture('cannongunbase');
            var turretBarrelTextures_1 = A.range(3).map(function (i) { return AssetCache.getTexture("cannongunbarrel/" + i); });
            if (!turretBaseTexture_1 || turretBarrelTextures_1.some(function (t) { return !t; }))
                return undefined;
            var outlineFilter_1 = new Effects.Filters.Outline(0x000000, 1);
            var _loop_20 = function (i_1) {
                var angle_1 = i_1 * 360 / CANNON_TEXTURE_N;
                cannonTextureCache.push(A.range(3).map(function (i) {
                    var texture = new BasicTexture(44, 44, 'Cannon.getCannonTextureForAngleFrame');
                    turretBaseTexture_1.renderTo(texture, { x: 22, y: 22 });
                    turretBarrelTextures_1[i].renderTo(texture, { x: 22, y: 22, angle: angle_1 });
                    return new AnchoredTexture(texture.transform({ filters: [outlineFilter_1] }, 'Cannon.getCannonTextureForAngleFrame'), 0.5, 0.5);
                }));
            };
            for (var i_1 = 0; i_1 < CANNON_TEXTURE_N; i_1++) {
                _loop_20(i_1);
            }
        }
        var i = M.mod(Math.round(angle / 360 * CANNON_TEXTURE_N), CANNON_TEXTURE_N);
        return cannonTextureCache[i][frame];
    }
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Cannonball = /** @class */ (function (_super) {
        __extends(Cannonball, _super);
        function Cannonball(config) {
            var _this = _super.call(this, 'balls/cannonball', 8, config) || this;
            _this.setMassScale(4);
            return _this;
        }
        Cannonball.prototype.getName = function () { return 'Cannonball'; };
        Cannonball.prototype.getDesc = function () { return 'Heavy'; };
        Cannonball.prototype.getShopDmg = function () { return 1; };
        Cannonball.prototype.getShopHp = function () { return 1; };
        return Cannonball;
    }(Ball));
    Balls.Cannonball = Cannonball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Cheel = /** @class */ (function (_super) {
        __extends(Cheel, _super);
        function Cheel(config) {
            var _this = _super.call(this, 'balls/cheel', 8, config) || this;
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFF0000,
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
                scale: _this.auraRadius / 64,
            }));
            _this.dmgBank = 0;
            _this.addAbility('update', Cheel.update);
            _this.addAbility('onDeath', Cheel.onDeath);
            return _this;
        }
        Cheel.prototype.getName = function () { return 'Cheel'; };
        Cheel.prototype.getDesc = function () { return "Reduce nearby enemies' damage by [r]" + this.cheelRate + "<sword>/s[/r]. Give " + this.dmgMult + "x stolen damage to random allies as damage buffs"; };
        Cheel.prototype.getShopDmg = function () { return 1; };
        Cheel.prototype.getShopHp = function () { return 5; };
        Cheel.prototype.getCredits = function () { return [CreditsNames.TOMMYDOG145]; };
        Object.defineProperty(Cheel.prototype, "cheelRate", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cheel.prototype, "dmgMult", {
            get: function () { return 0.5 + this.level * 0.5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cheel.prototype, "auraRadius", {
            get: function () { return ((this.isInShop || this.isInYourSquadScene) && !this.isBeingMoved()) ? 20 : this.physicalRadius - 8 + 30 + 5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Cheel.prototype, "dmgDisperseBatch", {
            get: function () { return 1 / this.dmgMult; },
            enumerable: false,
            configurable: true
        });
        Cheel.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            this.aura.scale = M.lerpTime(this.aura.scale, this.auraRadius / 64, 100, this.delta);
            World.Actions.orderWorldObjectBefore(this.aura, this);
        };
        Cheel.prototype.setForInShop = function () {
            this.aura.scale = this.auraRadius / 64;
        };
        Cheel.update = function (source, world) {
            var e_159, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            try {
                for (var enemyBalls_2 = __values(enemyBalls), enemyBalls_2_1 = enemyBalls_2.next(); !enemyBalls_2_1.done; enemyBalls_2_1 = enemyBalls_2.next()) {
                    var ball = enemyBalls_2_1.value;
                    if (G.distance(ball, source) < ball.radius + source.auraRadius) {
                        var cheeledDmg = source.cheelRate * source.delta;
                        if (ball.dmg <= 0) {
                            ball.showDmgStat(-cheeledDmg, 0.5);
                            continue;
                        }
                        ball.cheelFor(cheeledDmg);
                        source.dmgBank += cheeledDmg;
                        ball.addLeeched(0.1);
                    }
                }
            }
            catch (e_159_1) { e_159 = { error: e_159_1 }; }
            finally {
                try {
                    if (enemyBalls_2_1 && !enemyBalls_2_1.done && (_a = enemyBalls_2.return)) _a.call(enemyBalls_2);
                }
                finally { if (e_159) throw e_159.error; }
            }
            Cheel.disperseDmg(source, world);
        };
        Cheel.onDeath = function (source, world) {
            Cheel.disperseDmg(source, world, 'onDeath');
        };
        Cheel.disperseDmg = function (source, world, onDeath) {
            while (source.dmgBank >= source.dmgDisperseBatch) {
                source.dmgBank -= source.dmgDisperseBatch;
                Cheel.disperseSingle(source, world, source.dmgDisperseBatch);
            }
            if (onDeath && source.dmgBank > 0) {
                Cheel.disperseSingle(source, world, source.dmgBank);
            }
        };
        Cheel.disperseSingle = function (source, world, amount) {
            var allyBalls = getAlliesNotSelf(world, source);
            var targetBall = Ball.Random.element(allyBalls);
            if (targetBall) {
                world.addWorldObject(new RandomBuff(source.x, source.y, source, targetBall, { dmg: amount * source.dmgMult, hp: 0 }, function (allies) { return Ball.Random.element(allies); }));
            }
        };
        return Cheel;
    }(Ball));
    Balls.Cheel = Cheel;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Coin = /** @class */ (function (_super) {
        __extends(Coin, _super);
        function Coin(config) {
            var _this = _super.call(this, 'balls/coin', 8, config) || this;
            _this.storesMoney = true;
            _this.addAbility('onStartShop', Coin.onStartShop);
            return _this;
        }
        Coin.prototype.getName = function () { return 'Coin'; };
        Coin.prototype.getDesc = function () { return "+[gold]<coin>" + Coin.getGoldGainPerRound(this) + "[/gold] per round while in your squad"; };
        Coin.prototype.getShopDmg = function () { return 1; };
        Coin.prototype.getShopHp = function () { return 3; };
        Coin.getGoldGainPerRound = function (source) { return source.level; };
        Coin.onStartShop = function (source, world) {
            source.properties.metadata.extraSellValue += Coin.getGoldGainPerRound(source);
            world.addWorldObject(new GainedGold(source.x, source.y - 8, Coin.getGoldGainPerRound(source), 'up'));
            world.playSound('buyball');
        };
        return Coin;
    }(Ball));
    Balls.Coin = Coin;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Commando = /** @class */ (function (_super) {
        __extends(Commando, _super);
        function Commando(config) {
            var _this = _super.call(this, 'balls/commando', 8, config) || this;
            _this.addAbility('onBallDie', Commando.onBallDie);
            return _this;
        }
        Commando.prototype.getName = function () { return 'Commando'; };
        Commando.prototype.getDesc = function () { return "Gain +" + buffText(this.buffDamage, this.buffHealth) + " when an ally dies"; };
        Commando.prototype.getShopDmg = function () { return 5; };
        Commando.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Commando.prototype, "buffDamage", {
            get: function () { return 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Commando.prototype, "buffHealth", {
            get: function () { return 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Commando.onBallDie = function (source, world, ball) {
            if (ball.team !== source.team)
                return;
            source.buff(source.buffDamage, source.buffHealth);
        };
        return Commando;
    }(Ball));
    Balls.Commando = Commando;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Crown = /** @class */ (function (_super) {
        __extends(Crown, _super);
        function Crown(config) {
            var _this = _super.call(this, 'balls/crown', 8, config) || this;
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFFDB00,
                blendMode: Texture.BlendModes.ADD,
                scale: _this.auraRadius / 64,
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onDeath', Crown.onDeath, { canActivateTwice: false });
            return _this;
        }
        Crown.prototype.getName = function () { return 'The Crown'; };
        Crown.prototype.getDesc = function () {
            if (this.plusStars === 0)
                return "On death, is [gold]permanently[/gold] replaced with the enemy that killed it";
            return "On death, is [gold]permanently[/gold] replaced with the enemy that killed it, +" + this.plusStars + "[gold]<star>[/gold]";
        };
        Crown.prototype.getShopDmg = function () { return 6; };
        Crown.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Crown.prototype, "plusStars", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Crown.prototype, "auraRadius", {
            get: function () { return this.physicalRadius + 6; },
            enumerable: false,
            configurable: true
        });
        Crown.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            this.aura.scale = this.auraRadius / 64;
            World.Actions.orderWorldObjectBefore(this.aura, this);
        };
        Crown.onDeath = function (source, world, killedBy) {
            if (!killedBy)
                return;
            if (source.team !== 'friend' || !youArePlaying(world))
                return;
            if (source.squadIndexReference < 0 || source.squadIndexReference >= GAME_DATA.squad.balls.length)
                return;
            if (killedBy.team === source.team)
                return;
            var metadata = O.deepClone(killedBy.properties.metadata);
            metadata.obtainedWithCrown = true;
            var squadBall = GAME_DATA.squad.balls[source.squadIndexReference];
            GAME_DATA.squad.balls[source.squadIndexReference] = {
                x: squadBall.x,
                y: squadBall.y,
                properties: {
                    type: killedBy.properties.type,
                    level: killedBy.level + source.plusStars,
                    damage: squadBall.properties.damage,
                    health: squadBall.properties.health,
                    equipment: killedBy.equipment ? killedBy.equipment.equipmentType : -1,
                    metadata: metadata,
                }
            };
            if (_.includes(Crown.USELESS_BALLS, killedBy.properties.type)) {
                USELESS_CROWN_REPLACEMENT = true;
            }
        };
        Crown.USELESS_BALLS = [
            0,
            3,
            16,
            20,
            31,
            54,
        ];
        return Crown;
    }(Ball));
    Balls.Crown = Crown;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Crusher = /** @class */ (function (_super) {
        __extends(Crusher, _super);
        function Crusher(config) {
            var _this = _super.call(this, 'balls/crusher', 8, config) || this;
            _this.cooldown = _this.addTimer(0.1);
            _this.cooldown.finish();
            _this.addAbility('onCollideWithEnemyPostDamage', Crusher.onCollideWithEnemyPostDamage, { canActivateTwice: false });
            return _this;
        }
        Crusher.prototype.getName = function () { return 'Crusher'; };
        Crusher.prototype.getDesc = function () { return "On collide with enemy, gain [r]" + this.dmgGain + "<sword>[/r]"; };
        Crusher.prototype.getShopDmg = function () { return 1; };
        Crusher.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Crusher.prototype, "dmgGain", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Crusher.onCollideWithEnemyPostDamage = function (source, world, collideWith, damage) {
            if (!source.cooldown.done)
                return;
            Crusher.buff(source);
            if (source.shouldActivateAbilityTwice()) {
                Crusher.buff(source);
            }
            source.cooldown.reset();
        };
        Crusher.buff = function (source) {
            source.buff(source.dmgGain, 0);
        };
        return Crusher;
    }(Ball));
    Balls.Crusher = Crusher;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var CrystalBall = /** @class */ (function (_super) {
        __extends(CrystalBall, _super);
        function CrystalBall(config) {
            var _this = _super.call(this, 'balls/crystalball', 8, config) || this;
            _this.addAbility('onSell', CrystalBall.onSell);
            return _this;
        }
        CrystalBall.prototype.getName = function () { return 'Crystal Ball'; };
        CrystalBall.prototype.getDesc = function () { return "On sell, give\n" + buffText(CrystalBall.getBuffAmount(this), CrystalBall.getBuffAmount(this)) + " to a random ally"; };
        CrystalBall.prototype.getShopDmg = function () { return 2; };
        CrystalBall.prototype.getShopHp = function () { return 4; };
        CrystalBall.getBuffAmount = function (source) { return source.level; };
        CrystalBall.onSell = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: CrystalBall.getBuffAmount(source), hp: CrystalBall.getBuffAmount(source) }, function (_) { return Ball.Random.element(validBalls); }));
        };
        return CrystalBall;
    }(Ball));
    Balls.CrystalBall = CrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var CueBall = /** @class */ (function (_super) {
        __extends(CueBall, _super);
        function CueBall(config) {
            var _this = _super.call(this, 'balls/cueball', 8, config) || this;
            _this.cue = _this.addChild(new Cue(function () { return CueBall.getClosestAlly(_this, _this.world); }));
            _this.addAbility('onEnterBattle', CueBall.onEnterBattle, { canActivateTwice: false });
            return _this;
        }
        CueBall.prototype.getName = function () { return 'Cue Ball'; };
        CueBall.prototype.getDesc = function () { return "On enter battle, launch toward the closest ally. Bounces allies up to [lb]" + this.bounceSpeedLimitPercent + "%[/lb] max speed on collision"; };
        CueBall.prototype.getShopDmg = function () { return 3; };
        CueBall.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(CueBall.prototype, "extraMomentumFactor", {
            get: function () { return 1 + 0.2 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CueBall.prototype, "bounceSpeedLimitPercent", {
            get: function () { return 100 + 20 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CueBall.prototype, "bounceSpeedLimit", {
            get: function () { return this.bounceSpeedLimitPercent / 100; },
            enumerable: false,
            configurable: true
        });
        CueBall.prototype.onCollide = function (collision) {
            _super.prototype.onCollide.call(this, collision);
            if (collision.other.obj instanceof Ball && collision.other.obj.team === this.team) {
                collision.other.obj.v.x += (collision.other.post_vx - collision.other.pre_vx) * this.extraMomentumFactor;
                collision.other.obj.v.y += (collision.other.post_vy - collision.other.pre_vy) * this.extraMomentumFactor;
                collision.other.obj.addBoostMaxSpeed(this, 'other', this.bounceSpeedLimit, this.bounceSpeedLimit, 1);
            }
        };
        CueBall.prototype.canAccelerateOnEnter = function () {
            return !!CueBall.getClosestAlly(this, this.world);
        };
        CueBall.onEnterBattle = function (source, world) {
            CueBall.doBoost(source, world);
            if (source.shouldActivateAbilityTwice()) {
                source.doAfterTime(0.5, function () { return CueBall.doBoost(source, world); });
            }
        };
        CueBall.doBoost = function (source, world) {
            if (!source.canAccelerateOnEnter())
                return;
            var closestBall = CueBall.getClosestAlly(source, world);
            if (!closestBall)
                return;
            var initialSpeed = isFinite(source.maxSpeed) ? source.maxSpeed : 150;
            var f = closestBall.getPosition().subtract(source).normalize();
            source.v.set(f).scale(initialSpeed);
            world.playSound('cuehit', { humanized: false, limit: 2 });
            world.addWorldObject(new BurstPuffSystem({
                x: source.x,
                y: source.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(6 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.5,
                    p: Random.inCircle(5),
                    v: f.scaled(-100).add(Random.onCircle(30)),
                    color: 0xFFFFFF,
                    radius: 4,
                    finalRadius: 0,
                }); },
            }));
            if (source.cue) {
                source.removeChildKeepWorldPosition(source.cue);
                source.cue.fire();
                source.cue = undefined;
            }
        };
        CueBall.getClosestAlly = function (source, world) {
            if (!world)
                return undefined;
            if (source.isInShop || source.isInYourSquadScene)
                return undefined;
            var ballMover = world.select.type(BallMover, false);
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop && (ballMover === null || ballMover === void 0 ? void 0 : ballMover.movingThing) !== ball; });
            return M.argmin(validBalls, function (ball) { return G.distance(source, ball); });
        };
        return CueBall;
    }(Ball));
    Balls.CueBall = CueBall;
    var Cue = /** @class */ (function (_super) {
        __extends(Cue, _super);
        function Cue(getTarget) {
            var _this = _super.call(this, {
                texture: 'cue',
                alpha: 0,
                effects: { outline: { color: 0x000000 } },
            }) || this;
            _this.getTarget = getTarget;
            _this.updatePosition();
            _this.updateAlpha();
            return _this;
        }
        Object.defineProperty(Cue.prototype, "parentCueBall", {
            get: function () { return this.parent instanceof CueBall ? this.parent : undefined; },
            enumerable: false,
            configurable: true
        });
        Cue.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            if (this.world.getLayerByName(Battle.Layers.fx)) {
                this.layer = Battle.Layers.fx;
            }
        };
        Cue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.updatePosition();
            this.updateAlpha();
        };
        Cue.prototype.updatePosition = function () {
            var parentBall = this.parentCueBall;
            var target = this.getTarget();
            if (!parentBall || !target)
                return;
            var angle = G.angle(parentBall, target) + 180;
            var distance = parentBall.visibleRadius + M.lerp(4, 7, Tween.Easing.OscillateSine(2)(this.life.time));
            this.localx = M.cos(angle) * distance;
            this.localy = M.sin(angle) * distance;
            this.angle = angle;
        };
        Cue.prototype.updateAlpha = function () {
            var parentBall = this.parentCueBall;
            var targetAlpha = (parentBall === null || parentBall === void 0 ? void 0 : parentBall.canAccelerateOnEnter()) && (parentBall === null || parentBall === void 0 ? void 0 : parentBall.state) !== Ball.States.BATTLE ? 1 : 0;
            this.alpha = M.moveToClamp(this.alpha, targetAlpha, 4, this.delta);
            this.effects.outline.alpha = this.alpha;
        };
        Cue.prototype.fire = function () {
            var cue = this;
            var targetPos = Vector2.fromPolar(30, this.angle + 180).add(cue);
            this.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, [
                                S.tweenPt(0.15, cue, cue, targetPos, Tween.Easing.OutQuad),
                                S.tween(0.25, cue, 'alpha', 1, 0, Tween.Easing.InQuad),
                            ]];
                        case 1:
                            _a.sent();
                            cue.kill();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return Cue;
    }(Sprite));
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var DeathStar = /** @class */ (function (_super) {
        __extends(DeathStar, _super);
        function DeathStar(config) {
            var _this = _super.call(this, 'balls/deathstar', 16, config) || this;
            _this.mass = 8;
            _this.addAbility('onBallShootProjectile', DeathStar.onBallShootProjectile);
            return _this;
        }
        DeathStar.prototype.getName = function () { return 'Death Star'; };
        DeathStar.prototype.getDesc = function () { return "When an ally shoots a damaging projectile, [lb]" + this.shootChancePercent + "%[/lb] chance to shoot a [r]1<sword>[/r] homing spike at a random enemy"; };
        DeathStar.prototype.getShopDmg = function () { return 4; };
        DeathStar.prototype.getShopHp = function () { return 9; };
        Object.defineProperty(DeathStar.prototype, "shootChancePercent", {
            get: function () { return Math.min(5 + 15 * this.level, 80); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DeathStar.prototype, "shootChance", {
            get: function () { return this.shootChancePercent / 100; },
            enumerable: false,
            configurable: true
        });
        DeathStar.onBallShootProjectile = function (source, world, ball, hitCount) {
            var e_160, _a;
            if (ball.team !== source.team)
                return;
            if (ball instanceof DeathStar)
                return;
            var spikesShot = 0;
            for (var i = 0; i < hitCount; i++) {
                if (Ball.Random.boolean(source.shootChance))
                    spikesShot++;
            }
            if (spikesShot > 0) {
                var enemies = getEnemies(world, source);
                if (enemies.length === 0)
                    return;
                var spikeCounts = M.batch(spikesShot, 3);
                var randomBall = Ball.Random.element(enemies);
                try {
                    for (var spikeCounts_1 = __values(spikeCounts), spikeCounts_1_1 = spikeCounts_1.next(); !spikeCounts_1_1.done; spikeCounts_1_1 = spikeCounts_1.next()) {
                        var count = spikeCounts_1_1.value;
                        world.addWorldObject(new HomingSpike(source.x, source.y, source, randomBall, 1, count, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
                        source.didShootProjectile(count);
                    }
                }
                catch (e_160_1) { e_160 = { error: e_160_1 }; }
                finally {
                    try {
                        if (spikeCounts_1_1 && !spikeCounts_1_1.done && (_a = spikeCounts_1.return)) _a.call(spikeCounts_1);
                    }
                    finally { if (e_160) throw e_160.error; }
                }
            }
        };
        return DeathStar;
    }(Ball));
    Balls.DeathStar = DeathStar;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Devil = /** @class */ (function (_super) {
        __extends(Devil, _super);
        function Devil(config) {
            var _this = _super.call(this, 'balls/devil', 8, config) || this;
            _this.horns = _this.addChild(new Sprite({
                texture: 'devilhorns',
                tint: Ball.getTeamColor(config.team),
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onDeath', Devil.onDeath);
            return _this;
        }
        Devil.prototype.getName = function () { return 'Devil'; };
        Devil.prototype.getDesc = function () { return "On death, shoot a [r]" + this.spikeDamage + "<sword>[/r] homing spike at every enemy"; };
        Devil.prototype.getShopDmg = function () { return 5; };
        Devil.prototype.getShopHp = function () { return 3; };
        Devil.prototype.getCredits = function () { return [CreditsNames.FIREBALLME, CreditsNames.NEPDEP]; };
        Object.defineProperty(Devil.prototype, "spikeDamage", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Devil.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.horns.alpha = this.alpha;
            this.horns.scale = this.ballScale * this.moveScale;
            this.horns.angle = this.angle;
            this.horns.effects.outline.color = this.effects.outline.color;
            this.horns.effects.outline.enabled = this.effects.outline.enabled;
            World.Actions.orderWorldObjectAfter(this.horns, this);
        };
        Devil.onDeath = function (source, world, killedBy) {
            var e_161, _a;
            var enemies = getEnemies(world, source);
            if (enemies.length === 0)
                return;
            try {
                for (var enemies_2 = __values(enemies), enemies_2_1 = enemies_2.next(); !enemies_2_1.done; enemies_2_1 = enemies_2.next()) {
                    var enemy = enemies_2_1.value;
                    world.addWorldObject(new HomingSpike(source.x, source.y, source, enemy, source.spikeDamage, 1, function (_) { return undefined; }));
                    source.didShootProjectile(1);
                }
            }
            catch (e_161_1) { e_161 = { error: e_161_1 }; }
            finally {
                try {
                    if (enemies_2_1 && !enemies_2_1.done && (_a = enemies_2.return)) _a.call(enemies_2);
                }
                finally { if (e_161) throw e_161.error; }
            }
        };
        return Devil;
    }(Ball));
    Balls.Devil = Devil;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Dolly = /** @class */ (function (_super) {
        __extends(Dolly, _super);
        function Dolly(config) {
            var _this = _super.call(this, 'balls/dolly', 8, config) || this;
            _this.shouldActivateAbility = true;
            _this.addAbility('onPreBattle', Dolly.onPreBattle, { canActivateTwice: false });
            _this.addAbility('onEnterBattle', Dolly.onEnterBattle, { canActivateTwice: false });
            return _this;
        }
        Dolly.prototype.getName = function () { return 'Dolly'; };
        Dolly.prototype.getDesc = function () { return "At the start of battle, summon a " + buffText(this.power, this.power) + " Dolly for every unfilled ball spot"; };
        Dolly.prototype.getShopDmg = function () { return 3; };
        Dolly.prototype.getShopHp = function () { return 3; };
        Dolly.prototype.getCredits = function () { return [CreditsNames.XIAOSLOTH]; };
        Object.defineProperty(Dolly.prototype, "power", {
            get: function () { return 3 + this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Dolly.onPreBattle = function (source, world) {
            Dolly.fillSquad(source, world);
        };
        Dolly.onEnterBattle = function (source, world) {
            var battleTimer = world.select.type(BattleTimer, false);
            var timeInBattle = battleTimer ? battleTimer.battleTime : 0;
            if (timeInBattle > 0.3 || source.hasActivatedAbility('onPreBattle'))
                return;
            Dolly.fillSquad(source, world);
        };
        Dolly.fillSquad = function (source, world) {
            if (!source.shouldActivateAbility)
                return;
            var script = source.runScript(function () {
                var unfilledAllySlots, _loop_21, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            unfilledAllySlots = GET_MAX_SQUAD_SIZE() - source.getSquadSize(world);
                            _loop_21 = function (i) {
                                var allies, allyAveragePos, side, location_1, locations, location2, d, locations_1, locations_1_1, loc;
                                var e_162, _a;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            allies = getAllies(world, source);
                                            allyAveragePos = G.average.apply(G, __spread(allies));
                                            side = (allyAveragePos && allyAveragePos.x < world.width / 2) ? 'left' : 'right';
                                            location_1 = Locations.getRandomLocation(source, world, side, function (location) {
                                                if (allies.some(function (ally) { return G.distance(ally, location) < ally.physicalRadius + source.physicalRadius + 4; }))
                                                    return -Infinity;
                                                return -G.distance(location, source);
                                            });
                                            locations = [location_1];
                                            if (source.shouldActivateAbilityTwice()) {
                                                location2 = vec2(location_1);
                                                d = Ball.Random.onCircle(8);
                                                location_1.add(d);
                                                location2.add(d.scale(-1));
                                                locations.push(location2);
                                            }
                                            try {
                                                for (locations_1 = (e_162 = void 0, __values(locations)), locations_1_1 = locations_1.next(); !locations_1_1.done; locations_1_1 = locations_1.next()) {
                                                    loc = locations_1_1.value;
                                                    Dolly.summonClone(source, world, loc);
                                                }
                                            }
                                            catch (e_162_1) { e_162 = { error: e_162_1 }; }
                                            finally {
                                                try {
                                                    if (locations_1_1 && !locations_1_1.done && (_a = locations_1.return)) _a.call(locations_1);
                                                }
                                                finally { if (e_162) throw e_162.error; }
                                            }
                                            world.addWorldObject(newPuff(location_1.x, location_1.y, Battle.Layers.fx, 'small'));
                                            source.flash(0xFFFFFF, 1);
                                            world.playSound('sellball');
                                            return [4 /*yield*/, S.wait(0.15)];
                                        case 1:
                                            _b.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < unfilledAllySlots)) return [3 /*break*/, 4];
                            return [5 /*yield**/, _loop_21(i)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
            source.setPreBattleAbilityActiveCheck(function () { return !script.done; });
        };
        Dolly.summonClone = function (source, world, location) {
            world.addWorldObject(squadBallToWorldBall({
                x: location.x,
                y: location.y,
                properties: {
                    type: 137,
                    level: 1,
                    damage: source.power,
                    health: source.power,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            if (source instanceof Dolly) {
                source.shouldActivateAbility = false;
            }
        };
        return Dolly;
    }(Ball));
    Balls.Dolly = Dolly;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Dove = /** @class */ (function (_super) {
        __extends(Dove, _super);
        function Dove(config) {
            var _this = _super.call(this, 'balls/dove', 8, config) || this;
            _this.seenOtherAllyDovesThisRound = false;
            _this.addAbility('onStartShop', Dove.onStartShop, { nullifyable: false, canActivateTwice: false });
            return _this;
        }
        Dove.prototype.getName = function () { return 'Dove'; };
        Dove.prototype.getDesc = function () { return "On your next loss, you do not lose [r]<heart>[/r]\n\nPermanently removed from your squad on use"; };
        Dove.prototype.getShopDmg = function () { return 3; };
        Dove.prototype.getShopHp = function () { return 3; };
        Dove.prototype.getCredits = function () { return [CreditsNames.FIREBALLME]; };
        Dove.onStartShop = function (source, world) {
            var otherUnseenDovesInSquad = getAlliesNotSelf(world, source).filter(function (ball) { return ball instanceof Dove && !ball.isInShop && !ball.seenOtherAllyDovesThisRound; });
            if (otherUnseenDovesInSquad.length > 0) {
                source.seenOtherAllyDovesThisRound = true;
            }
            if (getLastRoundResult() === 'loss' && !source.seenOtherAllyDovesThisRound) {
                addBallTypeForAlmanacWin(127);
                ShopActions.removeBallFromSquad(source);
                source.kill();
            }
        };
        return Dove;
    }(Ball));
    Balls.Dove = Dove;
})(Balls || (Balls = {}));
/// <reference path="ball.ts" />
var Balls;
(function (Balls) {
    var EightBall = /** @class */ (function (_super) {
        __extends(EightBall, _super);
        function EightBall(config) {
            var _this = _super.call(this, 'balls/8ball', 8, config) || this;
            _this.addAbility('onSurviveBattle', function (source, world) {
                addStartShopEffect({
                    type: 'gold',
                    sourceSquadIndex: source.squadIndexReference,
                    gold: source.goldGain,
                });
            });
            return _this;
        }
        EightBall.prototype.getName = function () { return '8 Ball'; };
        EightBall.prototype.getDesc = function () { return "Gain [gold]<coin>" + this.goldGain + "[/gold] if it survives a battle"; };
        EightBall.prototype.getShopDmg = function () { return 1; };
        EightBall.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(EightBall.prototype, "goldGain", {
            get: function () { return 2 + this.level; },
            enumerable: false,
            configurable: true
        });
        return EightBall;
    }(Ball));
    Balls.EightBall = EightBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var FireFighter = /** @class */ (function (_super) {
        __extends(FireFighter, _super);
        function FireFighter(config) {
            var _this = _super.call(this, 'balls/firefighter', 8, config) || this;
            _this.shootTime = 0;
            _this.addAbility('update', FireFighter.update, { canActivateTwice: false });
            return _this;
        }
        FireFighter.prototype.getName = function () { return 'Fire Fighter'; };
        FireFighter.prototype.getDesc = function () { return "Every " + this.maxShootTime + "s, shoot a [r]" + this.spikeDmg + "<sword>[/r] homing spike at every burning enemy"; };
        FireFighter.prototype.getShopDmg = function () { return 3; };
        FireFighter.prototype.getShopHp = function () { return 8; };
        Object.defineProperty(FireFighter.prototype, "maxShootTime", {
            get: function () { return 0.5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FireFighter.prototype, "spikeDmg", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        FireFighter.update = function (source, world) {
            if (source.state !== Ball.States.PRE_BATTLE && source.state !== Ball.States.BATTLE)
                return;
            source.shootTime += source.delta;
            if (source.shootTime >= source.maxShootTime) {
                FireFighter.shootEnemies(source, world);
                if (source.shouldActivateAbilityTwice()) {
                    FireFighter.shootEnemies(source, world);
                }
                source.shootTime -= source.maxShootTime;
            }
        };
        FireFighter.shootEnemies = function (source, world) {
            var e_163, _a;
            var validEnemies = getEnemies(world, source).filter(function (enemy) { return enemy.isBurning(); });
            try {
                for (var validEnemies_1 = __values(validEnemies), validEnemies_1_1 = validEnemies_1.next(); !validEnemies_1_1.done; validEnemies_1_1 = validEnemies_1.next()) {
                    var enemy = validEnemies_1_1.value;
                    world.addWorldObject(new HomingSpike(source.x, source.y, source, enemy, source.spikeDmg, 1, function (enemyBalls) { return undefined; }));
                    source.didShootProjectile(1);
                }
            }
            catch (e_163_1) { e_163 = { error: e_163_1 }; }
            finally {
                try {
                    if (validEnemies_1_1 && !validEnemies_1_1.done && (_a = validEnemies_1.return)) _a.call(validEnemies_1);
                }
                finally { if (e_163) throw e_163.error; }
            }
        };
        return FireFighter;
    }(Ball));
    Balls.FireFighter = FireFighter;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Fireball = /** @class */ (function (_super) {
        __extends(Fireball, _super);
        function Fireball(config) {
            var _this = _super.call(this, 'balls/fireball', 8, config) || this;
            var outlineI = _.findLastIndex(_this.effects.pre.filters, function (f) { return f instanceof Effects.Filters.Outline; });
            if (outlineI >= 0) {
                _this.effects.pre.filters[outlineI] = new Effects.Filters.Outline(Ball.getDarkTeamColor(_this.team), 1);
            }
            _this.fireFilter = new FireFilter();
            _this.fire = _this.addChild(new Sprite({
                texture: new AnchoredTexture(Texture.filledRect(66, 66, 0xFF8F00), 0.5, 0.5),
                effects: { pre: { filters: [_this.fireFilter] } },
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onCollideWithEnemyPostDamage', Fireball.onCollideWithEnemyPostDamage);
            return _this;
        }
        Fireball.prototype.getName = function () { return 'Fireball'; };
        Fireball.prototype.getDesc = function () { return "On collision, light enemies on fire for [lb]" + this.burnTime + "s[/lb]\n\nBurning balls take [r]1<sword>/s[/r]"; };
        Fireball.prototype.getShopDmg = function () { return 0; };
        Fireball.prototype.getShopHp = function () { return 3; };
        Fireball.prototype.getShopRelativePosition = function () { return vec2(0, 3); };
        Fireball.prototype.getCredits = function () { return [CreditsNames.RATIS, CreditsNames.WALUX]; };
        Object.defineProperty(Fireball.prototype, "burnTime", {
            get: function () { return 1 + this.properties.level; },
            enumerable: false,
            configurable: true
        });
        Fireball.prototype.updateBattle = function () {
            _super.prototype.updateBattle.call(this);
            var targetAngle = 180 - this.angle;
            var targetLength = M.mapClamp(this.getSpeed(), 0, Ball.maxSpeedBase, 0, 2);
            var angleDiff = M.angleDiff(this.fireFilter.angle, targetAngle);
            targetLength = M.mapClamp(angleDiff, 0, 90, targetLength, 0);
            this.fireFilter.angle = M.moveToAngleClamp(this.fireFilter.angle, targetAngle, 480, this.delta);
            this.fireFilter.length = M.moveToClamp(this.fireFilter.length, targetLength, 8, this.delta);
        };
        Fireball.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.fire.alpha = this.alpha;
            this.fire.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectBefore(this.fire, this);
        };
        Fireball.prototype.onCollide = function (collision) {
            _super.prototype.onCollide.call(this, collision);
            if (this.state === Ball.States.BATTLE) {
                this.fireFilter.length = 0;
            }
        };
        Fireball.onCollideWithEnemyPostDamage = function (source, world, collideWith, damage) {
            collideWith.addBurning(source, source.burnTime);
        };
        return Fireball;
    }(Ball));
    Balls.Fireball = Fireball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Fragmenter = /** @class */ (function (_super) {
        __extends(Fragmenter, _super);
        function Fragmenter(config) {
            var _this = _super.call(this, 'balls/fragmenter', 8, config) || this;
            _this.addAbility('onDeath', Fragmenter.onDeath);
            return _this;
        }
        Fragmenter.prototype.getName = function () { return 'Fragmenter'; };
        Fragmenter.prototype.getDesc = function () {
            return "On death, shoot " + this.spikes + " spikes in a circle that deal [r]" + this.spikeDamage + "<sword>[/r] each";
        };
        Fragmenter.prototype.getShopDmg = function () { return 1; };
        Fragmenter.prototype.getShopHp = function () { return 3; };
        Fragmenter.prototype.getCredits = function () { return [CreditsNames.NEPDEP, CreditsNames.FLAREDESEL]; };
        Object.defineProperty(Fragmenter.prototype, "spikes", {
            get: function () { return 12; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Fragmenter.prototype, "spikeDamage", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Fragmenter.onDeath = function (source, world, killedBy) {
            var spikeCounts = M.batch(source.spikes, 20);
            for (var i = 0; i < spikeCounts.length; i++) {
                var angle = (i + 0.5) / spikeCounts.length * 360;
                world.addWorldObject(new Spike(source.x, source.y, Vector2.fromPolar(150, angle), source, source.spikeDamage, spikeCounts[i]));
                source.didShootProjectile(spikeCounts[i]);
            }
            world.playSound('spike');
        };
        return Fragmenter;
    }(Ball));
    Balls.Fragmenter = Fragmenter;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Gacha = /** @class */ (function (_super) {
        __extends(Gacha, _super);
        function Gacha(config) {
            var _this = _super.call(this, 'balls/gacha', 8, config) || this;
            _this.addAbility('onDeath', Gacha.onDeath);
            return _this;
        }
        Gacha.prototype.getName = function () { return 'Gacha Ball'; };
        Gacha.prototype.getDesc = function () {
            if (this.plusStars === 0)
                return "On death, summon a random " + buffText(this.newBallPower, this.newBallPower) + " ball from the shop. What's it gonna be??";
            return "On death, summon a random " + buffText(this.newBallPower, this.newBallPower) + " ball from the shop, +[gold]" + this.plusStars + "<star>[/gold]";
        };
        Gacha.prototype.getShopDmg = function () { return 2; };
        Gacha.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(Gacha.prototype, "newBallPower", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Gacha.prototype, "plusStars", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Gacha.onDeath = function (source, world, killedBy) {
            var validBallTypes = getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly)
                .filter(function (type) { return !_.contains(Gacha.USELESS_BALL_TYPES, type); });
            var ballType = Ball.Random.element(validBallTypes);
            var level = getBallTypeLevelForRound(ballType, GAME_DATA.round) + source.plusStars;
            world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: ballType,
                    level: level,
                    damage: source.newBallPower,
                    health: source.newBallPower,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            world.playSound('buyball');
        };
        Gacha.USELESS_BALL_TYPES = [
            6,
            9,
            10,
            24,
            25,
            32,
            35,
            37,
            38,
            39,
            47,
            48,
            101,
            114,
            116,
            126,
            127,
            133,
            134,
            135,
            136,
            137,
            139,
            140,
            142,
        ];
        return Gacha;
    }(Ball));
    Balls.Gacha = Gacha;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Gladiator = /** @class */ (function (_super) {
        __extends(Gladiator, _super);
        function Gladiator(config) {
            var _this = _super.call(this, 'balls/gladiator', 8, config) || this;
            _this.shieldsGained = 0;
            _this.addAbility('onKill', Gladiator.onKill, { canActivateTwice: false });
            return _this;
        }
        Gladiator.prototype.getName = function () { return 'Gladiator'; };
        Gladiator.prototype.getDesc = function () {
            if (this.totalShields === 1)
                return "Gains a Shield after its [lb]first[/lb] kill";
            return "Gains a Shield after each of its first [lb]" + this.totalShields + "[/lb] kills";
        };
        Gladiator.prototype.getShopDmg = function () { return 5; };
        Gladiator.prototype.getShopHp = function () { return 4; };
        Gladiator.prototype.getCredits = function () { return [CreditsNames.BALLAM]; };
        Object.defineProperty(Gladiator.prototype, "totalShields", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Gladiator.onKill = function (source, world, killed) {
            source.runScript(S.chain(S.yield(), S.call(function () {
                if (source.shieldsGained < source.totalShields) {
                    source.equip(0);
                    source.shieldsGained++;
                    world.playSound('buyball', { limit: 2 });
                }
            })));
        };
        return Gladiator;
    }(Ball));
    Balls.Gladiator = Gladiator;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var GlitchedBall = /** @class */ (function (_super) {
        __extends(GlitchedBall, _super);
        function GlitchedBall(config) {
            var _this = _super.call(this, 'balls/commando', 8, config) || this;
            _this.baseTextureIndex = 0;
            _this.effects.post.filters.push(new Effects.Filters.Glitch(8, 4, 4));
            _this.addTimer(0.2, function () { return _this.changeAnimations(); }, Infinity);
            _this.addAbility('onCollideWithEnemyPostDamage', GlitchedBall.onCollideWithEnemyPostDamage);
            return _this;
        }
        GlitchedBall.prototype.getName = function () { return 'Gl[glitched]it[offsety 1]c[/offsety]he[/glitched]d B[glitched]a[offsety 1]l[/offsety]l[/glitched]'; };
        GlitchedBall.prototype.getDesc = function () { return "Does a random effect when it collides with an enemy. Effect power increases with level."; };
        GlitchedBall.prototype.getShopDmg = function () { return 2; };
        GlitchedBall.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(GlitchedBall.prototype, "power", {
            get: function () { return this.level + 1; },
            enumerable: false,
            configurable: true
        });
        GlitchedBall.prototype.changeAnimations = function () {
            var baseTexture = this.getNextBaseTexture();
            this.changeBaseTextureAndRadius(baseTexture, 8);
        };
        GlitchedBall.onCollideWithEnemyPostDamage = function (source, world, collideWith, damage) {
            var possibleEffects = [
                function () { return GlitchedBall.buffSelfDamage(source, world); },
                function () { return GlitchedBall.buffSelfHealth(source, world); },
                function () { return GlitchedBall.buffAllyDamage(source, world); },
                function () { return GlitchedBall.buffAllyHealth(source, world); },
                function () { return GlitchedBall.homingSpikeToRandomEnemy(source, world); },
                function () { return GlitchedBall.homingSpikeToHitEnemy(source, world, collideWith); },
                function () { return GlitchedBall.randomSpikes(source, world); },
                function () { return GlitchedBall.explosion(source, world); },
                function () { return GlitchedBall.slowEnemy(source, world, collideWith); },
                function () { return GlitchedBall.spawnSkeleton(source, world); },
                function () { return GlitchedBall.giveEquipmentToAlly(source, world); },
                function () { return GlitchedBall.sporeOnHitEnemy(source, world, collideWith); },
                function () { return GlitchedBall.clawHitEnemy(source, world, collideWith); },
                function () { return GlitchedBall.goEthereal(source, world); },
                function () { return GlitchedBall.boostAllies(source, world); },
                function () { return GlitchedBall.leaveAcidPool(source, world); },
                function () { return GlitchedBall.stopEnemy(source, world, collideWith); },
            ];
            var attemptsLeft = 10;
            while (attemptsLeft > 0) {
                attemptsLeft--;
                var effect = Ball.Random.element(possibleEffects);
                var success = effect();
                if (success)
                    break;
            }
            if (Ball.Random.boolean(0.1))
                world.runScript(glitchSmall(world));
        };
        GlitchedBall.buffSelfDamage = function (source, world) {
            source.buff(source.power, 0);
            return true;
        };
        GlitchedBall.buffSelfHealth = function (source, world) {
            source.buff(0, source.power);
            return true;
        };
        GlitchedBall.buffAllyDamage = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return false;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: source.power, hp: 0 }, function (allies) { return Ball.Random.element(allies); }));
            return true;
        };
        GlitchedBall.buffAllyHealth = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return false;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: 0, hp: source.power }, function (allies) { return Ball.Random.element(allies); }));
            return true;
        };
        GlitchedBall.homingSpikeToRandomEnemy = function (source, world) {
            var e_164, _a;
            var enemies = getEnemies(world, source);
            if (enemies.length === 0)
                return false;
            var spikeCounts = M.batch(source.power, 20);
            try {
                for (var spikeCounts_2 = __values(spikeCounts), spikeCounts_2_1 = spikeCounts_2.next(); !spikeCounts_2_1.done; spikeCounts_2_1 = spikeCounts_2.next()) {
                    var count = spikeCounts_2_1.value;
                    var randomBall = Ball.Random.element(enemies);
                    world.addWorldObject(new HomingSpike(source.x, source.y, source, randomBall, 1, count, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
                    source.didShootProjectile(count);
                }
            }
            catch (e_164_1) { e_164 = { error: e_164_1 }; }
            finally {
                try {
                    if (spikeCounts_2_1 && !spikeCounts_2_1.done && (_a = spikeCounts_2.return)) _a.call(spikeCounts_2);
                }
                finally { if (e_164) throw e_164.error; }
            }
            return true;
        };
        GlitchedBall.homingSpikeToHitEnemy = function (source, world, enemy) {
            var e_165, _a;
            if (enemy.hp <= 0)
                return false;
            var spikeCounts = M.batch(source.power, 20);
            try {
                for (var spikeCounts_3 = __values(spikeCounts), spikeCounts_3_1 = spikeCounts_3.next(); !spikeCounts_3_1.done; spikeCounts_3_1 = spikeCounts_3.next()) {
                    var count = spikeCounts_3_1.value;
                    world.addWorldObject(new HomingSpike(source.x, source.y, source, enemy, 1, count, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
                    source.didShootProjectile(count);
                }
            }
            catch (e_165_1) { e_165 = { error: e_165_1 }; }
            finally {
                try {
                    if (spikeCounts_3_1 && !spikeCounts_3_1.done && (_a = spikeCounts_3.return)) _a.call(spikeCounts_3);
                }
                finally { if (e_165) throw e_165.error; }
            }
            return true;
        };
        GlitchedBall.randomSpikes = function (source, world) {
            var e_166, _a;
            var spikeCounts = M.batch(source.power * 2, 20);
            try {
                for (var spikeCounts_4 = __values(spikeCounts), spikeCounts_4_1 = spikeCounts_4.next(); !spikeCounts_4_1.done; spikeCounts_4_1 = spikeCounts_4.next()) {
                    var count = spikeCounts_4_1.value;
                    world.addWorldObject(new Spike(source.x, source.y, Ball.Random.onCircle(150), source, 1, count));
                    source.didShootProjectile(count);
                }
            }
            catch (e_166_1) { e_166 = { error: e_166_1 }; }
            finally {
                try {
                    if (spikeCounts_4_1 && !spikeCounts_4_1.done && (_a = spikeCounts_4.return)) _a.call(spikeCounts_4);
                }
                finally { if (e_166) throw e_166.error; }
            }
            world.playSound('spike');
            return true;
        };
        GlitchedBall.explosion = function (source, world) {
            world.addWorldObject(new Explosion(source.x, source.y, source.physicalRadius - 8 + 30, { ally: 0, enemy: source.power }, source));
            world.playSound('shake');
            return true;
        };
        GlitchedBall.slowEnemy = function (source, world, enemy) {
            if (enemy.hp <= 0)
                return false;
            enemy.addSlow('yarn', 0.5, source.power);
            return true;
        };
        GlitchedBall.spawnSkeleton = function (source, world) {
            world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: source.power,
                    health: 1,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            return true;
        };
        GlitchedBall.giveEquipmentToAlly = function (source, world) {
            var equipmentTier = M.clamp(source.power, 1, 3);
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.equipment; });
            if (validBalls.length === 0)
                return false;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomEquipment(source.x, source.y, source, randomBall, Ball.Random.element(getPurchasableEquipmentTypesForExactTier(equipmentTier)), true, function (allies) { return Ball.Random.element(allies.filter(function (ally) { return !ally.equipment; })); }, Utils.NOOP));
            return true;
        };
        GlitchedBall.sporeOnHitEnemy = function (source, world, enemy) {
            if (enemy.hp <= 0)
                return false;
            if (source.power < 3)
                return false;
            world.addWorldObject(new HomingSpore(source.x, source.y, source, enemy));
            return true;
        };
        GlitchedBall.clawHitEnemy = function (source, world, enemy) {
            if (enemy.hp <= 0)
                return false;
            source.world.addWorldObject(new ClawSlash(enemy, source, source.power, true));
            return true;
        };
        GlitchedBall.goEthereal = function (source, world) {
            source.becomeEtherealForTime(1);
            return true;
        };
        GlitchedBall.boostAllies = function (source, world) {
            var e_167, _a;
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return false;
            var alliesToBoost = Math.min(source.power, validBalls.length);
            if (validBalls.length > alliesToBoost) {
                Ball.Random.shuffle(validBalls);
                validBalls = validBalls.slice(0, alliesToBoost);
            }
            try {
                for (var validBalls_4 = __values(validBalls), validBalls_4_1 = validBalls_4.next(); !validBalls_4_1.done; validBalls_4_1 = validBalls_4.next()) {
                    var ball = validBalls_4_1.value;
                    world.addWorldObject(new HomingBoost(source.x, source.y, source, ball, 1, Ball.Random.float(0.2, 0.6), function (allies) { return Ball.Random.element(allies); }));
                }
            }
            catch (e_167_1) { e_167 = { error: e_167_1 }; }
            finally {
                try {
                    if (validBalls_4_1 && !validBalls_4_1.done && (_a = validBalls_4.return)) _a.call(validBalls_4);
                }
                finally { if (e_167) throw e_167.error; }
            }
            return true;
        };
        GlitchedBall.leaveAcidPool = function (source, world) {
            world.addWorldObject(new AcidPool(source.x, source.y, source, source.physicalRadius + 30, 0.5 * source.power));
            return true;
        };
        GlitchedBall.stopEnemy = function (source, world, enemy) {
            if (enemy.hp <= 0)
                return false;
            enemy.stop(1);
            world.playSound('stopboom', { limit: 4 });
            return true;
        };
        GlitchedBall.prototype.getNextBaseTexture = function () {
            if (_.isEmpty(this.baseTextures))
                this.baseTextures = Object.keys(ballTextureCache).filter(function (key) { return key !== "undefined" && !_.contains(GlitchedBall.BAD_TEXTURES, key); });
            if (_.isEmpty(this.baseTextures))
                this.baseTextures = ['balls/ninja', 'balls/crystalball', 'balls/martyr'];
            var baseTexture = this.baseTextures[this.baseTextureIndex];
            this.baseTextureIndex = M.mod(this.baseTextureIndex + 1, this.baseTextures.length);
            return baseTexture;
        };
        GlitchedBall.BAD_TEXTURES = [
            "balls/splitspawn",
            "balls/normal",
            "balls/turret",
            "balls/thief",
            "balls/snowball",
            "balls/biogrenade",
            "balls/wobby2",
            "balls/wobby3",
            "balls/wobby4",
            "balls/matryoshkaxl",
            "balls/matryoshkal",
            "balls/matryoshkas",
            "balls/matryoshkaxs",
            "balls/mortar",
            "balls/mimic",
            "balls/scrapcannon",
        ];
        return GlitchedBall;
    }(Ball));
    Balls.GlitchedBall = GlitchedBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var GlitchedBallArg = /** @class */ (function (_super) {
        __extends(GlitchedBallArg, _super);
        function GlitchedBallArg(config) {
            var _this = _super.call(this, 'balls/commando', 8, config) || this;
            _this.canFreeze = false;
            _this.baseTextureIndex = 0;
            _this.effects.post.filters.push(new Effects.Filters.Glitch(8, 4, 4));
            _this.addTimer(0.2, function () { return _this.changeAnimations(); }, Infinity);
            _this.addAbility('onCollideWithBallPreDamage', GlitchedBallArg.onCollideWithBallPreDamage);
            return _this;
        }
        GlitchedBallArg.prototype.getName = function () { return 'Gl[glitched]<g4>t[offsety 2]c[/offsety]he[/glitched]d B[glitched]<g2>[offsety 1]<g3>[/offsety]l[/glitched]'; };
        GlitchedBallArg.prototype.getDesc = function () { return "<g2>?[glitched]?? <g1><g3><g4><g5>[/glitched]??<g4> [glitched]<g5><g4>[/glitched]<g1>?<g3> R<g1> oun?d5 [glitched]<g2><g4>[/glitched]?"; };
        GlitchedBallArg.prototype.getShopDmg = function () { return 2; };
        GlitchedBallArg.prototype.getShopHp = function () { return 3; };
        GlitchedBallArg.prototype.getShopCost = function () { return 0; };
        GlitchedBallArg.prototype.isGlitched = function () {
            return true;
        };
        GlitchedBallArg.prototype.changeAnimations = function () {
            var baseTexture = this.getNextBaseTexture();
            this.changeBaseTextureAndRadius(baseTexture, 8);
        };
        GlitchedBallArg.onCollideWithBallPreDamage = function (source, world, ball) {
            if (ball.team === source.team)
                return;
            world.runScript(glitchSmall(world));
        };
        GlitchedBallArg.prototype.getNextBaseTexture = function () {
            if (_.isEmpty(this.baseTextures))
                this.baseTextures = Object.keys(ballTextureCache).filter(function (key) { return key !== "undefined" && !_.contains(Balls.GlitchedBall.BAD_TEXTURES, key); });
            ;
            if (_.isEmpty(this.baseTextures))
                this.baseTextures = ['balls/ninja', 'balls/crystalball', 'balls/martyr'];
            var baseTexture = this.baseTextures[this.baseTextureIndex];
            this.baseTextureIndex = M.mod(this.baseTextureIndex + 1, this.baseTextures.length);
            return baseTexture;
        };
        return GlitchedBallArg;
    }(Ball));
    Balls.GlitchedBallArg = GlitchedBallArg;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var GoldCrystalBall = /** @class */ (function (_super) {
        __extends(GoldCrystalBall, _super);
        function GoldCrystalBall(config) {
            var _this = _super.call(this, 'balls/goldcrystalball', 8, config) || this;
            _this.addAbility('onSell', GoldCrystalBall.onSell);
            return _this;
        }
        GoldCrystalBall.prototype.getName = function () { return 'Crystal Ball [gold]<star>[/gold]'; };
        GoldCrystalBall.prototype.getDesc = function () { return "On sell, give " + GoldCrystalBall.getBuffAmount(this) + "[gold]<star>[/gold] to a random ally"; };
        GoldCrystalBall.prototype.getShopDmg = function () { return 1; };
        GoldCrystalBall.prototype.getShopHp = function () { return 3; };
        GoldCrystalBall.prototype.getCredits = function () { return [CreditsNames.NEPDEP]; };
        GoldCrystalBall.getBuffAmount = function (source) { return source.level; };
        GoldCrystalBall.onSell = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            var levels = GoldCrystalBall.getBuffAmount(source);
            for (var i = 0; i < levels; i++) {
                world.addWorldObject(new HomingBoost(source.x, source.y, source, randomBall, 1, Ball.Random.float(0.5, 0.9), function (_) { return Ball.Random.element(validBalls); }));
            }
        };
        return GoldCrystalBall;
    }(Ball));
    Balls.GoldCrystalBall = GoldCrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Grave = /** @class */ (function (_super) {
        __extends(Grave, _super);
        function Grave(config) {
            var _this = _super.call(this, 'balls/grave', 8, config) || this;
            _this.skeletons = [];
            _this.addAbility('update', Grave.update, { canActivateTwice: false });
            return _this;
        }
        Grave.prototype.getName = function () { return 'Grave'; };
        Grave.prototype.getDesc = function () { return "Summon two " + buffText(this.skeletonDmg, this.skeletonHp) + " skeletons. Whenever one of these skeletons dies, summon another one"; };
        Grave.prototype.getShopDmg = function () { return 2; };
        Grave.prototype.getShopHp = function () { return 8; };
        Grave.prototype.getCredits = function () { return [CreditsNames.CONFLICTING_THEMES, CreditsNames.MATERWELONS]; };
        Object.defineProperty(Grave.prototype, "skeletonDmg", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Grave.prototype, "skeletonHp", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Grave.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            A.filterInPlace(source.skeletons, function (s) { return s && s.world; });
            if (_.size(source.skeletons) >= 2)
                return;
            Grave.summonSkeleton(source, world);
            if (source.shouldActivateAbilityTwice()) {
                Grave.summonSkeleton(source, world);
            }
            source.addChild(new Sprite({
                texture: 'necromancerbeams',
                copyFromParent: ['layer'],
                scale: (source.physicalRadius + 10) / 64,
                life: 0.7,
                vangle: 180,
                update: function () {
                    this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                    World.Actions.orderWorldObjectBefore(this, this.parent);
                },
            }));
            world.playSound('sellball');
        };
        Grave.summonSkeleton = function (source, world) {
            var d = Ball.Random.onCircle(16);
            var p = source.getPosition().add(d);
            var skeleton = world.addWorldObject(squadBallToWorldBall({
                x: p.x,
                y: p.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: source.skeletonDmg,
                    health: source.skeletonHp,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            skeleton.addChild(new Sprite({
                texture: 'aura',
                tint: 0x57007F,
                scale: 16 / 64,
                copyFromParent: ['layer'],
                postUpdate: function () {
                    World.Actions.orderWorldObjectBefore(this, skeleton);
                },
            }));
            skeleton.v.set(d.withMagnitude(100));
            source.skeletons.push(skeleton);
            world.addWorldObject(new BurstPuffSystem({
                x: skeleton.x,
                y: skeleton.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(10 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.7,
                    v: Random.inCircle(80),
                    color: 0xEC77FF,
                    finalColor: 0x57007F,
                    radius: 4,
                    finalRadius: 0,
                }); },
            }));
        };
        return Grave;
    }(Ball));
    Balls.Grave = Grave;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var GreenCrystalBall = /** @class */ (function (_super) {
        __extends(GreenCrystalBall, _super);
        function GreenCrystalBall(config) {
            var _this = _super.call(this, 'balls/greencrystalball', 8, config) || this;
            _this.addAbility('onSell', GreenCrystalBall.onSell);
            return _this;
        }
        GreenCrystalBall.prototype.getName = function () { return 'Crystal Ball [g]<heart>[/g]'; };
        GreenCrystalBall.prototype.getDesc = function () { return "On sell, give [g]" + GreenCrystalBall.getBuffAmount(this) + "<heart>[/g] to a random ally"; };
        GreenCrystalBall.prototype.getShopDmg = function () { return 1; };
        GreenCrystalBall.prototype.getShopHp = function () { return 4; };
        GreenCrystalBall.getBuffAmount = function (source) { return source.level; };
        GreenCrystalBall.onSell = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: 0, hp: GreenCrystalBall.getBuffAmount(source) }, function (_) { return Ball.Random.element(validBalls); }));
        };
        return GreenCrystalBall;
    }(Ball));
    Balls.GreenCrystalBall = GreenCrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Grenade = /** @class */ (function (_super) {
        __extends(Grenade, _super);
        function Grenade(config) {
            var _this = _super.call(this, 'balls/grenade', 8, config) || this;
            _this.angle = 90;
            _this.visibleExplosionRadius = _this.explosionRadius;
            _this.handle = _this.addChild(new Sprite({
                texture: 'grenadehandle',
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onDeath', Grenade.onDeath);
            return _this;
        }
        Grenade.prototype.getName = function () { return 'Grenade'; };
        Grenade.prototype.getDesc = function () { return "Explode on death, dealing [r]its <sword>[/r] in a radius\n\nHealth resets to zero on level-up"; };
        Grenade.prototype.getShopDmg = function () { return 2; };
        Grenade.prototype.getShopHp = function () { return 0; };
        Object.defineProperty(Grenade.prototype, "explosionRadius", {
            get: function () { return this.physicalRadius - 8 + 100 * Math.exp(0.25 * this.level) / (Math.exp(0.25 * this.level) + 3); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Grenade.prototype, "explosionDmgMult", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Grenade.prototype, "yourSquadRadius", {
            get: function () { return 15; },
            enumerable: false,
            configurable: true
        });
        Grenade.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.handle.alpha = this.alpha;
            this.handle.scale = this.ballScale * this.moveScale;
            this.handle.angle = this.angle - 90;
            this.handle.effects.outline.color = this.effects.outline.color;
            this.handle.effects.outline.enabled = this.effects.outline.enabled;
            World.Actions.orderWorldObjectBefore(this.handle, this);
            if ((this.isInShop && !this.isBeingMoved()) || this.isNullified()) {
                this.visibleExplosionRadius = 0;
            }
            else {
                this.visibleExplosionRadius = M.lerpTime(this.visibleExplosionRadius, this.explosionRadius, 100, this.delta);
            }
        };
        Grenade.prototype.setForInShop = function () {
            this.visibleExplosionRadius = 0;
        };
        Grenade.prototype.render = function (texture, x, y) {
            var drawRadius = this.isInYourSquadScene ? this.yourSquadRadius : this.visibleExplosionRadius;
            Draw.brush.color = Color.lerpColorByLch(0xFF0000, 0xFF3333, Tween.Easing.OscillateSine(2)(this.life.time));
            Draw.brush.alpha = 0.6;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, drawRadius, Draw.ALIGNMENT_INNER);
            _super.prototype.render.call(this, texture, x, y);
        };
        Grenade.prototype.levelUp = function (withProperties, withFanfare, withStatIncrease) {
            if (withFanfare === void 0) { withFanfare = true; }
            if (withStatIncrease === void 0) { withStatIncrease = true; }
            _super.prototype.levelUp.call(this, withProperties, withFanfare, withStatIncrease);
            this.hp = 0;
        };
        Grenade.onDeath = function (source, world, killedBy) {
            var explosionDamage = source.explosionDmgMult * source.dmg;
            world.addWorldObject(new Explosion(source.x, source.y, source.explosionRadius, { ally: 0, enemy: explosionDamage }, source));
        };
        return Grenade;
    }(Ball));
    Balls.Grenade = Grenade;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Guardian = /** @class */ (function (_super) {
        __extends(Guardian, _super);
        function Guardian(config) {
            var _this = _super.call(this, 'balls/guardian', 8, config) || this;
            _this.cooldown = new AbilityCooldown(0.5, 2);
            _this.addAbility('onBallTakeDamage', Guardian.onBallTakeDamage);
            return _this;
        }
        Guardian.prototype.getName = function () { return 'Guardian'; };
        Guardian.prototype.getDesc = function () { return "When an ally takes discrete damage, heal it for [g]" + this.healAmount + "<heart>[/g]"; };
        Guardian.prototype.getShopDmg = function () { return 3; };
        Guardian.prototype.getShopHp = function () { return 6; };
        Guardian.prototype.getCredits = function () { return [CreditsNames.TOMMYDOG145]; };
        Object.defineProperty(Guardian.prototype, "healAmount", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Guardian.prototype.update = function () {
            _super.prototype.update.call(this);
            this.cooldown.update(this.delta);
        };
        Guardian.onBallTakeDamage = function (source, world, ball, damage) {
            if (ball.team !== source.team)
                return;
            if (!source.cooldown.consumeUse())
                return;
            world.addWorldObject(new HomingHeal(source.x, source.y, source, ball, source.healAmount, function (balls) { return undefined; }));
        };
        return Guardian;
    }(Ball));
    Balls.Guardian = Guardian;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Haunt = /** @class */ (function (_super) {
        __extends(Haunt, _super);
        function Haunt(config) {
            var _this = _super.call(this, 'balls/haunt', 8, config) || this;
            _this.addAbility('onDeath', Haunt.onDeath, { canActivateTwice: false });
            return _this;
        }
        Haunt.prototype.getName = function () { return 'Haunt'; };
        Haunt.prototype.getDesc = function () { return "On death, haunts the enemy that killed it, dealing [r]" + this.ghostDmg + "<sword>/s[/r] for the rest of the battle"; };
        Haunt.prototype.getShopDmg = function () { return 4; };
        Haunt.prototype.getShopHp = function () { return 5; };
        Haunt.prototype.getCredits = function () { return [CreditsNames.CONFLICTING_THEMES, CreditsNames.MATERWELONS]; };
        Object.defineProperty(Haunt.prototype, "ghostDmg", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Haunt.onDeath = function (source, world, killedBy) {
            if (!killedBy || killedBy.team === source.team)
                return;
            var ghost = world.addWorldObject(new Ghost(source.x, source.y, source, killedBy, source.ghostDmg));
            if (source.shouldActivateAbilityTwice()) {
                var p_1 = Ball.Random.onCircle(5);
                ghost.doAfterTime(0.1, function () { return world.addWorldObject(new Ghost(source.x + p_1.x, source.y + p_1.y, source, killedBy, source.ghostDmg)); });
            }
            world.playSound('spook');
        };
        return Haunt;
    }(Ball));
    Balls.Haunt = Haunt;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Healer = /** @class */ (function (_super) {
        __extends(Healer, _super);
        function Healer(config) {
            var _this = _super.call(this, 'balls/healer', 8, config) || this;
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0x00FF00,
                blendMode: Texture.BlendModes.ADD,
                scale: _this.auraRadius / 64,
                copyFromParent: ['layer'],
            }));
            _this.addAbility('update', Healer.update);
            return _this;
        }
        Healer.prototype.getName = function () { return 'Healer'; };
        Healer.prototype.getDesc = function () { return "Allies heal [g]" + this.healRate + "<heart>/s[/g] within its aura during battle"; };
        Healer.prototype.getShopDmg = function () { return 1; };
        Healer.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(Healer.prototype, "healRate", {
            get: function () { return 1 + this.level * 0.5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Healer.prototype, "auraRadius", {
            get: function () {
                if ((this.isInShop || this.isInYourSquadScene) && !this.isBeingMoved())
                    return 20;
                return this.physicalRadius - 8 + 28 * (1 + (this.level - 1) * 0.3);
            },
            enumerable: false,
            configurable: true
        });
        Healer.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            this.aura.scale = M.lerpTime(this.aura.scale, this.auraRadius / 64, 100, this.delta);
            World.Actions.orderWorldObjectBefore(this.aura, this);
        };
        Healer.prototype.setForInShop = function () {
            this.aura.scale = this.auraRadius / 64;
        };
        Healer.update = function (source, world) {
            var e_168, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return G.distance(ball, source) < ball.radius + source.auraRadius; });
            try {
                for (var validBalls_5 = __values(validBalls), validBalls_5_1 = validBalls_5.next(); !validBalls_5_1.done; validBalls_5_1 = validBalls_5.next()) {
                    var ball = validBalls_5_1.value;
                    ball.healFor(source.healRate * source.delta, source);
                }
            }
            catch (e_168_1) { e_168 = { error: e_168_1 }; }
            finally {
                try {
                    if (validBalls_5_1 && !validBalls_5_1.done && (_a = validBalls_5.return)) _a.call(validBalls_5);
                }
                finally { if (e_168) throw e_168.error; }
            }
        };
        return Healer;
    }(Ball));
    Balls.Healer = Healer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Hitman = /** @class */ (function (_super) {
        __extends(Hitman, _super);
        function Hitman(config) {
            var _this = _super.call(this, 'balls/hitman', 8, config) || this;
            _this.addAbility('onPreBattle', Hitman.onPreBattle, { canActivateTwice: false });
            _this.addAbility('onEnterBattle', Hitman.onEnterBattle, { canActivateTwice: false });
            return _this;
        }
        Hitman.prototype.getName = function () { return 'Hitman'; };
        Hitman.prototype.getDesc = function () { return "On enter battle, sacrifice [r]half of its <sword>[/r] to shoot a homing spike at the farthest enemy for [r]" + this.spikeDamageMultiplier + "x the sacrificed <sword>[/r]"; };
        Hitman.prototype.getShopDmg = function () { return 4; };
        Hitman.prototype.getShopHp = function () { return 4; };
        Hitman.prototype.getCredits = function () { return [CreditsNames.XIAOSLOTH, CreditsNames.JUNJ]; };
        Object.defineProperty(Hitman.prototype, "spikeDamageMultiplier", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Hitman.onPreBattle = function (source, world) {
            Hitman.selectTargetAndShootSpike(source, world);
        };
        Hitman.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Hitman.selectTargetAndShootSpike(source, world);
        };
        Hitman.selectTargetAndShootSpike = function (source, world) {
            var validBalls = getEnemies(world, source);
            if (validBalls.length === 0)
                return;
            var farthestBall = M.argmax(validBalls, function (ball) { return G.distance(ball, source); });
            Hitman.shootSpike(source, world, farthestBall);
            if (source.shouldActivateAbilityTwice()) {
                Hitman.shootSpike(source, world, farthestBall);
            }
            source.dmg /= 2;
            source.showDmgStat(-1, 1);
        };
        Hitman.shootSpike = function (source, world, target) {
            var spike = world.addWorldObject(new HomingSpike(source.x, source.y, source, target, source.dmg / 2 * source.spikeDamageMultiplier, 1, function (enemyBalls) { return undefined; }));
            source.didShootProjectile(1);
            source.setPreBattleAbilityActiveCheck(function () { return spike.world; });
        };
        return Hitman;
    }(Ball));
    Balls.Hitman = Hitman;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Impostor = /** @class */ (function (_super) {
        __extends(Impostor, _super);
        function Impostor(config) {
            var _this = _super.call(this, 'balls/impostor', 8, config) || this;
            _this.addChild(new AbilityRadius(_this, function () { return _this.disguised ? 0 : _this.detectionRadius; }, 0xFF0000, 0xFF3333, 0.6));
            _this.addAbility('onPlay', Impostor.onPlay, { nullifyable: false, canActivateTwice: false });
            return _this;
        }
        Impostor.prototype.getName = function () { return this.disguised ? 'Crewmate' : 'Impostor'; };
        Impostor.prototype.getDesc = function () {
            var s = this.tasksPerMinute === 1 ? '' : 's';
            if (this.disguised)
                return "Performs [lb]" + this.tasksPerMinute + "[/lb] task" + s + " per minute and is definitely not suspicious";
            return "Damage is boosted by +[r]" + this.extraDamage + "<sword>[/r] if there is only one enemy nearby, [r]but deals " + this.lowDamage + "<sword> otherwise[/r]";
        };
        Impostor.prototype.getShopDmg = function () { return 2; };
        Impostor.prototype.getShopHp = function () { return 4; };
        Impostor.prototype.getCredits = function () { return [CreditsNames.FIREBALLME, CreditsNames.JAEIL]; };
        Object.defineProperty(Impostor.prototype, "extraDamage", {
            get: function () { return 3 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Impostor.prototype, "lowDamage", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Impostor.prototype, "detectionRadius", {
            get: function () { return this.physicalRadius + 36; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Impostor.prototype, "tasksPerMinute", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Impostor.prototype.updateBattle = function () {
            _super.prototype.updateBattle.call(this);
            if (this.disguised) {
                this.undisguise();
                this.world.addWorldObject(new CircleImpact(this.x, this.y, this.physicalRadius, { ally: 0, enemy: 0 }, this));
                this.world.playSound('cloak', { humanized: false, limit: 2 });
            }
        };
        Impostor.prototype.getAbilityOverrideCollisionDamage = function () {
            var enemies = this.getEnemiesInRange(this.world);
            if (enemies.length > 1) {
                return this.lowDamage;
            }
            var extraDamage = this.shouldActivateAbilityTwice() ? 2 * this.extraDamage : this.extraDamage;
            return _super.prototype.getAbilityOverrideCollisionDamage.call(this) + extraDamage;
        };
        Impostor.onPlay = function (source, world) {
            source.runScript(source.dropInVent());
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        Impostor.prototype.onTeamsSpawned = function () {
            if (GAME_MODE === 'mm') {
                this.flipSideMM();
            }
            else {
                this.flipSideVS();
            }
        };
        Impostor.prototype.dropInVent = function () {
            var impostor = this;
            return function () {
                var vent;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            impostor.setVisible(false);
                            vent = impostor.world.addWorldObject(new Sprite({
                                x: impostor.x, y: impostor.y,
                                animations: [Animations.fromTextureList({ name: 'vent', textureRoot: 'impostor_vent', textures: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 20, 20], frameRate: 18 })],
                                layer: Battle.Layers.fx,
                                effects: { post: { filters: [new BallTeamColorFilter(Ball.getTeamColor(impostor.team))] } },
                            }));
                            return [4 /*yield*/, S.waitUntil(function () { return !vent.getCurrentAnimationName(); })];
                        case 1:
                            _a.sent();
                            vent.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, S.tween(0.2, vent, 'alpha', 1, 0)];
                                        case 1:
                                            _a.sent();
                                            vent.kill();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            };
        };
        Impostor.prototype.flipSideMM = function () {
            var impostor = this;
            this.runScript(function () {
                var vent;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!impostor.isVisible()) return [3 /*break*/, 2];
                            return [4 /*yield*/, impostor.dropInVent()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            impostor.teleport(impostor.world.width - impostor.x, impostor.y);
                            impostor.disguise();
                            return [4 /*yield*/];
                        case 3:
                            _a.sent();
                            vent = impostor.world.addWorldObject(new Sprite({
                                x: impostor.x, y: impostor.y,
                                animations: [Animations.fromTextureList({ name: 'vent', textureRoot: 'impostor_vent', textures: [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0], frameRate: 18 })],
                                layer: Battle.Layers.onground,
                                effects: { post: { filters: [new BallTeamColorFilter(Ball.getTeamColor(Ball.getInverseTeam(impostor.team)))] } },
                            }));
                            return [4 /*yield*/, S.waitUntil(function () { return !vent.getCurrentAnimationName(); })];
                        case 4:
                            _a.sent();
                            impostor.setVisible(true);
                            vent.setTexture('impostor_vent/20');
                            vent.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, S.tween(0.2, vent, 'alpha', 1, 0)];
                                        case 1:
                                            _a.sent();
                                            vent.kill();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        Impostor.prototype.flipSideVS = function () {
            this.x = this.world.width - this.x;
            this.disguise();
        };
        Impostor.prototype.getEnemiesInRange = function (world) {
            var _this = this;
            return getEnemies(world, this).filter(function (enemy) { return G.distance(enemy, _this) < enemy.physicalRadius + _this.detectionRadius; });
        };
        return Impostor;
    }(Ball));
    Balls.Impostor = Impostor;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Leech = /** @class */ (function (_super) {
        __extends(Leech, _super);
        function Leech(config) {
            var _this = _super.call(this, 'balls/leech', 8, config) || this;
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFF0000,
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
                scale: _this.auraRadius / 64,
            }));
            _this.hpBank = 0;
            _this.addAbility('update', Leech.update);
            _this.addAbility('onDeath', Leech.onDeath);
            return _this;
        }
        Leech.prototype.getName = function () { return 'Leech'; };
        Leech.prototype.getDesc = function () { return "[r]-" + this.leechRate + "<heart>/s[/r] to enemies in its aura. Give " + this.healMult + "x leeched damage to random allies as health buffs"; };
        Leech.prototype.getShopDmg = function () { return 1; };
        Leech.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Leech.prototype, "leechRate", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Leech.prototype, "healMult", {
            get: function () { return 1 + this.level / 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Leech.prototype, "auraRadius", {
            get: function () {
                if ((this.isInShop || this.isInYourSquadScene) && !this.isBeingMoved())
                    return 20;
                return this.physicalRadius - 8 + 30 + 5 * (this.level - 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Leech.prototype, "hpDisperseBatch", {
            get: function () { return 1 / this.healMult; },
            enumerable: false,
            configurable: true
        });
        Leech.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            this.aura.scale = M.lerpTime(this.aura.scale, this.auraRadius / 64, 100, this.delta);
            World.Actions.orderWorldObjectBefore(this.aura, this);
        };
        Leech.prototype.setForInShop = function () {
            this.aura.scale = this.auraRadius / 64;
        };
        Leech.update = function (source, world) {
            var e_169, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            try {
                for (var enemyBalls_3 = __values(enemyBalls), enemyBalls_3_1 = enemyBalls_3.next(); !enemyBalls_3_1.done; enemyBalls_3_1 = enemyBalls_3.next()) {
                    var ball = enemyBalls_3_1.value;
                    if (G.distance(ball, source) < ball.radius + source.auraRadius) {
                        var hpToLeech = source.leechRate * source.delta;
                        var actualHpLeeched = ball.leechFor(hpToLeech, source);
                        source.hpBank += actualHpLeeched;
                        ball.addLeeched(0.1);
                    }
                }
            }
            catch (e_169_1) { e_169 = { error: e_169_1 }; }
            finally {
                try {
                    if (enemyBalls_3_1 && !enemyBalls_3_1.done && (_a = enemyBalls_3.return)) _a.call(enemyBalls_3);
                }
                finally { if (e_169) throw e_169.error; }
            }
            Leech.disperseHp(source, world);
        };
        Leech.onDeath = function (source, world, killedBy) {
            Leech.disperseHp(source, world, 'onDeath');
        };
        Leech.disperseHp = function (source, world, onDeath) {
            while (source.hpBank >= source.hpDisperseBatch) {
                source.hpBank -= source.hpDisperseBatch;
                Leech.disperseSingle(source, world, source.hpDisperseBatch);
            }
            if (onDeath && source.hpBank > 0) {
                Leech.disperseSingle(source, world, source.hpBank);
            }
        };
        Leech.disperseSingle = function (source, world, amount) {
            var allyBalls = getAlliesNotSelf(world, source);
            var needyBalls = allyBalls.filter(function (ball) { return ball.hp < ball.maxhp; });
            var targetBall = needyBalls.length > 0 ? Ball.Random.element(needyBalls) : Ball.Random.element(allyBalls);
            if (targetBall) {
                world.addWorldObject(new RandomBuff(source.x, source.y, source, targetBall, { dmg: 0, hp: amount * source.healMult }, function (allies) {
                    var needies = allies.filter(function (ball) { return ball.hp < ball.maxhp; });
                    return needies.length > 0 ? Ball.Random.element(needies) : Ball.Random.element(allies);
                }));
            }
        };
        return Leech;
    }(Ball));
    Balls.Leech = Leech;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Martyr = /** @class */ (function (_super) {
        __extends(Martyr, _super);
        function Martyr(config) {
            var _this = _super.call(this, 'balls/martyr', 8, config) || this;
            _this.addAbility('onDeath', Martyr.onDeath);
            return _this;
        }
        Martyr.prototype.getName = function () { return 'Martyr'; };
        Martyr.prototype.getDesc = function () { return "On death, give " + buffText(this.buffAmount, this.buffAmount) + " to a random ally"; };
        Martyr.prototype.getShopDmg = function () { return 1; };
        Martyr.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Martyr.prototype, "buffAmount", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Martyr.onDeath = function (source, world, killedBy) {
            var validBalls = getAlliesNotSelf(world, source);
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: source.buffAmount, hp: source.buffAmount }, function (allies) { return Ball.Random.element(allies); }));
        };
        return Martyr;
    }(Ball));
    Balls.Martyr = Martyr;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Matryoshka = /** @class */ (function (_super) {
        __extends(Matryoshka, _super);
        function Matryoshka(config) {
            var _this = _super.call(this, 'balls/matryoshkas', 6, config) || this;
            _this._size = 1;
            _this.isOriginal = true;
            _this.lastEquipmentType = -1;
            _this.setSize(_this.level);
            _this.lastEquipmentType = config.properties.equipment;
            _this.addAbility('onDeath', Matryoshka.onDeath);
            return _this;
        }
        Matryoshka.prototype.getName = function () { return "Matryoshka " + getSizeInfo(this._size).name; };
        Matryoshka.prototype.getDesc = function () {
            if (this._size === 0)
                return "The final layer!";
            return "On death, summon a " + buffText(this.nextDmg, this.nextHp) + " smaller version of itself with the last equipment it had";
        };
        Matryoshka.prototype.getShopDmg = function () { return 2; };
        Matryoshka.prototype.getShopHp = function () { return 6; };
        Matryoshka.prototype.getCredits = function () { return [CreditsNames.C_RRY]; };
        Object.defineProperty(Matryoshka.prototype, "nextDmg", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Matryoshka.prototype, "nextHp", {
            get: function () { return this.level > 3 ? this.level - 3 : 1; },
            enumerable: false,
            configurable: true
        });
        Matryoshka.prototype.update = function () {
            _super.prototype.update.call(this);
            if (this.isOriginal) {
                this.setSize(this.level);
            }
            if (this.equipment) {
                this.lastEquipmentType = this.equipment.equipmentType;
            }
        };
        Matryoshka.prototype.getSize = function () {
            return this._size;
        };
        Matryoshka.prototype.setSize = function (size) {
            size = M.clamp(size, 0, 4);
            if (this._size === size)
                return;
            this._size = size;
            this.changeBaseTextureAndRadius("balls/matryoshka" + getSizeInfo(size).texture, getSizeInfo(size).radius);
        };
        Matryoshka.onDeath = function (source, world, killedBy) {
            if (source.getSize() === 0)
                return;
            var ball = squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: source.properties.type,
                    level: source.properties.level,
                    damage: source.nextDmg,
                    health: source.nextHp,
                    // No Best Friend
                    equipment: source.lastEquipmentType !== 20 ? source.lastEquipmentType : -1,
                    metadata: {},
                }
            }, undefined, -1, source.team);
            // Redundant check to force TS type
            if (!(ball instanceof Balls.Matryoshka)) {
                return;
            }
            world.addWorldObject(ball);
            ball.setSize(source.getSize() - 1);
            ball.isOriginal = false;
        };
        return Matryoshka;
    }(Ball));
    Balls.Matryoshka = Matryoshka;
    function getSizeInfo(size) {
        if (size in sizeInfo)
            return sizeInfo[size];
        if (size < 0)
            return sizeInfo[0];
        return sizeInfo[4];
    }
    var sizeInfo = {
        0: { texture: 'xs', name: 'XS', radius: 4 },
        1: { texture: 's', name: 'S', radius: 6 },
        2: { texture: 'm', name: 'M', radius: 8 },
        3: { texture: 'l', name: 'L', radius: 11 },
        4: { texture: 'xl', name: 'XL', radius: 16 },
    };
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Mechanic = /** @class */ (function (_super) {
        __extends(Mechanic, _super);
        function Mechanic(config) {
            var _this = _super.call(this, 'balls/mechanic', 8, config) || this;
            _this.equipmentsGiven = 0;
            _this.addAbility('onPreBattle', Mechanic.onPreBattle);
            _this.addAbility('update', Mechanic.update);
            return _this;
        }
        Mechanic.prototype.getName = function () { return 'Mechanic'; };
        Mechanic.prototype.getDesc = function () {
            return "Gives [lb]" + this.equipmentsToGive + "[/lb] [color " + getColorForTier(this.equipmentTier) + "]Tier " + 'I'.repeat(this.equipmentTier) + "[/color] equipments to random unequipped allies";
        };
        Mechanic.prototype.getShopDmg = function () { return 3; };
        Mechanic.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(Mechanic.prototype, "equipmentTier", {
            get: function () { return Math.min(this.level, 3); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mechanic.prototype, "equipmentsToGive", {
            get: function () { return this.level <= 3 ? 2 : this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Mechanic.prototype.onStateChangePreBattle = function () {
            this.equipmentsGiven = 0;
        };
        Mechanic.onPreBattle = function (source, world) {
            Mechanic.attemptGiveEquipmentsToAllies(source, world);
        };
        Mechanic.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            Mechanic.attemptGiveEquipmentsToAllies(source, world);
        };
        Mechanic.attemptGiveEquipmentsToAllies = function (source, world) {
            var e_170, _a;
            var currentRandomEquipments = world.select.typeAll(RandomEquipment);
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.equipment && !currentRandomEquipments.some(function (re) { return re.target === ball; }); });
            if (validBalls.length === 0)
                return;
            var equipmentsLeftToGive = source.equipmentsToGive - source.equipmentsGiven;
            if (validBalls.length > equipmentsLeftToGive) {
                Ball.Random.shuffle(validBalls);
                validBalls = validBalls.slice(0, equipmentsLeftToGive);
            }
            var res = [];
            var _loop_22 = function (ball) {
                var possibleEquipments = getPurchasableEquipmentTypesForExactTier(source.equipmentTier).filter(function (e) { return !_.contains(Mechanic.USELESS_EQUIPMENT_TYPES, e); });
                if (_.isEmpty(possibleEquipments)) {
                    return { value: void 0 };
                }
                var re = world.addWorldObject(new RandomEquipment(source.x, source.y, source, ball, Ball.Random.element(possibleEquipments), true, function (allies) {
                    var cre = world.select.typeAll(RandomEquipment);
                    var validAllies = allies.filter(function (ally) { return ally !== source && !ally.equipment && !cre.some(function (re) { return re.target === ball; }); });
                    return Ball.Random.element(validAllies);
                }, function () {
                    source.equipmentsGiven--;
                }));
                res.push(re);
            };
            try {
                for (var validBalls_6 = __values(validBalls), validBalls_6_1 = validBalls_6.next(); !validBalls_6_1.done; validBalls_6_1 = validBalls_6.next()) {
                    var ball = validBalls_6_1.value;
                    var state_5 = _loop_22(ball);
                    if (typeof state_5 === "object")
                        return state_5.value;
                }
            }
            catch (e_170_1) { e_170 = { error: e_170_1 }; }
            finally {
                try {
                    if (validBalls_6_1 && !validBalls_6_1.done && (_a = validBalls_6.return)) _a.call(validBalls_6);
                }
                finally { if (e_170) throw e_170.error; }
            }
            if (res.length > 0) {
                world.playSound('sellball', { limit: 2 });
            }
            source.equipmentsGiven += validBalls.length;
            source.setPreBattleAbilityActiveCheck(function () { return res.some(function (re) { return re.world; }); });
        };
        Mechanic.USELESS_EQUIPMENT_TYPES = [
            4,
            8,
            10,
            18,
            19,
            32,
            37,
            41,
            42,
        ];
        return Mechanic;
    }(Ball));
    Balls.Mechanic = Mechanic;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Medic = /** @class */ (function (_super) {
        __extends(Medic, _super);
        function Medic(config) {
            var _this = _super.call(this, 'balls/medic', 8, config) || this;
            _this.addAbility('onTakeDamage', Medic.onTakeDamage);
            return _this;
        }
        Medic.prototype.getName = function () { return 'Medic'; };
        Medic.prototype.getDesc = function () { return "When this takes discrete damage, dispense a medpack that heals allies for [g]" + this.medpackHealth + "<heart>[/g] when they roll over it\n\nMedics cannot pick up medpacks"; };
        Medic.prototype.getShopDmg = function () { return 1; };
        Medic.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Medic.prototype, "medpackHealth", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Medic.onTakeDamage = function (source, world, damage) {
            world.addWorldObject(new Medpack(source.x, source.y, Ball.Random.inDisc(60, 120), source, source.medpackHealth));
        };
        return Medic;
    }(Ball));
    Balls.Medic = Medic;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Mercenary = /** @class */ (function (_super) {
        __extends(Mercenary, _super);
        function Mercenary(config) {
            var _this = _super.call(this, 'balls/mercenary', 8, config) || this;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', Mercenary.onPreBattle);
            _this.addAbility('onEnterBattle', Mercenary.onEnterBattle);
            _this.addAbility('onKill', Mercenary.onKill);
            return _this;
        }
        Mercenary.prototype.getName = function () { return 'Mercenary'; };
        Mercenary.prototype.getDesc = function () { return "Gain [r]" + this.dmgGain + "<sword>[/r] when entering the battle\n\nYou must [r]pay[/r] [gold]<coin>" + this.payPerKill + "[/gold] for each kill it gets"; };
        Mercenary.prototype.getShopDmg = function () { return 2; };
        Mercenary.prototype.getShopHp = function () { return 4; };
        Mercenary.prototype.getCredits = function () { return [CreditsNames.JUNJ]; };
        Object.defineProperty(Mercenary.prototype, "dmgGain", {
            get: function () { return 1 + 2 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mercenary.prototype, "payPerKill", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Mercenary.onPreBattle = function (source, world) {
            Mercenary.getBuff(source);
        };
        Mercenary.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Mercenary.getBuff(source);
        };
        Mercenary.getBuff = function (source) {
            source.buff(source.dmgGain, 0);
        };
        Mercenary.onKill = function (source, world, killed) {
            if (source.team !== 'friend' || !youArePlaying(world))
                return;
            addStartShopEffect({
                type: 'gold',
                sourceSquadIndex: source.squadIndexReference,
                gold: -source.payPerKill,
            });
        };
        return Mercenary;
    }(Ball));
    Balls.Mercenary = Mercenary;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Mimic = /** @class */ (function (_super) {
        __extends(Mimic, _super);
        function Mimic(config) {
            var _this = _super.call(this, 'balls/mimic', 8, config) || this;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onStartShop', Mimic.onStartShop, { canActivateTwice: false });
            _this.addAbility('onSell', Mimic.onSell, { canActivateTwice: false });
            _this.addAbility('onLevelUp', Mimic.onLevelUp);
            _this.addAbility('onRestock', Mimic.onRestock);
            _this.addAbility('onPlay', Mimic.onPlay);
            _this.addAbility('onPreBattle', Mimic.onPreBattle, { canActivateTwice: false });
            _this.addAbility('onEnterBattle', Mimic.onEnterBattle, { canActivateTwice: false });
            return _this;
        }
        Mimic.prototype.getName = function () { return 'Mimic'; };
        Mimic.prototype.getDesc = function () {
            var levelIncreaseText = this.targetLevelIncrease > 0 ? " [w]+[/w]" + this.targetLevelIncrease + "<star>" : '';
            return "Copies the type of the closest ally during the shop and battle\n\nIn battle, copies [gold]half the target's\nlevel" + levelIncreaseText + "[/gold].\nCannot Mimic Impostors";
        };
        Mimic.prototype.getShopDmg = function () { return 2; };
        Mimic.prototype.getShopHp = function () { return 8; };
        Mimic.prototype.getCredits = function () { return [CreditsNames.SHUICHI_SAIHARA]; };
        Object.defineProperty(Mimic.prototype, "targetLevelIncrease", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        Mimic.prototype.update = function () {
            _super.prototype.update.call(this);
            this.updateClosestTarget();
            this.updateRenderFacade();
            if (this.renderFacade) {
                this.setBallScale(this.renderFacade.radius / this.radius * this.renderFacade.ballScale);
                this.renderFacade.setMoveScale(this.moveScale);
            }
            else {
                this.setBallScale(1);
            }
        };
        Mimic.prototype.updateClosestTarget = function () {
            if (!this.alive)
                return;
            var closestAlly = Mimic.getClosestAlly(this, this.world);
            if (!closestAlly) {
                this.currentTarget = undefined;
                return;
            }
            var ballMover = this.world.select.type(BallMover, false);
            if (ballMover && ballMover.movingThing === this) {
                return;
            }
            this.currentTarget = closestAlly;
        };
        Mimic.prototype.updateRenderFacade = function () {
            if (!this.currentTarget) {
                this.renderFacade = undefined;
                return;
            }
            if (!this.renderFacade || this.renderFacade.properties.type !== this.currentTarget.properties.type || this.renderFacade.level !== this.level) {
                this.renderFacade = squadBallToWorldBall({
                    x: 0, y: 0,
                    properties: {
                        type: this.currentTarget.properties.type,
                        damage: this.dmg,
                        health: this.hp,
                        equipment: -1,
                        level: this.level,
                        metadata: {},
                    }
                }, undefined, -1, this.team);
                if (this.renderFacade.properties.type === 11) {
                    this.renderFacade.changeBaseTextureAndRadius('mimictextures/turret', this.renderFacade.radius);
                }
                else if (this.renderFacade.properties.type === 53) {
                    this.renderFacade.changeBaseTextureAndRadius('mimictextures/cannon', this.renderFacade.radius);
                }
                else if (this.renderFacade.properties.type === 109) {
                    this.renderFacade.changeBaseTextureAndRadius('mimictextures/boomer', this.renderFacade.radius);
                }
                else if (this.renderFacade.properties.type === 130) {
                    this.renderFacade.changeBaseTextureAndRadius('mimictextures/scrapcannon', this.renderFacade.radius);
                }
            }
            if (this.renderFacade) {
                this.renderFacade.alpha = M.lerp(0.5, 0.8, Tween.Easing.OscillateSine(1)(this.life.time));
            }
        };
        Mimic.prototype.render = function (texture, x, y) {
            _super.prototype.render.call(this, texture, x, y);
            if (this.renderFacade) {
                this.renderFacade.render(texture, x, y);
            }
        };
        Mimic.onStartShop = function (source, world) {
            source.updateClosestTarget();
            if (!source.currentTarget)
                return;
            Mimic.doOnStartShop(source, source.currentTarget, world);
            if (source.shouldActivateAbilityTwice()) {
                Mimic.doOnStartShop(source, source.currentTarget, world);
            }
        };
        Mimic.doOnStartShop = function (source, target, world) {
            if (target instanceof Balls.Powerball) {
                Balls.Powerball.onStartShop(source, world);
            }
            if (target instanceof Balls.Coin) {
                Balls.Coin.onStartShop(source, world);
            }
            if (target instanceof Balls.Seed) {
                Balls.Seed.onStartShop(source, world);
            }
            if (target instanceof Balls.ScrapCannon) {
                Balls.ScrapCannon.onStartShop(source, world);
            }
        };
        Mimic.onSell = function (source, world) {
            if (!source.currentTarget)
                return;
            Mimic.doOnSell(source, source.currentTarget, world, 1);
            if (source.shouldActivateAbilityTwice()) {
                Mimic.doOnSell(source, source.currentTarget, world, 2);
            }
        };
        Mimic.doOnSell = function (source, target, world, whichTime) {
            if (target instanceof Balls.Recycler) {
                Balls.Recycler.onSell(source, world);
            }
            if (target instanceof Balls.CrystalBall) {
                Balls.CrystalBall.onSell(source, world);
            }
            if (target instanceof Balls.RedCrystalBall) {
                Balls.RedCrystalBall.onSell(source, world);
            }
            if (target instanceof Balls.GreenCrystalBall) {
                Balls.GreenCrystalBall.onSell(source, world);
            }
            if (target instanceof Balls.OldCrystalBall) {
                Balls.OldCrystalBall.onSell(source, world);
            }
            if (target instanceof Balls.NeoCrystalBall) {
                Balls.NeoCrystalBall.onSell(source, world);
            }
            if (target instanceof Balls.Wizard && whichTime <= 1) {
                Balls.Wizard.onSell(source, world);
            }
            if (target instanceof Balls.GoldCrystalBall) {
                Balls.GoldCrystalBall.onSell(source, world);
            }
        };
        Mimic.onLevelUp = function (source, world) {
            if (!source.currentTarget)
                return;
            if (source.currentTarget instanceof Balls.Wobby) {
                Balls.Wobby.onLevelUp(source, world);
            }
        };
        Mimic.onRestock = function (source, world) {
            if (!source.currentTarget)
                return;
            if (source.currentTarget instanceof Balls.ScrapCannon) {
                Balls.ScrapCannon.onRestock(source, world);
            }
        };
        Mimic.onPlay = function (source, world) {
            if (!source.currentTarget)
                return;
            if (source.currentTarget instanceof Balls.Vagrant) {
                Balls.Vagrant.onPlay(source, world);
            }
            if (source.currentTarget instanceof Balls.BallOfIce) {
                Balls.BallOfIce.onPlay(source, world);
            }
            if (source.currentTarget instanceof Balls.Bank) {
                Balls.Bank.onPlay(source, world);
            }
            if (source.currentTarget instanceof Balls.Battery) {
                Balls.Battery.onPlay(source, world);
            }
            if (source.currentTarget instanceof Balls.Impostor) {
                world.playSound('error', { humanized: false });
                world.addWorldObject(new BallMoverError(source.x, source.y - 8, "MIMIC\nFAILED", 2));
            }
        };
        Mimic.onPreBattle = function (source, world) {
            Mimic.copyClosestAlly(source, world);
        };
        Mimic.onEnterBattle = function (source, world) {
            Mimic.copyClosestAlly(source, world);
        };
        Mimic.copyClosestAlly = function (source, world) {
            var closestAlly = Mimic.getClosestAlly(source, world);
            if (!closestAlly)
                return;
            var newBall = world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: closestAlly.properties.type,
                    damage: source.dmg,
                    health: source.hp,
                    equipment: source.equipment ? source.equipment.equipmentType : -1,
                    level: Math.ceil(closestAlly.level / 2) + source.targetLevelIncrease,
                    metadata: source.properties.metadata,
                },
            }, source.squad, source.squadIndexReference, source.team, false, false));
            newBall.timesKilledEnemy = source.timesKilledEnemy;
            world.addWorldObject(newPuff(newBall.x, newBall.y, Battle.Layers.fx, 'medium'));
            world.playSound('sellball');
            newBall.addStun('other', 1);
            source.cancelAbilities();
            source.removeFromWorld();
        };
        Mimic.getClosestAlly = function (source, world) {
            if (source.isInShop || source.isInYourSquadScene)
                return undefined;
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) {
                return !ball.isInShop && !ball.isInYourSquadScene && !(ball instanceof Mimic) && !(ball instanceof Balls.Impostor);
            });
            return M.argmin(validBalls, function (ball) { return G.distance(source, ball); });
        };
        return Mimic;
    }(Ball));
    Balls.Mimic = Mimic;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Miner = /** @class */ (function (_super) {
        __extends(Miner, _super);
        function Miner(config) {
            var _this = _super.call(this, 'balls/miner', 8, config) || this;
            _this.addAbility('onTakeDamage', Miner.onTakeDamage);
            return _this;
        }
        Miner.prototype.getName = function () { return 'Miner'; };
        Miner.prototype.getDesc = function () { return "When this takes discrete damage, drop a land mine that explodes for [r]" + this.mineDamage + "<sword>[/r] when an enemy rolls near it"; };
        Miner.prototype.getShopDmg = function () { return 1; };
        Miner.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Miner.prototype, "mineDamage", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Miner.onTakeDamage = function (source, world, damage) {
            world.addWorldObject(new LandMine(source.x, source.y, Ball.Random.inDisc(60, 120), source, source.mineDamage));
        };
        return Miner;
    }(Ball));
    Balls.Miner = Miner;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Necromancer = /** @class */ (function (_super) {
        __extends(Necromancer, _super);
        function Necromancer(config) {
            var _this = _super.call(this, 'balls/necromancer', 8, config) || this;
            _this.skeletonsSummoned = 0;
            _this.addAbility('onBallDie', Necromancer.onBallDie);
            return _this;
        }
        Necromancer.prototype.getName = function () { return 'Necromancer'; };
        Necromancer.prototype.getDesc = function () { return "When an ally dies, summon a " + buffText(this.skeletonDmg, this.skeletonHp) + " skeleton (up to " + this.maxSkeletons + " total)"; };
        Necromancer.prototype.getShopDmg = function () { return 1; };
        Necromancer.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Necromancer.prototype, "skeletonDmg", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Necromancer.prototype, "skeletonHp", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Necromancer.prototype, "maxSkeletons", {
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Necromancer.onBallDie = function (source, world, ballThatDied) {
            if (ballThatDied.team !== source.team)
                return;
            if (source.skeletonsSummoned >= source.maxSkeletons)
                return;
            var p = source.getPosition().add(Ball.Random.onCircle(16));
            var ball = world.addWorldObject(squadBallToWorldBall({
                x: p.x,
                y: p.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: source.skeletonDmg,
                    health: source.skeletonHp,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
            source.addChild(new Sprite({
                texture: 'necromancerbeams',
                copyFromParent: ['layer'],
                scale: (source.physicalRadius + 10) / 64,
                life: 0.7,
                vangle: 180,
                update: function () {
                    this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                    World.Actions.orderWorldObjectBefore(this, this.parent);
                },
            }));
            world.addWorldObject(new BurstPuffSystem({
                x: ball.x,
                y: ball.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(10 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.7,
                    v: Random.inCircle(80),
                    color: 0xEC77FF,
                    finalColor: 0x57007F,
                    radius: 4,
                    finalRadius: 0,
                }); },
            }));
            source.skeletonsSummoned++;
        };
        return Necromancer;
    }(Ball));
    Balls.Necromancer = Necromancer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var NeoCrystalBall = /** @class */ (function (_super) {
        __extends(NeoCrystalBall, _super);
        function NeoCrystalBall(config) {
            var _this = _super.call(this, 'balls/neocrystalball', 8, config) || this;
            _this.overlay = _this.addChild(new Sprite({
                texture: 'neocrystalballoverlay',
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onSell', NeoCrystalBall.onSell);
            return _this;
        }
        NeoCrystalBall.prototype.getName = function () { return 'Neo Crystal Ball'; };
        NeoCrystalBall.prototype.getDesc = function () { return "On sell, give a random ally either [g]" + NeoCrystalBall.getBuffAmount(this) + "<heart>[/g] or [r]" + NeoCrystalBall.getBuffAmount(this) + "<sword>[/r] (random)"; };
        NeoCrystalBall.prototype.getShopDmg = function () { return 2; };
        NeoCrystalBall.prototype.getShopHp = function () { return 4; };
        NeoCrystalBall.getBuffAmount = function (source) { return 2 * source.level; };
        NeoCrystalBall.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.overlay.alpha = this.alpha;
            this.overlay.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.overlay, this);
        };
        NeoCrystalBall.onSell = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBuff = Ball.Random.boolean() ? { dmg: NeoCrystalBall.getBuffAmount(source), hp: 0 } : { dmg: 0, hp: NeoCrystalBall.getBuffAmount(source) };
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, randomBuff, function (_) { return Ball.Random.element(validBalls); }));
        };
        return NeoCrystalBall;
    }(Ball));
    Balls.NeoCrystalBall = NeoCrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Ninja = /** @class */ (function (_super) {
        __extends(Ninja, _super);
        function Ninja(config) {
            var _this = _super.call(this, 'balls/ninja', 8, config) || this;
            _this.addAbility('onPreBattle', Ninja.onPreBattle);
            _this.addAbility('onEnterBattle', Ninja.onEnterBattle);
            return _this;
        }
        Ninja.prototype.getName = function () { return 'Ninja'; };
        Ninja.prototype.getDesc = function () { return "On enter battle, shoot [lb]" + this.spikes + "[/lb] [r]" + this.spikeDamage + "<sword>[/r] homing spikes at the enemy with the lowest [g]<heart>[/g]\n\nCannot target Grenades"; };
        Ninja.prototype.getShopDmg = function () { return 4; };
        Ninja.prototype.getShopHp = function () { return 2; };
        Ninja.prototype.getCredits = function () { return [CreditsNames.BALLAM]; };
        Object.defineProperty(Ninja.prototype, "spikes", {
            get: function () { return 2 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Ninja.prototype, "spikeDamage", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Ninja.onPreBattle = function (source, world) {
            Ninja.shootSpikes(source, world);
        };
        Ninja.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Ninja.shootSpikes(source, world);
        };
        Ninja.shootSpikes = function (source, world) {
            var e_171, _a;
            var validBalls = getEnemies(world, source).filter(function (ball) { return !(ball instanceof Balls.Grenade); });
            if (validBalls.length === 0)
                return;
            var spikeCounts = M.batch(source.spikes, 20);
            var weakestBall = M.argmin(validBalls, function (ball) { return ball.hp; });
            var spikes = [];
            try {
                for (var spikeCounts_5 = __values(spikeCounts), spikeCounts_5_1 = spikeCounts_5.next(); !spikeCounts_5_1.done; spikeCounts_5_1 = spikeCounts_5.next()) {
                    var count = spikeCounts_5_1.value;
                    var spike = world.addWorldObject(new HomingSpike(source.x, source.y, source, weakestBall, source.spikeDamage, count, function (enemyBalls) { return undefined; }));
                    spikes.push(spike);
                    source.didShootProjectile(count);
                }
            }
            catch (e_171_1) { e_171 = { error: e_171_1 }; }
            finally {
                try {
                    if (spikeCounts_5_1 && !spikeCounts_5_1.done && (_a = spikeCounts_5.return)) _a.call(spikeCounts_5);
                }
                finally { if (e_171) throw e_171.error; }
            }
            source.setPreBattleAbilityActiveCheck(function () { return spikes.some(function (spike) { return spike.world; }); });
        };
        return Ninja;
    }(Ball));
    Balls.Ninja = Ninja;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Normal = /** @class */ (function (_super) {
        __extends(Normal, _super);
        function Normal(config) {
            return _super.call(this, 'balls/normal', 8, config) || this;
        }
        Normal.prototype.getName = function () { return this.team === 'neutral' ? 'Neutral Ball' : 'Basic Ball'; };
        Normal.prototype.getDesc = function () { return this.team === 'neutral' ? 'Attacks both teams' : 'No effect :('; };
        return Normal;
    }(Ball));
    Balls.Normal = Normal;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Nullifier = /** @class */ (function (_super) {
        __extends(Nullifier, _super);
        function Nullifier(config) {
            var _this = _super.call(this, 'balls/nullifier', 8, config) || this;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', Nullifier.onPreBattle);
            _this.addAbility('onEnterBattle', Nullifier.onEnterBattle);
            _this.addAbility('onDeath', Nullifier.onDeath, { nullifyable: false });
            _this.addAbility('update', Nullifier.update);
            return _this;
        }
        Nullifier.prototype.getName = function () { return 'Nullifier'; };
        Nullifier.prototype.getDesc = function () {
            if (this.nullifyTime === 0)
                return "Completely disable the effects and equipment of a random enemy with a battle effect until the battle starts";
            var max = this.nullifyTime === this.maxNullifyTime ? ' (max)' : '';
            return "Completely disable the effects and equipment of a random enemy with a battle effect until the battle starts and [lb]" + this.nullifyTime + "s[/lb] after" + max;
        };
        Nullifier.prototype.getShopDmg = function () { return 2; };
        Nullifier.prototype.getShopHp = function () { return 6; };
        Nullifier.prototype.getCredits = function () { return [CreditsNames.TOMMYDOG145]; };
        Object.defineProperty(Nullifier.prototype, "nullifyTime", {
            get: function () {
                if (this.level === 1)
                    return 0;
                if (this.level === 2)
                    return 2;
                if (this.level === 3)
                    return 4;
                if (this.level === 4)
                    return 5;
                if (this.level === 5)
                    return 5.5;
                if (this.level === 6)
                    return 6;
                if (this.level === 7)
                    return 6.5;
                return this.maxNullifyTime;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Nullifier.prototype, "maxNullifyTime", {
            get: function () { return 7; },
            enumerable: false,
            configurable: true
        });
        Nullifier.onPreBattle = function (source, world) {
            Nullifier.selectTarget(source, world);
            Nullifier.nullifyTarget(source, world);
        };
        Nullifier.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Nullifier.selectTarget(source, world);
            Nullifier.nullifyTarget(source, world);
        };
        Nullifier.onDeath = function (source, world, killedBy) {
            if (!source.target)
                return;
            source.target.removeNullified();
        };
        Nullifier.selectTarget = function (source, world) {
            var enemies = getEnemies(world, source).filter(function (ball) { return !(ball instanceof Nullifier) && !ball.statusEffects.find(function (effect) { return effect.type === 'nullified'; }); });
            var battleEnemies = enemies.filter(function (ball) { return ball.hasBattleEffect(); });
            if (battleEnemies.length > 0)
                enemies = battleEnemies;
            if (enemies.length === 0)
                return;
            source.target = Ball.Random.element(enemies);
        };
        Nullifier.update = function (source, world) {
            if (source.state === Ball.States.PREP)
                return;
            if (getBattleState(world) === Ball.States.BATTLE)
                return;
            Nullifier.nullifyTarget(source, world);
        };
        Nullifier.nullifyTarget = function (source, world) {
            if (!source.target)
                return;
            source.target.addNullified(Math.max(source.nullifyTime, 0.2));
            source.target.cancelAbilities();
        };
        return Nullifier;
    }(Ball));
    Balls.Nullifier = Nullifier;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var OldCrystalBall = /** @class */ (function (_super) {
        __extends(OldCrystalBall, _super);
        function OldCrystalBall(config) {
            var _this = _super.call(this, 'balls/oldcrystalball', 8, config) || this;
            _this.addAbility('onSell', OldCrystalBall.onSell);
            return _this;
        }
        OldCrystalBall.prototype.getName = function () { return 'Old Crystal Ball'; };
        OldCrystalBall.prototype.getDesc = function () { return "On sell, give [r]" + OldCrystalBall.getBuffAmount(this) + "<sword>[/r] to all shop balls"; };
        OldCrystalBall.prototype.getShopDmg = function () { return 6; };
        OldCrystalBall.prototype.getShopHp = function () { return 2; };
        OldCrystalBall.getBuffAmount = function (source) { return source.level; };
        OldCrystalBall.onSell = function (source, world) {
            var e_172, _a;
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return ball.isInShop; });
            if (validBalls.length === 0)
                return;
            try {
                for (var validBalls_7 = __values(validBalls), validBalls_7_1 = validBalls_7.next(); !validBalls_7_1.done; validBalls_7_1 = validBalls_7.next()) {
                    var ball = validBalls_7_1.value;
                    world.addWorldObject(new RandomBuff(source.x, source.y, source, ball, { dmg: OldCrystalBall.getBuffAmount(source), hp: 0 }, function (_) { return undefined; }));
                }
            }
            catch (e_172_1) { e_172 = { error: e_172_1 }; }
            finally {
                try {
                    if (validBalls_7_1 && !validBalls_7_1.done && (_a = validBalls_7.return)) _a.call(validBalls_7);
                }
                finally { if (e_172) throw e_172.error; }
            }
        };
        return OldCrystalBall;
    }(Ball));
    Balls.OldCrystalBall = OldCrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Phoenix = /** @class */ (function (_super) {
        __extends(Phoenix, _super);
        function Phoenix(config) {
            var _this = _super.call(this, 'balls/phoenix', 8, config) || this;
            _this.isResurrection = false;
            _this.canExplode = true;
            _this.visibleExplosionRadius = _this.explosionRadius;
            _this.fuseTime = 0;
            _this.fuseFilter = new Effects.Filters.Silhouette(0xFF8F00, 1);
            _this.fuseFilter.amount = 0;
            var i = _this.effects.pre.filters.findIndex(function (f) { return f instanceof BallTeamColorFilter; });
            _this.effects.pre.filters.splice(i + 1, 0, _this.fuseFilter);
            _this.addAbility('update', Phoenix.update, { canActivateTwice: false });
            _this.addAbility('onDeath', Phoenix.onDeath, { canActivateTwice: false });
            return _this;
        }
        Phoenix.prototype.getName = function () { return 'Phoenix'; };
        Phoenix.prototype.getDesc = function () { return "Burst into flames after " + this.explodeTime + "s, igniting enemies for [lb]" + this.burnTime + "s[/lb], and [y]resurrect shortly after[/y]\n\nBurning balls take [r]1<sword>/s[/r]"; };
        Phoenix.prototype.getShopDmg = function () { return 3; };
        Phoenix.prototype.getShopHp = function () { return 6; };
        Phoenix.prototype.getCredits = function () { return [CreditsNames.FIREBALLME]; };
        Object.defineProperty(Phoenix.prototype, "explodeTime", {
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Phoenix.prototype, "burnTime", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Phoenix.prototype, "explosionRadius", {
            get: function () { return this.physicalRadius - 8 + 40 * (1 + (this.level - 1) * 0.25); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Phoenix.prototype, "yourSquadRadius", {
            get: function () { return 15; },
            enumerable: false,
            configurable: true
        });
        Phoenix.prototype.render = function (texture, x, y) {
            var drawRadius = this.isInYourSquadScene ? this.yourSquadRadius : this.visibleExplosionRadius;
            Draw.brush.color = Color.lerpColorByLch(0xFF8F00, 0xFFBF00, Tween.Easing.OscillateSine(2)(this.life.time));
            Draw.brush.alpha = 0.6;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, drawRadius, Draw.ALIGNMENT_INNER);
            _super.prototype.render.call(this, texture, x, y);
        };
        Phoenix.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.isInShop && !this.isBeingMoved()) {
                this.visibleExplosionRadius = 0;
            }
            else if (!this.canExplode) {
                this.visibleExplosionRadius = 0;
            }
            else {
                this.visibleExplosionRadius = M.lerpTime(this.visibleExplosionRadius, this.explosionRadius, 100, this.delta);
            }
        };
        Phoenix.prototype.setForInShop = function () {
            this.visibleExplosionRadius = 0;
        };
        Phoenix.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            if (!source.canExplode)
                return;
            source.fuseTime += source.delta;
            source.fuseFilter.amount = M.mapClamp(source.timeInBattle, 0, source.explodeTime, 0, 1);
            if (source.fuseTime >= source.explodeTime) {
                var hp = source.hp;
                var dmg = source.dmg;
                source.takeDamage(2 * source.hp, source, 'other', true);
                Phoenix.explode(source, world, hp, dmg);
            }
        };
        Phoenix.onDeath = function (source, world, killedBy) {
            if (!source.canExplode)
                return;
            Phoenix.explode(source, world, 0, 1);
        };
        Phoenix.explode = function (source, world, hp, dmg) {
            world.addWorldObject(new PhoenixAshes(source.x, source.y, source, hp, dmg));
            world.addWorldObject(new FireExplosion(source.x, source.y, source.explosionRadius, source.burnTime, source));
            source.canExplode = false;
        };
        return Phoenix;
    }(Ball));
    Balls.Phoenix = Phoenix;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Pickleball = /** @class */ (function (_super) {
        __extends(Pickleball, _super);
        function Pickleball(config) {
            var _this = _super.call(this, 'balls/pickleball', 8, config) || this;
            _this.addAbility('onBuy', Pickleball.onBuy, { canActivateTwice: false });
            return _this;
        }
        Pickleball.prototype.getName = function () { return 'Pickleball'; };
        Pickleball.prototype.getDesc = function () { return "On buy, replace the shop's inventory with pickles"; };
        Pickleball.prototype.getShopDmg = function () { return 2; };
        Pickleball.prototype.getShopHp = function () { return 1; };
        Pickleball.onBuy = function (source, world) {
            Shop.restockPickles(world);
            if (source.shouldActivateAbilityTwice()) {
                source.doAfterTime(0.5, function () { return Shop.restockPickles(world); });
            }
        };
        return Pickleball;
    }(Ball));
    Balls.Pickleball = Pickleball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Pinata = /** @class */ (function (_super) {
        __extends(Pinata, _super);
        function Pinata(config) {
            var _this = _super.call(this, 'balls/pinata', 8, config) || this;
            _this.addAbility('onBuy', Pinata.onBuy);
            _this.addAbility('onDeath', Pinata.onDeath);
            return _this;
        }
        Pinata.prototype.getName = function () { return 'Pi<ntick>ata'; };
        Pinata.prototype.getDesc = function () { return "Happy Birthday!"; };
        Pinata.prototype.getShopDmg = function () { return 1; };
        Pinata.prototype.getShopHp = function () { return 1; };
        Object.defineProperty(Pinata.prototype, "numberOfThings", {
            get: function () { return 2 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Pinata.prototype, "power", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Pinata.onBuy = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            var buff = Ball.Random.boolean() ? { dmg: 1, hp: 0 } : { dmg: 0, hp: 1 };
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, buff, function (_) { return Ball.Random.element(validBalls); }));
        };
        Pinata.onDeath = function (source, world, killedBy) {
            world.addWorldObject(new Explosion(source.x, source.y, source.physicalRadius, { ally: 0, enemy: 0 }));
            world.addWorldObject(newBdayPuff(source.x, source.y, Battle.Layers.fx, 'medium'));
            world.playSound('popper');
            world.playSound('confetti');
            var createThingElements = [
                function () { return Pinata.createMedkit(source, world); },
                function () { return Pinata.createMedkitDmg(source, world); },
                function () { return Pinata.createLandmine(source, world); },
            ];
            for (var i = 0; i < source.numberOfThings; i++) {
                Ball.Random.element(createThingElements)();
            }
        };
        Pinata.createMedkit = function (source, world) {
            world.addWorldObject(new Medpack(source.x, source.y, Ball.Random.inDisc(60, 120), source, source.power));
        };
        Pinata.createMedkitDmg = function (source, world) {
            world.addWorldObject(new MedkitDmg(source.x, source.y, Ball.Random.inDisc(60, 120), source, source.power));
        };
        Pinata.createLandmine = function (source, world) {
            world.addWorldObject(new LandMine(source.x, source.y, Ball.Random.inDisc(60, 120), source, source.power));
        };
        return Pinata;
    }(Ball));
    Balls.Pinata = Pinata;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var PokeBall = /** @class */ (function (_super) {
        __extends(PokeBall, _super);
        function PokeBall(config) {
            var _this = _super.call(this, 'balls/pokeball', 8, config) || this;
            _this.canBeTargetedForDeath = false;
            _this.absorbedBalls = [];
            _this.crosshair = _this.addChild(new Sprite({
                texture: 'crosshair',
                alpha: 0,
            }));
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', PokeBall.onPreBattle);
            _this.addAbility('onEnterBattle', PokeBall.onEnterBattle);
            _this.addAbility('onDeath', PokeBall.onDeath, { canActivateTwice: false });
            return _this;
        }
        PokeBall.prototype.getName = function () { return 'Pok<etick> Ball'; };
        PokeBall.prototype.getDesc = function () {
            var levelDiffDisplay = '';
            if (this.levelDiff < 0)
                levelDiffDisplay = " with -[gold]" + -this.levelDiff + "<star>[/gold]";
            if (this.levelDiff > 0)
                levelDiffDisplay = " with +[gold]" + this.levelDiff + "<star>[/gold]";
            return "At the start of battle, kill the closest ally, storing it inside. On death, resummon the stored ally" + levelDiffDisplay + "\n\nCannot be killed by an ally at the start of battle";
        };
        PokeBall.prototype.getShopDmg = function () { return 3; };
        PokeBall.prototype.getShopHp = function () { return 3; };
        Object.defineProperty(PokeBall.prototype, "levelDiff", {
            get: function () { return this.level - 1; },
            enumerable: false,
            configurable: true
        });
        PokeBall.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            if (this.world.getLayerByName(Battle.Layers.fx)) {
                this.crosshair.layer = Battle.Layers.fx;
            }
        };
        PokeBall.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            var hasActivatedAbility = A.overlaps(this.activatedAbilities, ['onPreBattle', 'onEnterBattle']);
            var closestAlly = PokeBall.getClosestAlly(this, this.world);
            if (this.isInShop || this.isInYourSquadScene || !closestAlly || this.isNullified() || hasActivatedAbility || this.state === Ball.States.BATTLE) {
                this.crosshair.alpha = M.moveToClamp(this.crosshair.alpha, 0, 4, this.delta);
            }
            else {
                this.crosshair.teleport(closestAlly);
                this.crosshair.alpha = M.moveToClamp(this.crosshair.alpha, 0.8, 1, this.delta);
            }
        };
        PokeBall.prototype.setForInShop = function () {
            _super.prototype.setForInShop.call(this);
            this.crosshair.alpha = 0;
        };
        PokeBall.onPreBattle = function (source, world) {
            PokeBall.eatAlly(source, world);
        };
        PokeBall.onEnterBattle = function (source, world) {
            var battleTimer = world.select.type(BattleTimer, false);
            var timeInBattle = battleTimer ? battleTimer.battleTime : 0;
            if (timeInBattle > 0.3 || source.hasActivatedAbility('onPreBattle'))
                return;
            PokeBall.eatAlly(source, world);
        };
        PokeBall.eatAlly = function (source, world) {
            var ballToAbsorb = PokeBall.getClosestAlly(source, world);
            if (!ballToAbsorb)
                return;
            source.absorbedBalls.push(ballToAbsorb);
            ballToAbsorb.targetedForDeath = true;
            ballToAbsorb.cancelAbilities();
            var absorbedHp = ballToAbsorb.hp;
            world.addWorldObject(new InstantKillSlash(ballToAbsorb, source));
            ballToAbsorb.hp = absorbedHp;
            world.addWorldObject(newPuff(ballToAbsorb.x, ballToAbsorb.y, Battle.Layers.fx, 'medium'));
            source.flash(0xFFFFFF, 1);
        };
        PokeBall.onDeath = function (source, world, killedBy) {
            if (_.isEmpty(source.absorbedBalls))
                return;
            for (var i = 0; i < source.absorbedBalls.length; i++) {
                var absorbedBall = source.absorbedBalls[i];
                var equipment = absorbedBall.equipment ? absorbedBall.equipment.equipmentType : -1;
                if (equipment === 20) { // Disallow Best Friend
                    equipment = -1;
                }
                var d = source.absorbedBalls.length === 1 ? Vector2.ZERO : Vector2.RIGHT.rotate(360 * i / source.absorbedBalls.length).scale(8);
                var ball = world.addWorldObject(squadBallToWorldBall({
                    x: source.x + d.x,
                    y: source.y + d.y,
                    properties: {
                        type: absorbedBall.properties.type,
                        damage: absorbedBall.dmg,
                        health: absorbedBall.hp,
                        equipment: equipment,
                        level: Math.max(absorbedBall.level + source.levelDiff, 1),
                        metadata: absorbedBall.properties.metadata,
                    },
                }, absorbedBall.squad, absorbedBall.squadIndexReference, source.team));
                ball.timesKilledEnemy = absorbedBall.timesKilledEnemy;
            }
            source.absorbedBalls = [];
        };
        PokeBall.getClosestAlly = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return ball.canBeTargetedForDeath && !ball.targetedForDeath && !ball.isInShop; });
            if (validBalls.length === 0)
                return undefined;
            return M.argmin(validBalls, function (ball) { return G.distance(source, ball); });
        };
        return PokeBall;
    }(Ball));
    Balls.PokeBall = PokeBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Powerball = /** @class */ (function (_super) {
        __extends(Powerball, _super);
        function Powerball(config) {
            var _this = _super.call(this, 'balls/powerball', 8, config) || this;
            _this.addAbility('onStartShop', Powerball.onStartShop);
            return _this;
        }
        Powerball.prototype.getName = function () { return 'Powerball'; };
        Powerball.prototype.getDesc = function () { return "Start the shop with [gold]<coin>" + Powerball.getGoldGain(this) + " extra[/gold] ([gold]<coin>3[/gold] max)"; };
        Powerball.prototype.getShopDmg = function () { return 1; };
        Powerball.prototype.getShopHp = function () { return 3; };
        Powerball.getGoldGain = function (source) { return Math.min(source.level, 3); };
        Powerball.onStartShop = function (source, world) {
            addStartShopEffect({
                type: 'gold',
                sourceSquadIndex: source.squadIndexReference,
                gold: Powerball.getGoldGain(source),
            });
        };
        return Powerball;
    }(Ball));
    Balls.Powerball = Powerball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Psychic = /** @class */ (function (_super) {
        __extends(Psychic, _super);
        function Psychic(config) {
            var _this = _super.call(this, 'balls/psychic', 8, config) || this;
            _this.eye = _this.addChild(new Sprite({
                animations: [Animations.fromTextureList({ name: 'glow', textureRoot: 'psychiceye', textures: [0, 1], frameRate: 16, count: Infinity })],
                defaultAnimation: 'glow',
                tint: 0xFF44FF,
                alpha: 0.6,
                copyFromParent: ['layer'],
                visible: false,
            }));
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFF44FF,
                alpha: 0.5,
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
                visible: false,
            }));
            _this.wub = new Sound('wub');
            _this.wub.loop = true;
            _this.wub.volume = 0;
            _this.lastTargeting = false;
            _this.timesAbilityActivated = 0;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', Psychic.onPreBattle, { canActivateTwice: false });
            _this.addAbility('onEnterBattle', Psychic.onEnterBattle, { canActivateTwice: false });
            return _this;
        }
        Psychic.prototype.getName = function () { return 'Psychic'; };
        Psychic.prototype.getDesc = function () {
            var amount = this.maxHits === 1 ? 'once' : (this.maxHits === 2 ? 'twice' : this.maxHits + " times");
            return "Lock the enemy with the highest [r]<sword>[/r] in place until it is hit [lb]" + amount + "[/lb]\n\nThe locked enemy takes half damage, but deals none";
        };
        Psychic.prototype.getShopDmg = function () { return 2; };
        Psychic.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Psychic.prototype, "maxHits", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Psychic.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            this.wub.controller = this.world.soundManager;
        };
        Psychic.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            World.Actions.orderWorldObjectAfter(this.eye, this);
            World.Actions.orderWorldObjectAfter(this.aura, this);
            if (this.isTargeting()) {
                this.setTexture(this.animationManager.animations['prep'][0].texture);
                this.angle = 0;
            }
        };
        Psychic.prototype.updateBattle = function () {
            var _this = this;
            _super.prototype.updateBattle.call(this);
            if (this.isTargeting()) {
                this.target.addStun('psychic', 0.1);
                this.eye.setVisible(true);
                this.aura.setVisible(true);
                this.aura.scale = M.lerp(12, 14, M.mod(Math.floor(this.life.time * 16), 2)) / 64;
                this.wub.volume = M.lerpTime(this.wub.volume, 1, 5, this.delta);
            }
            else {
                this.eye.setVisible(false);
                this.aura.setVisible(false);
                this.wub.volume = M.lerpTime(this.wub.volume, 0, 5, this.delta);
                if (this.lastTargeting && this.timesAbilityActivated === 1 && this.shouldActivateAbilityTwice()) {
                    this.doAfterTime(0.5, function () { return Psychic.startPsychicing(_this, _this.world); });
                }
            }
            this.wub.update(this.delta);
            this.lastTargeting = this.isTargeting();
        };
        Psychic.prototype.isTargeting = function () {
            var _this = this;
            var totalMaxHits = this.world.select.typeAll(Balls.Psychic).filter(function (ball) { return ball.team === _this.team; }).map(function (ball) { return ball.maxHits; }).reduce(function (a, b) { return a + b; });
            return this.target && this.target.world && this.target.timesTakenDamage - this.startTimesHit < totalMaxHits;
        };
        Psychic.onPreBattle = function (source, world) {
            Psychic.startPsychicing(source, world);
        };
        Psychic.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Psychic.startPsychicing(source, world);
        };
        Psychic.startPsychicing = function (source, world) {
            source.timesAbilityActivated++;
            source.runScript(S.chain(S.yield(), S.call(function () {
                var validEnemies = getEnemies(world, source);
                if (validEnemies.length === 0)
                    return;
                source.target = M.argmax(validEnemies, function (ball) { return ball.dmg; });
                source.startTimesHit = source.target.timesTakenDamage;
            })));
        };
        return Psychic;
    }(Ball));
    Balls.Psychic = Psychic;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var QuestionBall = /** @class */ (function (_super) {
        __extends(QuestionBall, _super);
        function QuestionBall(config) {
            var _this = _super.call(this, 'balls/questionball', 8, config) || this;
            _this.currentGold = 0;
            _this.angle = 90;
            _this.addAbility('onTakeDamage', QuestionBall.onTakeDamage);
            return _this;
        }
        QuestionBall.prototype.getName = function () { return '? Ball'; };
        QuestionBall.prototype.getDesc = function () { return "When this takes discrete damage, gain [gold]<coin>1[/gold] (max [lb]" + this.maxGold + "[/lb])"; };
        QuestionBall.prototype.getShopDmg = function () { return 1; };
        QuestionBall.prototype.getShopHp = function () { return 3; };
        QuestionBall.prototype.getCredits = function () { return [CreditsNames.POPAN, CreditsNames.MATERWELONS]; };
        Object.defineProperty(QuestionBall.prototype, "maxGold", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        QuestionBall.onTakeDamage = function (source, world, damage) {
            if (source.currentGold >= source.maxGold)
                return;
            if (source.team === 'friend' && youArePlaying(world)) {
                addStartShopEffect({
                    type: 'gold',
                    gold: 1,
                    sourceSquadIndex: source.squadIndexReference,
                });
            }
            source.currentGold++;
            source.flash(0xFFFFFF, 1, 0.2);
            world.playSound('mariocoin', { humanized: false });
            if (source.currentGold >= source.maxGold) {
                source.changeBaseTextureAndRadius('balls/questionballspent', source.radius);
            }
        };
        return QuestionBall;
    }(Ball));
    Balls.QuestionBall = QuestionBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Recycler = /** @class */ (function (_super) {
        __extends(Recycler, _super);
        function Recycler(config) {
            var _this = _super.call(this, 'balls/recycler', 8, config) || this;
            _this.addAbility('onSell', Recycler.onSell);
            return _this;
        }
        Recycler.prototype.getName = function () { return 'Recycler'; };
        Recycler.prototype.getDesc = function () { return "On sell, gain [lb]" + Recycler.getFreeRestocks(this) + "[/lb] free restocks for this round"; };
        Recycler.prototype.getShopDmg = function () { return 2; };
        Recycler.prototype.getShopHp = function () { return 2; };
        Recycler.getFreeRestocks = function (source) { return 1 + source.level; };
        Recycler.onSell = function (source, world) {
            GAME_DATA.freeRestocksUntilPlay += Recycler.getFreeRestocks(source);
        };
        return Recycler;
    }(Ball));
    Balls.Recycler = Recycler;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var RedCrystalBall = /** @class */ (function (_super) {
        __extends(RedCrystalBall, _super);
        function RedCrystalBall(config) {
            var _this = _super.call(this, 'balls/redcrystalball', 8, config) || this;
            _this.addAbility('onSell', RedCrystalBall.onSell);
            return _this;
        }
        RedCrystalBall.prototype.getName = function () { return 'Crystal Ball [r]<sword>[/r]'; };
        RedCrystalBall.prototype.getDesc = function () { return "On sell, give [r]" + RedCrystalBall.getBuffAmount(this) + "<sword>[/r] to a random ally"; };
        RedCrystalBall.prototype.getShopDmg = function () { return 1; };
        RedCrystalBall.prototype.getShopHp = function () { return 3; };
        RedCrystalBall.getBuffAmount = function (source) { return source.level; };
        RedCrystalBall.onSell = function (source, world) {
            var validBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !ball.isInShop; });
            if (validBalls.length === 0)
                return;
            var randomBall = Ball.Random.element(validBalls);
            world.addWorldObject(new RandomBuff(source.x, source.y, source, randomBall, { dmg: RedCrystalBall.getBuffAmount(source), hp: 0 }, function (_) { return Ball.Random.element(validBalls); }));
        };
        return RedCrystalBall;
    }(Ball));
    Balls.RedCrystalBall = RedCrystalBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Reducer = /** @class */ (function (_super) {
        __extends(Reducer, _super);
        function Reducer(config) {
            var _this = _super.call(this, 'balls/reducer', 8, config) || this;
            _this.addAbility('onPreBattle', Reducer.onPreBattle);
            _this.addAbility('onEnterBattle', Reducer.onEnterBattle);
            return _this;
        }
        Reducer.prototype.getName = function () { return 'Reducer'; };
        Reducer.prototype.getDesc = function () {
            if (this.starsToRemove === 1)
                return "On enter battle, remove [lb]1[/lb] star from a random enemy";
            return "On enter battle, remove [lb]" + this.starsToRemove + "[/lb] stars from random enemies";
        };
        Reducer.prototype.getShopDmg = function () { return 3; };
        Reducer.prototype.getShopHp = function () { return 3; };
        Reducer.prototype.getCredits = function () { return [CreditsNames.ACIDGUY, CreditsNames.JUNJ]; };
        Object.defineProperty(Reducer.prototype, "starsToRemove", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Reducer.onPreBattle = function (source, world) {
            Reducer.removeStarsFromEnemies(source, world);
        };
        Reducer.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Reducer.removeStarsFromEnemies(source, world);
        };
        Reducer.removeStarsFromEnemies = function (source, world) {
            var validBalls = getEnemies(world, source).filter(function (ball) { return ball.level > 1; });
            if (validBalls.length === 0)
                return;
            var deleveledBalls = [];
            var deboosts = [];
            var _loop_23 = function (i) {
                var ball = Ball.Random.element(validBalls);
                if (!ball)
                    return "break";
                var deboost = world.addWorldObject(new RandomDeboost(source.x, source.y, source, ball, Ball.Random.float(0.2, 0.6), function (enemies) { return Ball.Random.element(enemies); }));
                deboosts.push(deboost);
                deleveledBalls.push(ball);
                if (deleveledBalls.filter(function (b) { return b === ball; }).length === ball.level - 1) {
                    A.removeAll(validBalls, ball);
                }
            };
            for (var i = 0; i < source.starsToRemove; i++) {
                var state_6 = _loop_23(i);
                if (state_6 === "break")
                    break;
            }
            source.setPreBattleAbilityActiveCheck(function () { return deboosts.some(function (deboost) { return deboost.world; }); });
        };
        return Reducer;
    }(Ball));
    Balls.Reducer = Reducer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Sapper = /** @class */ (function (_super) {
        __extends(Sapper, _super);
        function Sapper(config) {
            var _this = _super.call(this, 'balls/sapper', 8, config) || this;
            _this.addAbility('onPreBattle', Sapper.onPreBattle);
            _this.addAbility('onEnterBattle', Sapper.onEnterBattle);
            return _this;
        }
        Sapper.prototype.getName = function () { return 'Sapper'; };
        Sapper.prototype.getDesc = function () {
            if (this.saps === 1)
                return "On enter battle, break the equipment of a random enemy";
            return "On enter battle, break the equipment of [lb]" + this.saps + "[/lb] random enemies";
        };
        Sapper.prototype.getShopDmg = function () { return 4; };
        Sapper.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Sapper.prototype, "saps", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Sapper.onPreBattle = function (source, world) {
            Sapper.sap(source, world);
        };
        Sapper.onEnterBattle = function (source, world) {
            if (source.hasActivatedAbility('onPreBattle'))
                return;
            Sapper.sap(source, world);
        };
        Sapper.sap = function (source, world) {
            var e_173, _a;
            var currentSaps = world.select.typeAll(HomingSap).filter(function (sap) { return sap.team === source.team; });
            var validEnemies = getEnemies(world, source).filter(function (ball) { return ball.equipment && !currentSaps.some(function (sap) { return sap.target === ball; }); });
            if (validEnemies.length === 0)
                return;
            if (validEnemies.length > source.saps) {
                Ball.Random.shuffle(validEnemies);
                validEnemies = validEnemies.slice(0, source.saps);
            }
            var saps = [];
            try {
                for (var validEnemies_2 = __values(validEnemies), validEnemies_2_1 = validEnemies_2.next(); !validEnemies_2_1.done; validEnemies_2_1 = validEnemies_2.next()) {
                    var enemy = validEnemies_2_1.value;
                    var sap = world.addWorldObject(new HomingSap(source.x, source.y, source.team, enemy));
                    saps.push(sap);
                }
            }
            catch (e_173_1) { e_173 = { error: e_173_1 }; }
            finally {
                try {
                    if (validEnemies_2_1 && !validEnemies_2_1.done && (_a = validEnemies_2.return)) _a.call(validEnemies_2);
                }
                finally { if (e_173) throw e_173.error; }
            }
            source.setPreBattleAbilityActiveCheck(function () { return saps.some(function (sap) { return sap.world; }); });
        };
        return Sapper;
    }(Ball));
    Balls.Sapper = Sapper;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Scavenger = /** @class */ (function (_super) {
        __extends(Scavenger, _super);
        function Scavenger(config) {
            var _this = _super.call(this, 'balls/scavenger', 8, config) || this;
            _this.restocksGained = 0;
            _this.addAbility('onKill', Scavenger.onKill);
            return _this;
        }
        Scavenger.prototype.getName = function () { return 'Scavenger'; };
        Scavenger.prototype.getDesc = function () {
            var s = this.freeRestocksPerKill === 1 ? '' : 's';
            return "Gain [lb]" + this.freeRestocksPerKill + "[/lb] free restock" + s + " next\nround for each kill (max " + this.limit + ")";
        };
        Scavenger.prototype.getShopDmg = function () { return 3; };
        Scavenger.prototype.getShopHp = function () { return 1; };
        Scavenger.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        Object.defineProperty(Scavenger.prototype, "freeRestocksPerKill", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Scavenger.prototype, "limit", {
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Scavenger.onKill = function (source, world, killed) {
            if (source.team !== 'friend' || !youArePlaying(world))
                return;
            if (source.restocksGained >= source.limit)
                return;
            var restocksToGain = M.clamp(source.freeRestocksPerKill, 0, source.limit - source.restocksGained);
            addStartShopEffect({
                type: 'restocks',
                sourceSquadIndex: source.squadIndexReference,
                restocks: restocksToGain,
            });
            source.restocksGained += restocksToGain;
        };
        return Scavenger;
    }(Ball));
    Balls.Scavenger = Scavenger;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var ScrapCannon = /** @class */ (function (_super) {
        __extends(ScrapCannon, _super);
        function ScrapCannon(config) {
            var _this = _super.call(this, 'balls/scrapcannon', 8, config) || this;
            if (_this.properties.metadata.currentRoundPower === undefined) {
                _this.properties.metadata.currentRoundPower = 0;
            }
            _this.powerFilter = new PowerFilter(ScrapCannon.getPowerPercent(_this));
            _this.gun = _this.addChild(new Sprite({
                texture: getCannonTextureForAngleFrame(0, 0),
                copyFromParent: ['layer'],
                effects: { post: { filters: [_this.powerFilter] } },
                data: {
                    gunAngle: 0,
                    gunTime: 0,
                },
                update: function () {
                    this.data.gunTime = M.clamp(this.data.gunTime - 2 * this.delta, 0, 1);
                    var frame = Math.ceil(M.lerp(2, 0, 1 - this.data.gunTime));
                    this.setTexture(getCannonTextureForAngleFrame(this.data.gunAngle, frame));
                },
            }));
            _this.shootTime = Ball.Random.float(1, 1.5);
            _this.addAbility('onStartShop', ScrapCannon.onStartShop, { nullifyable: false, canActivateTwice: false });
            _this.addAbility('onRestock', ScrapCannon.onRestock);
            _this.addAbility('update', ScrapCannon.update, { canActivateTwice: false });
            return _this;
        }
        ScrapCannon.prototype.getName = function () { return 'Scrap Cannon'; };
        ScrapCannon.prototype.getDesc = function () {
            var fireRateColor = Color.lerpColorByRgb(0xFFFFFF, 0x00FF00, ScrapCannon.getPowerPercent(this));
            return "Shoots the closest enemy for [r]" + this.bulletDmg + "<sword>[/r] every \\[[color " + fireRateColor + "]" + this.currentShootTime.toFixed(1) + "s[/color]\\]. Restocking the shop increases the fire rate";
        };
        ScrapCannon.prototype.getShopDmg = function () { return 3; };
        ScrapCannon.prototype.getShopHp = function () { return 6; };
        ScrapCannon.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        Object.defineProperty(ScrapCannon.prototype, "bulletDmg", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrapCannon.prototype, "bulletSpeed", {
            get: function () { return 200; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrapCannon.prototype, "shootTimeMin", {
            get: function () { return 0.5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScrapCannon.prototype, "shootTimeMax", {
            get: function () { return 1.5; },
            enumerable: false,
            configurable: true
        });
        ScrapCannon.getPowerPercent = function (source) { return M.mapClamp(source.properties.metadata.currentRoundPower, 0, this.maxPower, 0, 1); };
        Object.defineProperty(ScrapCannon.prototype, "currentShootTime", {
            get: function () { return M.lerp(this.shootTimeMax, this.shootTimeMin, ScrapCannon.getPowerPercent(this)); },
            enumerable: false,
            configurable: true
        });
        ScrapCannon.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.gun.alpha = this.alpha;
            this.gun.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.gun, this);
            this.powerFilter.power = ScrapCannon.getPowerPercent(this);
        };
        ScrapCannon.prototype.levelUp = function (withProperties, withFanfare, withStatIncrease) {
            _super.prototype.levelUp.call(this, withProperties, withFanfare, withStatIncrease);
            if (withProperties && withProperties !== this.properties) {
                this.properties.metadata.currentRoundPower = Math.max(this.properties.metadata.currentRoundPower, withProperties.metadata.currentRoundPower);
            }
        };
        ScrapCannon.onStartShop = function (source, world) {
            source.properties.metadata.currentRoundPower = 0;
        };
        ScrapCannon.onRestock = function (source, world) {
            if (!source.properties.metadata.currentRoundPower)
                source.properties.metadata.currentRoundPower = 0;
            if (source.properties.metadata.currentRoundPower >= ScrapCannon.maxPower)
                return;
            source.properties.metadata.currentRoundPower++;
            if (source instanceof ScrapCannon) {
                source.shootTime = source.currentShootTime - Ball.Random.float(0, 0.5);
            }
            world.playSound('charge', { humanized: false, speed: pitch(2 * source.properties.metadata.currentRoundPower - 1) });
            if (ScrapCannon.getPowerPercent(source) >= 1) {
                world.playSound('medkitheal', { humanized: false, speed: 1.5 });
            }
        };
        ScrapCannon.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            var target = M.argmin(enemyBalls, function (ball) { return G.distance(source, ball); });
            if (target) {
                var dx = target.x - source.x;
                var dy = target.y - source.y;
                var angle = M.atan2(dy, dx);
                source.gun.data.gunAngle = angle;
                if (world.select.raycast(source.x, source.y, dx, dy, [Battle.PhysicsGroups.walls]).some(function (coll) { return coll.t < 1; })) {
                    source.shootTime = M.clamp(source.shootTime, 0, 0.5);
                }
            }
            source.shootTime += source.delta;
            while (source.shootTime >= source.currentShootTime) {
                ScrapCannon.shoot(source, world);
                if (source.shouldActivateAbilityTwice()) {
                    source.doAfterTime(0.1, function () { return ScrapCannon.shoot(source, world); });
                }
                source.shootTime -= source.currentShootTime;
            }
        };
        ScrapCannon.shoot = function (source, world) {
            source.gun.data.gunTime = 1;
            var d = Vector2.fromPolar(1, source.gun.data.gunAngle);
            var v = d.withMagnitude(source.bulletSpeed);
            world.addWorldObject(new ScrapBullet(source.x + 12 * d.x, source.y + 12 * d.y, v, source, source.bulletDmg));
            world.addWorldObject(new BurstPuffSystem({
                x: source.x + 12 * source.ballScale * d.x,
                y: source.y + 12 * source.ballScale * d.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(2 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.3,
                    v: vec2(v.x / 2 + Random.float(-50, 50), v.y / 2 + Random.float(-50, 50)),
                    color: 0x333333,
                    radius: 2,
                    finalRadius: 0,
                }); },
            }));
            world.playSound('scrap', { humanized: false }).speed = Random.float(0.95, 1.05);
            source.didShootProjectile(1);
        };
        ScrapCannon.maxPower = 4;
        return ScrapCannon;
    }(Ball));
    Balls.ScrapCannon = ScrapCannon;
    var CANNON_TEXTURE_N = 32;
    var cannonTextureCache = [];
    function getCannonTextureForAngleFrame(angle, frame) {
        if (cannonTextureCache.length === 0) {
            var baseTexture_1 = AssetCache.getTexture('scrapgunbase');
            var barrelTextures_1 = A.range(3).map(function (i) { return AssetCache.getTexture("scrapgunbarrel/" + i); });
            if (!baseTexture_1 || barrelTextures_1.some(function (t) { return !t; }))
                return undefined;
            var outlineFilter_2 = new Effects.Filters.Outline(0x000000, 1);
            var _loop_24 = function (i_2) {
                var angle_2 = i_2 * 360 / CANNON_TEXTURE_N;
                cannonTextureCache.push(A.range(3).map(function (i) {
                    var texture = new BasicTexture(32, 32, 'ScrapCannon.getCannonTextureForAngleFrame');
                    baseTexture_1.renderTo(texture, { x: 16, y: 16 });
                    barrelTextures_1[i].renderTo(texture, { x: 16, y: 16, angle: angle_2 });
                    return new AnchoredTexture(texture.transform({ filters: [outlineFilter_2] }, 'ScrapCannon.getCannonTextureForAngleFrame'), 0.5, 0.5);
                }));
            };
            for (var i_2 = 0; i_2 < CANNON_TEXTURE_N; i_2++) {
                _loop_24(i_2);
            }
        }
        var i = M.mod(Math.round(angle / 360 * CANNON_TEXTURE_N), CANNON_TEXTURE_N);
        return cannonTextureCache[i][frame];
    }
    var PowerFilter = /** @class */ (function (_super) {
        __extends(PowerFilter, _super);
        function PowerFilter(power) {
            return _super.call(this, {
                uniforms: { 'float power': power },
                code: "\n                    if (inp.r < 0.01 && inp.g > 0.99) {\n                        float powerRequired = mapClamp(inp.b, 0.0, 136.0/255.0, 0.0, 1.0);\n                        float amount = step(powerRequired, power);\n                        outp.rgb = vec3(0.0, lerp(0.0, 1.0, amount), 0.0);\n\n                        float fullPowerAmount = step(0.99, power);\n                        outp.rgb = lerp(outp.rgb, vec3(1.0, 1.0, 1.0), fullPowerAmount * (sin(12.0*t)+1.0)/2.0);\n                    }\n                "
            }) || this;
        }
        Object.defineProperty(PowerFilter.prototype, "power", {
            set: function (v) { this.setUniform('power', v); },
            enumerable: false,
            configurable: true
        });
        return PowerFilter;
    }(TextureFilter));
    function pitch(n) {
        return Math.pow(2, [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24][n - 1] / 12);
    }
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Seed = /** @class */ (function (_super) {
        __extends(Seed, _super);
        function Seed(config) {
            var _this = _super.call(this, 'balls/seed', 8, config) || this;
            _this.addAbility('onStartShop', Seed.onStartShop, { canActivateTwice: false });
            return _this;
        }
        Seed.prototype.getName = function () { return 'Seed'; };
        Seed.prototype.getDesc = function () { return "When the shop moves to the next tier, transform into a random ball of that tier"; };
        Seed.prototype.getShopDmg = function () { return 1; };
        Seed.prototype.getShopHp = function () { return 4; };
        Seed.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        Seed.onStartShop = function (source, world) {
            var tierJustUnlocked = getTierJustUnlocked();
            if (tierJustUnlocked < 1)
                return;
            var validBallTypes = getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly)
                .filter(function (t) { return TYPE_TO_BALL_TYPE_DEF[t].tier === tierJustUnlocked && !_.contains(Seed.INVALID_BALL_TYPES, t); });
            if (_.isEmpty(validBallTypes))
                return;
            var ballType = Ball.Random.element(validBallTypes);
            ShopActions.removeBallFromSquad(source);
            source.removeFromWorld();
            var newBall = world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: ballType,
                    level: source.level,
                    damage: source.dmg,
                    health: source.hp,
                    equipment: source.equipment ? source.equipment.equipmentType : -1,
                    metadata: source.properties.metadata,
                }
            }, GAME_DATA.squad, GAME_DATA.squad.balls.length, source.team));
            newBall.showAllStats();
            GAME_DATA.squad.balls.push({
                x: newBall.x,
                y: newBall.y,
                properties: newBall.properties,
            });
        };
        Seed.INVALID_BALL_TYPES = [
            127,
        ];
        return Seed;
    }(Ball));
    Balls.Seed = Seed;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Seeker = /** @class */ (function (_super) {
        __extends(Seeker, _super);
        function Seeker(config) {
            var _this = _super.call(this, 'balls/seeker', 8, config) || this;
            _this.cooldown = new AbilityCooldown(0.5, 2);
            _this.addAbility('onCollideWithEnemyPostDamage', Seeker.onCollideWithEnemyPostDamage);
            return _this;
        }
        Seeker.prototype.getName = function () { return 'Seeker'; };
        Seeker.prototype.getDesc = function () {
            return "On collision, shoot a [r]" + this.spikeDamage + "<sword>[/r] homing spike at a random enemy";
        };
        Seeker.prototype.getShopDmg = function () { return 1; };
        Seeker.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Seeker.prototype, "spikeDamage", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Seeker.prototype.update = function () {
            _super.prototype.update.call(this);
            this.cooldown.update(this.delta);
        };
        Seeker.onCollideWithEnemyPostDamage = function (source, world, enemy) {
            var enemies = getEnemies(world, source);
            if (enemies.length === 0)
                return;
            if (!source.cooldown.consumeUse())
                return;
            var randomBall = Ball.Random.element(enemies);
            world.addWorldObject(new HomingSpike(source.x, source.y, source, randomBall, source.spikeDamage, 1, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
            source.didShootProjectile(1);
        };
        return Seeker;
    }(Ball));
    Balls.Seeker = Seeker;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Skeleton = /** @class */ (function (_super) {
        __extends(Skeleton, _super);
        function Skeleton(config) {
            return _super.call(this, 'balls/skeleton', 8, config) || this;
        }
        Skeleton.prototype.getName = function () { return 'Skeleton'; };
        Skeleton.prototype.getDesc = function () { return 'No effect'; };
        return Skeleton;
    }(Ball));
    Balls.Skeleton = Skeleton;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Sleeper = /** @class */ (function (_super) {
        __extends(Sleeper, _super);
        function Sleeper(config) {
            var _this = _super.call(this, 'balls/sleeper', 8, config) || this;
            _this.behaviorSm = new StateMachine();
            _this.behaviorSm.addState('roll', {
                script: S.wait(function () { return _this.rollTime; }),
                update: function () { return _this.updateRoll(); },
                transitions: [{ toState: 'slowing', condition: function () { return !_this.isNullified(); } }],
            });
            _this.behaviorSm.addState('slowing', {
                script: S.doOverTime(0.75, function (t) { return _this.addSlow('other', M.lerp(0, 1, t), 0.1); }),
                transitions: [{ toState: 'heal' }],
            });
            _this.behaviorSm.addState('heal', {
                script: S.wait(function () { return _this.getHealTime(); }),
                update: function () { return _this.updateHeal(); },
                transitions: [{ toState: 'roll' }],
            });
            _this.aura = _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0x00FF00,
                blendMode: Texture.BlendModes.ADD,
                scale: _this.visibleHealRadius / 64,
                copyFromParent: ['layer'],
            }));
            _this.addAbility('update', Sleeper.update, { canActivateTwice: false, nullifyable: false });
            return _this;
        }
        Sleeper.prototype.getName = function () { return 'Sleeper'; };
        Sleeper.prototype.getDesc = function () { return "Stops regularly to heal itself for [g]" + this.healSelfRate + "<heart>/s[/g] and nearby allies for [g]" + this.healAllyRate + "<heart>/s[/g]"; };
        Sleeper.prototype.getShopDmg = function () { return 1; };
        Sleeper.prototype.getShopHp = function () { return 6; };
        Sleeper.prototype.getCredits = function () { return [CreditsNames.JUNJ]; };
        Object.defineProperty(Sleeper.prototype, "rollTime", {
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sleeper.prototype, "healTime", {
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sleeper.prototype, "healSelfRate", {
            get: function () { return this.level / 4; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sleeper.prototype, "healAllyRate", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sleeper.prototype, "healRadius", {
            get: function () { return this.physicalRadius - 8 + 48 + 12 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sleeper.prototype, "visibleHealRadius", {
            get: function () {
                if (this.isInShop || this.isInYourSquadScene)
                    return 0;
                if (this.behaviorSm.getCurrentStateName() === 'heal')
                    return this.healRadius;
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Sleeper.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            source.behaviorSm.update(source.delta);
        };
        Sleeper.prototype.onStateChangeBattle = function () {
            this.behaviorSm.setState('heal');
        };
        Sleeper.prototype.updateRoll = function () {
        };
        Sleeper.prototype.updateHeal = function () {
            var e_174, _a;
            var _this = this;
            if (this.isNullified()) {
                this.behaviorSm.setState('roll');
                return;
            }
            this.addStun('other', 0.1);
            var allies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === _this.team && G.distance(ball, _this) < ball.radius + _this.healRadius; });
            try {
                for (var allies_2 = __values(allies), allies_2_1 = allies_2.next(); !allies_2_1.done; allies_2_1 = allies_2.next()) {
                    var ally = allies_2_1.value;
                    var healRate = ally === this ? this.healSelfRate : this.healAllyRate;
                    ally.healFor(healRate * this.delta, this);
                }
            }
            catch (e_174_1) { e_174 = { error: e_174_1 }; }
            finally {
                try {
                    if (allies_2_1 && !allies_2_1.done && (_a = allies_2.return)) _a.call(allies_2);
                }
                finally { if (e_174) throw e_174.error; }
            }
        };
        Sleeper.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.aura.alpha = M.lerp(0.8, 1.0, (Math.sin(4 * this.aura.life.time) + 1) / 2);
            this.aura.scale = M.lerpTime(this.aura.scale, this.visibleHealRadius / 64, 10, this.delta);
            World.Actions.orderWorldObjectBefore(this.aura, this);
        };
        Sleeper.prototype.setForInShop = function () {
            this.aura.scale = this.visibleHealRadius / 64;
        };
        Sleeper.prototype.getHealTime = function () {
            if (this.shouldActivateAbilityTwice()) {
                return this.healTime * 2;
            }
            return this.healTime;
        };
        return Sleeper;
    }(Ball));
    Balls.Sleeper = Sleeper;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Sniper = /** @class */ (function (_super) {
        __extends(Sniper, _super);
        function Sniper(config) {
            var _this = _super.call(this, 'balls/sniper', 8, config) || this;
            _this.enemyTrackers = {};
            _this.addAbility('update', Sniper.update, { canActivateTwice: false });
            _this.addAbility('onBallJoin', Sniper.onBallJoin, { canActivateTwice: false });
            return _this;
        }
        Sniper.prototype.getName = function () { return 'Sniper'; };
        Sniper.prototype.getDesc = function () { return "When an enemy is summoned or gains " + this.gainInterval + " [r]<sword>[/r]/[g]<heart>[/g], shoot a [r]" + this.bulletDmg + "<sword>[/r] bullet at it"; };
        Sniper.prototype.getShopDmg = function () { return 4; };
        Sniper.prototype.getShopHp = function () { return 4; };
        Object.defineProperty(Sniper.prototype, "gainInterval", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sniper.prototype, "bulletDmg", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Sniper.prototype, "bulletSpeed", {
            get: function () { return 600; },
            enumerable: false,
            configurable: true
        });
        Sniper.update = function (source, world) {
            if (source.state !== Ball.States.PRE_BATTLE && source.state !== Ball.States.BATTLE)
                return;
            Sniper.updateEnemyTrackers(source, world);
        };
        Sniper.updateEnemyTrackers = function (source, world) {
            var e_175, _a;
            var enemies = getEnemies(world, source);
            var _loop_25 = function (enemy) {
                if (enemy.name && enemy.name in source.enemyTrackers) {
                    var tracker = source.enemyTrackers[enemy.name];
                    if (enemy.hp > tracker.lastHp)
                        tracker.totalGain += enemy.hp - tracker.lastHp;
                    if (enemy.dmg > tracker.lastDmg)
                        tracker.totalGain += enemy.dmg - tracker.lastDmg;
                    tracker.lastHp = enemy.hp;
                    tracker.lastDmg = enemy.dmg;
                    var bulletCount_1 = 0;
                    while (tracker.totalGain >= source.gainInterval) {
                        tracker.totalGain -= source.gainInterval;
                        bulletCount_1++;
                    }
                    if (bulletCount_1 > 0) {
                        Sniper.shootBullets(source, world, enemy, bulletCount_1);
                        if (source.shouldActivateAbilityTwice()) {
                            source.doAfterTime(0.1, function () { return Sniper.shootBullets(source, world, enemy, bulletCount_1); });
                        }
                    }
                }
                else {
                    source.enemyTrackers[enemy.name] = {
                        lastHp: enemy.hp,
                        lastDmg: enemy.dmg,
                        totalGain: 0,
                    };
                }
            };
            try {
                for (var enemies_3 = __values(enemies), enemies_3_1 = enemies_3.next(); !enemies_3_1.done; enemies_3_1 = enemies_3.next()) {
                    var enemy = enemies_3_1.value;
                    _loop_25(enemy);
                }
            }
            catch (e_175_1) { e_175 = { error: e_175_1 }; }
            finally {
                try {
                    if (enemies_3_1 && !enemies_3_1.done && (_a = enemies_3.return)) _a.call(enemies_3);
                }
                finally { if (e_175) throw e_175.error; }
            }
        };
        Sniper.onBallJoin = function (source, world, ball) {
            if (ball.team === source.team)
                return;
            if (!ball.isSummon)
                return;
            Sniper.shootBullets(source, world, ball, 1);
            if (source.shouldActivateAbilityTwice()) {
                source.doAfterTime(0.1, function () { return Sniper.shootBullets(source, world, ball, 1); });
            }
        };
        Sniper.shootBullets = function (source, world, enemy, bulletCount) {
            var bulletSpeed = Ball.Random.float(source.bulletSpeed - 50, source.bulletSpeed + 50);
            var bulletV = enemy.getPosition().subtract(source).setMagnitude(bulletSpeed);
            world.addWorldObject(new TurretBullet(source.x, source.y, bulletV, source, source.bulletDmg, bulletCount));
            world.playSound('shoot', { humanized: false }).speed = Random.float(0.95, 1.05);
            source.didShootProjectile(bulletCount);
        };
        return Sniper;
    }(Ball));
    Balls.Sniper = Sniper;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Snowball = /** @class */ (function (_super) {
        __extends(Snowball, _super);
        function Snowball(config) {
            var _this = _super.call(this, 'balls/snowball', 8, config) || this;
            _this.INITIAL_SCALE = 0.6;
            _this.MAX_SCALE = 2;
            _this.setBallScale(_this.INITIAL_SCALE);
            _this.totalHealthGained = 0;
            _this.addAbility('update', Snowball.update);
            return _this;
        }
        Snowball.prototype.getName = function () { return 'Snowball'; };
        Snowball.prototype.getDesc = function () { return "Grows in size as it rolls, slowly gaining mass and [g]" + this.maxHealthGain + "<heart>[/g] extra health over " + this.totalTimeToGain + " seconds"; };
        Snowball.prototype.getShopDmg = function () { return 1; };
        Snowball.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Snowball.prototype, "maxHealthGain", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Snowball.prototype, "totalTimeToGain", {
            get: function () { return 10; },
            enumerable: false,
            configurable: true
        });
        Snowball.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var growthRate = (source.MAX_SCALE - source.INITIAL_SCALE) / source.totalTimeToGain;
            var newBallScale = Math.min(source.ballScale + growthRate * source.delta, source.MAX_SCALE);
            source.setBallScale(newBallScale);
            if (source.totalHealthGained < source.maxHealthGain) {
                var healRate = source.maxHealthGain / source.totalTimeToGain;
                var healthAmount = Math.min(healRate * source.delta, source.maxHealthGain - source.totalHealthGained);
                source.hp += healthAmount;
                source.maxhp += healthAmount;
                source.totalHealthGained += healthAmount;
                source.showHpStat(healthAmount, 0.5);
            }
        };
        return Snowball;
    }(Ball));
    Balls.Snowball = Snowball;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Spiker = /** @class */ (function (_super) {
        __extends(Spiker, _super);
        function Spiker(config) {
            var _this = _super.call(this, 'balls/spiker', 8, config) || this;
            _this.addAbility('onTakeDamage', Spiker.onTakeDamage);
            return _this;
        }
        Spiker.prototype.getName = function () { return 'Spiker'; };
        Spiker.prototype.getDesc = function () {
            return "When this takes discrete damage, shoot [lb]" + this.spikes + "[/lb] random spikes that deal [r]" + this.spikeDamage + "<sword>[/r] each";
        };
        Spiker.prototype.getShopDmg = function () { return 1; };
        Spiker.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Spiker.prototype, "spikes", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Spiker.prototype, "spikeDamage", {
            get: function () { return 0.75 + 0.25 * this.level; },
            enumerable: false,
            configurable: true
        });
        Spiker.onTakeDamage = function (source, world, damage) {
            var e_176, _a;
            var spikeCounts = M.batch(source.spikes, 20);
            try {
                for (var spikeCounts_6 = __values(spikeCounts), spikeCounts_6_1 = spikeCounts_6.next(); !spikeCounts_6_1.done; spikeCounts_6_1 = spikeCounts_6.next()) {
                    var count = spikeCounts_6_1.value;
                    world.addWorldObject(new Spike(source.x, source.y, Ball.Random.onCircle(150), source, source.spikeDamage, count));
                    source.didShootProjectile(count);
                }
            }
            catch (e_176_1) { e_176 = { error: e_176_1 }; }
            finally {
                try {
                    if (spikeCounts_6_1 && !spikeCounts_6_1.done && (_a = spikeCounts_6.return)) _a.call(spikeCounts_6);
                }
                finally { if (e_176) throw e_176.error; }
            }
            world.playSound('spike');
        };
        return Spiker;
    }(Ball));
    Balls.Spiker = Spiker;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Splinter = /** @class */ (function (_super) {
        __extends(Splinter, _super);
        function Splinter(config) {
            var _this = _super.call(this, 'balls/splinter', 8, config) || this;
            _this.addAbility('onDeath', Splinter.onDeath);
            return _this;
        }
        Splinter.prototype.getName = function () { return 'Splinter'; };
        Splinter.prototype.getDesc = function () {
            if (this.spikes === 1)
                return "On death, shoot a homing spike at a random enemy that deals [r]1<sword>[/r]";
            return "On death, shoot [lb]" + this.spikes + "[/lb] homing spikes at random enemies that deal [r]1<sword>[/r] each";
        };
        Splinter.prototype.getShopDmg = function () { return 1; };
        Splinter.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Splinter.prototype, "spikes", {
            get: function () { return 1 + this.level; },
            enumerable: false,
            configurable: true
        });
        Splinter.onDeath = function (source, world, killedBy) {
            var e_177, _a;
            var enemies = getEnemies(world, source);
            if (enemies.length === 0)
                return;
            var spikeCounts = M.batch(source.spikes, 20);
            try {
                for (var spikeCounts_7 = __values(spikeCounts), spikeCounts_7_1 = spikeCounts_7.next(); !spikeCounts_7_1.done; spikeCounts_7_1 = spikeCounts_7.next()) {
                    var count = spikeCounts_7_1.value;
                    var randomBall = Ball.Random.element(enemies);
                    world.addWorldObject(new HomingSpike(source.x, source.y, source, randomBall, 1, count, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
                    source.didShootProjectile(count);
                }
            }
            catch (e_177_1) { e_177 = { error: e_177_1 }; }
            finally {
                try {
                    if (spikeCounts_7_1 && !spikeCounts_7_1.done && (_a = spikeCounts_7.return)) _a.call(spikeCounts_7);
                }
                finally { if (e_177) throw e_177.error; }
            }
        };
        return Splinter;
    }(Ball));
    Balls.Splinter = Splinter;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Splitter = /** @class */ (function (_super) {
        __extends(Splitter, _super);
        function Splitter(config) {
            var _this = _super.call(this, 'balls/split', 8, config) || this;
            _this.addAbility('onDeath', Splitter.onDeath);
            return _this;
        }
        Splitter.prototype.getName = function () { return 'Splitter'; };
        Splitter.prototype.getDesc = function () { return "On death, summon [lb]" + this.ballsToSpawn + "[/lb] " + buffText(1, 2) + " split balls"; };
        Splitter.prototype.getShopDmg = function () { return 2; };
        Splitter.prototype.getShopHp = function () { return 4; };
        Object.defineProperty(Splitter.prototype, "ballsToSpawn", {
            get: function () { return this.level + 1; },
            enumerable: false,
            configurable: true
        });
        Splitter.onDeath = function (source, world, killedBy) {
            var d = vec2(1, 0);
            for (var i = 0; i < source.ballsToSpawn; i++) {
                var ball = world.addWorldObject(squadBallToWorldBall({
                    x: source.x + 4 * d.x,
                    y: source.y + 4 * d.y,
                    properties: {
                        type: 3,
                        level: 1,
                        damage: 1,
                        health: 2,
                        equipment: -1,
                        metadata: {},
                    }
                }, undefined, -1, source.team));
                if (source.state === Ball.States.BATTLE) {
                    ball.v.set(50 * d.x, 50 * d.y);
                }
                d.rotate(360 / source.ballsToSpawn);
            }
        };
        return Splitter;
    }(Ball));
    Balls.Splitter = Splitter;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var SplitterSpawn = /** @class */ (function (_super) {
        __extends(SplitterSpawn, _super);
        function SplitterSpawn(config) {
            return _super.call(this, 'balls/splitspawn', 4, config) || this;
        }
        SplitterSpawn.prototype.getName = function () { return 'Splitter Spawn'; };
        SplitterSpawn.prototype.getDesc = function () { return 'No effect'; };
        SplitterSpawn.prototype.getShopDmg = function () { return 1; };
        SplitterSpawn.prototype.getShopHp = function () { return 2; };
        return SplitterSpawn;
    }(Ball));
    Balls.SplitterSpawn = SplitterSpawn;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Stinger = /** @class */ (function (_super) {
        __extends(Stinger, _super);
        function Stinger(config) {
            var _this = _super.call(this, 'balls/stinger', 8, config) || this;
            _this.stinger = _this.addChild(new Sprite({
                x: 0, y: -12,
                texture: 'stingerspike',
                copyFromParent: ['layer'],
                angle: -90,
                bounds: new CircleBounds(0, 0, 6),
                effects: { outline: { color: 0x000000 } },
            }));
            _this.addAbility('update', Stinger.update, { canActivateTwice: false });
            return _this;
        }
        Stinger.prototype.getName = function () { return 'Stinger'; };
        Stinger.prototype.getDesc = function () { return "The first enemy stung is slowed by " + this.slowFactorPercent + "% and takes [r]" + this.totalStingerDamage + "<sword>[/r] over " + this.stingDuration + "s"; };
        Stinger.prototype.getShopDmg = function () { return 1; };
        Stinger.prototype.getShopHp = function () { return 6; };
        Stinger.prototype.getShopRelativePosition = function () { return vec2(0, 2); };
        Stinger.prototype.getCredits = function () { return [CreditsNames.XIAOSLOTH]; };
        Object.defineProperty(Stinger.prototype, "slowFactorPercent", {
            get: function () { return M.clamp(20 + 10 * (this.level - 1), 0, 100); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Stinger.prototype, "slowFactor", {
            get: function () { return this.slowFactorPercent / 100; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Stinger.prototype, "totalStingerDamage", {
            get: function () { return 5 + 2 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Stinger.prototype, "stingDuration", {
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Stinger.prototype.postUpdate = function () {
            var _a;
            _super.prototype.postUpdate.call(this);
            if ((_a = this.stinger) === null || _a === void 0 ? void 0 : _a.world) {
                this.stinger.alpha = this.alpha;
                this.stinger.scale = this.ballScale * this.moveScale;
                World.Actions.orderWorldObjectBefore(this.stinger, this);
            }
        };
        Stinger.update = function (source, world) {
            var e_178, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            if (!source.stinger || !source.stinger.world)
                return;
            var targetAngle = source.angle - 90;
            source.stinger.angle = M.moveToAngleClamp(source.stinger.angle, targetAngle, 360, source.delta);
            var d = Vector2.fromPolar(12, source.stinger.angle);
            source.stinger.localx = d.x * source.stinger.scaleX;
            source.stinger.localy = d.y * source.stinger.scaleY;
            var enemies = getEnemies(world, source);
            try {
                for (var enemies_4 = __values(enemies), enemies_4_1 = enemies_4.next(); !enemies_4_1.done; enemies_4_1 = enemies_4.next()) {
                    var enemy = enemies_4_1.value;
                    if (!source.stinger.bounds.isOverlapping(enemy.bounds))
                        continue;
                    if (source.shouldActivateAbilityTwice()) {
                        Stinger.sting(source, enemy, -15);
                        Stinger.sting(source, enemy, 15);
                    }
                    else {
                        Stinger.sting(source, enemy, 0);
                    }
                    world.playSound('stab');
                    world.addWorldObject(newPuff(source.stinger.x, source.stinger.y, Battle.Layers.fx, 'small'));
                    source.stinger.kill();
                    break;
                }
            }
            catch (e_178_1) { e_178 = { error: e_178_1 }; }
            finally {
                try {
                    if (enemies_4_1 && !enemies_4_1.done && (_a = enemies_4.return)) _a.call(enemies_4);
                }
                finally { if (e_178) throw e_178.error; }
            }
        };
        Stinger.sting = function (source, enemy, angleOffset) {
            enemy.addSlow('other', source.slowFactor, source.stingDuration);
            enemy.addSpreadDamage(source, source.totalStingerDamage, source.stingDuration);
            enemy.addChild(new Sting(enemy, source, source.stingDuration, angleOffset));
        };
        return Stinger;
    }(Ball));
    Balls.Stinger = Stinger;
    var Sting = /** @class */ (function (_super) {
        __extends(Sting, _super);
        function Sting(parent, source, life, angleOffset) {
            var _this = _super.call(this, {
                texture: 'stingerspike',
                copyFromParent: ['layer'],
                effects: { outline: { color: 0x000000 } },
                life: life,
            }) || this;
            _this.ballParent = parent;
            _this.dAngle = source.getPosition().subtract(parent).angle - parent.angle + angleOffset;
            _this.updateTransform();
            return _this;
        }
        Sting.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.updateTransform();
            World.Actions.orderWorldObjectBefore(this, this.ballParent);
        };
        Sting.prototype.kill = function () {
            var _a;
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.addWorldObject(newPuff(this.x, this.y, Battle.Layers.fx, 'small'));
            _super.prototype.kill.call(this);
        };
        Sting.prototype.updateTransform = function () {
            var angle = this.ballParent.angle + this.dAngle;
            this.angle = angle - 180;
            var localPos = Vector2.fromPolar(this.ballParent.physicalRadius, angle);
            this.localx = localPos.x;
            this.localy = localPos.y;
        };
        return Sting;
    }(Sprite));
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Stopper = /** @class */ (function (_super) {
        __extends(Stopper, _super);
        function Stopper(config) {
            var _this = _super.call(this, 'balls/stopper', 8, config) || this;
            _this.visibleStopRadius = _this.stopRadius;
            _this.cooldown = _this.addTimer(0.1);
            _this.cooldown.finish();
            _this.addAbility('onCollideWithEnemyPostDamage', Stopper.onCollideWithEnemyPostDamage, { canActivateTwice: false });
            return _this;
        }
        Stopper.prototype.getName = function () { return 'Stopper'; };
        Stopper.prototype.getDesc = function () { return "On collide with enemy, stop enemies in a radius for 1s"; };
        Stopper.prototype.getShopDmg = function () { return 3; };
        Stopper.prototype.getShopHp = function () { return 5; };
        Stopper.prototype.getCredits = function () { return [CreditsNames.C_RRY]; };
        Object.defineProperty(Stopper.prototype, "stopRadius", {
            get: function () { return this.physicalRadius - 8 + 100 * Math.exp(0.25 * this.level) / (Math.exp(0.25 * this.level) + 3); },
            enumerable: false,
            configurable: true
        });
        Stopper.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if ((this.isInShop && !this.isBeingMoved()) || this.isInYourSquadScene || this.isNullified()) {
                this.visibleStopRadius = 0;
            }
            else {
                this.visibleStopRadius = M.lerpTime(this.visibleStopRadius, this.stopRadius, 100, this.delta);
            }
        };
        Stopper.prototype.render = function (texture, x, y) {
            Draw.brush.color = 0xFF0000;
            Draw.brush.alpha = 0.7;
            Draw.brush.thickness = 1;
            var vertices = G.generatePolygonVertices(x, y, this.visibleStopRadius + 1, 8);
            Draw.polygonOutline(texture, vertices);
            _super.prototype.render.call(this, texture, x, y);
        };
        Stopper.onCollideWithEnemyPostDamage = function (source, world, collideWith, damage) {
            if (!source.cooldown.done)
                return;
            Stopper.stopEnemies(source, world);
            if (source.shouldActivateAbilityTwice()) {
                source.doAfterTime(0.3, function () { return Stopper.stopEnemies(source, world); });
            }
            source.cooldown.reset();
        };
        Stopper.stopEnemies = function (source, world) {
            var e_179, _a;
            var validEnemies = getEnemies(world, source)
                .filter(function (enemy) { return G.distance(enemy, source) <= source.stopRadius + enemy.physicalRadius; });
            try {
                for (var validEnemies_3 = __values(validEnemies), validEnemies_3_1 = validEnemies_3.next(); !validEnemies_3_1.done; validEnemies_3_1 = validEnemies_3.next()) {
                    var enemy = validEnemies_3_1.value;
                    enemy.stop(1);
                }
            }
            catch (e_179_1) { e_179 = { error: e_179_1 }; }
            finally {
                try {
                    if (validEnemies_3_1 && !validEnemies_3_1.done && (_a = validEnemies_3.return)) _a.call(validEnemies_3);
                }
                finally { if (e_179) throw e_179.error; }
            }
            world.playSound('stopboom', { limit: 4 });
            if (source.hp > 0) {
                source.addChild(new Stop(0, 0, source.visibleStopRadius + 1, source));
            }
            else {
                world.addWorldObject(new Stop(source.x, source.y, source.visibleStopRadius + 1, source));
            }
        };
        return Stopper;
    }(Ball));
    Balls.Stopper = Stopper;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Toxin = /** @class */ (function (_super) {
        __extends(Toxin, _super);
        function Toxin(config) {
            var _this = _super.call(this, 'balls/toxin', 8, config) || this;
            _this.addAbility('onEnterBattle', Toxin.onEnterBattle, { canActivateTwice: false });
            _this.addAbility('onDeath', Toxin.onDeath, { canActivateTwice: false });
            return _this;
        }
        Toxin.prototype.getName = function () { return 'Toxin'; };
        Toxin.prototype.getDesc = function () { return "On enter battle AND on death, leave a pool of acid which damages enemies for [r]" + this.acidDamage + "<sword>/s[/r]"; };
        Toxin.prototype.getShopDmg = function () { return 3; };
        Toxin.prototype.getShopHp = function () { return 3; };
        Toxin.prototype.getCredits = function () { return [CreditsNames.NEPDEP]; };
        Object.defineProperty(Toxin.prototype, "acidDamage", {
            get: function () { return 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Toxin.prototype, "acidRadius", {
            get: function () { return this.physicalRadius - 8 + 45 * Math.exp(0.75 * this.level) / (Math.exp(0.75 * this.level) + 2); },
            enumerable: false,
            configurable: true
        });
        Toxin.prototype.onAdd = function () {
            var _this = this;
            _super.prototype.onAdd.call(this);
            this.addChild(new AbilityRadius(this, function () { return _this.acidRadius; }, 0x00FF00, 0x33FF33, 0.7));
        };
        Toxin.onEnterBattle = function (source, world) {
            Toxin.createPool(source.x, source.y, source, world);
            if (source.shouldActivateAbilityTwice()) {
                world.runScript(function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, S.wait(0.3)];
                            case 1:
                                _a.sent();
                                Toxin.createPool(source.x, source.y, source, world);
                                return [2 /*return*/];
                        }
                    });
                });
            }
        };
        Toxin.onDeath = function (source, world) {
            Toxin.createPool(source.x, source.y, source, world);
            if (source.shouldActivateAbilityTwice()) {
                world.runScript(function () {
                    var pos;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, S.wait(0.3)];
                            case 1:
                                _a.sent();
                                pos = source.getPosition().add(Ball.Random.onCircle(10));
                                Toxin.createPool(pos.x, pos.y, source, world);
                                return [2 /*return*/];
                        }
                    });
                });
            }
        };
        Toxin.createPool = function (x, y, source, world) {
            world.addWorldObject(new AcidPool(x, y, source, source.acidRadius, source.acidDamage));
            world.playSound('slosh');
        };
        return Toxin;
    }(Ball));
    Balls.Toxin = Toxin;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Trainer = /** @class */ (function (_super) {
        __extends(Trainer, _super);
        function Trainer(config) {
            var _this = _super.call(this, 'balls/trainer', 8, config) || this;
            _this.addAbility('onBallEnterBattle', Trainer.onBallEnterBattle);
            return _this;
        }
        Trainer.prototype.getName = function () { return 'Trainer'; };
        Trainer.prototype.getDesc = function () { return "When an ally enters battle, give it [r]" + this.buffDamage + "<sword>[/r]"; };
        Trainer.prototype.getShopDmg = function () { return 5; };
        Trainer.prototype.getShopHp = function () { return 7; };
        Object.defineProperty(Trainer.prototype, "buffDamage", {
            get: function () { return 1 + 0.5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Trainer.onBallEnterBattle = function (source, world, ball) {
            if (ball.team !== source.team)
                return;
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/];
                        case 1:
                            _a.sent();
                            ball.buff(source.buffDamage, 0);
                            source.addChild(new Sprite({
                                texture: 'buffbeams',
                                blendMode: Texture.BlendModes.ADD,
                                copyFromParent: ['layer'],
                                scale: (source.physicalRadius + 4) / 64,
                                life: 0.5,
                                vangle: 90,
                                update: function () {
                                    this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                                    World.Actions.orderWorldObjectBefore(this, this.parent);
                                },
                            }));
                            return [2 /*return*/];
                    }
                });
            });
        };
        return Trainer;
    }(Ball));
    Balls.Trainer = Trainer;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Turret = /** @class */ (function (_super) {
        __extends(Turret, _super);
        function Turret(config) {
            var _this = _super.call(this, 'balls/turret', 8, config) || this;
            _this.gun = _this.addChild(new Sprite({
                texture: getTurretTextureForAngleFrame(0, 0),
                copyFromParent: ['layer'],
                data: {
                    gunAngle: 0,
                    gunTime: 0,
                },
                update: function () {
                    this.data.gunTime = M.clamp(this.data.gunTime - 2 * this.delta, 0, 1);
                    var frame = Math.ceil(M.lerp(2, 0, 1 - this.data.gunTime));
                    this.setTexture(getTurretTextureForAngleFrame(this.data.gunAngle, frame));
                },
            }));
            _this.shootTime = Ball.Random.float(0.5, 1);
            _this.addAbility('update', Turret.update, { canActivateTwice: false });
            return _this;
        }
        Turret.prototype.getName = function () { return 'Turret'; };
        Turret.prototype.getDesc = function () { return "Shoots the closest enemy for [r]" + this.bulletDmg + "<sword>/s[/r]"; };
        Turret.prototype.getShopDmg = function () { return 2; };
        Turret.prototype.getShopHp = function () { return 5; };
        Object.defineProperty(Turret.prototype, "bulletDmg", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Turret.prototype, "bulletSpeed", {
            get: function () { return 300; },
            enumerable: false,
            configurable: true
        });
        Turret.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.gun.alpha = this.alpha;
            this.gun.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.gun, this);
        };
        Turret.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemyBalls = getEnemies(world, source);
            var target = M.argmin(enemyBalls, function (ball) { return G.distance(source, ball); });
            if (target) {
                var dx = target.x - source.x;
                var dy = target.y - source.y;
                var angle = M.atan2(dy, dx);
                source.gun.data.gunAngle = angle;
                if (world.select.raycast(source.x, source.y, dx, dy, [Battle.PhysicsGroups.walls]).some(function (coll) { return coll.t < 1; })) {
                    source.shootTime = M.clamp(source.shootTime, 0, 0.5);
                }
            }
            source.shootTime += source.delta;
            while (source.shootTime >= 1) {
                Turret.shoot(source, world);
                if (source.shouldActivateAbilityTwice()) {
                    source.doAfterTime(0.1, function () { return Turret.shoot(source, world); });
                }
                source.shootTime -= 1;
            }
        };
        Turret.shoot = function (source, world) {
            source.gun.data.gunTime = 1;
            var d = Vector2.fromPolar(1, source.gun.data.gunAngle);
            var v = d.withMagnitude(source.bulletSpeed);
            world.addWorldObject(new TurretBullet(source.x + 12 * d.x, source.y + 12 * d.y, v, source, source.bulletDmg, 1));
            world.addWorldObject(new BurstPuffSystem({
                x: source.x + 12 * source.ballScale * d.x,
                y: source.y + 12 * source.ballScale * d.y,
                layer: Battle.Layers.fx,
                puffCount: Math.floor(2 * getParticleLevel()),
                puffConfigFactory: function () { return ({
                    maxLife: 0.3,
                    v: vec2(v.x / 2 + Random.float(-50, 50), v.y / 2 + Random.float(-50, 50)),
                    color: 0xFFFFFF,
                    radius: 2,
                    finalRadius: 0,
                }); },
            }));
            world.playSound('shoot', { humanized: false }).speed = Random.float(0.95, 1.05);
            source.didShootProjectile(1);
        };
        return Turret;
    }(Ball));
    Balls.Turret = Turret;
    var TURRET_TEXTURE_N = 32;
    var turretTextureCache = [];
    function getTurretTextureForAngleFrame(angle, frame) {
        if (turretTextureCache.length === 0) {
            var turretBaseTexture_2 = AssetCache.getTexture('turretgunbase');
            var turretBarrelTextures_2 = A.range(3).map(function (i) { return AssetCache.getTexture("turretgunbarrel/" + i); });
            if (!turretBaseTexture_2 || turretBarrelTextures_2.some(function (t) { return !t; }))
                return undefined;
            var outlineFilter_3 = new Effects.Filters.Outline(0x000000, 1);
            var _loop_26 = function (i_3) {
                var angle_3 = i_3 * 360 / TURRET_TEXTURE_N;
                turretTextureCache.push(A.range(3).map(function (i) {
                    var texture = new BasicTexture(32, 32, 'Turret.getTurretTextureForAngleFrame');
                    turretBaseTexture_2.renderTo(texture, { x: 16, y: 16 });
                    turretBarrelTextures_2[i].renderTo(texture, { x: 16, y: 16, angle: angle_3 });
                    return new AnchoredTexture(texture.transform({ filters: [outlineFilter_3] }, 'Turret.getTurretTextureForAngleFrame'), 0.5, 0.5);
                }));
            };
            for (var i_3 = 0; i_3 < TURRET_TEXTURE_N; i_3++) {
                _loop_26(i_3);
            }
        }
        var i = M.mod(Math.round(angle / 360 * TURRET_TEXTURE_N), TURRET_TEXTURE_N);
        return turretTextureCache[i][frame];
    }
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Vagrant = /** @class */ (function (_super) {
        __extends(Vagrant, _super);
        function Vagrant(config) {
            var _this = _super.call(this, 'balls/vagrant', 8, config) || this;
            _this.addAbility('onPlay', Vagrant.onPlay);
            return _this;
        }
        Vagrant.prototype.getName = function () { return 'Vagrant'; };
        Vagrant.prototype.getDesc = function () {
            var PLAY = "" + (GAME_MODE === 'vs' ? 'LOCK IN' : 'PLAY');
            if (Vagrant.getTakeNumberOfItems(this) > 1)
                return "On " + PLAY + ", takes [lb]" + Vagrant.getTakeNumberOfItems(this) + "[/lb] random items from the shop for free\n\nWill not take Molecular Disassemblers";
            return "On " + PLAY + ", takes a random item from the shop for free\n\nWill not take Molecular Disassemblers";
        };
        Vagrant.prototype.getShopDmg = function () { return 3; };
        Vagrant.prototype.getShopHp = function () { return 4; };
        Vagrant.getTakeNumberOfItems = function (source) { return source.level; };
        Vagrant.onPlay = function (source, world) {
            var e_180, _a;
            var currentHomingItems = world.select.typeAll(HomingItem);
            var validItems = world.select.typeAll(BallItem).filter(function (item) { return item.isPurchasable() && !_.contains(Vagrant.INVALID_ITEMS, item.type) && !currentHomingItems.some(function (h) { return h.item === item; }); });
            if (validItems.length === 0)
                return;
            if (validItems.length > Vagrant.getTakeNumberOfItems(source)) {
                Ball.Random.shuffle(validItems);
                validItems = validItems.slice(0, Vagrant.getTakeNumberOfItems(source));
            }
            try {
                for (var validItems_1 = __values(validItems), validItems_1_1 = validItems_1.next(); !validItems_1_1.done; validItems_1_1 = validItems_1.next()) {
                    var item = validItems_1_1.value;
                    if (item.frozen) {
                        world.playSound('unfreeze');
                        item.unfreeze();
                    }
                    item.removeFromWorld();
                    world.addWorldObject(new HomingItem(item.x, item.y, source, item));
                }
            }
            catch (e_180_1) { e_180 = { error: e_180_1 }; }
            finally {
                try {
                    if (validItems_1_1 && !validItems_1_1.done && (_a = validItems_1.return)) _a.call(validItems_1);
                }
                finally { if (e_180) throw e_180.error; }
            }
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        Vagrant.INVALID_ITEMS = [
            46,
            47,
        ];
        return Vagrant;
    }(Ball));
    Balls.Vagrant = Vagrant;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Vampire = /** @class */ (function (_super) {
        __extends(Vampire, _super);
        function Vampire(config) {
            var _this = _super.call(this, 'balls/vampire', 8, config) || this;
            _this.vampRing = _this.addChild(new VampRing(0, 0));
            _this.vampRing.copyFromParent.push('layer');
            _this.addAbility('update', Vampire.update);
            return _this;
        }
        Vampire.prototype.getName = function () { return 'Vampire'; };
        Vampire.prototype.getDesc = function () { return "Drain [g]" + this.drainRate + "<heart>/s TOTAL[/g] from nearby allies, absorbing [lb]" + this.absorbMult + "x[/lb] as health\n\nCannot drain from other Vampires"; };
        Vampire.prototype.getShopDmg = function () { return 5; };
        Vampire.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Vampire.prototype, "drainRate", {
            get: function () { return 3 + 1 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Vampire.prototype, "drainRadius", {
            get: function () { return 24; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Vampire.prototype, "absorbMult", {
            get: function () { return 1.25 + 0.25 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Vampire.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.vampRing.setVisible(!this.isInShop && !this.isInYourSquadScene);
            World.Actions.orderWorldObjectBefore(this.vampRing, this);
        };
        Vampire.prototype.setForInShop = function () {
            this.vampRing.setVisible(false);
        };
        Vampire.update = function (source, world) {
            var e_181, _a;
            if (source.state !== Ball.States.BATTLE)
                return;
            var allyBalls = getAlliesNotSelf(world, source).filter(function (ball) { return !(ball instanceof Vampire) && G.distance(ball, source) < ball.physicalRadius + source.drainRadius; });
            if (allyBalls.length === 0)
                return;
            var drainRateForEachBall = source.drainRate / allyBalls.length;
            var totalHpDrained = 0;
            try {
                for (var allyBalls_1 = __values(allyBalls), allyBalls_1_1 = allyBalls_1.next(); !allyBalls_1_1.done; allyBalls_1_1 = allyBalls_1.next()) {
                    var ball = allyBalls_1_1.value;
                    var hpToDrain = drainRateForEachBall * source.delta;
                    var actualHpDrained = ball.leechFor(hpToDrain, source);
                    ball.addLeeched(0.1);
                    if (ball.dead) {
                        world.addWorldObject(new Explosion(ball.x, ball.y, 10, { ally: 0, enemy: 0 }));
                        world.runScript(shake(world, 1, 0.1));
                    }
                    totalHpDrained += actualHpDrained;
                }
            }
            catch (e_181_1) { e_181 = { error: e_181_1 }; }
            finally {
                try {
                    if (allyBalls_1_1 && !allyBalls_1_1.done && (_a = allyBalls_1.return)) _a.call(allyBalls_1);
                }
                finally { if (e_181) throw e_181.error; }
            }
            var healedHp = totalHpDrained * source.absorbMult;
            source.maxhp += healedHp;
            source.hp += healedHp;
            source.showHpStat(healedHp, 0.5);
        };
        return Vampire;
    }(Ball));
    Balls.Vampire = Vampire;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Vanguard = /** @class */ (function (_super) {
        __extends(Vanguard, _super);
        function Vanguard(config) {
            var _this = _super.call(this, 'balls/vanguard', 8, config) || this;
            _this.visibleBlockRadius = _this.auraRadius;
            _this.addAbility('update', Vanguard.update);
            return _this;
        }
        Vanguard.prototype.getName = function () { return 'Vanguard'; };
        Vanguard.prototype.getDesc = function () { return "Allies take [r]" + this.dmgReduction + "<sword>[/r] less per hit while in its radius (cannot decrease damage below 0.75)"; };
        Vanguard.prototype.getShopDmg = function () { return 2; };
        Vanguard.prototype.getShopHp = function () { return 6; };
        Object.defineProperty(Vanguard.prototype, "dmgReduction", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Vanguard.prototype, "auraRadius", {
            get: function () { return this.physicalRadius + 40 + 8 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Vanguard.prototype, "yourSquadRadius", {
            get: function () { return 15; },
            enumerable: false,
            configurable: true
        });
        Vanguard.prototype.render = function (texture, x, y) {
            var drawRadius = this.isInYourSquadScene ? this.yourSquadRadius : this.visibleBlockRadius;
            Draw.brush.color = Color.lerpColorByLch(0xFFFF00, 0xFFD800, Tween.Easing.OscillateSine(2)(this.life.time));
            Draw.brush.alpha = 0.6;
            Draw.brush.thickness = 1;
            Draw.circleOutline(texture, x, y, drawRadius, Draw.ALIGNMENT_INNER);
            _super.prototype.render.call(this, texture, x, y);
        };
        Vanguard.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.isInShop && !this.isBeingMoved()) {
                this.visibleBlockRadius = 0;
            }
            else {
                this.visibleBlockRadius = M.lerpTime(this.visibleBlockRadius, this.auraRadius, 100, this.delta);
            }
        };
        Vanguard.prototype.setForInShop = function () {
            this.visibleBlockRadius = 0;
        };
        Vanguard.update = function (source, world) {
            var e_182, _a;
            if (source.state !== Ball.States.BATTLE && source.state !== Ball.States.PRE_BATTLE)
                return;
            var balls = getAlliesNotSelf(world, source).filter(function (ball) { return G.distance(ball, source) < ball.radius + source.auraRadius; });
            try {
                for (var balls_18 = __values(balls), balls_18_1 = balls_18.next(); !balls_18_1.done; balls_18_1 = balls_18.next()) {
                    var ball = balls_18_1.value;
                    ball.addProtected(source, source.dmgReduction, 0.1);
                }
            }
            catch (e_182_1) { e_182 = { error: e_182_1 }; }
            finally {
                try {
                    if (balls_18_1 && !balls_18_1.done && (_a = balls_18.return)) _a.call(balls_18);
                }
                finally { if (e_182) throw e_182.error; }
            }
        };
        return Vanguard;
    }(Ball));
    Balls.Vanguard = Vanguard;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var VoodooBall = /** @class */ (function (_super) {
        __extends(VoodooBall, _super);
        function VoodooBall(config) {
            var _this = _super.call(this, 'balls/voodooball', 8, config) || this;
            _this.addAbility('onDeath', VoodooBall.onDeath);
            return _this;
        }
        VoodooBall.prototype.getName = function () { return 'Voodoo Ball'; };
        VoodooBall.prototype.getDesc = function () { return "On death, reflect " + this.damagePercent + "% of its killer's [r]<sword>[/r] back at it"; };
        VoodooBall.prototype.getShopDmg = function () { return 4; };
        VoodooBall.prototype.getShopHp = function () { return 4; };
        VoodooBall.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        Object.defineProperty(VoodooBall.prototype, "damagePercent", {
            get: function () {
                return 10 + 10 * this.level;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VoodooBall.prototype, "damageFactor", {
            get: function () { return this.damagePercent / 100; },
            enumerable: false,
            configurable: true
        });
        VoodooBall.onDeath = function (source, world, killedBy) {
            killedBy.takeDamage(killedBy.dmg * source.damageFactor, source, 'other');
            killedBy.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                                killedBy.tint = Color.lerpColorByLch(0xB200B2, 0xFFFFFF, t);
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            world.addWorldObject(new Voodoo(killedBy));
        };
        return VoodooBall;
    }(Ball));
    Balls.VoodooBall = VoodooBall;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Watcher = /** @class */ (function (_super) {
        __extends(Watcher, _super);
        function Watcher(config) {
            var _this = _super.call(this, 'balls/watcher', 8, config) || this;
            _this.addAbility('onBallJoin', Watcher.onBallJoin);
            return _this;
        }
        Watcher.prototype.getName = function () { return 'Watcher'; };
        Watcher.prototype.getDesc = function () { return "When an ally or enemy is summoned, gain " + buffText(this.buffDamage, this.buffHealth); };
        Watcher.prototype.getShopDmg = function () { return 3; };
        Watcher.prototype.getShopHp = function () { return 3; };
        Watcher.prototype.getCredits = function () { return [CreditsNames.LIFEWRATH]; };
        Object.defineProperty(Watcher.prototype, "buffDamage", {
            get: function () { return 0.5 + 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Watcher.prototype, "buffHealth", {
            get: function () { return 0.5 + 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Watcher.onBallJoin = function (source, world, ball) {
            if (!ball.isSummon)
                return;
            Watcher.giveBuff(source);
        };
        Watcher.giveBuff = function (source) {
            source.buff(source.buffDamage, source.buffHealth);
        };
        return Watcher;
    }(Ball));
    Balls.Watcher = Watcher;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Watermelon = /** @class */ (function (_super) {
        __extends(Watermelon, _super);
        function Watermelon(config) {
            var _this = _super.call(this, 'balls/watermelon', 8, config) || this;
            _this.angle = 90;
            _this.displayedName = Random.boolean(0.9) ? 'Watermelon' : 'Materwelon';
            _this.direction = vec2(0, 0);
            _this.cooldown = _this.addTimer(0.1);
            _this.cooldown.finish();
            _this.addAbility('onCollideWithEnemyPostDamage', Watermelon.onCollideWithEnemyPostDamage, { canActivateTwice: false });
            return _this;
        }
        Watermelon.prototype.getName = function () { return this.displayedName; };
        Watermelon.prototype.getDesc = function () { return "Collisions cause [r]" + this.splashDamage + "<sword>[/r] splash damage to nearby enemies"; };
        Watermelon.prototype.getShopDmg = function () { return 0; };
        Watermelon.prototype.getShopHp = function () { return 3; };
        Watermelon.prototype.getCredits = function () { return [CreditsNames.POPAN]; };
        Object.defineProperty(Watermelon.prototype, "splashDamage", {
            get: function () { return 0.5 + 0.5 * this.level; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Watermelon.prototype, "splashRadius", {
            get: function () { return 24; },
            enumerable: false,
            configurable: true
        });
        Watermelon.prototype.updateBattle = function () {
            _super.prototype.updateBattle.call(this);
            this.direction.set(this.v);
        };
        Watermelon.onCollideWithEnemyPostDamage = function (source, world, collideWith, damage) {
            if (!source.cooldown.done)
                return;
            Watermelon.splash(source, world);
            if (source.shouldActivateAbilityTwice()) {
                source.doAfterTime(0.1, function () { return Watermelon.splash(source, world); });
            }
            source.cooldown.reset();
        };
        Watermelon.splash = function (source, world) {
            var p = source.direction.withMagnitude(16).add(source.x, source.y);
            var splash = world.addWorldObject(new CircleImpact(p.x, p.y, source.splashRadius, { ally: 0, enemy: source.splashDamage }, source));
            splash.color = 0xFF0044;
            world.playSound('splash');
        };
        return Watermelon;
    }(Ball));
    Balls.Watermelon = Watermelon;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Wizard = /** @class */ (function (_super) {
        __extends(Wizard, _super);
        function Wizard(config) {
            var _this = _super.call(this, 'balls/wizard', 8, config) || this;
            _this.hat = _this.addChild(new Sprite({
                texture: 'wizardhat',
                copyFromParent: ['layer'],
            }));
            _this.addAbility('onSell', Wizard.onSell, { canActivateTwice: false });
            return _this;
        }
        Wizard.prototype.getName = function () { return 'Wizard'; };
        Wizard.prototype.getDesc = function () {
            if (Wizard.getRestocks(this) === 1)
                return "If sold, will reappear in the shop next restock with +" + buffText(Wizard.getBuffAmount(this), Wizard.getBuffAmount(this)) + "\n\nRequired restocks carry over between rounds";
            return "If sold, will reappear in the shop after [lb]" + Wizard.getRestocks(this) + "[/lb] restocks\nwith +" + buffText(Wizard.getBuffAmount(this), Wizard.getBuffAmount(this)) + "\n\nRequired restocks carry over between rounds";
        };
        Wizard.prototype.getShopDmg = function () { return 3; };
        Wizard.prototype.getShopHp = function () { return 3; };
        Wizard.prototype.getShopRelativePosition = function () { return vec2(0, 4); };
        Wizard.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        Wizard.getRestocks = function (source) { return Math.max(8 - 2 * (source.level - 1), 1); };
        Wizard.getBuffAmount = function (source) { return 1; };
        Wizard.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.hat.alpha = this.alpha;
            this.hat.scale = this.ballScale * this.moveScale;
            World.Actions.orderWorldObjectAfter(this.hat, this);
        };
        Wizard.prototype.changeHighlight = function (enabled, color, alpha) {
            if (color === undefined)
                color = this.hat.effects.outline.color;
            if (alpha === undefined)
                alpha = this.hat.effects.outline.alpha;
            this.hat.effects.outline.enabled = enabled;
            this.hat.effects.outline.color = color;
            this.hat.effects.outline.alpha = alpha;
        };
        Wizard.onSell = function (source, world) {
            Wizard.giveBuff(source);
            if (source.shouldActivateAbilityTwice()) {
                Wizard.giveBuff(source);
            }
            GAME_DATA.restockQueue.push({ restocksLeft: Wizard.getRestocks(source), ball: source.properties });
        };
        Wizard.giveBuff = function (source) {
            source.dmg += Wizard.getBuffAmount(source);
            source.hp += Wizard.getBuffAmount(source);
            source.properties.damage += Wizard.getBuffAmount(source);
            source.properties.health += Wizard.getBuffAmount(source);
        };
        return Wizard;
    }(Ball));
    Balls.Wizard = Wizard;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Wobby = /** @class */ (function (_super) {
        __extends(Wobby, _super);
        function Wobby(config) {
            var _this = _super.call(this, Wobby.getTextureForLevel(config.properties.level), 8, config) || this;
            _this.addAbility('onLevelUp', Wobby.onLevelUp);
            _this.addAbility('onLevelDown', Wobby.onLevelDown, { canActivateTwice: false });
            return _this;
        }
        Wobby.prototype.getName = function () { return 'Wobby'; };
        Wobby.prototype.getDesc = function () { return "On level up, give [g]" + Wobby.getBuffAmount(this) + "<heart>[/g] to itself and allies"; };
        Wobby.prototype.getShopDmg = function () { return 4; };
        Wobby.prototype.getShopHp = function () { return 5; };
        Wobby.getBuffAmount = function (source) { return 1; };
        Wobby.prototype.changeAnimations = function () {
            var baseTexture = Wobby.getTextureForLevel(this.level);
            this.changeBaseTextureAndRadius(baseTexture, 8);
        };
        Wobby.onLevelUp = function (source, world) {
            var e_183, _a;
            if (source instanceof Wobby) {
                source.changeAnimations();
            }
            if (source.world instanceof AlmanacMenu)
                return;
            var validBalls = getAllies(world, source).filter(function (ball) { return ball.isInShop == source.isInShop; });
            try {
                for (var validBalls_8 = __values(validBalls), validBalls_8_1 = validBalls_8.next(); !validBalls_8_1.done; validBalls_8_1 = validBalls_8.next()) {
                    var ball = validBalls_8_1.value;
                    world.addWorldObject(new Buff(source.x, source.y, ball, { dmg: 0, hp: Wobby.getBuffAmount(source) }));
                }
            }
            catch (e_183_1) { e_183 = { error: e_183_1 }; }
            finally {
                try {
                    if (validBalls_8_1 && !validBalls_8_1.done && (_a = validBalls_8.return)) _a.call(validBalls_8);
                }
                finally { if (e_183) throw e_183.error; }
            }
        };
        Wobby.onLevelDown = function (source, world) {
            source.changeAnimations();
        };
        Wobby.getTextureForLevel = function (level) {
            return "balls/wobby" + M.clamp(level, 1, 4);
        };
        return Wobby;
    }(Ball));
    Balls.Wobby = Wobby;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Zombie = /** @class */ (function (_super) {
        __extends(Zombie, _super);
        function Zombie(config) {
            var _this = _super.call(this, 'balls/zombie', 8, config) || this;
            _this.addAbility('onDeath', Zombie.onDeath);
            return _this;
        }
        Zombie.prototype.getName = function () { return 'Zombie'; };
        Zombie.prototype.getDesc = function () { return "On death, summon a " + buffText(this.skeletonPower, this.skeletonPower) + " skeleton"; };
        Zombie.prototype.getShopDmg = function () { return 1; };
        Zombie.prototype.getShopHp = function () { return 2; };
        Object.defineProperty(Zombie.prototype, "skeletonPower", {
            get: function () { return this.level; },
            enumerable: false,
            configurable: true
        });
        Zombie.onDeath = function (source, world, killedBy) {
            world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: source.skeletonPower,
                    health: source.skeletonPower,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
        };
        return Zombie;
    }(Ball));
    Balls.Zombie = Zombie;
})(Balls || (Balls = {}));
var Balls;
(function (Balls) {
    var Zoomer = /** @class */ (function (_super) {
        __extends(Zoomer, _super);
        function Zoomer(config) {
            var _this = _super.call(this, 'balls/zoomer', 8, config) || this;
            _this.addAbility('update', Zoomer.update);
            return _this;
        }
        Zoomer.prototype.getName = function () { return 'Zoomer'; };
        Zoomer.prototype.getDesc = function () { return "Always moves at minimum [lb]" + this.speedPercent + "%[/lb] speed"; };
        Zoomer.prototype.getShopDmg = function () { return 1; };
        Zoomer.prototype.getShopHp = function () { return 4; };
        Zoomer.prototype.getCredits = function () { return [CreditsNames.NEPDEP]; };
        Object.defineProperty(Zoomer.prototype, "speedPercent", {
            get: function () { return 90 + 5 * (this.level - 1); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Zoomer.prototype, "speedFactor", {
            get: function () { return this.speedPercent / 100; },
            enumerable: false,
            configurable: true
        });
        Zoomer.update = function (source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var maxSpeed = isFinite(source.maxSpeed) ? source.maxSpeed : 150;
            var targetSpeed = maxSpeed * source.speedFactor;
            if (source.v.magnitude > 0 && source.v.magnitude < targetSpeed) {
                source.v.setMagnitude(targetSpeed);
            }
            source.addBoostMaxSpeed(source, 'other', source.speedFactor, source.speedFactor, 0.5);
        };
        return Zoomer;
    }(Ball));
    Balls.Zoomer = Zoomer;
})(Balls || (Balls = {}));
var BallItem = /** @class */ (function (_super) {
    __extends(BallItem, _super);
    function BallItem(x, y, texture) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: texture,
            layer: Battle.Layers.ui,
            bounds: new CircleBounds(0, 0, 12),
        }) || this;
        _this.defaultOutline = 0xFFFFFF;
        _this.defaultOutlineAlpha = 1;
        _this.canFreeze = true;
        _this.moveScale = 1;
        return _this;
    }
    BallItem.prototype.getType = function () { return 'Item'; };
    BallItem.prototype.getName = function () { return 'unknown'; };
    BallItem.prototype.getDesc = function () { return 'unknown'; };
    BallItem.prototype.getShopCost = function () { return 3; };
    BallItem.prototype.getCredits = function () { return []; };
    Object.defineProperty(BallItem.prototype, "mapToEquipmentTypes", {
        get: function () { return []; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BallItem.prototype, "frozen", {
        get: function () { return !!this.freezeSprite; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BallItem.prototype, "isInShop", {
        get: function () { return true; },
        enumerable: false,
        configurable: true
    });
    BallItem.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        if (this.freezeSprite) {
            World.Actions.orderWorldObjectAfter(this.freezeSprite, this);
        }
    };
    BallItem.prototype.canApplyToBall = function (ball) {
        return true;
    };
    BallItem.prototype.changeHighlight = function (enabled, color, alpha) {
        if (color === undefined)
            color = this.effects.outline.color;
        if (alpha === undefined)
            alpha = this.effects.outline.alpha;
        this.effects.outline.enabled = enabled;
        this.effects.outline.color = color;
        this.effects.outline.alpha = alpha;
    };
    BallItem.prototype.freeze = function (immediate) {
        this.freezeSprite = this.addChild(new FreezeIce(8, immediate));
        if (this.shopSpot >= 0) {
            GAME_DATA.frozenThings[this.shopSpot] = {
                type: 'item',
                itemType: this.type
            };
        }
    };
    BallItem.prototype.getDescPrefix = function () {
        return undefined;
    };
    BallItem.prototype.giveShine = function () {
        this.removeShine();
        this.effects.pre.filters.push(new ShineFilter(Color.lerpColorByLch(getColorForTier(this.tier), 0xFFFFFF, 0.5)));
    };
    BallItem.prototype.isAboutToReplace = function (ball) {
        return false;
    };
    BallItem.prototype.isGlitched = function () {
        return false;
    };
    BallItem.prototype.isPurchasable = function () {
        return true;
    };
    BallItem.prototype.onApplyToBall = function (ball) {
    };
    BallItem.prototype.onPickUp = function () {
    };
    BallItem.prototype.onPutDown = function () {
    };
    BallItem.prototype.onStartShopBeforeStartShopEffects = function () {
    };
    BallItem.prototype.removeShine = function () {
        var i = this.effects.pre.filters.findIndex(function (filter) { return filter instanceof ShineFilter; });
        if (i >= 0) {
            this.effects.pre.filters.splice(i, 1);
        }
    };
    BallItem.prototype.setMoveScale = function (moveScale) {
        this.moveScale = moveScale;
        this.scale = this.moveScale;
        this.bounds.radius = 12 * this.moveScale;
    };
    BallItem.prototype.unfreeze = function () {
        this.freezeSprite.kill();
        this.freezeSprite = undefined;
        if (this.shopSpot >= 0) {
            GAME_DATA.frozenThings[this.shopSpot] = undefined;
        }
    };
    return BallItem;
}(Sprite));
/// <reference path="./ballItem.ts" />
var EquipmentItem = /** @class */ (function (_super) {
    __extends(EquipmentItem, _super);
    function EquipmentItem(x, y, texture, equipmentType) {
        var _this = _super.call(this, x, y, texture) || this;
        _this.equipmentType = equipmentType;
        return _this;
    }
    EquipmentItem.prototype.getType = function () { return 'Equipment'; };
    Object.defineProperty(EquipmentItem.prototype, "mapToEquipmentTypes", {
        get: function () { return [this.equipmentType]; },
        enumerable: false,
        configurable: true
    });
    EquipmentItem.prototype.onApplyToBall = function (ball) {
        ball.equip(this.equipmentType);
    };
    EquipmentItem.prototype.isAboutToReplace = function (ball) {
        return !!ball.equipment;
    };
    return EquipmentItem;
}(BallItem));
/// <reference path="./equipmentItem.ts" />
var BallItems;
(function (BallItems) {
    var ArmorPlating = /** @class */ (function (_super) {
        __extends(ArmorPlating, _super);
        function ArmorPlating(x, y) {
            return _super.call(this, x, y, 'items/armorplating', 3) || this;
        }
        ArmorPlating.prototype.getName = function () { return 'Armor Plating'; };
        ArmorPlating.prototype.getDesc = function () { return "Decrease all instances of damage taken by 2 (cannot decrease damage below 0.75)"; };
        return ArmorPlating;
    }(EquipmentItem));
    BallItems.ArmorPlating = ArmorPlating;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var BallSharpener = /** @class */ (function (_super) {
        __extends(BallSharpener, _super);
        function BallSharpener(x, y) {
            return _super.call(this, x, y, 'items/ballsharpener') || this;
        }
        BallSharpener.prototype.getName = function () { return 'Ball Sharpener'; };
        BallSharpener.prototype.getDesc = function () { return "Give a ball [r]+" + this.buffAmount + "<sword>[/r]"; };
        Object.defineProperty(BallSharpener.prototype, "buffAmount", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        BallSharpener.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: this.buffAmount, hp: 0 }));
        };
        return BallSharpener;
    }(BallItem));
    BallItems.BallSharpener = BallSharpener;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var BallSharpener1 = /** @class */ (function (_super) {
        __extends(BallSharpener1, _super);
        function BallSharpener1(x, y) {
            return _super.call(this, x, y, 'items/ballsharpener1') || this;
        }
        BallSharpener1.prototype.getName = function () { return 'Mini Sharpener'; };
        BallSharpener1.prototype.getDesc = function () { return "Give a ball [r]+" + this.buffAmount + "<sword>[/r]\n\nAvailable only in Tier 1"; };
        Object.defineProperty(BallSharpener1.prototype, "buffAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        BallSharpener1.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: this.buffAmount, hp: 0 }));
        };
        return BallSharpener1;
    }(BallItem));
    BallItems.BallSharpener1 = BallSharpener1;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Bandaid = /** @class */ (function (_super) {
        __extends(Bandaid, _super);
        function Bandaid(x, y) {
            return _super.call(this, x, y, 'items/bandaid', 17) || this;
        }
        Bandaid.prototype.getName = function () { return 'Bandaid'; };
        Bandaid.prototype.getDesc = function () { return "Gain [g]1<heart>[/g]\n\nIf the equipped ball dies during battle, it gains [g]1<heart>[/g] next round"; };
        Bandaid.prototype.onApplyToBall = function (ball) {
            _super.prototype.onApplyToBall.call(this, ball);
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: 0, hp: 1 }));
        };
        return Bandaid;
    }(EquipmentItem));
    BallItems.Bandaid = Bandaid;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var BestFriend = /** @class */ (function (_super) {
        __extends(BestFriend, _super);
        function BestFriend(x, y) {
            return _super.call(this, x, y, 'items/bestfriend', 20) || this;
        }
        BestFriend.prototype.getName = function () { return 'Best Friend'; };
        BestFriend.prototype.getDesc = function () { return "On death, revive with [r]1<sword>[/r] [g]1<heart>[/g]"; };
        BestFriend.prototype.getCredits = function () { return [CreditsNames.HOPOO_GAMES]; };
        return BestFriend;
    }(EquipmentItem));
    BallItems.BestFriend = BestFriend;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var BirthdayCake = /** @class */ (function (_super) {
        __extends(BirthdayCake, _super);
        function BirthdayCake(x, y) {
            var _this = _super.call(this, x, y, 'items/birthdaycake') || this;
            _this.canFreeze = false;
            _this.addChild(new Sprite({
                texture: 'buffbeams',
                blendMode: Texture.BlendModes.ADD,
                copyFromParent: ['layer'],
                scale: 0.25,
                vangle: 90,
                update: function () {
                    World.Actions.orderWorldObjectBefore(this, this.parent);
                },
            }));
            return _this;
        }
        BirthdayCake.prototype.getName = function () { return 'Birthday Cake'; };
        BirthdayCake.prototype.getDesc = function () { return "Enter [gold]Birthday Mode[/]! Every Pi<ntick>ata you buy gives your team a buff!"; };
        BirthdayCake.prototype.getShopCost = function () { return 3; };
        BirthdayCake.prototype.onApplyToBall = function (ball) {
            var world = this.world;
            world.runScript(function () {
                var flash, puffPositions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            flash = world.addWorldObject(new Sprite({
                                texture: Texture.filledRect(global.gameWidth, global.gameHeight, 0xFFFFFF),
                                alpha: 0,
                            }));
                            world.playSound('sweep');
                            return [4 /*yield*/, S.tween(1.8, flash, 'alpha', 0, 1)];
                        case 1:
                            _a.sent();
                            Arenas.SET_FOR_ARENA(world, Arenas.ARENA_BDAY);
                            GAME_DATA.arena = Arenas.ARENA_BDAY;
                            global.game.playSound('yay').volume = 0.5;
                            global.game.playSound('confetti').volume = 0.7;
                            puffPositions = [vec2(80, 80), vec2(240, 160), vec2(80, 160), vec2(240, 80), vec2(80, 80), vec2(240, 160), vec2(80, 160)];
                            world.runScript(S.loopFor(puffPositions.length, function (i) { return function () {
                                var puffSystem;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            global.game.playSound('popper').volume = 0.35;
                                            puffSystem = world.addWorldObject(new BurstPuffSystem({
                                                x: puffPositions[i].x, y: puffPositions[i].y,
                                                puffCount: 25,
                                                puffConfigFactory: function () { return ({
                                                    maxLife: 0.5,
                                                    v: Random.inCircle(200),
                                                    color: Random.element([0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF]),
                                                    radius: 4,
                                                    finalRadius: 0,
                                                }); },
                                            }));
                                            World.Actions.orderWorldObjectBefore(puffSystem, flash);
                                            return [4 /*yield*/, S.wait(0.2)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }; }));
                            return [4 /*yield*/, S.tween(0.5, flash, 'alpha', 1, 0)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return BirthdayCake;
    }(BallItem));
    BallItems.BirthdayCake = BirthdayCake;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Bounty = /** @class */ (function (_super) {
        __extends(Bounty, _super);
        function Bounty(x, y) {
            return _super.call(this, x, y, 'items/bounty', 11) || this;
        }
        Bounty.prototype.getName = function () { return 'Bounty'; };
        Bounty.prototype.getDesc = function () { return "Start the shop with [gold]1<coin>[/gold] extra for each kill (max [gold]3<coin>[/gold])"; };
        return Bounty;
    }(EquipmentItem));
    BallItems.Bounty = Bounty;
})(BallItems || (BallItems = {}));
/// <reference path="./equipmentItem.ts" />
var BallItems;
(function (BallItems) {
    var CatEars = /** @class */ (function (_super) {
        __extends(CatEars, _super);
        function CatEars(x, y) {
            return _super.call(this, x, y, 'items/catears', 4) || this;
        }
        CatEars.prototype.getName = function () { return 'Cat Ears'; };
        CatEars.prototype.getDesc = function () { return "They do nothing, but I've been told cute cosmetics increase in-app purchase sales??"; };
        CatEars.prototype.getShopCost = function () { return 0; };
        return CatEars;
    }(EquipmentItem));
    BallItems.CatEars = CatEars;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Claws = /** @class */ (function (_super) {
        __extends(Claws, _super);
        function Claws(x, y) {
            return _super.call(this, x, y, 'items/claws', 5) || this;
        }
        Claws.prototype.getName = function () { return 'Claws'; };
        Claws.prototype.getDesc = function () { return "Claw the first enemy collided with for [r]4<sword> extra[/r]"; };
        return Claws;
    }(EquipmentItem));
    BallItems.Claws = Claws;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var CloutInAJar = /** @class */ (function (_super) {
        __extends(CloutInAJar, _super);
        function CloutInAJar(x, y) {
            return _super.call(this, x, y, 'items/clout') || this;
        }
        CloutInAJar.prototype.getName = function () { return 'Clout-In-A-Jar'; };
        CloutInAJar.prototype.getDesc = function () { return "Gain +[gold]1<star>[/gold]"; };
        CloutInAJar.prototype.onApplyToBall = function (ball) {
            ball.levelUp(undefined, true, false);
        };
        return CloutInAJar;
    }(BallItem));
    BallItems.CloutInAJar = CloutInAJar;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var CollectibleCoin = /** @class */ (function (_super) {
        __extends(CollectibleCoin, _super);
        function CollectibleCoin(x, y) {
            return _super.call(this, x, y, 'items/collectiblecoin') || this;
        }
        CollectibleCoin.prototype.getName = function () { return 'Collectible Coin'; };
        CollectibleCoin.prototype.getDesc = function () { return "Start the shop with [gold]1<coin>[/gold] extra each round while this item is [lb]frozen[/lb]"; };
        CollectibleCoin.prototype.isPurchasable = function () {
            return false;
        };
        CollectibleCoin.prototype.onStartShopBeforeStartShopEffects = function () {
            if (!this.frozen)
                return;
            addStartShopEffect({
                type: 'gold',
                gold: 1,
                sourceSquadIndex: -1,
            });
            animateGiveOrTakeShopGold(this.world, this, 1);
            addItemTypeForAlmanacWin(this.type);
        };
        return CollectibleCoin;
    }(BallItem));
    BallItems.CollectibleCoin = CollectibleCoin;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ConsolationPrize = /** @class */ (function (_super) {
        __extends(ConsolationPrize, _super);
        function ConsolationPrize(x, y) {
            return _super.call(this, x, y, 'items/consolationprize') || this;
        }
        ConsolationPrize.prototype.getName = function () { return 'Consolation Prize'; };
        ConsolationPrize.prototype.getDesc = function () { return "Give a ball " + buffText(this.buffDmgAmount, this.buffHpAmount) + "\n\nOnly available if you lost the previous round"; };
        Object.defineProperty(ConsolationPrize.prototype, "buffDmgAmount", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ConsolationPrize.prototype, "buffHpAmount", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        ConsolationPrize.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: this.buffDmgAmount, hp: this.buffHpAmount }));
        };
        return ConsolationPrize;
    }(BallItem));
    BallItems.ConsolationPrize = ConsolationPrize;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Contagion = /** @class */ (function (_super) {
        __extends(Contagion, _super);
        function Contagion(x, y) {
            return _super.call(this, x, y, 'items/contagion', 32) || this;
        }
        Contagion.prototype.getName = function () { return 'Contagion'; };
        Contagion.prototype.getDesc = function () { return "At the start of battle, give nearby allies [dg]Infection equipments[/dg]\n\nInfected balls summon Skeletons on death"; };
        return Contagion;
    }(EquipmentItem));
    BallItems.Contagion = Contagion;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Curry = /** @class */ (function (_super) {
        __extends(Curry, _super);
        function Curry(x, y) {
            return _super.call(this, x, y, 'items/curry', 40) || this;
        }
        Curry.prototype.getName = function () { return 'Curry'; };
        Curry.prototype.getDesc = function () { return "The equipped ball is on fire and moves at 200% speed for 10 seconds after entering battle"; };
        Curry.prototype.getCredits = function () { return [CreditsNames.C_RRY]; };
        Curry.prototype.onApplyToBall = function (ball) {
            var _a;
            _super.prototype.onApplyToBall.call(this, ball);
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('fireignite', { humanized: false });
        };
        return Curry;
    }(EquipmentItem));
    BallItems.Curry = Curry;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var CursedDoll = /** @class */ (function (_super) {
        __extends(CursedDoll, _super);
        function CursedDoll(x, y) {
            return _super.call(this, x, y, 'items/curseddoll', 35) || this;
        }
        CursedDoll.prototype.getName = function () { return 'Cursed Doll'; };
        CursedDoll.prototype.getDesc = function () { return "On death, transform the killer into a skeleton"; };
        CursedDoll.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        return CursedDoll;
    }(EquipmentItem));
    BallItems.CursedDoll = CursedDoll;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var CursedEye = /** @class */ (function (_super) {
        __extends(CursedEye, _super);
        function CursedEye(x, y) {
            return _super.call(this, x, y, 'items/cursedeye', 36) || this;
        }
        CursedEye.prototype.getName = function () { return 'Cursed Eye'; };
        CursedEye.prototype.getDesc = function () { return "Teleport away from enemies on taking damage"; };
        CursedEye.prototype.getCredits = function () { return [CreditsNames.ISAAC]; };
        return CursedEye;
    }(EquipmentItem));
    BallItems.CursedEye = CursedEye;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Gift = /** @class */ (function (_super) {
        __extends(Gift, _super);
        function Gift(x, y) {
            return _super.call(this, x, y, 'items/gift') || this;
        }
        Gift.prototype.getName = function () { return 'A Gift'; };
        Gift.prototype.getDesc = function () { return "Happy Birthday!"; };
        Gift.prototype.getShopCost = function () { return 0; };
        Gift.prototype.onApplyToBall = function (ball) {
            var _this = this;
            var choices = [
                function () { return _this.giveBuff(ball); },
                function () { return _this.giveEquipment(ball); },
            ];
            Ball.Random.elementWeighted(choices, [0.2, 0.8])();
        };
        Gift.prototype.giveBuff = function (ball) {
            var buff = Ball.Random.element([
                { dmg: 2, hp: 0 },
                { dmg: 0, hp: 2 },
                { dmg: 1, hp: 1 },
            ]);
            this.world.addWorldObject(new Buff(this.x, this.y, ball, buff));
            return true;
        };
        Gift.prototype.giveEquipment = function (ball) {
            var currentTier = getShopTierForRound(GAME_DATA.round);
            var possibleEquipments = _.flatten([1, 2, 3, 4].filter(function (i) { return i <= currentTier; }).map(function (tier) { return getPurchasableEquipmentTypesForExactTier(tier); }));
            if (_.isEmpty(possibleEquipments)) {
                return false;
            }
            this.world.addWorldObject(new RandomEquipment(this.x, this.y, ball, ball, Ball.Random.element(possibleEquipments), false, function (allies) { return undefined; }, Utils.NOOP));
            return true;
        };
        return Gift;
    }(BallItem));
    BallItems.Gift = Gift;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var GlitchedItemArg = /** @class */ (function (_super) {
        __extends(GlitchedItemArg, _super);
        function GlitchedItemArg(x, y) {
            var _this = _super.call(this, x, y, 'items/clout') || this;
            _this.canFreeze = false;
            _this.baseTextureIndex = 0;
            _this.effects.post.filters.push(new Effects.Filters.Glitch(8, 4, 4));
            _this.addTimer(0.2, function () { return _this.changeAnimations(); }, Infinity);
            return _this;
        }
        GlitchedItemArg.prototype.getName = function () { return '[glitched]G[offsety -1]li[/offsety]<g1>[/glitched][offsety 6]ch[/offsety][glitched]<g3>d[/glitched] [offsety 4]I[/offsety][glitched]<g2>e[/glitched]m'; };
        GlitchedItemArg.prototype.getDesc = function () { return "<g1><g4>[glitched]<g2><g3> <g5><g2><g1>??[/glitched]??<g4>"; };
        GlitchedItemArg.prototype.getShopCost = function () { return 0; };
        GlitchedItemArg.prototype.isGlitched = function () {
            return true;
        };
        GlitchedItemArg.prototype.changeAnimations = function () {
            var baseTexture = this.getNextBaseTexture();
            this.setTexture(baseTexture);
        };
        GlitchedItemArg.prototype.canApplyToBall = function (ball) {
            return ball instanceof Balls.GlitchedBallArg;
        };
        GlitchedItemArg.prototype.onApplyToBall = function (ball) {
            saveMatchmakingOrChallengeModeOrDailyGameData(undefined, CHALLENGE_MODE_ENABLED, DAILY);
            global.theater.playCutscene(ARG.Cutscenes.BEGIN_ARG);
        };
        GlitchedItemArg.prototype.getNextBaseTexture = function () {
            if (_.isEmpty(this.baseTextures))
                this.baseTextures = Object.keys(AssetCache.textures).filter(function (key) { return key.startsWith('items/'); });
            var baseTexture = this.baseTextures[this.baseTextureIndex];
            this.baseTextureIndex = M.mod(this.baseTextureIndex + 1, this.baseTextures.length);
            return baseTexture;
        };
        return GlitchedItemArg;
    }(BallItem));
    BallItems.GlitchedItemArg = GlitchedItemArg;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var GreenCube = /** @class */ (function (_super) {
        __extends(GreenCube, _super);
        function GreenCube(x, y) {
            return _super.call(this, x, y, 'items/greencube', 34) || this;
        }
        GreenCube.prototype.getName = function () { return 'Green Cube'; };
        GreenCube.prototype.getDesc = function () { return "The equipped ball's abilities have a 33% chance of activating twice"; };
        GreenCube.prototype.getCredits = function () { return [CreditsNames.C_RRY]; };
        GreenCube.prototype.canApplyToBall = function (ball) {
            return !_.contains(GreenCube.INVALID_BALL_TYPES, ball.properties.type);
        };
        GreenCube.INVALID_BALL_TYPES = [
            0,
            25,
            45,
            46,
            110,
            127,
            136,
            143,
        ];
        return GreenCube;
    }(EquipmentItem));
    BallItems.GreenCube = GreenCube;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var HotPickle = /** @class */ (function (_super) {
        __extends(HotPickle, _super);
        function HotPickle(x, y) {
            var _this = _super.call(this, x, y, 'items/hotpickle') || this;
            _this.canFreeze = false;
            return _this;
        }
        HotPickle.prototype.getName = function () { return 'Hot Pickle'; };
        HotPickle.prototype.getDesc = function () { return "Give a ball [r]+1<sword>[/r]"; };
        HotPickle.prototype.getShopCost = function () { return 1; };
        HotPickle.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: 1, hp: 0 }));
        };
        return HotPickle;
    }(BallItem));
    BallItems.HotPickle = HotPickle;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var HuntersMark = /** @class */ (function (_super) {
        __extends(HuntersMark, _super);
        function HuntersMark(x, y) {
            return _super.call(this, x, y, 'items/huntersmark', 39) || this;
        }
        HuntersMark.prototype.getName = function () { return "Hunter's Mark"; };
        HuntersMark.prototype.getDesc = function () { return "On enter battle, place a mark on a random enemy. All ally spikes will home in on that enemy"; };
        HuntersMark.prototype.getCredits = function () { return [CreditsNames.TOMMYDOG145, CreditsNames.NEPDEP]; };
        return HuntersMark;
    }(EquipmentItem));
    BallItems.HuntersMark = HuntersMark;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var HyperDriver = /** @class */ (function (_super) {
        __extends(HyperDriver, _super);
        function HyperDriver(x, y) {
            return _super.call(this, x, y, 'items/hyperdriver', 8) || this;
        }
        HyperDriver.prototype.getName = function () { return 'Hyper Driver'; };
        HyperDriver.prototype.getDesc = function () {
            var PLAY = "" + (GAME_MODE === 'vs' || GAME_MODE === 'spectate' ? 'LOCK IN' : 'PLAY');
            return "On " + PLAY + ", take [gold]<coin>5 unspent[/gold] to permanently gain " + buffText(2, 2);
        };
        HyperDriver.prototype.canApplyToBall = function (ball) {
            return !ball.isInShop;
        };
        return HyperDriver;
    }(EquipmentItem));
    BallItems.HyperDriver = HyperDriver;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Jetpack = /** @class */ (function (_super) {
        __extends(Jetpack, _super);
        function Jetpack(x, y) {
            return _super.call(this, x, y, 'items/jetpack', 28) || this;
        }
        Jetpack.prototype.getName = function () { return 'Jetpack'; };
        Jetpack.prototype.getDesc = function () { return "Accelerate up to 2x speed. Breaks on collision with an enemy"; };
        Jetpack.prototype.getCredits = function () { return [CreditsNames.ANYTHING_GOES]; };
        return Jetpack;
    }(EquipmentItem));
    BallItems.Jetpack = Jetpack;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Joker = /** @class */ (function (_super) {
        __extends(Joker, _super);
        function Joker(x, y) {
            return _super.call(this, x, y, 'items/joker', 37) || this;
        }
        Joker.prototype.getName = function () { return 'Joker'; };
        Joker.prototype.getDesc = function () { return "Scramble enemy positions at the start of battle\n\nPermanently breaks after use"; };
        return Joker;
    }(EquipmentItem));
    BallItems.Joker = Joker;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Magnet = /** @class */ (function (_super) {
        __extends(Magnet, _super);
        function Magnet(x, y) {
            return _super.call(this, x, y, 'items/magnet', 1) || this;
        }
        Magnet.prototype.getName = function () { return 'Magnet'; };
        Magnet.prototype.getDesc = function () { return "Magnetize toward enemies, up to 133% the normal speed/damage cap"; };
        return Magnet;
    }(EquipmentItem));
    BallItems.Magnet = Magnet;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Medkit = /** @class */ (function (_super) {
        __extends(Medkit, _super);
        function Medkit(x, y) {
            return _super.call(this, x, y, 'items/medkit', 26) || this;
        }
        Medkit.prototype.getName = function () { return 'Medkit'; };
        Medkit.prototype.getDesc = function () { return "Heal for [g]2<heart>[/g]\n2 seconds after taking any damage\n\nTaking damage resets the timer"; };
        Medkit.prototype.getCredits = function () { return [CreditsNames.HOPOO_GAMES]; };
        return Medkit;
    }(EquipmentItem));
    BallItems.Medkit = Medkit;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Mitosis = /** @class */ (function (_super) {
        __extends(Mitosis, _super);
        function Mitosis(x, y) {
            return _super.call(this, x, y, 'items/mitosis', 27) || this;
        }
        Mitosis.prototype.getName = function () { return 'Mitosis'; };
        Mitosis.prototype.getDesc = function () { return "At the start of battle, split into two copies with\n[r]half <sword>[/r], [g]half <heart>[/g], and [gold]half <star>[/gold]\n\n(Activates before other abilities)"; };
        return Mitosis;
    }(EquipmentItem));
    BallItems.Mitosis = Mitosis;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Mocha = /** @class */ (function (_super) {
        __extends(Mocha, _super);
        function Mocha(x, y) {
            return _super.call(this, x, y, 'items/mocha', 42) || this;
        }
        Mocha.prototype.getName = function () { return 'Mocha'; };
        Mocha.prototype.getDesc = function () { return "Start moving before other balls"; };
        Mocha.prototype.getCredits = function () { return [CreditsNames.NEPDEP]; };
        return Mocha;
    }(EquipmentItem));
    BallItems.Mocha = Mocha;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var MolecularDisassembler = /** @class */ (function (_super) {
        __extends(MolecularDisassembler, _super);
        function MolecularDisassembler(x, y) {
            var _this = _super.call(this, x, y, 'items/moleculardisassembler') || this;
            _this.defaultOutlineAlpha = 0;
            return _this;
        }
        MolecularDisassembler.prototype.getName = function () { return 'Molecular Disassembler'; };
        MolecularDisassembler.prototype.getDesc = function () { return "Disintegrate a ball, producing [g]4<heart>[/g] for random allies\n\nProduce an extra [r]1<sword>[/r] if the ball had an equipment"; };
        MolecularDisassembler.prototype.getCredits = function () { return [CreditsNames.JUNJ]; };
        Object.defineProperty(MolecularDisassembler.prototype, "hpGain", {
            get: function () { return 4; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MolecularDisassembler.prototype, "dmgBonusGain", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        MolecularDisassembler.prototype.canApplyToBall = function (ball) {
            return !ball.isInShop;
        };
        MolecularDisassembler.prototype.onApplyToBall = function (ball) {
            var filter = new DisintegrateFilter();
            ball.effects.post.filters.push(filter);
            ball.addTag(Tags.DELAY_PLAY);
            var md = this;
            ball.isBeingDisintegrated = true;
            ball.runScript(function () {
                var nova;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            ball.world.playSound('disintegrate');
                            return [4 /*yield*/, S.wait(1)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.schedule(0, S.tween(2, filter, 'amount', 0, 0.7), 0.5, S.call(function () { return md.giveBuff(ball, 0, 1); }), 0.75, S.call(function () { return md.giveBuff(ball, 0, 1); }), 1, S.call(function () { return md.giveBuff(ball, 0, 1); }), 1.25, S.call(function () { return md.giveBuff(ball, 0, 1); }))];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.5)];
                        case 3:
                            _a.sent();
                            ball.world.playSound('dioboom');
                            nova = ball.world.addWorldObject(new Sprite({
                                x: ball.x, y: ball.y,
                                texture: 'necromancerbeams',
                                scale: 0,
                                life: 1,
                                vangle: 360,
                                tags: [Tags.DELAY_PLAY],
                                layer: Battle.Layers.fx,
                            }));
                            return [4 /*yield*/, S.tween(0.05, nova, 'scale', 0, (ball.physicalRadius + 8) / 64)];
                        case 4:
                            _a.sent();
                            if (ball.equipment)
                                md.giveBuff(ball, 1, 0);
                            ShopActions.removeBallFromSquad(ball);
                            ball.kill();
                            nova.runScript(function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, S.tween(0.2, nova, 'scale', nova.scale, 0)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        MolecularDisassembler.prototype.giveBuff = function (source, dmg, hp) {
            var validAllies = getAlliesNotSelf(source.world, source).filter(function (ally) { return !ally.isInShop; });
            if (validAllies.length === 0)
                return;
            var randomAlly = Ball.Random.element(validAllies);
            var buff = source.world.addWorldObject(new Buff(source.x, source.y, randomAlly, { dmg: dmg, hp: hp }, vec2(Random.sign() * 200, 0)));
            buff.addTag(Tags.DELAY_PLAY);
        };
        MolecularDisassembler.loadFilter = function () {
            Texture.EFFECT_ONLY.renderTo(new BasicTexture(1, 1, 'MolecularDisassembler.loadFilter'), { filters: [new DisintegrateFilter()] });
        };
        return MolecularDisassembler;
    }(BallItem));
    BallItems.MolecularDisassembler = MolecularDisassembler;
    var DisintegrateFilter = /** @class */ (function (_super) {
        __extends(DisintegrateFilter, _super);
        function DisintegrateFilter() {
            var _this = _super.call(this, {
                uniforms: { 'float amount': 0 },
                code: "\n                    float staticNoise = map(pnoise(x+0.3, y+0.15, t*100.0), -1.0, 1.0, 0.0, 1.0);\n                    float staticF = step(staticNoise, 0.5);\n                    outp.rgb = vec3(1.0, 1.0, 1.0) * staticF;\n\n                    float alphaNoise = map(pnoise(x+10.7, y+7.25, 0.1), -1.0, 1.0, 0.0, 1.0);\n                    float alphaF = step(alphaNoise, 1.0 - amount);\n                    outp.a = inp.a * alphaF;\n                "
            }) || this;
            _this._amount = 0;
            return _this;
        }
        Object.defineProperty(DisintegrateFilter.prototype, "amount", {
            get: function () { return this._amount; },
            set: function (v) {
                if (this._amount === v)
                    return;
                this._amount = v;
                this.setUniform('amount', M.clamp(v, 0, Infinity));
            },
            enumerable: false,
            configurable: true
        });
        return DisintegrateFilter;
    }(TextureFilter));
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var OrbitingPotato = /** @class */ (function (_super) {
        __extends(OrbitingPotato, _super);
        function OrbitingPotato(x, y) {
            return _super.call(this, x, y, 'items/orbitingpotato') || this;
        }
        OrbitingPotato.prototype.getName = function () { return 'Orbiting Potato'; };
        OrbitingPotato.prototype.getDesc = function () { return "Gain an orbiting potato that deals [r]5<sword>/s[/r] to enemies and can block projectiles\n\nCan equip up to 3 potatoes at the same time"; };
        OrbitingPotato.prototype.getType = function () { return 'Equipment'; };
        Object.defineProperty(OrbitingPotato.prototype, "mapToEquipmentTypes", {
            get: function () { return [21, 22, 23]; },
            enumerable: false,
            configurable: true
        });
        OrbitingPotato.prototype.canApplyToBall = function (ball) {
            if (ball.equipment && ball.equipment.equipmentType === 23)
                return false;
            return true;
        };
        OrbitingPotato.prototype.onApplyToBall = function (ball) {
            if (ball.equipment && ball.equipment.equipmentType === 21)
                ball.equip(22);
            else if (ball.equipment && ball.equipment.equipmentType === 22)
                ball.equip(23);
            else
                ball.equip(21);
        };
        OrbitingPotato.prototype.isAboutToReplace = function (ball) {
            if (!ball.equipment)
                return false;
            if (ball.equipment.equipmentType === 21 || ball.equipment.equipmentType === 22 || ball.equipment.equipmentType === 23)
                return false;
            return true;
        };
        return OrbitingPotato;
    }(BallItem));
    BallItems.OrbitingPotato = OrbitingPotato;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Overcharger = /** @class */ (function (_super) {
        __extends(Overcharger, _super);
        function Overcharger(x, y) {
            var _this = _super.call(this, x, y, 'items/overcharger', 13) || this;
            _this.zapRing = _this.addChild(new ZapRing(9, {
                y: -0.5,
                copyFromParent: ['layer'],
            }));
            return _this;
        }
        Overcharger.prototype.getName = function () { return 'Overcharger'; };
        Overcharger.prototype.getDesc = function () { return "Zap nearby enemies for [r]2<sword>/s[/r] initially, decaying to [r]1<sword>/s[/r] over 1s"; };
        Overcharger.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            World.Actions.orderWorldObjectAfter(this.zapRing, this);
            this.zapRing.radius = 9 * this.moveScale;
        };
        Overcharger.prototype.onApplyToBall = function (ball) {
            var _a;
            _super.prototype.onApplyToBall.call(this, ball);
            (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('zapequip', { humanized: false });
        };
        return Overcharger;
    }(EquipmentItem));
    BallItems.Overcharger = Overcharger;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ParticipationTrophy = /** @class */ (function (_super) {
        __extends(ParticipationTrophy, _super);
        function ParticipationTrophy(x, y) {
            return _super.call(this, x, y, 'items/participationtrophy') || this;
        }
        ParticipationTrophy.prototype.getName = function () { return 'Participation Trophy'; };
        ParticipationTrophy.prototype.getDesc = function () { return "Give a ball " + buffText(this.buffDmgAmount, this.buffHpAmount) + "\n\nOnly available if you lost the previous round"; };
        Object.defineProperty(ParticipationTrophy.prototype, "buffDmgAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ParticipationTrophy.prototype, "buffHpAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        ParticipationTrophy.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: this.buffDmgAmount, hp: this.buffHpAmount }));
        };
        return ParticipationTrophy;
    }(BallItem));
    BallItems.ParticipationTrophy = ParticipationTrophy;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Pickle = /** @class */ (function (_super) {
        __extends(Pickle, _super);
        function Pickle(x, y) {
            var _this = _super.call(this, x, y, 'items/pickle') || this;
            _this.canFreeze = false;
            return _this;
        }
        Pickle.prototype.getName = function () { return 'Pickle'; };
        Pickle.prototype.getDesc = function () { return "Give a ball [g]+1<heart>[/g]"; };
        Pickle.prototype.getShopCost = function () { return 1; };
        Pickle.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: 0, hp: 1 }));
        };
        return Pickle;
    }(BallItem));
    BallItems.Pickle = Pickle;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var PolarityInverter = /** @class */ (function (_super) {
        __extends(PolarityInverter, _super);
        function PolarityInverter(x, y) {
            var _this = _super.call(this, x, y, 'items/polarityinverter', 9) || this;
            _this.addChild(new Sprite({
                texture: 'items/polarityinverterfan',
                copyFromParent: ['layer'],
                vangle: -720,
                update: function () {
                    if (this.parent && this.parent instanceof BallItem) {
                        World.Actions.orderWorldObjectAfter(this, this.parent);
                        this.scale = this.parent.moveScale;
                    }
                }
            }));
            return _this;
        }
        PolarityInverter.prototype.getName = function () { return 'Polarity Inverter'; };
        PolarityInverter.prototype.getDesc = function () { return "Travel in the opposite direction around the arena AND magnetize toward enemies"; };
        return PolarityInverter;
    }(EquipmentItem));
    BallItems.PolarityInverter = PolarityInverter;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Polisher = /** @class */ (function (_super) {
        __extends(Polisher, _super);
        function Polisher(x, y) {
            return _super.call(this, x, y, 'items/polisher') || this;
        }
        Polisher.prototype.getName = function () { return 'Polisher'; };
        Polisher.prototype.getDesc = function () { return "Give a ball [g]+" + this.buffAmount + "<heart>[/g]"; };
        Object.defineProperty(Polisher.prototype, "buffAmount", {
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Polisher.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: 0, hp: this.buffAmount }));
        };
        return Polisher;
    }(BallItem));
    BallItems.Polisher = Polisher;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Polisher1 = /** @class */ (function (_super) {
        __extends(Polisher1, _super);
        function Polisher1(x, y) {
            return _super.call(this, x, y, 'items/polisher1') || this;
        }
        Polisher1.prototype.getName = function () { return 'Mini Polisher'; };
        Polisher1.prototype.getDesc = function () { return "Give a ball [g]+" + this.buffAmount + "<heart>[/g]"; };
        Object.defineProperty(Polisher1.prototype, "buffAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Polisher1.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: 0, hp: this.buffAmount }));
        };
        return Polisher1;
    }(BallItem));
    BallItems.Polisher1 = Polisher1;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ProtectionBubble = /** @class */ (function (_super) {
        __extends(ProtectionBubble, _super);
        function ProtectionBubble(x, y) {
            return _super.call(this, x, y, 'items/protectionbubble', 29) || this;
        }
        ProtectionBubble.prototype.getName = function () { return 'Protection Bubble'; };
        ProtectionBubble.prototype.getDesc = function () { return "Take 50% less damage, but deal none on collision"; };
        ProtectionBubble.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        return ProtectionBubble;
    }(EquipmentItem));
    BallItems.ProtectionBubble = ProtectionBubble;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var RedCube = /** @class */ (function (_super) {
        __extends(RedCube, _super);
        function RedCube(x, y) {
            return _super.call(this, x, y, 'items/redcube', 33) || this;
        }
        RedCube.prototype.getName = function () { return 'Red Cube'; };
        RedCube.prototype.getDesc = function () { return "Damage taken is spread over 3 seconds"; };
        RedCube.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        return RedCube;
    }(EquipmentItem));
    BallItems.RedCube = RedCube;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Rejuvenator = /** @class */ (function (_super) {
        __extends(Rejuvenator, _super);
        function Rejuvenator(x, y) {
            return _super.call(this, x, y, 'items/rejuvenator', 7) || this;
        }
        Rejuvenator.prototype.getName = function () { return 'Rejuvenator'; };
        Rejuvenator.prototype.getDesc = function () { return "Passively heal for [g]0.5<heart>/s[/g]"; };
        return Rejuvenator;
    }(EquipmentItem));
    BallItems.Rejuvenator = Rejuvenator;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var RetroGlasses = /** @class */ (function (_super) {
        __extends(RetroGlasses, _super);
        function RetroGlasses(x, y) {
            return _super.call(this, x, y, 'items/retroglasses', 19) || this;
        }
        RetroGlasses.prototype.getName = function () { return 'Retro Glasses'; };
        RetroGlasses.prototype.getDesc = function () { return "The equipped ball is significantly more likely to be in the shop on every roll"; };
        RetroGlasses.prototype.canApplyToBall = function (ball) {
            var type = ball.properties.type;
            if (!_.contains(getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly), type))
                return false;
            if (type === 127)
                return false; // Dove
            return true;
        };
        return RetroGlasses;
    }(EquipmentItem));
    BallItems.RetroGlasses = RetroGlasses;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ScribbledMap = /** @class */ (function (_super) {
        __extends(ScribbledMap, _super);
        function ScribbledMap(x, y) {
            var _this = _super.call(this, x, y, 'items/scribbledmap') || this;
            _this.defaultOutlineAlpha = 0;
            _this.canFreeze = false;
            _this.effects.post.filters.push(new FlipbookFilter(1, 2, 1, 1));
            _this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFFDB00,
                blendMode: Texture.BlendModes.ADD,
                scale: 20 / 64,
                alpha: 0.5,
                copyFromParent: ['layer'],
                update: function () {
                    World.Actions.orderWorldObjectBefore(this, this.parent);
                    this.scale = M.lerp(20 / 64, 16 / 64, Tween.Easing.OscillateSine(0.5)(this.life.time));
                },
            }));
            return _this;
        }
        ScribbledMap.prototype.getName = function () { return 'Scribbled Map'; };
        ScribbledMap.prototype.getDesc = function () { return "[color 0xFFFF97]Win or lose,\nHaven awaits[/color]"; };
        ScribbledMap.prototype.getShopCost = function () { return 0; };
        ScribbledMap.prototype.isGlitched = function () {
            return true;
        };
        ScribbledMap.prototype.onApplyToBall = function (ball) {
            GAME_DATA.arg2Trigger.strategy = true;
            var world = this.world;
            world.runScript(function () {
                var reveal, sound;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            reveal = new RevealFilter(0);
                            world.addWorldObject(new Sprite({
                                name: 'strategy',
                                x: 0, y: 0,
                                texture: 'strategy',
                                layer: Battle.Layers.ground,
                                effects: { post: { filters: [reveal] } },
                            }));
                            sound = world.playSound('arg/atmosphere');
                            sound.loop = true;
                            sound.volume = 0;
                            return [4 /*yield*/, [
                                    S.tween(30, reveal, 'amount', 0, 1),
                                    S.tween(30, sound, 'volume', 0, 1),
                                ]];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.tween(1, sound, 'volume', 1, 0)];
                        case 2:
                            _a.sent();
                            sound.stop();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return ScribbledMap;
    }(BallItem));
    BallItems.ScribbledMap = ScribbledMap;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Shield = /** @class */ (function (_super) {
        __extends(Shield, _super);
        function Shield(x, y) {
            return _super.call(this, x, y, 'items/shield', 0) || this;
        }
        Shield.prototype.getName = function () { return 'Shield'; };
        Shield.prototype.getDesc = function () { return "Blocks the first discrete instance of damage"; };
        return Shield;
    }(EquipmentItem));
    BallItems.Shield = Shield;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Silencer = /** @class */ (function (_super) {
        __extends(Silencer, _super);
        function Silencer(x, y) {
            return _super.call(this, x, y, 'items/silencer', 25) || this;
        }
        Silencer.prototype.getName = function () { return 'Silencer'; };
        Silencer.prototype.getDesc = function () { return "On collision, the damage that would have been dealt is instead shot as 1-3 homing spikes toward random enemies. Each spike gains +[r]1<sword>[/r]"; };
        return Silencer;
    }(EquipmentItem));
    BallItems.Silencer = Silencer;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var SkullCharm = /** @class */ (function (_super) {
        __extends(SkullCharm, _super);
        function SkullCharm(x, y) {
            return _super.call(this, x, y, 'items/skullcharm', 2) || this;
        }
        SkullCharm.prototype.getName = function () { return 'Skull Charm'; };
        SkullCharm.prototype.getDesc = function () { return "Summon a " + buffText(1, 2) + " skeleton on death\n\nSkeleton gains [r]+1<sword>[/r] for each [gold]<star>[/gold] on the equipped ball"; };
        return SkullCharm;
    }(EquipmentItem));
    BallItems.SkullCharm = SkullCharm;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var SmokeBomb = /** @class */ (function (_super) {
        __extends(SmokeBomb, _super);
        function SmokeBomb(x, y) {
            return _super.call(this, x, y, 'items/smokebomb', 16) || this;
        }
        SmokeBomb.prototype.getName = function () { return 'Smoke Bomb'; };
        SmokeBomb.prototype.getDesc = function () { return "Disappear on entering battle, avoiding collisions for 2 seconds. Reappear in a burst of [r]2x the ball's <sword>[/r]"; };
        return SmokeBomb;
    }(EquipmentItem));
    BallItems.SmokeBomb = SmokeBomb;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Spinach = /** @class */ (function (_super) {
        __extends(Spinach, _super);
        function Spinach(x, y) {
            return _super.call(this, x, y, 'items/spinach') || this;
        }
        Spinach.prototype.getName = function () { return 'Spinach'; };
        Spinach.prototype.getDesc = function () { return "Give a ball " + buffText(this.buffDmgAmount, this.buffHpAmount); };
        Object.defineProperty(Spinach.prototype, "buffDmgAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Spinach.prototype, "buffHpAmount", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Spinach.prototype.onApplyToBall = function (ball) {
            this.world.addWorldObject(new Buff(this.x, this.y, ball, { dmg: this.buffDmgAmount, hp: this.buffHpAmount }));
        };
        return Spinach;
    }(BallItem));
    BallItems.Spinach = Spinach;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var StarCatcher = /** @class */ (function (_super) {
        __extends(StarCatcher, _super);
        function StarCatcher(x, y) {
            return _super.call(this, x, y, 'items/starcatcher', 30) || this;
        }
        StarCatcher.prototype.getName = function () { return 'Star Catcher'; };
        StarCatcher.prototype.getDesc = function () { return "On enter battle, steal [gold]1<star>[/gold] from a random enemy"; };
        StarCatcher.prototype.getCredits = function () { return [CreditsNames.NEPDEP]; };
        return StarCatcher;
    }(EquipmentItem));
    BallItems.StarCatcher = StarCatcher;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var Supernova = /** @class */ (function (_super) {
        __extends(Supernova, _super);
        function Supernova(x, y) {
            return _super.call(this, x, y, 'items/supernova') || this;
        }
        Supernova.prototype.getName = function () { return 'Supernova'; };
        Supernova.prototype.getDesc = function () { return "Convert [gold]1<star>[/gold] into either [g]+" + this.buffAmount + "<heart>[/g] or [r]+" + this.buffAmount + "<sword>[/r] (random)"; };
        Object.defineProperty(Supernova.prototype, "buffAmount", {
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Supernova.prototype.canApplyToBall = function (ball) {
            return ball.level > 1;
        };
        Supernova.prototype.onApplyToBall = function (ball) {
            var randomBuff = Ball.Random.boolean() ? { dmg: this.buffAmount, hp: 0 } : { dmg: 0, hp: this.buffAmount };
            ball.runScript(function () {
                var nova, buff;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            ball.world.playSound('implode');
                            nova = ball.addChild(new Sprite({
                                texture: 'necromancerbeams',
                                copyFromParent: ['layer'],
                                scale: 0,
                                life: 1,
                                vangle: 180,
                                tags: [Tags.DELAY_PLAY],
                                update: function () {
                                    World.Actions.orderWorldObjectAfter(this, ball.stars);
                                },
                            }));
                            return [4 /*yield*/, S.doOverTime(1, function (t) { return nova.scale = M.jumpParabola(0.5, 1, 0, t) * (ball.physicalRadius + 4) / 64; })];
                        case 1:
                            _a.sent();
                            ball.levelDown();
                            buff = ball.world.addWorldObject(new Buff(ball.x, ball.y - ball.physicalRadius - 2, ball, randomBuff, vec2(Random.sign() * 200, 0)));
                            buff.addTag(Tags.DELAY_PLAY);
                            return [2 /*return*/];
                    }
                });
            });
        };
        return Supernova;
    }(BallItem));
    BallItems.Supernova = Supernova;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var TheBug = /** @class */ (function (_super) {
        __extends(TheBug, _super);
        function TheBug(x, y) {
            var _this = _super.call(this, x, y, 'items/thebug', 41) || this;
            _this.canFreeze = false;
            _this.effects.post.filters.push(new Effects.Filters.Glitch(2, 2, 4));
            return _this;
        }
        TheBug.prototype.getName = function () { return 'Th<g3> B[glitched]u[/]g'; };
        TheBug.prototype.getDesc = function () { return "The equ<g2>pped ball transforms into a r<g4>ndom shop ball on restock"; };
        TheBug.prototype.getShopCost = function () { return 0; };
        TheBug.prototype.canApplyToBall = function (ball) {
            if (ball.isInShop)
                return false;
            return _super.prototype.canApplyToBall.call(this, ball);
        };
        TheBug.prototype.onApplyToBall = function (ball) {
            if (ball instanceof Balls.GlitchedBallArg) {
                saveMatchmakingOrChallengeModeOrDailyGameData(undefined, CHALLENGE_MODE_ENABLED, DAILY);
                global.theater.playCutscene(ARG.Cutscenes.BEGIN_ARG);
            }
            else {
                this.world.runScript(glitchSmall(this.world));
                _super.prototype.onApplyToBall.call(this, ball);
            }
        };
        return TheBug;
    }(EquipmentItem));
    BallItems.TheBug = TheBug;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var TheseGuns = /** @class */ (function (_super) {
        __extends(TheseGuns, _super);
        function TheseGuns(x, y) {
            return _super.call(this, x, y, 'items/guns', 6) || this;
        }
        TheseGuns.prototype.getName = function () { return 'These Guns!!'; };
        TheseGuns.prototype.getDesc = function () { return "Punches nearby enemies for [r]2<sword>[/r] each. Breaks after two punches."; };
        return TheseGuns;
    }(EquipmentItem));
    BallItems.TheseGuns = TheseGuns;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ThiefMask = /** @class */ (function (_super) {
        __extends(ThiefMask, _super);
        function ThiefMask(x, y) {
            return _super.call(this, x, y, 'items/thiefmask', 10) || this;
        }
        ThiefMask.prototype.getName = function () { return 'Thief Mask'; };
        ThiefMask.prototype.getDesc = function () { return "Steal the equipment of a random enemy at the start of battle"; };
        return ThiefMask;
    }(EquipmentItem));
    BallItems.ThiefMask = ThiefMask;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var TimeBomb = /** @class */ (function (_super) {
        __extends(TimeBomb, _super);
        function TimeBomb(x, y) {
            var _this = _super.call(this, x, y, 'items/timebomb', 38) || this;
            _this.addAnimation(Animations.fromTextureList({ name: 'idle', textures: ['items/timebomb', 'items/timebomboff'], frameRate: 2, count: Infinity }));
            _this.playAnimation('idle');
            return _this;
        }
        TimeBomb.prototype.getName = function () { return 'Time Bomb'; };
        TimeBomb.prototype.getDesc = function () { return "Explode after 3 seconds in battle, dealing its [r]<sword>[/r] in a radius"; };
        return TimeBomb;
    }(EquipmentItem));
    BallItems.TimeBomb = TimeBomb;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var ToxicFungus = /** @class */ (function (_super) {
        __extends(ToxicFungus, _super);
        function ToxicFungus(x, y) {
            return _super.call(this, x, y, 'items/toxicfungus', 15) || this;
        }
        ToxicFungus.prototype.getName = function () { return 'Toxic Fungus'; };
        ToxicFungus.prototype.getDesc = function () { return "On enter battle, plant a [dg]spore equipment[/dg] on the enemy with the highest [g]<heart>[/g]\n\nSpored balls take [r]1<sword>[/r] extra per hit"; };
        return ToxicFungus;
    }(EquipmentItem));
    BallItems.ToxicFungus = ToxicFungus;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var UnstableCatalyst = /** @class */ (function (_super) {
        __extends(UnstableCatalyst, _super);
        function UnstableCatalyst(x, y) {
            return _super.call(this, x, y, 'items/unstablecatalyst', 12) || this;
        }
        UnstableCatalyst.prototype.getName = function () { return 'Unstable Catalyst'; };
        UnstableCatalyst.prototype.getDesc = function () { return "Passively convert -[g]0.25<heart>/s[/g] into +[r]1<sword>/s[/r] during battle. Stops when health is 0"; };
        return UnstableCatalyst;
    }(EquipmentItem));
    BallItems.UnstableCatalyst = UnstableCatalyst;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var VIPTicket = /** @class */ (function (_super) {
        __extends(VIPTicket, _super);
        function VIPTicket(x, y) {
            return _super.call(this, x, y, 'items/vipticket', 18) || this;
        }
        VIPTicket.prototype.getName = function () { return 'VIP Ticket'; };
        VIPTicket.prototype.getDesc = function () { return "While equipped, the shop stocks one less ball and one extra item"; };
        return VIPTicket;
    }(EquipmentItem));
    BallItems.VIPTicket = VIPTicket;
})(BallItems || (BallItems = {}));
var BallItems;
(function (BallItems) {
    var VoodooPin = /** @class */ (function (_super) {
        __extends(VoodooPin, _super);
        function VoodooPin(x, y) {
            return _super.call(this, x, y, 'items/voodoopin', 24) || this;
        }
        VoodooPin.prototype.getName = function () { return 'Voodoo Pin'; };
        VoodooPin.prototype.getDesc = function () { return "Sacrifice\n[g]1 max <heart>/s[/g] to damage the enemy with the highest [r]<sword>[/r] for [r]1.5<sword>/s[/r]\n\n[r]Can kill the wearer[/r]"; };
        VoodooPin.prototype.getCredits = function () { return [CreditsNames.MATERWELONS]; };
        return VoodooPin;
    }(EquipmentItem));
    BallItems.VoodooPin = VoodooPin;
})(BallItems || (BallItems = {}));
var Equipment = /** @class */ (function (_super) {
    __extends(Equipment, _super);
    function Equipment(config) {
        var _this = _super.call(this, config) || this;
        _this.equipmentType = -1;
        _this.preBattleAbilityInitialWaitTime = 0.2;
        _this.blockOneDiscreteDamage = false;
        _this.magnetizeAmount = 0;
        _this.flatDamageChange = 0;
        _this.percentDamageChange = 1;
        _this.reverseDirection = false;
        _this.stockExtraItems = 0;
        _this.stockEquippedBall = false;
        _this.noCollisionDamage = false;
        _this.spreadDamageOverTime = 0;
        _this.chanceToActivateAbilitiesTwice = 0;
        _this.startEarlyTime = 0;
        _this.breakIcon = config.breakIcon;
        _this.abilitySet = new AbilitySet();
        return _this;
    }
    Equipment.prototype.getName = function () { return 'unknown'; };
    Equipment.prototype.getDesc = function () { return 'unknown'; };
    Object.defineProperty(Equipment.prototype, "isPreBattleAbilityActive", {
        get: function () {
            if (!this._preBattleAbilityActiveCheck)
                return false;
            if (!this._preBattleAbilityActiveCheck()) {
                this._preBattleAbilityActiveCheck = undefined;
                return false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    // Do not forget to add isNullified check and hasBattleEffect for future equipment effects!
    Equipment.prototype.addAbility = function (type, abilityFunction, config) {
        var _this = this;
        var _a;
        var nullifyable = (_a = config === null || config === void 0 ? void 0 : config.nullifyable) !== null && _a !== void 0 ? _a : true;
        this.abilitySet.addAbility(type, function (source, world) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            return abilityFunction.apply(void 0, __spread([_this, source, world], rest));
        }, nullifyable);
    };
    Equipment.prototype.break = function () {
        var _a;
        if (this.parent) {
            var breakSprite_1 = this.parent.addChild(new Sprite({
                texture: this.breakIcon,
                layer: Battle.Layers.fx,
                scale: 0.8,
                alpha: 0.5,
            }));
            breakSprite_1.runScript(S.chain(S.simul(S.tween(0.1, breakSprite_1, 'scale', 0.8, 1, Tween.Easing.OutQuad), S.tween(0.1, breakSprite_1, 'alpha', 0.5, 1, Tween.Easing.OutQuad)), S.tween(0.25, breakSprite_1, 'alpha', 0.5, 0, Tween.Easing.OutQuad), S.call(function () { return breakSprite_1.kill(); })));
        }
        (_a = this.world) === null || _a === void 0 ? void 0 : _a.playSound('eqbreak');
        this.kill();
    };
    Equipment.prototype.cancelAbilities = function () {
        this.abilitySet.cancelAbilities(this);
    };
    Equipment.prototype.getEquipmentTexture = function () {
        return this.getTexture();
    };
    Equipment.prototype.getParent = function () {
        if (this.parent && this.parent instanceof Ball)
            return this.parent;
        return undefined;
    };
    Equipment.prototype.hasAbility = function (abilityType) {
        return this.abilitySet.hasAbility(abilityType);
    };
    Equipment.prototype.hasBattleEffect = function () {
        for (var ability in ABILITIES) {
            var abilityType = ability;
            if (ABILITIES[abilityType].battle && this.hasAbility(abilityType))
                return true;
        }
        if (this.blockOneDiscreteDamage)
            return true;
        if (this.magnetizeAmount !== 0)
            return true;
        if (this.flatDamageChange !== 0)
            return true;
        if (this.percentDamageChange !== 1)
            return true;
        if (this.reverseDirection)
            return true;
        if (this.noCollisionDamage)
            return true;
        if (this.spreadDamageOverTime !== 0)
            return true;
        if (this.startEarlyTime > 0)
            return true;
        return false;
    };
    Equipment.prototype.onAdd = function () {
        this.mainWorld = this.world;
        _super.prototype.onAdd.call(this);
    };
    Equipment.prototype.queueAbilities = function (type) {
        var _a;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        var nullified = (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.isNullified();
        this.abilitySet.queueAbilities(type, this, nullified, params);
    };
    Equipment.prototype.setForShare = function () {
    };
    Equipment.prototype.setPreBattleAbilityActiveCheck = function (check) {
        this._preBattleAbilityActiveCheck = check;
    };
    return Equipment;
}(Sprite));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var ArmorPlating = /** @class */ (function (_super) {
        __extends(ArmorPlating, _super);
        function ArmorPlating() {
            var _this = _super.call(this, {
                copyFromParent: ['layer'],
                breakIcon: 'items/armorplating',
            }) || this;
            _this.flatDamageChange = -2;
            return _this;
        }
        ArmorPlating.prototype.getName = function () { return 'Armor Plating'; };
        ArmorPlating.prototype.getDesc = function () { return "Decrease all instances of damage taken by 2 (cannot decrease damage below 0.75)"; };
        ArmorPlating.prototype.render = function (texture, x, y) {
            if (this.parent && this.parent instanceof Ball) {
                var radius = this.parent.visibleRadius;
                if (this.parent.isInShop)
                    radius++;
                Draw.brush.color = 0x404040;
                Draw.brush.alpha = 1;
                Draw.brush.thickness = 2;
                Draw.circleOutline(texture, x, y, radius + 1, Draw.ALIGNMENT_MIDDLE);
                Draw.brush.color = 0x00FFFF;
                Draw.brush.thickness = 1;
                var startR = radius;
                var endR = radius + 2;
                for (var i = 0; i < 12; i++) {
                    var angle = 4 + 30 * i;
                    var cos = M.cos(angle);
                    var sin = M.sin(angle);
                    Draw.line(texture, x + cos * startR, y + sin * startR, x + cos * endR, y + sin * endR);
                }
                Draw.brush.color = 0x000000;
                Draw.circleOutline(texture, x, y, radius, Draw.ALIGNMENT_OUTER);
                Draw.circleOutline(texture, x, y, radius + 2, Draw.ALIGNMENT_OUTER);
            }
            _super.prototype.render.call(this, texture, x, y);
        };
        ArmorPlating.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.parent)
                World.Actions.orderWorldObjectBefore(this, this.parent);
        };
        return ArmorPlating;
    }(Equipment));
    Equipments.ArmorPlating = ArmorPlating;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var OrbitEquipment = /** @class */ (function (_super) {
    __extends(OrbitEquipment, _super);
    function OrbitEquipment(icon, breakIcon) {
        var _this = _super.call(this, {
            copyFromParent: ['layer'],
            breakIcon: breakIcon,
        }) || this;
        _this.orbitingIcon = _this.addChild(new OrbitingIcon(icon, function () { return _this.parent instanceof Ball ? _this.parent : undefined; }));
        _this.orbitingIcon.life.time = Random.float(0, 1);
        return _this;
    }
    OrbitEquipment.prototype.getEquipmentTexture = function () {
        return this.orbitingIcon.getTexture();
    };
    OrbitEquipment.prototype.setForShare = function () {
        _super.prototype.setForShare.call(this);
        this.orbitingIcon.setForShare();
    };
    return OrbitEquipment;
}(Equipment));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Bandaid = /** @class */ (function (_super) {
        __extends(Bandaid, _super);
        function Bandaid() {
            var _this = _super.call(this, 'equipments/bandaid', 'items/bandaid') || this;
            _this.addAbility('onEquip', Bandaid.onEquip);
            _this.addAbility('onDeath', Bandaid.onDeath);
            return _this;
        }
        Bandaid.prototype.getName = function () { return 'Bandaid'; };
        Bandaid.prototype.getDesc = function () { return "If this ball dies during battle, it gains [g]1<heart>[/g] next round"; };
        Bandaid.onEquip = function (equipment, source, world) {
            if (source.state !== Ball.States.PRE_BATTLE && source.state !== Ball.States.BATTLE)
                return;
            source.buff(0, 1);
        };
        Bandaid.onDeath = function (equipment, source, world, killedBy) {
            if (source.team !== 'friend')
                return;
            if (!youArePlaying(world))
                return;
            if (source.squadIndexReference < 0)
                return;
            if (hasStartShopEffect('buff', source.squadIndexReference))
                return;
            addStartShopEffect({
                type: 'buff',
                sourceSquadIndex: source.squadIndexReference,
                health: 1,
                damage: 0,
            });
        };
        return Bandaid;
    }(OrbitEquipment));
    Equipments.Bandaid = Bandaid;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var BestFriend = /** @class */ (function (_super) {
        __extends(BestFriend, _super);
        function BestFriend() {
            var _this = _super.call(this, 'equipments/bestfriend', 'items/bestfriend') || this;
            _this.orbitingIcon.radiusScale = 14 / 12;
            _this.addAbility('onDeath', BestFriend.onDeath);
            return _this;
        }
        BestFriend.prototype.getName = function () { return 'Best Friend'; };
        BestFriend.prototype.getDesc = function () { return "On death, revive with [r]1<sword>[/r] [g]1<heart>[/g]"; };
        BestFriend.onDeath = function (equipment, source, world, killedBy) {
            source.unequip();
            var ballToRevive = source;
            if (source instanceof Balls.Crown && source.squadIndexReference >= 0 && source.squadIndexReference < GAME_DATA.squad.balls.length) {
                ballToRevive = squadBallToWorldBall(GAME_DATA.squad.balls[source.squadIndexReference], source.squad, source.squadIndexReference, source.team);
            }
            world.addWorldObject(new Dio(source.x, source.y, ballToRevive, 1, 1));
        };
        return BestFriend;
    }(OrbitEquipment));
    Equipments.BestFriend = BestFriend;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Bounty = /** @class */ (function (_super) {
        __extends(Bounty, _super);
        function Bounty() {
            var _this = _super.call(this, 'equipments/bounty', 'items/bounty') || this;
            _this.totalGoldGained = 0;
            _this.addAbility('onKill', Bounty.onKill);
            return _this;
        }
        Bounty.prototype.getName = function () { return 'Bounty'; };
        Bounty.prototype.getDesc = function () { return "Start the shop with [gold]1<coin>[/gold] extra for each kill (max [gold]3<coin>[/gold])"; };
        Bounty.onKill = function (equipment, source, world, killed) {
            if (source.team !== 'friend')
                return;
            if (!youArePlaying(world))
                return;
            if (equipment.totalGoldGained >= 3)
                return;
            addStartShopEffect({
                type: 'gold',
                sourceSquadIndex: source.squadIndexReference,
                gold: 1,
            });
            equipment.totalGoldGained++;
        };
        return Bounty;
    }(OrbitEquipment));
    Equipments.Bounty = Bounty;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var CatEars = /** @class */ (function (_super) {
        __extends(CatEars, _super);
        function CatEars() {
            var _this = _super.call(this, {
                texture: 'equipments/catears',
                copyFromParent: ['layer'],
                breakIcon: 'items/catears',
            }) || this;
            _this.addAbility('onCollideWithEnemyPostDamage', CatEars.onCollideWithEnemyPostDamage);
            return _this;
        }
        CatEars.prototype.getName = function () { return 'Cat Ears'; };
        CatEars.prototype.getDesc = function () { return ''; };
        CatEars.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.parent && this.parent instanceof Ball) {
                this.localy = -Math.max(this.parent.visibleRadius - 8, 0);
                World.Actions.orderWorldObjectBefore(this, this.parent);
            }
        };
        CatEars.onCollideWithEnemyPostDamage = function (equipment, source, world, ball, damage) {
            if (Ball.Random.boolean(1 / 200) && (!ball.equipment || !(ball.equipment instanceof Equipments.CatEars))) {
                world.runScript(function () {
                    var bg, catPos, cat, catEars, claw;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                bg = world.addWorldObject(new Sprite({ texture: fullscreenTexture.get(), layer: Battle.Layers.fg }));
                                catPos = getCatPos(source, ball);
                                cat = world.addWorldObject(new Sprite({ x: catPos.x, y: catPos.y, texture: 'buffcat', layer: Battle.Layers.fg, flipX: catPos.x > ball.x }));
                                catEars = world.addWorldObject(new Sprite({ x: equipment.x, y: equipment.y, texture: 'equipments/catears', effects: { outline: { color: 0xFFFFFF } }, layer: Battle.Layers.fg }));
                                claw = world.addWorldObject(new ClawSlash(ball, source, 1, false));
                                claw.layer = Battle.Layers.fg;
                                return [4 /*yield*/, S.wait(0.1)];
                            case 1:
                                _a.sent();
                                bg.tint = 0x000000;
                                cat.effects.invertColors.enabled = true;
                                return [4 /*yield*/, S.wait(0.2)];
                            case 2:
                                _a.sent();
                                bg.kill();
                                cat.kill();
                                catEars.kill();
                                claw.kill();
                                return [2 /*return*/];
                        }
                    });
                });
            }
        };
        return CatEars;
    }(Equipment));
    Equipments.CatEars = CatEars;
    function getCatPos(parent, collideWith) {
        var result = vec2(parent.x, parent.y);
        if (Math.abs(result.x - collideWith.x) < 56) {
            if (result.x < collideWith.x)
                result.x = collideWith.x - 56;
            else
                result.x = collideWith.x + 56;
        }
        result.y = M.clamp(result.y, 53, global.gameHeight - 53);
        return result;
    }
    var fullscreenTexture = new LazyValue(function () { return Texture.filledRect(global.gameWidth, global.gameHeight, 0xFFFFFF); });
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Claws = /** @class */ (function (_super) {
        __extends(Claws, _super);
        function Claws() {
            var _this = _super.call(this, 'equipments/claws', 'items/claws') || this;
            _this.addAbility('onCollideWithEnemyPostDamage', Claws.onCollideWithEnemyPostDamage);
            return _this;
        }
        Claws.prototype.getName = function () { return 'Claws'; };
        Claws.prototype.getDesc = function () { return "Claws the first enemy collided with for [r]4<sword> extra[/r]"; };
        Claws.onCollideWithEnemyPostDamage = function (equipment, source, world, ball, damage) {
            world.addWorldObject(new ClawSlash(ball, source, 4, true));
            source.unequip();
        };
        return Claws;
    }(OrbitEquipment));
    Equipments.Claws = Claws;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var Contagion = /** @class */ (function (_super) {
        __extends(Contagion, _super);
        function Contagion() {
            var _this = _super.call(this, {
                texture: new AnchoredTexture(Texture.filledCircle(49, 0xFFFFFF), 0.5, 0.5),
                copyFromParent: ['layer'],
                breakIcon: 'items/contagion',
                effects: { pre: { filters: [new ContagionFilter()] }, outline: { color: 0x30A000 } },
            }) || this;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', Contagion.onPreBattle);
            return _this;
        }
        Contagion.prototype.getName = function () { return 'Contagion'; };
        Contagion.prototype.getDesc = function () { return "At the start of battle, give nearby allies [dg]Infection equipments[/dg]"; };
        Object.defineProperty(Contagion.prototype, "infectionRadius", {
            get: function () {
                var parent = this.getParent();
                return (!parent || parent.isInShop || parent.isInYourSquadScene) ? parent.physicalRadius - 8 + 16 : 50;
            },
            enumerable: false,
            configurable: true
        });
        Contagion.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.scale = (this.infectionRadius - 1) / 49;
            if (this.parent)
                World.Actions.orderWorldObjectAfter(this, this.parent);
        };
        Contagion.prototype.getEquipmentTexture = function () {
            return AssetCache.getTexture('items/contagion');
        };
        Contagion.onPreBattle = function (equipment, source, world) {
            Contagion.plantInfections(equipment, source, world);
            source.runScript(function () {
                var filter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filter = equipment.effects.pre.filters.find(function (f) { return f instanceof ContagionFilter; });
                            if (!filter)
                                return [2 /*return*/];
                            return [4 /*yield*/, S.tween(0.1, filter, 'flash', 0, 0.2, Tween.Easing.OutQuad)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, [
                                    S.tween(0.2, equipment, 'alpha', 1, 0, Tween.Easing.InQuad),
                                    S.tween(0.2, equipment.effects.outline, 'alpha', 1, 0, Tween.Easing.InQuad),
                                ]];
                        case 2:
                            _a.sent();
                            source.unequip();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Contagion.plantInfections = function (equipment, source, world) {
            var e_184, _a;
            var validBalls = getAlliesNotSelf(world, source).filter(function (ally) { return G.distance(source, ally) < equipment.infectionRadius + ally.physicalRadius; });
            if (validBalls.length === 0)
                return;
            try {
                for (var validBalls_9 = __values(validBalls), validBalls_9_1 = validBalls_9.next(); !validBalls_9_1.done; validBalls_9_1 = validBalls_9.next()) {
                    var ball = validBalls_9_1.value;
                    ball.equip(31);
                    world.addWorldObject(newPuff(ball.x, ball.y, Battle.Layers.fx, 'small'));
                }
            }
            catch (e_184_1) { e_184 = { error: e_184_1 }; }
            finally {
                try {
                    if (validBalls_9_1 && !validBalls_9_1.done && (_a = validBalls_9.return)) _a.call(validBalls_9);
                }
                finally { if (e_184) throw e_184.error; }
            }
            world.playSound('steal', { limit: 2 });
        };
        Contagion.loadFilter = function () {
            Texture.EFFECT_ONLY.renderTo(new BasicTexture(1, 1, 'Contagion.loadFilter'), { filters: [new ContagionFilter()] });
        };
        return Contagion;
    }(Equipment));
    Equipments.Contagion = Contagion;
    var ContagionFilter = /** @class */ (function (_super) {
        __extends(ContagionFilter, _super);
        function ContagionFilter() {
            var _this = _super.call(this, {
                uniforms: { 'float flash': 0 },
                code: "\n                    float scale = 10.0;\n                    float p = mapClamp(pnoise(x/scale, y/scale, t), -1.0, 1.0, 0.0, 1.0);\n                    outp = vec4(0.33, 1.0, 0.0, (0.05 + p * 0.3 + flash) * outp.a);\n                "
            }) || this;
            _this._flash = 0;
            return _this;
        }
        Object.defineProperty(ContagionFilter.prototype, "flash", {
            get: function () { return this._flash; },
            set: function (v) {
                if (this._flash === v)
                    return;
                this._flash = v;
                this.setUniform('flash', v);
            },
            enumerable: false,
            configurable: true
        });
        return ContagionFilter;
    }(TextureFilter));
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Curry = /** @class */ (function (_super) {
        __extends(Curry, _super);
        function Curry() {
            var _this = _super.call(this, 'equipments/curry', 'items/curry') || this;
            _this.addAbility('onEnterBattle', Curry.onEnterBattle, { nullifyable: false });
            return _this;
        }
        Curry.prototype.getName = function () { return 'Curry'; };
        Curry.prototype.getDesc = function () { return "On fire and moves at 200% speed for 10 seconds"; };
        Curry.onEnterBattle = function (equipment, source, world) {
            equipment.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.doOverTime(10, function (t) {
                                if (!source.isNullified()) {
                                    source.addBurning(source, 0.1);
                                    source.addBoostMaxSpeed(equipment, 'other', 2, 2, 1);
                                    source.addScaleAcceleration(equipment, 2, 0.1);
                                }
                            })];
                        case 1:
                            _a.sent();
                            if (source.equipment === equipment) {
                                source.breakEquipment();
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        return Curry;
    }(OrbitEquipment));
    Equipments.Curry = Curry;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var CursedDoll = /** @class */ (function (_super) {
        __extends(CursedDoll, _super);
        function CursedDoll() {
            var _this = _super.call(this, 'equipments/curseddoll', 'items/curseddoll') || this;
            _this.addAbility('onDeath', CursedDoll.onDeath);
            return _this;
        }
        CursedDoll.prototype.getName = function () { return 'Cursed Doll'; };
        CursedDoll.prototype.getDesc = function () { return "On death, transforms its killer into a skeleton"; };
        CursedDoll.onDeath = function (equipment, source, world, killedBy) {
            if (killedBy.dead || !killedBy.alive)
                return;
            world.addWorldObject(squadBallToWorldBall({
                x: killedBy.x,
                y: killedBy.y,
                properties: {
                    type: 16,
                    level: killedBy.level,
                    damage: killedBy.dmg,
                    health: killedBy.hp,
                    equipment: killedBy.equipment ? killedBy.equipment.equipmentType : -1,
                    metadata: {},
                }
            }, undefined, -1, killedBy.team, false, false));
            killedBy.kill();
        };
        return CursedDoll;
    }(OrbitEquipment));
    Equipments.CursedDoll = CursedDoll;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var CursedEye = /** @class */ (function (_super) {
        __extends(CursedEye, _super);
        function CursedEye() {
            var _this = _super.call(this, 'equipments/cursedeye', 'items/cursedeye') || this;
            _this.addAbility('onTakeDamage', CursedEye.onTakeDamage);
            return _this;
        }
        CursedEye.prototype.getName = function () { return 'Cursed Eye'; };
        CursedEye.prototype.getDesc = function () { return "Teleports away from enemies when it takes discrete damage"; };
        CursedEye.onTakeDamage = function (equipment, source, world, damage) {
            if (source.hp <= 0)
                return;
            var teleportLocation = CursedEye.getTeleportLocation(source, world);
            var oldLocation = source.getPosition();
            source.teleport(teleportLocation);
            world.runScript(function () {
                var radius, maxScaleY, teleport1, teleport2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            radius = M.clamp(Math.floor(source.physicalRadius), 8, 16);
                            maxScaleY = 10;
                            teleport1 = world.addWorldObject(new Sprite({
                                x: oldLocation.x, y: oldLocation.y,
                                texture: new AnchoredTexture(Texture.filledCircle(radius, 0xFFFFFF), 0.5, 0.5),
                                layer: Battle.Layers.fx,
                            }));
                            teleport2 = world.addWorldObject(new Sprite({
                                x: teleportLocation.x, y: teleportLocation.y,
                                texture: new AnchoredTexture(Texture.filledCircle(radius, 0xFFFFFF), 0.5, 0.5),
                                layer: Battle.Layers.fx,
                                scaleX: 1 / maxScaleY,
                                scaleY: maxScaleY,
                                offsetY: -maxScaleY * radius,
                            }));
                            world.playSound('pew', { humanized: false });
                            return [4 /*yield*/, S.doOverTime(0.1, function (t) {
                                    teleport1.scaleY = M.lerp(1, maxScaleY, Tween.Easing.InQuad(t));
                                    teleport1.scaleX = 2 / teleport1.scaleY;
                                    teleport1.offsetY = -teleport1.scaleY * radius;
                                    teleport2.scaleY = M.lerp(maxScaleY, 1, t);
                                    teleport2.scaleX = 2 / teleport2.scaleY;
                                    teleport2.offsetY = -teleport2.scaleY * radius;
                                })];
                        case 1:
                            _a.sent();
                            teleport1.kill();
                            teleport2.kill();
                            return [2 /*return*/];
                    }
                });
            });
        };
        CursedEye.getTeleportLocation = function (source, world) {
            var randomLocations = A.range(20).map(function (_) { return CursedEye.getRandomLocation(source, world); })
                .filter(function (location) { return CursedEye.isLocationValid(source, world, location); });
            if (_.isEmpty(randomLocations)) {
                return source.getPosition();
            }
            var enemies = getEnemies(world, source);
            return M.argmax(randomLocations, function (location) { return CursedEye.locationFitnessFunction(location, enemies); });
        };
        CursedEye.getRandomLocation = function (source, world) {
            return vec2(Ball.Random.float(16 + source.physicalRadius, world.width - 16 - source.physicalRadius), Ball.Random.float(16 + source.physicalRadius, world.height - 16 - source.physicalRadius));
        };
        CursedEye.isLocationValid = function (source, world, location) {
            CursedEye.CHECK_BOUNDS.x = location.x;
            CursedEye.CHECK_BOUNDS.y = location.y;
            CursedEye.CHECK_BOUNDS.radius = source.physicalRadius;
            return _.isEmpty(world.select.overlap(CursedEye.CHECK_BOUNDS, [Battle.PhysicsGroups.walls]));
        };
        CursedEye.locationFitnessFunction = function (location, enemies) {
            return M.min(enemies, function (enemy) { return G.distance(enemy, location); });
        };
        CursedEye.CHECK_BOUNDS = new CircleBounds(0, 0, 0);
        return CursedEye;
    }(OrbitEquipment));
    Equipments.CursedEye = CursedEye;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var GreenCube = /** @class */ (function (_super) {
        __extends(GreenCube, _super);
        function GreenCube() {
            var _this = _super.call(this, 'equipments/greencube', 'items/greencube') || this;
            _this.chanceToActivateAbilitiesTwice = 0.33;
            return _this;
        }
        GreenCube.prototype.getName = function () { return 'Green Cube'; };
        GreenCube.prototype.getDesc = function () { return "Abilities have a 33% chance of activating twice"; };
        return GreenCube;
    }(OrbitEquipment));
    Equipments.GreenCube = GreenCube;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var HuntersMark = /** @class */ (function (_super) {
        __extends(HuntersMark, _super);
        function HuntersMark() {
            var _this = _super.call(this, 'equipments/huntersmark', 'items/huntersmark') || this;
            _this.addAbility('onPreBattle', HuntersMark.onPreBattle);
            _this.addAbility('onEnterBattle', HuntersMark.onEnterBattle);
            return _this;
        }
        HuntersMark.prototype.getName = function () { return "Hunter's Mark"; };
        HuntersMark.prototype.getDesc = function () { return "On enter battle, place a mark on a random enemy. All ally spikes will home in on that enemy"; };
        HuntersMark.onPreBattle = function (equipment, source, world) {
            HuntersMark.sendMark(equipment, source, world);
            source.unequip();
        };
        HuntersMark.onEnterBattle = function (equipment, source, world) {
            HuntersMark.sendMark(equipment, source, world);
            source.unequip();
        };
        HuntersMark.sendMark = function (equipment, source, world) {
            var validBalls = getEnemies(world, source);
            var getRandomEnemy = function (enemies) {
                var marks = world.select.typeAll(HomingMark);
                return Ball.Random.element(enemies.filter(function (enemy) { return !enemy.isMarked() && !marks.some(function (mark) { return mark.target === enemy; }); }));
            };
            var enemy = getRandomEnemy(validBalls);
            if (!enemy)
                return;
            var hm = world.addWorldObject(new HomingMark(equipment.orbitingIcon.x, equipment.orbitingIcon.y, source, enemy, function (enemies) { return getRandomEnemy(enemies); }));
            source.flash(0xFFFFFF, 1);
            equipment.setPreBattleAbilityActiveCheck(function () { return hm.world; });
        };
        return HuntersMark;
    }(OrbitEquipment));
    Equipments.HuntersMark = HuntersMark;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var HyperDriver = /** @class */ (function (_super) {
        __extends(HyperDriver, _super);
        function HyperDriver() {
            var _this = _super.call(this, 'equipments/hyperdriver', 'items/hyperdriver') || this;
            _this.addAbility('onPlay', HyperDriver.onPlay);
            return _this;
        }
        HyperDriver.prototype.getName = function () { return 'Hyper Driver'; };
        HyperDriver.prototype.getDesc = function () {
            var PLAY = "" + (GAME_MODE === 'vs' || GAME_MODE === 'spectate' ? 'LOCK IN' : 'PLAY');
            return "On " + PLAY + ", takes [gold]<coin>" + this.goldRequirement + " unspent[/gold] to permanently gain " + buffText(2, 2);
        };
        Object.defineProperty(HyperDriver.prototype, "goldRequirement", {
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        HyperDriver.onPlay = function (equipment, source, world) {
            if (GAME_DATA.gold < equipment.goldRequirement)
                return;
            GAME_DATA.gold -= equipment.goldRequirement;
            animateGiveOrTakeShopGold(world, source, -equipment.goldRequirement);
            source.buff(2, 2);
            FIND_OPPONENT_WAIT_TIME = Math.max(FIND_OPPONENT_WAIT_TIME, 2);
        };
        return HyperDriver;
    }(OrbitEquipment));
    Equipments.HyperDriver = HyperDriver;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var Infection = /** @class */ (function (_super) {
        __extends(Infection, _super);
        function Infection() {
            var _this = _super.call(this, 'equipments/infection', 'equipments/infection') || this;
            _this.addAbility('onDeath', Infection.onDeath);
            return _this;
        }
        Infection.prototype.getName = function () { return 'Infection'; };
        Infection.prototype.getDesc = function () { return "Summons a " + buffText(1, 2) + " Skeleton on death"; };
        Infection.onDeath = function (equipment, source, world, killedBy) {
            world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: 1,
                    health: 2,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
        };
        return Infection;
    }(OrbitEquipment));
    Equipments.Infection = Infection;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var Jetpack = /** @class */ (function (_super) {
        __extends(Jetpack, _super);
        function Jetpack() {
            var _this = _super.call(this, {
                copyFromParent: ['layer'],
                breakIcon: 'items/jetpack',
            }) || this;
            _this.thrusterL = _this.addChild(new Thruster(-1));
            _this.thrusterR = _this.addChild(new Thruster(1));
            _this.addAbility('update', Jetpack.update);
            _this.addAbility('onCollideWithEnemyPostDamage', Jetpack.onCollideWithEnemyPostDamage);
            return _this;
        }
        Jetpack.prototype.getName = function () { return 'Jetpack'; };
        Jetpack.prototype.getDesc = function () { return "Accelerates up to 2x speed. Breaks on collision with an enemy"; };
        Jetpack.prototype.onAdd = function () {
            _super.prototype.onAdd.call(this);
            this.updateThrusterPositions();
            this.rocketSound = new Sound('rocket', this.world.soundManager);
            this.rocketSound.loop = true;
        };
        Jetpack.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            this.updateThrusterPositions();
        };
        Jetpack.update = function (equipment, source, world) {
            if (source.state === Ball.States.BATTLE && !source.isNullified() && source.getSlowEffectSpeedMultiplier() > 0.5) {
                equipment.thrusterL.turnOn();
                equipment.thrusterR.turnOn();
                source.addBoostMaxSpeed(equipment, 'other', 2, 2, 0.2);
                var acc = Vector2.fromPolar(200, source.angle - 90);
                source.v.add(acc.scale(equipment.delta));
                if (source.life.time > 0.25 && world.timeScale > 0.01)
                    equipment.rocketSound.update(equipment.delta);
            }
            else {
                equipment.thrusterL.turnOff();
                equipment.thrusterR.turnOff();
            }
        };
        Jetpack.onCollideWithEnemyPostDamage = function (equipment, source, world, ball, damage) {
            world.playSound('shake', { humanized: false });
            world.playSound('shake2', { humanized: false });
            source.breakEquipment();
            source.removeStatusEffectsOfType('boostmaxspeed');
            world.addWorldObject(new Explosion(source.x, source.y, source.physicalRadius + 4, { ally: 0, enemy: 0 }));
        };
        Jetpack.prototype.updateThrusterPositions = function () {
            if (this.parent && this.parent instanceof Ball) {
                var angle = this.parent.state === Ball.States.BATTLE ? this.parent.angle : 0;
                this.thrusterL.angle = angle;
                this.thrusterR.angle = angle;
                var d = vec2(this.parent.visibleRadius, 0).rotate(angle);
                this.thrusterL.localx = -d.x;
                this.thrusterL.localy = -d.y;
                this.thrusterR.localx = d.x;
                this.thrusterR.localy = d.y;
                World.Actions.orderWorldObjectBefore(this.thrusterL, this.parent);
                World.Actions.orderWorldObjectBefore(this.thrusterR, this.parent);
            }
        };
        return Jetpack;
    }(Equipment));
    Equipments.Jetpack = Jetpack;
    var Thruster = /** @class */ (function (_super) {
        __extends(Thruster, _super);
        function Thruster(dir) {
            return _super.call(this, {
                animations: [
                    Animations.fromSingleTexture({ name: 'off', texture: 'equipments/thruster/0' }),
                    Animations.fromTextureList({ name: 'on', textureRoot: 'equipments/thruster', textures: [1, 2, 3], frameRate: 24, count: Infinity }),
                ],
                copyFromParent: ['layer'],
                flipX: dir < 0,
            }) || this;
        }
        Thruster.prototype.turnOn = function () {
            this.playAnimation('on');
        };
        Thruster.prototype.turnOff = function () {
            this.playAnimation('off');
        };
        return Thruster;
    }(Sprite));
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Joker = /** @class */ (function (_super) {
        __extends(Joker, _super);
        function Joker() {
            var _this = _super.call(this, 'equipments/joker', 'items/joker') || this;
            _this.used = false;
            _this.addAbility('onPreBattle', Joker.onPreBattle);
            return _this;
        }
        Joker.prototype.getName = function () { return 'Joker'; };
        Joker.prototype.getDesc = function () { return "Scrambles enemy positions at the start of battle"; };
        Joker.onPreBattle = function (equipment, source, world) {
            if (world.select.typeAll(Joker).filter(function (joker) { var _a; return joker.used && ((_a = joker.getParent()) === null || _a === void 0 ? void 0 : _a.team) === source.team; }).length > 0)
                return;
            var allyBalls = getAllies(world, source);
            var enemyBalls = getEnemies(world, source);
            if (allyBalls.length === 0 || enemyBalls.length === 0)
                return;
            var flipSide = G.average.apply(G, __spread(enemyBalls)).x > G.average.apply(G, __spread(allyBalls)).x;
            var possiblePositions = getEnemyPositions(world, flipSide);
            var avoidPositions = [];
            var impostors = world.select.typeAll(Balls.Impostor).filter(function (impostor) { return impostor.team === source.team; });
            avoidPositions.push.apply(avoidPositions, __spread(impostors));
            equipment.used = true;
            var script = world.runScript(function () {
                var jokerSymbol;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            equipment.setVisible(false);
                            jokerSymbol = world.addWorldObject(new Sprite({
                                p: equipment.orbitingIcon,
                                texture: 'equipments/joker',
                                layer: Battle.Layers.fx,
                            }));
                            world.playSound('swoosh');
                            return [4 /*yield*/, S.tweenPt(1, jokerSymbol, jokerSymbol, vec2(160, source.team === 'friend' ? 110 : 130), Tween.Easing.OutQuad)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.wait(0.2)];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.either(
                                // Create fog effects
                                function () {
                                    var i, _loop_27;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                i = 0;
                                                _loop_27 = function () {
                                                    var padding, fog;
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0:
                                                                padding = 10;
                                                                fog = world.addWorldObject(new Sprite({
                                                                    x: flipSide ? Random.float(world.width / 2 + padding, world.width - padding) : Random.float(padding, world.width / 2 - padding),
                                                                    y: Random.float(padding, world.height - padding),
                                                                    texture: new AnchoredTexture(Texture.filledCircle(40, 0xFFFFFF, 0.6), 0.5, 0.5),
                                                                    layer: Battle.Layers.fx,
                                                                    tint: Random.element([0xFF0000, 0xFFFF00, 0x0000FF, 0x00FF00]),
                                                                    scale: Random.float(0.5, 0.75),
                                                                }));
                                                                if (i % 2 === 0)
                                                                    world.playSound('puff', { volume: 0.7 });
                                                                i++;
                                                                fog.runScript(function () {
                                                                    var pos;
                                                                    return __generator(this, function (_a) {
                                                                        switch (_a.label) {
                                                                            case 0:
                                                                                pos = fog.getPosition();
                                                                                fog.teleport(jokerSymbol);
                                                                                return [4 /*yield*/, S.simul(S.tweenPt(0.5, fog, fog, pos, Tween.Easing.OutQuad), S.tween(0.5, fog, 'scale', 0, 1))];
                                                                            case 1:
                                                                                _a.sent();
                                                                                return [4 /*yield*/, S.tween(0.5, fog, 'alpha', 1, 0, Tween.Easing.InQuad)];
                                                                            case 2:
                                                                                _a.sent();
                                                                                return [2 /*return*/];
                                                                        }
                                                                    });
                                                                });
                                                                return [4 /*yield*/, S.wait(0.025)];
                                                            case 1:
                                                                _a.sent();
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                };
                                                _a.label = 1;
                                            case 1:
                                                if (!true) return [3 /*break*/, 3];
                                                return [5 /*yield**/, _loop_27()];
                                            case 2:
                                                _a.sent();
                                                return [3 /*break*/, 1];
                                            case 3: return [2 /*return*/];
                                        }
                                    });
                                }, 
                                // Randomize enemies
                                function () {
                                    var i, newPositions, j;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, S.wait(1)];
                                            case 1:
                                                _a.sent();
                                                i = 0;
                                                _a.label = 2;
                                            case 2:
                                                if (!(i < 16)) return [3 /*break*/, 5];
                                                Ball.Random.shuffle(possiblePositions);
                                                newPositions = getNewEnemyPositions(possiblePositions, avoidPositions, enemyBalls);
                                                for (j = 0; j < enemyBalls.length; j++) {
                                                    enemyBalls[j].teleport(newPositions[j]);
                                                }
                                                world.playSound('swoosh', { volume: 0.5 });
                                                return [4 /*yield*/, S.wait(0.1)];
                                            case 3:
                                                _a.sent();
                                                _a.label = 4;
                                            case 4:
                                                i++;
                                                return [3 /*break*/, 2];
                                            case 5: return [2 /*return*/];
                                        }
                                    });
                                })];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, S.tween(0.5, jokerSymbol, 'alpha', 1, 0)];
                        case 4:
                            _a.sent();
                            jokerSymbol.kill();
                            source.unequip();
                            if (source.squad && source.squadIndexReference >= 0 && source.squad.balls[source.squadIndexReference].properties.equipment === equipment.equipmentType) {
                                addItemTypeForAlmanacWin(getItemTypeForEquipmentType(equipment.equipmentType));
                                source.squad.balls[source.squadIndexReference].properties.equipment = -1;
                            }
                            return [4 /*yield*/, S.wait(1)];
                        case 5:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            equipment.setPreBattleAbilityActiveCheck(function () { return !script.done; });
        };
        return Joker;
    }(OrbitEquipment));
    Equipments.Joker = Joker;
    function getEnemyPositions(world, flipSide) {
        var result = [];
        for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 10; j++) {
                var v = vec2(M.lerp(32, 144, i / 9), M.lerp(32, 208, j / 9));
                if (flipSide) {
                    v.x = 320 - v.x;
                }
                result.push(v);
            }
        }
        return result.filter(function (l) { return isLocationValid(world, l); });
    }
    var CHECK_BOUNDS = new CircleBounds(0, 0, 0);
    function isLocationValid(world, location) {
        CHECK_BOUNDS.x = location.x;
        CHECK_BOUNDS.y = location.y;
        CHECK_BOUNDS.radius = 16;
        return _.isEmpty(world.select.overlap(CHECK_BOUNDS, [Battle.PhysicsGroups.walls]));
    }
    function getNewEnemyPositions(possiblePositions, avoidPositions, enemies) {
        var e_185, _a;
        var result = [];
        var i = 0;
        try {
            for (var enemies_5 = __values(enemies), enemies_5_1 = enemies_5.next(); !enemies_5_1.done; enemies_5_1 = enemies_5.next()) {
                var _1 = enemies_5_1.value;
                while (i < possiblePositions.length && (result.some(function (l) { return G.distance(l, possiblePositions[i]) < 20; }) || avoidPositions.some(function (l) { return G.distance(l, possiblePositions[i]) < 32; }))) {
                    i++;
                }
                if (i >= possiblePositions.length) {
                    return Ball.Random.shuffle(enemies.map(function (e) { return e.getPosition(); }));
                }
                result.push(possiblePositions[i]);
                i++;
            }
        }
        catch (e_185_1) { e_185 = { error: e_185_1 }; }
        finally {
            try {
                if (enemies_5_1 && !enemies_5_1.done && (_a = enemies_5.return)) _a.call(enemies_5);
            }
            finally { if (e_185) throw e_185.error; }
        }
        return result;
    }
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Magnet = /** @class */ (function (_super) {
        __extends(Magnet, _super);
        function Magnet() {
            var _this = _super.call(this, 'equipments/magnet', 'items/magnet') || this;
            _this.applyMagnetismFactor = 0;
            _this.applyMagnetismCooldown = new Timer(0.5);
            _this.addAbility('update', Magnet.update);
            _this.addAbility('onCollideWithBallPreDamage', Magnet.onCollideWithBallPreDamage);
            return _this;
        }
        Magnet.prototype.getName = function () { return 'Magnet'; };
        Magnet.prototype.getDesc = function () { return "Magnetize toward enemies, up to 133% the normal speed cap"; };
        Object.defineProperty(Magnet.prototype, "timeToFullMagnetism", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Magnet.update = function (equipment, source, world) {
            if (source.state === Ball.States.BATTLE) {
                equipment.applyMagnetismCooldown.update(equipment.delta);
                if (equipment.applyMagnetismCooldown.done) {
                    equipment.applyMagnetismFactor = M.moveToClamp(equipment.applyMagnetismFactor, 1, 1 / equipment.timeToFullMagnetism, equipment.delta);
                }
                else {
                    equipment.applyMagnetismFactor = 0;
                }
            }
            else {
                equipment.applyMagnetismFactor = 0;
            }
            equipment.magnetizeAmount = M.lerp(0, 0.34, equipment.applyMagnetismFactor);
        };
        Magnet.onCollideWithBallPreDamage = function (equipment, source, world, ball) {
            if (ball.team === source.team)
                return;
            equipment.applyMagnetismFactor = 0;
            equipment.applyMagnetismCooldown.reset();
            equipment.magnetizeAmount = 0;
        };
        return Magnet;
    }(OrbitEquipment));
    Equipments.Magnet = Magnet;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Medkit = /** @class */ (function (_super) {
        __extends(Medkit, _super);
        function Medkit() {
            var _this = _super.call(this, 'equipments/medkit', 'items/medkit') || this;
            _this.avoidTime = 0;
            _this.hasTakenDamageOnce = false;
            _this.addAbility('update', Medkit.update);
            _this.addAbility('onTakeDamage', Medkit.onTakeDamage);
            _this.addAbility('onTakeLeechDamage', Medkit.onTakeLeechDamage);
            return _this;
        }
        Medkit.prototype.getName = function () { return 'Medkit'; };
        Medkit.prototype.getDesc = function () { return "Heals for [g]2<heart>[/g]\n2 seconds after taking any damage. Taking damage resets the timer"; };
        Medkit.update = function (equipment, source, world) {
            if (source.state !== Ball.States.BATTLE && source.state !== Ball.States.PRE_BATTLE)
                return;
            if (equipment.hasTakenDamageOnce && equipment.avoidTime > 0) {
                equipment.avoidTime -= equipment.delta;
                if (equipment.avoidTime <= 0) {
                    source.healFor(Medkit.HEAL_AMOUNT, source);
                    source.addHealthBuffPlus(Medkit.HEAL_AMOUNT);
                    source.showHpStat(Medkit.HEAL_AMOUNT, 1);
                    world.playSound('medkitgrab');
                    world.playSound('medkitheal');
                }
            }
        };
        Medkit.onTakeDamage = function (equipment, source, world, damage) {
            equipment.hasTakenDamageOnce = true;
            equipment.avoidTime = Medkit.MAX_AVOID_TIME;
        };
        Medkit.onTakeLeechDamage = function (equipment, source, world, damage) {
            equipment.hasTakenDamageOnce = true;
            equipment.avoidTime = Medkit.MAX_AVOID_TIME;
        };
        Medkit.MAX_AVOID_TIME = 2;
        Medkit.HEAL_AMOUNT = 2;
        return Medkit;
    }(OrbitEquipment));
    Equipments.Medkit = Medkit;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var Mitosis = /** @class */ (function (_super) {
        __extends(Mitosis, _super);
        function Mitosis() {
            var _this = _super.call(this, 'equipments/mitosis', 'items/mitosis') || this;
            _this.hasSetColor = false;
            _this.orbitingIcon2 = _this.addChild(new OrbitingIcon('equipments/mitosis', _this.orbitingIcon.getParentBall));
            _this.orbitingIcon2.life.time = Random.float(0, 1);
            _this.orbitingIcon2.direction = -1;
            _this.orbitingIcon2.oscSpeed = 0.7;
            _this.preBattleAbilityInitialWaitTime = 0.5;
            _this.addAbility('onPreBattle', onPreBattle);
            return _this;
        }
        Mitosis.prototype.getName = function () { return 'Mitosis'; };
        Mitosis.prototype.getDesc = function () { return "At the start of battle, split into two copies with\n[r]half <sword>[/r], [g]half <heart>[/g], and [gold]half <star>[/gold]"; };
        Mitosis.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.parent || !(this.parent instanceof Ball))
                return;
            if (!this.hasSetColor) {
                var teamColor = Ball.getTeamColor(this.parent.team);
                this.orbitingIcon.effects.post.filters.push(new BallTeamColorFilter(teamColor));
                this.orbitingIcon2.effects.post.filters.push(new BallTeamColorFilter(teamColor));
                this.hasSetColor = true;
            }
        };
        Mitosis.prototype.setForShare = function () {
            _super.prototype.setForShare.call(this);
            this.orbitingIcon2.setForShare();
        };
        return Mitosis;
    }(OrbitEquipment));
    Equipments.Mitosis = Mitosis;
    function onPreBattle(equipment, source, world) {
        split(source, world);
    }
    function split(source, world) {
        var d = Ball.Random.onCircle(8);
        addCopy(source, world, d);
        addCopy(source, world, d.scale(-1));
        world.playSound('sellball').volume = 0.5;
        world.addWorldObject(new BurstPuffSystem({
            x: source.x,
            y: source.y,
            layer: Battle.Layers.fx,
            puffCount: Math.floor(10 * getParticleLevel()),
            puffConfigFactory: function () { return ({
                maxLife: 0.7,
                v: Random.inCircle(80),
                color: 0xFFFFFF,
                radius: 4,
                finalRadius: 0,
            }); },
        }));
        source.cancelAbilities();
        source.removeFromWorld();
    }
    function addCopy(source, world, d) {
        var ball = squadBallToWorldBall({
            x: source.x + d.x,
            y: source.y + d.y,
            properties: {
                type: source.properties.type,
                level: Math.ceil(source.level / 2),
                damage: source.dmg / 2,
                health: source.hp / 2,
                equipment: -1,
                metadata: O.deepClone(source.properties.metadata),
            }
        }, source.squad, source.squadIndexReference, source.team);
        ball.isSummon = false;
        world.addWorldObject(ball);
    }
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Mocha = /** @class */ (function (_super) {
        __extends(Mocha, _super);
        function Mocha() {
            var _this = _super.call(this, 'equipments/mocha', 'items/mocha') || this;
            _this.startEarlyTime = 0.75;
            return _this;
        }
        Mocha.prototype.getName = function () { return 'Mocha'; };
        Mocha.prototype.getDesc = function () { return "Starts moving before other balls"; };
        return Mocha;
    }(OrbitEquipment));
    Equipments.Mocha = Mocha;
})(Equipments || (Equipments = {}));
var OrbitingIcon = /** @class */ (function (_super) {
    __extends(OrbitingIcon, _super);
    function OrbitingIcon(icon, getParentBall) {
        var _this = _super.call(this, {
            texture: icon,
        }) || this;
        _this.oscSpeed = 1;
        _this.radiusScale = 1;
        _this.direction = 1;
        _this.getParentBall = getParentBall;
        return _this;
    }
    OrbitingIcon.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updatePosition();
    };
    OrbitingIcon.prototype.updatePosition = function () {
        var t = this.life.time * this.direction;
        var parent = this.getParentBall();
        var radiusFactor = parent ? M.map(Math.max(parent.visibleRadius / 8, 1), 1, 12, 1, 10) * this.radiusScale : 1;
        var xfactor = M.lerp(-0.25, 0.25, Tween.Easing.OscillateSine(this.oscSpeed / 8)(t));
        this.localx = M.lerp(-12 * radiusFactor, 12 * radiusFactor, Tween.Easing.OscillateSine(this.oscSpeed)(t));
        this.localy = M.lerp(-6 * radiusFactor, 6 * radiusFactor, Tween.Easing.OscillateSine(this.oscSpeed)(t + 0.25)) + this.localx * xfactor;
    };
    OrbitingIcon.prototype.postUpdate = function () {
        var parent = this.getParentBall();
        if (parent) {
            this.layer = parent.layer;
            if (Tween.Easing.OscillateSine(this.oscSpeed)(this.life.time * this.direction + 0.25) < 0.5)
                World.Actions.orderWorldObjectAfter(this, parent.stars);
            else
                World.Actions.orderWorldObjectBefore(this, parent);
        }
        // Fix for Polarity Inverter's fan
        if (this.parent && this.parent instanceof Equipments.PolarityInverter && this.children.length === 1) {
            World.Actions.orderWorldObjectAfter(this.children[0], this);
        }
    };
    OrbitingIcon.prototype.setForShare = function () {
        this.life.time = Random.element([0, 0.5]);
        this.updatePosition();
    };
    return OrbitingIcon;
}(Sprite));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var OrbitingPotato = /** @class */ (function (_super) {
        __extends(OrbitingPotato, _super);
        function OrbitingPotato(count) {
            var _this = _super.call(this, {
                breakIcon: 'items/orbitingpotato',
                copyFromParent: ['layer'],
            }) || this;
            _this.dmg = 5;
            _this.range = 7;
            if (count <= 0) {
                console.error('Invalid potato count, defaulting to 1:', count);
                count = 1;
            }
            var dangle = 360 / count;
            _this.potatoes = A.range(count).map(function (i) { return newPotato(16, i * dangle, _this.dmg); });
            _this.addChildren(_this.potatoes);
            return _this;
        }
        OrbitingPotato.prototype.getName = function () { return 'Orbiting Potato'; };
        OrbitingPotato.prototype.getDesc = function () { return "Orbiting potatoes deal [r]5<sword>/s[/r] to enemies and can block projectiles"; };
        Object.defineProperty(OrbitingPotato.prototype, "count", {
            get: function () { return _.size(this.potatoes); },
            enumerable: false,
            configurable: true
        });
        OrbitingPotato.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            if (this.parent instanceof Ball) {
                this.potatoes.forEach(function (potato) { return potato.data.parent = _this.parent; });
            }
        };
        OrbitingPotato.prototype.postUpdate = function () {
            var e_186, _a;
            _super.prototype.postUpdate.call(this);
            if (this.parent && this.parent instanceof Ball) {
                try {
                    for (var _b = __values(this.potatoes), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var potato = _c.value;
                        potato.data.radius = this.parent.visibleRadius + this.range;
                        World.Actions.orderWorldObjectAfter(potato, this.parent);
                    }
                }
                catch (e_186_1) { e_186 = { error: e_186_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_186) throw e_186.error; }
                }
            }
        };
        return OrbitingPotato;
    }(Equipment));
    Equipments.OrbitingPotato = OrbitingPotato;
    function newPotato(radius, angle, dmg) {
        var result = new Sprite({
            x: radius * M.cos(angle), y: radius * M.sin(angle),
            texture: 'equipments/orbitingpotato',
            copyFromParent: ['layer'],
            data: { radius: radius, angle: angle },
            bounds: new CircleBounds(0, 0, 8),
            update: function () {
                var e_187, _a, e_188, _b;
                var parent = this.data.parent;
                if (!parent.isNullified()) {
                    this.data.angle += 540 * this.delta;
                }
                this.localx = this.data.radius * M.cos(this.data.angle);
                this.localy = this.data.radius * M.sin(this.data.angle);
                this.angle = this.data.angle - 20;
                if (parent.isNullified())
                    return;
                if (parent.state === Ball.States.BATTLE) {
                    var enemyBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team !== parent.team && ball.alive && !ball.dead; });
                    try {
                        for (var enemyBalls_4 = __values(enemyBalls), enemyBalls_4_1 = enemyBalls_4.next(); !enemyBalls_4_1.done; enemyBalls_4_1 = enemyBalls_4.next()) {
                            var ball = enemyBalls_4_1.value;
                            if (this.isOverlapping(ball.bounds)) {
                                ball.leechFor(dmg * this.delta, parent);
                            }
                        }
                    }
                    catch (e_187_1) { e_187 = { error: e_187_1 }; }
                    finally {
                        try {
                            if (enemyBalls_4_1 && !enemyBalls_4_1.done && (_a = enemyBalls_4.return)) _a.call(enemyBalls_4);
                        }
                        finally { if (e_187) throw e_187.error; }
                    }
                }
                if (parent.state === Ball.States.BATTLE || parent.state === Ball.States.PRE_BATTLE) {
                    var enemyProjectiles = this.world.select.typeAll(Projectile).filter(function (proj) { return proj.source && proj.source.team !== parent.team; });
                    try {
                        for (var enemyProjectiles_1 = __values(enemyProjectiles), enemyProjectiles_1_1 = enemyProjectiles_1.next(); !enemyProjectiles_1_1.done; enemyProjectiles_1_1 = enemyProjectiles_1.next()) {
                            var proj = enemyProjectiles_1_1.value;
                            if (!proj.bounds || proj.bounds instanceof NullBounds) {
                                console.error('Error: projectile has no bounds:', proj);
                            }
                            if (this.bounds.isOverlapping(proj.bounds)) {
                                this.world.playSound('sellball').volume = 0.5;
                                this.world.addWorldObject(newPuff(proj.x, proj.y, Battle.Layers.fx, 'small'));
                                proj.kill();
                            }
                        }
                    }
                    catch (e_188_1) { e_188 = { error: e_188_1 }; }
                    finally {
                        try {
                            if (enemyProjectiles_1_1 && !enemyProjectiles_1_1.done && (_b = enemyProjectiles_1.return)) _b.call(enemyProjectiles_1);
                        }
                        finally { if (e_188) throw e_188.error; }
                    }
                }
            }
        });
        return result;
    }
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var Overcharger = /** @class */ (function (_super) {
        __extends(Overcharger, _super);
        function Overcharger() {
            var _this = _super.call(this, {
                breakIcon: 'items/overcharger',
                copyFromParent: ['layer'],
            }) || this;
            _this.zapDistance = 42;
            _this.damageRate = 2;
            _this.zapRing = _this.addChild(new ZapRing(0, {
                copyFromParent: ['layer'],
            }));
            _this.zaps = {};
            _this.zapSoundTimer = new Timer(0.1, function () { var _a; return (_a = _this.world) === null || _a === void 0 ? void 0 : _a.playSound('zap', { humanized: false, limit: 4 }); }, Infinity);
            _this.addAbility('update', Overcharger.update);
            return _this;
        }
        Overcharger.prototype.getName = function () { return 'Overcharger'; };
        Overcharger.prototype.getDesc = function () { return "Zaps nearby enemies for [r]2<sword>/s[/r]\n\nDamage decays to [r]1<sword>/s[/r] over 1s"; };
        Overcharger.prototype.onRemove = function () {
            _super.prototype.onRemove.call(this);
            for (var uid in this.zaps) {
                this.zaps[uid].removeFromWorld();
            }
        };
        Overcharger.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.parent && this.parent instanceof Ball) {
                World.Actions.orderWorldObjectAfter(this, this.parent);
                World.Actions.orderWorldObjectAfter(this.zapRing, this);
                this.zapRing.radius = this.parent.visibleRadius;
            }
        };
        Overcharger.update = function (equipment, source, world) {
            var e_189, _a;
            var _b;
            if (source.state !== Ball.States.BATTLE)
                return;
            var enemies = getEnemies(world, source);
            var newZaps = {};
            try {
                for (var enemies_6 = __values(enemies), enemies_6_1 = enemies_6.next(); !enemies_6_1.done; enemies_6_1 = enemies_6.next()) {
                    var enemy = enemies_6_1.value;
                    if (enemy.world !== world || G.distance(source, enemy) > source.physicalRadius + equipment.zapDistance + enemy.physicalRadius)
                        continue;
                    if (enemy.uid in equipment.zaps) {
                        newZaps[enemy.uid] = equipment.zaps[enemy.uid];
                    }
                    else {
                        newZaps[enemy.uid] = world.addWorldObject(new Zap(equipment, enemy));
                    }
                    var damageMult = (_b = newZaps[enemy.uid].getDamageMult()) !== null && _b !== void 0 ? _b : 1;
                    enemy.leechFor(equipment.damageRate * damageMult * equipment.delta, source);
                }
            }
            catch (e_189_1) { e_189 = { error: e_189_1 }; }
            finally {
                try {
                    if (enemies_6_1 && !enemies_6_1.done && (_a = enemies_6.return)) _a.call(enemies_6);
                }
                finally { if (e_189) throw e_189.error; }
            }
            for (var uid in equipment.zaps) {
                if (!(uid in newZaps)) {
                    equipment.zaps[uid].kill();
                }
            }
            equipment.zaps = newZaps;
            if (!_.isEmpty(equipment.zaps))
                equipment.zapSoundTimer.update(equipment.delta);
        };
        return Overcharger;
    }(Equipment));
    Equipments.Overcharger = Overcharger;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var PolarityInverter = /** @class */ (function (_super) {
        __extends(PolarityInverter, _super);
        function PolarityInverter() {
            var _this = _super.call(this, 'equipments/polarityinverter', 'items/polarityinverter') || this;
            _this.reverseDirection = true;
            _this.fan = _this.orbitingIcon.addChild(new Sprite({
                texture: 'equipments/polarityinverterfan',
                copyFromParent: ['layer'],
                vangle: -720,
            }));
            _this.applyMagnetismFactor = 0;
            _this.applyMagnetismCooldown = new Timer(0.5);
            _this.applyMagnetismCooldown.finish();
            _this.orbitingIcon.direction = -1;
            _this.addAbility('update', PolarityInverter.update);
            _this.addAbility('onCollideWithBallPreDamage', PolarityInverter.onCollideWithBallPreDamage);
            return _this;
        }
        PolarityInverter.prototype.getName = function () { return 'Polarity Inverter'; };
        PolarityInverter.prototype.getDesc = function () { return "Travel in the opposite direction around the arena AND magnetize toward enemies"; };
        Object.defineProperty(PolarityInverter.prototype, "timeToFullMagnetism", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        PolarityInverter.update = function (equipment, source, world) {
            if (source.state === Ball.States.BATTLE) {
                equipment.applyMagnetismCooldown.update(equipment.delta);
                if (equipment.applyMagnetismCooldown.done) {
                    equipment.applyMagnetismFactor = M.moveToClamp(equipment.applyMagnetismFactor, 1, 1 / equipment.timeToFullMagnetism, equipment.delta);
                }
                else {
                    equipment.applyMagnetismFactor = 0;
                }
            }
            else {
                equipment.applyMagnetismFactor = 0;
            }
            equipment.magnetizeAmount = M.lerp(0, 0.5, equipment.applyMagnetismFactor);
        };
        PolarityInverter.onCollideWithBallPreDamage = function (equipment, source, world, ball) {
            if (ball.team === source.team)
                return;
            equipment.applyMagnetismFactor = 0;
            equipment.applyMagnetismCooldown.reset();
            equipment.magnetizeAmount = 0;
        };
        return PolarityInverter;
    }(OrbitEquipment));
    Equipments.PolarityInverter = PolarityInverter;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var ProtectionBubble = /** @class */ (function (_super) {
        __extends(ProtectionBubble, _super);
        function ProtectionBubble() {
            var _this = _super.call(this, {
                copyFromParent: ['layer'],
                breakIcon: 'items/protectionbubble',
            }) || this;
            _this.percentDamageChange = 1 - 0.5;
            _this.noCollisionDamage = true;
            return _this;
        }
        ProtectionBubble.prototype.getName = function () { return 'Protection Bubble'; };
        ProtectionBubble.prototype.getDesc = function () { return "Takes 50% less damage, but deals none on collision"; };
        ProtectionBubble.prototype.render = function (texture, x, y) {
            if (this.parent && this.parent instanceof Ball) {
                var radius = this.parent.visibleRadius + 4;
                Draw.brush.color = 0xFFFFFF;
                Draw.brush.alpha = 0.5;
                Draw.circleSolid(texture, x, y, radius);
                Draw.brush.color = 0x87E3FF;
                Draw.brush.alpha = 1;
                Draw.brush.thickness = 1;
                Draw.circleOutline(texture, x, y, radius, Draw.ALIGNMENT_INNER);
            }
            _super.prototype.render.call(this, texture, x, y);
        };
        ProtectionBubble.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.parent)
                World.Actions.orderWorldObjectAfter(this, this.parent);
        };
        return ProtectionBubble;
    }(Equipment));
    Equipments.ProtectionBubble = ProtectionBubble;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var RedCube = /** @class */ (function (_super) {
        __extends(RedCube, _super);
        function RedCube() {
            var _this = _super.call(this, 'equipments/redcube', 'items/redcube') || this;
            _this.spreadDamageOverTime = 3;
            return _this;
        }
        RedCube.prototype.getName = function () { return 'Red Cube'; };
        RedCube.prototype.getDesc = function () { return "Damage taken is spread over 3 seconds"; };
        return RedCube;
    }(OrbitEquipment));
    Equipments.RedCube = RedCube;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Rejuvenator = /** @class */ (function (_super) {
        __extends(Rejuvenator, _super);
        function Rejuvenator() {
            var _this = _super.call(this, 'equipments/rejuvenator', 'items/rejuvenator') || this;
            _this.addAbility('update', Rejuvenator.update);
            return _this;
        }
        Rejuvenator.prototype.getName = function () { return 'Rejuvenator'; };
        Rejuvenator.prototype.getDesc = function () { return "Passively heal for [g]0.5<heart>/s[/g]"; };
        Rejuvenator.update = function (equipment, source, world) {
            if (source.state !== Ball.States.BATTLE && source.state !== Ball.States.PRE_BATTLE)
                return;
            source.healFor(0.5 * equipment.delta, source);
        };
        return Rejuvenator;
    }(OrbitEquipment));
    Equipments.Rejuvenator = Rejuvenator;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var RetroGlasses = /** @class */ (function (_super) {
        __extends(RetroGlasses, _super);
        function RetroGlasses() {
            var _this = _super.call(this, 'equipments/retroglasses/0', 'items/retroglasses') || this;
            _this.stockEquippedBall = true;
            _this.orbitingIcon.oscSpeed = 0.6;
            _this.orbitingIcon.radiusScale = 14 / 12;
            _this.orbitingIcon.addAnimation(Animations.fromTextureList({ name: 'default', textureRoot: 'equipments/retroglasses',
                textures: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                frameRate: 8, count: Infinity }));
            _this.orbitingIcon.playAnimation('default');
            return _this;
        }
        RetroGlasses.prototype.getName = function () { return 'Retro Glasses'; };
        RetroGlasses.prototype.getDesc = function () { return "The equipped ball is significantly more likely to be in the shop on every roll"; };
        return RetroGlasses;
    }(OrbitEquipment));
    Equipments.RetroGlasses = RetroGlasses;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Shield = /** @class */ (function (_super) {
        __extends(Shield, _super);
        function Shield() {
            var _this = _super.call(this, 'equipments/shield', 'items/shield') || this;
            _this.blockOneDiscreteDamage = true;
            return _this;
        }
        Shield.prototype.getName = function () { return 'Shield'; };
        Shield.prototype.getDesc = function () { return "Blocks the first discrete instance of damage"; };
        return Shield;
    }(OrbitEquipment));
    Equipments.Shield = Shield;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Silencer = /** @class */ (function (_super) {
        __extends(Silencer, _super);
        function Silencer() {
            var _this = _super.call(this, 'equipments/silencer', 'items/silencer') || this;
            _this.noCollisionDamage = true;
            _this.cooldown = new AbilityCooldown(0.2, 2);
            _this.addAbility('onCollideWithEnemyPostDamage', Silencer.onCollideWithEnemyPostDamage);
            return _this;
        }
        Silencer.prototype.getName = function () { return 'Silencer'; };
        Silencer.prototype.getDesc = function () { return "On collision, the damage that would have been dealt is instead shot as 1-3 homing spikes toward random enemies. Each spike gains +[r]1<sword>[/r]"; };
        Silencer.prototype.update = function () {
            _super.prototype.update.call(this);
            this.cooldown.update(this.delta);
        };
        Silencer.onCollideWithEnemyPostDamage = function (equipment, source, world, ball, damage) {
            if (damage <= 0)
                return;
            if (!equipment.cooldown.consumeUse())
                return;
            var enemies = getEnemies(world, source);
            if (enemies.length === 0)
                return;
            var numSpikes = Ball.Random.int(1, 3);
            for (var i = 0; i < numSpikes; i++) {
                var randomBall = Ball.Random.element(enemies);
                world.addWorldObject(new HomingSpike(source.x, source.y, source, randomBall, damage / numSpikes + 1, 1, function (enemyBalls) { return Ball.Random.element(enemyBalls); }));
                source.didShootProjectile(1);
            }
        };
        return Silencer;
    }(OrbitEquipment));
    Equipments.Silencer = Silencer;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var SkullCharm = /** @class */ (function (_super) {
        __extends(SkullCharm, _super);
        function SkullCharm() {
            var _this = _super.call(this, 'equipments/skullcharm', 'items/skullcharm') || this;
            _this.addAbility('onDeath', SkullCharm.onDeath);
            return _this;
        }
        SkullCharm.prototype.getName = function () { return 'Skull Charm'; };
        SkullCharm.prototype.getDesc = function () { return "Summons a " + buffText(this.getParentLevel(), 2) + " skeleton on death"; };
        SkullCharm.onDeath = function (equipment, source, world, killedBy) {
            world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: 16,
                    level: 1,
                    damage: source.level,
                    health: 2,
                    equipment: -1,
                    metadata: {},
                }
            }, undefined, -1, source.team));
        };
        SkullCharm.prototype.getParentLevel = function () {
            var _a, _b;
            return (_b = (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.level) !== null && _b !== void 0 ? _b : 1;
        };
        return SkullCharm;
    }(OrbitEquipment));
    Equipments.SkullCharm = SkullCharm;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var SmokeBomb = /** @class */ (function (_super) {
        __extends(SmokeBomb, _super);
        function SmokeBomb() {
            var _this = _super.call(this, 'equipments/smokebomb', 'items/smokebomb') || this;
            _this.addAbility('onEnterBattle', SmokeBomb.onEnterBattle);
            return _this;
        }
        SmokeBomb.prototype.getName = function () { return 'Smoke Bomb'; };
        SmokeBomb.prototype.getDesc = function () { return "Disappear on entering battle, avoiding collisions for 2 seconds. Reappear in a burst of [r]2x the ball's <sword>[/r]"; };
        SmokeBomb.onEnterBattle = function (equipment, source, world) {
            source.becomeEtherealForTime(2);
            source.unequip();
        };
        return SmokeBomb;
    }(OrbitEquipment));
    Equipments.SmokeBomb = SmokeBomb;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var Spore = /** @class */ (function (_super) {
        __extends(Spore, _super);
        function Spore() {
            var _this = _super.call(this, 'equipments/spore', 'equipments/spore') || this;
            _this.flatDamageChange = 1;
            return _this;
        }
        Spore.prototype.getName = function () { return 'Spore'; };
        Spore.prototype.getDesc = function () { return "[r]Every instance of damage received is increased by " + this.flatDamageChange + "<sword>[/r]"; };
        return Spore;
    }(OrbitEquipment));
    Equipments.Spore = Spore;
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var StarCatcher = /** @class */ (function (_super) {
        __extends(StarCatcher, _super);
        function StarCatcher() {
            var _this = _super.call(this, 'equipments/starcatcher', 'items/starcatcher') || this;
            _this.addAbility('onPreBattle', StarCatcher.onPreBattle);
            _this.addAbility('onEnterBattle', StarCatcher.onEnterBattle);
            return _this;
        }
        StarCatcher.prototype.getName = function () { return 'Star Catcher'; };
        StarCatcher.prototype.getDesc = function () { return "On enter battle, steals [gold]1<star>[/gold] from a random enemy"; };
        StarCatcher.onPreBattle = function (equipment, source, world) {
            StarCatcher.stealStar(equipment, source, world);
            source.unequip();
        };
        StarCatcher.onEnterBattle = function (equipment, source, world) {
            StarCatcher.stealStar(equipment, source, world);
            source.unequip();
        };
        StarCatcher.stealStar = function (equipment, source, world) {
            var starCatchers = world.select.typeAll(StarCatcher);
            var validBalls = getEnemies(world, source).filter(function (enemy) { return starCatchers.filter(function (c) { return c.target === enemy; }).length < enemy.level - 1; });
            if (validBalls.length === 0)
                return;
            var randomEnemy = Ball.Random.element(validBalls);
            equipment.target = randomEnemy;
            var hand = world.addWorldObject(new StarCatcherHand(source.x, source.y, source, randomEnemy));
            equipment.setPreBattleAbilityActiveCheck(function () { return hand.world; });
        };
        return StarCatcher;
    }(OrbitEquipment));
    Equipments.StarCatcher = StarCatcher;
    var StarCatcherHand = /** @class */ (function (_super) {
        __extends(StarCatcherHand, _super);
        function StarCatcherHand(x, y, source, target) {
            var _this = _super.call(this, {
                x: x, y: y,
                texture: 'equipments/star_catcher',
                layer: Battle.Layers.fx,
                angle: target.getPosition().subtract(x, y).angle,
                flipY: target.x < x,
                effects: { outline: {} },
            }) || this;
            var hand = _this;
            _this.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            hand.world.playSound('steal');
                            return [4 /*yield*/, S.tweenPt(0.5, hand, hand, target)];
                        case 1:
                            _a.sent();
                            hand.grab(target);
                            hand.world.playSound('steal');
                            return [4 /*yield*/, S.tweenPt(0.5, hand, hand, source)];
                        case 2:
                            _a.sent();
                            source.levelUp(undefined, true, false);
                            hand.kill();
                            return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        StarCatcherHand.prototype.grab = function (target) {
            if (target.level <= 1)
                return;
            target.levelDown();
            var hand = this;
            this.addChild(new Sprite({
                y: -1,
                texture: 'star',
                layer: Battle.Layers.fx,
                update: function () {
                    World.Actions.orderWorldObjectAfter(this, hand);
                }
            }));
            this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFFFF00,
                blendMode: Texture.BlendModes.ADD,
                scale: 0.2,
                layer: Battle.Layers.fx,
                update: function () {
                    World.Actions.orderWorldObjectAfter(this, hand);
                }
            }));
        };
        return StarCatcherHand;
    }(Sprite));
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var TheBug = /** @class */ (function (_super) {
        __extends(TheBug, _super);
        function TheBug() {
            var _this = _super.call(this, 'equipments/thebug', 'items/thebug') || this;
            _this.orbitingIcon.effects.post.filters.push(new Effects.Filters.Glitch(4, 2, 2));
            _this.addAbility('onRestock', TheBug.onRestock);
            return _this;
        }
        TheBug.prototype.getName = function () { return 'The Bug'; };
        TheBug.prototype.getDesc = function () { return "Transforms into a random shop ball on restock"; };
        TheBug.onRestock = function (equipment, source, world) {
            var validBallTypes = getPurchasableBallTypesForRound(GAME_DATA.round, GAME_DATA.packs, GAME_DATA.weekly)
                .filter(function (t) {
                if (t === source.properties.type)
                    return false;
                if (_.contains(TheBug.INVALID_BALL_TYPES, t))
                    return false;
                if (GAME_DATA.lap > 1 && source.level > 3 && (_.contains(Shop.NO_TIER_CROWN_LEVEL_MUTATION_BALLS, t) || _.contains(Shop.REDUCED_TIER_CROWN_LEVEL_MUTATION_BALLS, t)))
                    return false;
                return true;
            });
            if (_.isEmpty(validBallTypes))
                return;
            var ballType = Ball.Random.element(validBallTypes);
            var isInSquad = source.squadIndexReference >= 0;
            if (isInSquad)
                ShopActions.removeBallFromSquad(source);
            source.removeFromWorld();
            var newBall = world.addWorldObject(squadBallToWorldBall({
                x: source.x,
                y: source.y,
                properties: {
                    type: ballType,
                    level: source.level,
                    damage: source.dmg,
                    health: source.hp,
                    equipment: source.equipment ? source.equipment.equipmentType : -1,
                    metadata: source.properties.metadata,
                }
            }, GAME_DATA.squad, GAME_DATA.squad.balls.length, source.team));
            newBall.showAllStats();
            world.runScript(function () {
                var g, glitchSound;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            g = new Effects.Filters.Glitch(8, 4, 4);
                            g.setUniform('t', Random.float(0, 10));
                            newBall.effects.post.filters.push(g);
                            glitchSound = world.playSound('arg/glitch_dialog', { limit: 1 });
                            glitchSound.volume = 0.5;
                            return [4 /*yield*/, S.wait(0.3)];
                        case 1:
                            _a.sent();
                            glitchSound.stop();
                            A.removeAll(newBall.effects.post.filters, g);
                            return [2 /*return*/];
                    }
                });
            });
            if (isInSquad) {
                GAME_DATA.squad.balls.push({
                    x: newBall.x,
                    y: newBall.y,
                    properties: newBall.properties,
                });
            }
        };
        TheBug.INVALID_BALL_TYPES = [
            127,
        ];
        return TheBug;
    }(OrbitEquipment));
    Equipments.TheBug = TheBug;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var TheseGuns = /** @class */ (function (_super) {
        __extends(TheseGuns, _super);
        function TheseGuns() {
            var _this = _super.call(this, {
                breakIcon: 'items/guns',
                copyFromParent: ['layer'],
            }) || this;
            _this.dmg = 1;
            _this.range = 28;
            _this.maxPunches = 2;
            _this.gunLeft = _this.addChild(newGun(-1, _this.dmg));
            _this.gunRight = _this.addChild(newGun(1, _this.dmg));
            _this.cooldown = _this.addTimer(0.2);
            _this.punches = 0;
            _this.stateMachine.addState('ready', {
                update: function () { return _this.updatePunches(); },
                script: S.waitUntil(function () { return _this.punches >= _this.maxPunches; }),
                transitions: [{ toState: 'taunt' }],
            });
            _this.stateMachine.addState('taunt', {
                script: S.chain(S.waitUntil(function () { return _this.gunLeft.state !== 'punch' && _this.gunRight.state !== 'punch'; }), S.call(function () { return _this.taunt(); }), S.wait(2.6), S.call(function () { return _this.unequip(); })),
            });
            _this.setState('ready');
            return _this;
        }
        TheseGuns.prototype.getName = function () { return 'These Guns!!'; };
        TheseGuns.prototype.getDesc = function () { return "Punches nearby enemies for [r]2<sword>[/r] each. Breaks after two punches."; };
        TheseGuns.prototype.updatePunches = function () {
            var _this = this;
            if (!this.world || !this.parent || !(this.parent instanceof Ball))
                return;
            if (this.parent.state !== Ball.States.BATTLE)
                return;
            if (this.punches >= this.maxPunches)
                return;
            if (!this.cooldown.done)
                return;
            var enemies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team !== _this.parent.team; });
            var validBallsLeft = this.gunLeft.state === 'idle' ? enemies.filter(function (ball) { return ball.x < _this.x && G.distance(ball, _this.gunLeft) < _this.range && ball !== _this.gunRight.data.target; }) : [];
            var validBallsRight = this.gunRight.state === 'idle' ? enemies.filter(function (ball) { return ball.x > _this.x && G.distance(ball, _this.gunRight) < _this.range && ball !== _this.gunLeft.data.target; }) : [];
            var selectedGun;
            var selectedValidBalls;
            if (validBallsLeft.length === 0) {
                selectedGun = this.gunRight;
                selectedValidBalls = validBallsRight;
            }
            else if (validBallsRight.length === 0) {
                selectedGun = this.gunLeft;
                selectedValidBalls = validBallsLeft;
            }
            else if (Ball.Random.boolean()) {
                selectedGun = this.gunRight;
                selectedValidBalls = validBallsRight;
            }
            else {
                selectedGun = this.gunLeft;
                selectedValidBalls = validBallsLeft;
            }
            var selectedTarget = M.argmin(selectedValidBalls, function (ball) { return G.distance(ball, selectedGun); });
            if (selectedTarget) {
                selectedGun.data.target = selectedTarget;
                selectedGun.data.parent = this.parent;
                selectedGun.setState('punch');
                this.punches++;
                this.cooldown.reset();
            }
        };
        TheseGuns.prototype.taunt = function () {
            if (!this.world || !this.parent || !(this.parent instanceof Ball))
                return;
            this.gunLeft.setState('taunt');
            this.gunRight.setState('taunt');
        };
        TheseGuns.prototype.unequip = function () {
            if (!this.world || !this.parent || !(this.parent instanceof Ball))
                return;
            this.world.addWorldObject(newPuff(this.parent.x, this.parent.y, Battle.Layers.fx, 'medium'));
            this.parent.unequip();
        };
        TheseGuns.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            if (this.parent && this.parent instanceof Ball) {
                this.gunLeft.localx = -this.parent.visibleRadius - 1;
                this.gunRight.localx = this.parent.visibleRadius + 1;
                World.Actions.orderWorldObjectBefore(this.gunLeft, this.parent);
                World.Actions.orderWorldObjectBefore(this.gunRight, this.parent);
            }
        };
        return TheseGuns;
    }(Equipment));
    Equipments.TheseGuns = TheseGuns;
    function newGun(dir, dmg) {
        var result = new Sprite({
            x: dir * 9, y: 1,
            animations: [
                Animations.fromTextureList({ name: 'idle', textureRoot: 'equipments/gun', textures: [0, 1], frameRate: 2, count: Infinity }),
                Animations.fromTextureList({ name: 'punch', textureRoot: 'equipments/gun', textures: [3, 3, 3, 2, 0], frameRate: 12, count: 1 }),
                Animations.fromTextureList({ name: 'taunt', textureRoot: 'equipments/gun', textures: [4, 5, 4, 5, 4, 5, 3, 2, 0], frameRate: 4 }),
            ],
            defaultAnimation: 'idle',
            effects: { outline: { color: 0x000000 } },
            copyFromParent: ['layer'],
            flipX: dir < 0,
        });
        result.stateMachine.addState('idle', {
            callback: function () { return result.playAnimation('idle'); },
        });
        result.stateMachine.addState('punch', {
            script: function () {
                var target, parent, d;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            target = result.data.target;
                            parent = result.data.parent;
                            if (!target || !parent)
                                return [2 /*return*/];
                            d = target.getPosition().subtract(result);
                            target.takeDamage(dmg, parent, 'other');
                            target.v.set(d.setMagnitude(250));
                            result.angle = dir > 0 ? d.angle : 180 + d.angle;
                            return [4 /*yield*/, S.playAnimation(result, 'punch')];
                        case 1:
                            _a.sent();
                            result.angle = 0;
                            result.data.target = undefined;
                            return [4 /*yield*/, S.wait(0.6)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            },
            transitions: [{ toState: 'idle' }]
        });
        result.stateMachine.addState('taunt', {
            script: function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.playAnimation(result, 'taunt')];
                        case 1:
                            _a.sent();
                            result.playAnimation('idle');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            },
        });
        result.setState('idle');
        return result;
    }
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var ThiefMask = /** @class */ (function (_super) {
        __extends(ThiefMask, _super);
        function ThiefMask() {
            var _this = _super.call(this, 'equipments/thiefmask', 'items/thiefmask') || this;
            _this.addAbility('onPreBattle', onPreBattle);
            return _this;
        }
        ThiefMask.prototype.getName = function () { return 'Thief Mask'; };
        ThiefMask.prototype.getDesc = function () { return "Steal the equipment of a random enemy at the start of battle"; };
        return ThiefMask;
    }(OrbitEquipment));
    Equipments.ThiefMask = ThiefMask;
    function onPreBattle(equipment, source, world) {
        var thiefMasks = world.select.typeAll(ThiefMask);
        var validEnemies = getEnemies(world, source).filter(function (ball) { return ball.equipment && !(ball.equipment instanceof ThiefMask) && !thiefMasks.some(function (tm) { return tm.target === ball; }); });
        if (validEnemies.length === 0)
            return;
        var randomEnemy = Ball.Random.element(validEnemies);
        equipment.target = randomEnemy;
        var hand = world.addWorldObject(new ThiefHand(source.x, source.y, source, randomEnemy));
        equipment.setPreBattleAbilityActiveCheck(function () { return hand.world; });
    }
    var ThiefHand = /** @class */ (function (_super) {
        __extends(ThiefHand, _super);
        function ThiefHand(x, y, source, target) {
            var _this = _super.call(this, {
                x: x, y: y,
                texture: 'equipments/thief_hand/0',
                layer: Battle.Layers.fx,
                angle: target.getPosition().subtract(x, y).angle,
                flipY: target.x < x,
                effects: { outline: {} },
            }) || this;
            var hand = _this;
            _this.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            hand.world.playSound('steal');
                            return [4 /*yield*/, S.tweenPt(0.5, hand, hand, target)];
                        case 1:
                            _a.sent();
                            hand.grab(target);
                            hand.world.playSound('steal');
                            return [4 /*yield*/, S.tweenPt(0.5, hand, hand, source)];
                        case 2:
                            _a.sent();
                            if (hand.stolenEquipmentType !== undefined) {
                                source.equip(hand.stolenEquipmentType);
                            }
                            hand.kill();
                            return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        ThiefHand.prototype.grab = function (target) {
            if (!target.equipment)
                return;
            this.stolenEquipmentType = target.equipment.equipmentType;
            target.unequip();
            this.setTexture('equipments/thief_hand/1');
            this.addEquipmentSprites(this.stolenEquipmentType);
        };
        ThiefHand.prototype.addEquipmentSprites = function (equipmentType) {
            var hand = this;
            this.addChild(new Sprite({
                texture: 'aura',
                tint: 0xFFFF00,
                blendMode: Texture.BlendModes.ADD,
                scale: 0.1,
                layer: Battle.Layers.fx,
                update: function () {
                    World.Actions.orderWorldObjectAfter(this, hand);
                }
            }));
            this.addChild(new Sprite({
                texture: TYPE_TO_EQUIPMENT_TYPE_DEF[equipmentType].factory().getEquipmentTexture(),
                layer: Battle.Layers.fx,
                update: function () {
                    World.Actions.orderWorldObjectAfter(this, hand);
                }
            }));
        };
        return ThiefHand;
    }(Sprite));
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var TimeBomb = /** @class */ (function (_super) {
        __extends(TimeBomb, _super);
        function TimeBomb() {
            var _this = _super.call(this, 'equipments/timebomb', 'items/timebomb') || this;
            _this.timeLeftToExplode = 2.8;
            _this.orbitingIcon.setTexture(getBombTextureForNumber(_this.timeLeftToExplode));
            _this.addAbility('update', TimeBomb.update);
            return _this;
        }
        TimeBomb.prototype.getName = function () { return 'Time Bomb'; };
        TimeBomb.prototype.getDesc = function () { return "Explodes after 3 seconds in battle, dealing its [r]<sword>[/r] in a radius"; };
        Object.defineProperty(TimeBomb.prototype, "explosionRadius", {
            get: function () { var _a, _b; return 50 + ((_b = (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.physicalRadius) !== null && _b !== void 0 ? _b : 8) - 8; },
            enumerable: false,
            configurable: true
        });
        TimeBomb.prototype.onAdd = function () {
            var _this = this;
            _super.prototype.onAdd.call(this);
            this.addChild(new AbilityRadius(this.getParent(), function () { return _this.explosionRadius; }, 0xFF0000, 0xFF3333, 0.6));
        };
        TimeBomb.update = function (equipment, source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            equipment.timeLeftToExplode -= equipment.delta;
            if (equipment.timeLeftToExplode <= 0) {
                world.playSound('shake2');
                world.addWorldObject(new Explosion(source.x, source.y, equipment.explosionRadius, { ally: 0, enemy: source.dmg }, source));
                source.takeDamage(source.hp * 2, source, 'other', true);
                source.unequip();
                return;
            }
            if (Math.ceil(equipment.timeLeftToExplode) < Math.ceil(equipment.timeLeftToExplode + equipment.delta)) {
                world.playSound('beep', { humanized: false });
            }
            equipment.orbitingIcon.setTexture(getBombTextureForNumber(equipment.timeLeftToExplode));
            if (equipment.timeLeftToExplode <= 1.2) {
                source.effects.silhouette.enabled = true;
                source.effects.silhouette.color = 0xFFFFFF;
                source.effects.silhouette.amount = M.mapClamp(equipment.timeLeftToExplode, 1.2, 0.8, 0, 1);
                if (equipment.timeLeftToExplode <= 1) {
                    source.offsetX = Tween.Easing.OscillateSine(6)(source.life.time);
                }
            }
        };
        return TimeBomb;
    }(OrbitEquipment));
    Equipments.TimeBomb = TimeBomb;
    function getBombTextureForNumber(n) {
        n = Math.ceil(n);
        return lazy("TimeBomb_texture(" + n + ")", function () {
            var texture = AssetCache.getTexture('equipments/timebomb').clone('TimeBomb.getBombTextureForNumber');
            new SpriteText({
                text: "" + n,
                font: 'smallnumbers',
                style: { color: 0xFF0000 },
                anchor: Vector2.CENTER,
            })
                .render(texture, 6, 7);
            return texture;
        });
    }
})(Equipments || (Equipments = {}));
var Equipments;
(function (Equipments) {
    var ToxicFungus = /** @class */ (function (_super) {
        __extends(ToxicFungus, _super);
        function ToxicFungus() {
            var _this = _super.call(this, 'equipments/toxicfungus', 'items/toxicfungus') || this;
            _this.addAbility('onPreBattle', ToxicFungus.onPreBattle);
            _this.addAbility('onEnterBattle', ToxicFungus.onEnterBattle);
            return _this;
        }
        ToxicFungus.prototype.getName = function () { return 'Toxic Fungus'; };
        ToxicFungus.prototype.getDesc = function () { return "On enter battle, plant a [dg]spore equipment[/dg] on the enemy with the highest [g]<heart>[/g]\n\nSpored balls take [r]1<sword>[/r] extra per hit"; };
        ToxicFungus.onPreBattle = function (equipment, source, world) {
            ToxicFungus.plantSpore(equipment, source, world);
            source.unequip();
        };
        ToxicFungus.onEnterBattle = function (equipment, source, world) {
            ToxicFungus.plantSpore(equipment, source, world);
            source.unequip();
        };
        ToxicFungus.plantSpore = function (equipment, source, world) {
            var validBalls = getEnemies(world, source);
            if (validBalls.length === 0)
                return;
            var strongestBall = M.argmax(validBalls, function (ball) { return ball.hp; });
            var hs = world.addWorldObject(new HomingSpore(source.x, source.y, source, strongestBall));
            equipment.setPreBattleAbilityActiveCheck(function () { return hs.world; });
        };
        return ToxicFungus;
    }(OrbitEquipment));
    Equipments.ToxicFungus = ToxicFungus;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var UnstableCatalyst = /** @class */ (function (_super) {
        __extends(UnstableCatalyst, _super);
        function UnstableCatalyst() {
            var _this = _super.call(this, 'equipments/unstablecatalyst', 'items/unstablecatalyst') || this;
            _this.addAbility('update', UnstableCatalyst.update);
            return _this;
        }
        UnstableCatalyst.prototype.getName = function () { return 'Unstable Catalyst'; };
        UnstableCatalyst.prototype.getDesc = function () { return "Passively convert -[g]0.25<heart>/s[/g] into +[r]1<sword>/s[/r]"; };
        Object.defineProperty(UnstableCatalyst.prototype, "healthDrainRate", {
            get: function () { return 0.25; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UnstableCatalyst.prototype, "damageGainRate", {
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        UnstableCatalyst.update = function (equipment, source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            var hpToConvert = Math.min(equipment.healthDrainRate * equipment.delta, source.hp);
            if (hpToConvert > 0) {
                source.hp -= hpToConvert;
                source.dmg += equipment.damageGainRate / equipment.healthDrainRate * hpToConvert;
                source.showHpStat(-hpToConvert, 0.5);
                source.showDmgStat(hpToConvert, 0.5);
            }
        };
        return UnstableCatalyst;
    }(OrbitEquipment));
    Equipments.UnstableCatalyst = UnstableCatalyst;
})(Equipments || (Equipments = {}));
/// <reference path="./orbitEquipment.ts" />
var Equipments;
(function (Equipments) {
    var VIPTicket = /** @class */ (function (_super) {
        __extends(VIPTicket, _super);
        function VIPTicket() {
            var _this = _super.call(this, 'equipments/vipticket', 'items/vipticket') || this;
            _this.stockExtraItems = 1;
            return _this;
        }
        VIPTicket.prototype.getName = function () { return 'VIP Ticket'; };
        VIPTicket.prototype.getDesc = function () { return "The shop stocks one less ball and one extra item"; };
        return VIPTicket;
    }(OrbitEquipment));
    Equipments.VIPTicket = VIPTicket;
})(Equipments || (Equipments = {}));
/// <reference path="./equipment.ts" />
var Equipments;
(function (Equipments) {
    var VoodooPin = /** @class */ (function (_super) {
        __extends(VoodooPin, _super);
        function VoodooPin() {
            var _this = _super.call(this, {
                texture: 'equipments/voodoopin',
                copyFromParent: ['layer'],
                breakIcon: 'items/voodoopin',
            }) || this;
            _this.stringTint = 0xFFFFFF;
            _this.addAbility('update', VoodooPin.update);
            return _this;
        }
        VoodooPin.prototype.getName = function () { return 'Voodoo Pin'; };
        VoodooPin.prototype.getDesc = function () { return 'Sacrifices\n[g]1 max <heart>/s[/g] to damage the enemy with the highest [r]<sword>[/r] for [r]1.5<sword>/s[/r]'; };
        VoodooPin.prototype.update = function () {
            var _a, _b;
            _super.prototype.update.call(this);
            if (this.target && (!this.target.world || !this.target.alive || this.target.dead)) {
                (_a = this.script) === null || _a === void 0 ? void 0 : _a.stop();
                (_b = this.getParent()) === null || _b === void 0 ? void 0 : _b.unequip();
            }
        };
        VoodooPin.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            var parent = this.getParent();
            if (!parent)
                return;
            this.localx = parent.visibleRadius / Math.SQRT2 + 1;
            this.localy = -parent.visibleRadius / Math.SQRT2 - 1;
            World.Actions.orderWorldObjectAfter(this, parent.stars);
        };
        VoodooPin.prototype.render = function (texture, x, y) {
            _super.prototype.render.call(this, texture, x, y);
            if (this.enemyPin) {
                var ex = x + this.enemyPin.x - this.x;
                var ey = y + this.enemyPin.y - this.y;
                Draw.brush.color = this.stringTint;
                Draw.brush.alpha = 0.5;
                Draw.brush.thickness = 1;
                Draw.line(texture, x + 1, y - 1, ex + 1, ey - 1);
            }
        };
        VoodooPin.prototype.onRemove = function () {
            if (this.enemyPin)
                this.enemyPin.kill();
            this.enemyPin = undefined;
            _super.prototype.onRemove.call(this);
        };
        VoodooPin.update = function (equipment, source, world) {
            if (source.state !== Ball.States.BATTLE)
                return;
            if (equipment.script)
                return;
            equipment.script = equipment.runScript(function () {
                var target, enemyBalls, damageDealt;
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/];
                        case 1:
                            _b.sent(); // Wait one frame to catch Vampires
                            _b.label = 2;
                        case 2:
                            if (!!target) return [3 /*break*/, 4];
                            enemyBalls = getEnemies(world, source);
                            target = M.argmax(enemyBalls, function (ball) { return ball.dmg; });
                            return [4 /*yield*/];
                        case 3:
                            _b.sent();
                            return [3 /*break*/, 2];
                        case 4:
                            equipment.target = target;
                            equipment.enemyPin = world.addWorldObject(new Sprite({
                                x: equipment.x, y: equipment.y,
                                texture: 'equipments/voodoopin_shoot',
                                layer: Battle.Layers.fx,
                            }));
                            world.playSound('spike');
                            return [4 /*yield*/, S.doOverTime(0.1, function (t) {
                                    equipment.enemyPin.x = M.lerp(equipment.x, target.x, t);
                                    equipment.enemyPin.y = M.lerp(equipment.y, target.y, t);
                                    equipment.enemyPin.angle = target.getPosition().subtract(equipment).angle;
                                })];
                        case 5:
                            _b.sent();
                            (_a = equipment.enemyPin) === null || _a === void 0 ? void 0 : _a.kill();
                            equipment.enemyPin = target.addChild(new Sprite({
                                x: 0, y: 0,
                                texture: 'equipments/voodoopin',
                                layer: Battle.Layers.fx,
                                update: function () {
                                    if (this.parent && this.parent instanceof Ball) {
                                        this.localx = source.visibleRadius / Math.SQRT2 + 1;
                                        this.localy = -source.visibleRadius / Math.SQRT2 - 1;
                                    }
                                }
                            }));
                            _b.label = 6;
                        case 6:
                            if (!true) return [3 /*break*/, 8];
                            damageDealt = source.takeDamage(0.75, source, 'other', true);
                            source.maxhp -= damageDealt;
                            target.takeDamage(1, source, 'other', true);
                            world.playSound('balldie');
                            source.flash(0xB200B2, 1, 0.5);
                            target.flash(0xB200B2, 1, 0.5);
                            return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                                    equipment.stringTint = Color.lerpColorByLch(0xB200B2, 0xFFFFFF, t);
                                })];
                        case 7:
                            _b.sent();
                            return [3 /*break*/, 6];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        };
        return VoodooPin;
    }(Equipment));
    Equipments.VoodooPin = VoodooPin;
})(Equipments || (Equipments = {}));
var AbilityAura = /** @class */ (function (_super) {
    __extends(AbilityAura, _super);
    function AbilityAura(ballParent, getAbilityRadius, color, alpha) {
        var _this = _super.call(this, {
            copyFromParent: ['layer'],
        }) || this;
        _this.ballParent = ballParent;
        _this.getAbilityRadius = getAbilityRadius;
        _this.color = color;
        _this.alpha = alpha;
        _this.visibleRadius = getAbilityRadius();
        return _this;
    }
    AbilityAura.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.updateVisibleRadius();
    };
    AbilityAura.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateVisibleRadius();
    };
    AbilityAura.prototype.updateVisibleRadius = function () {
        var radiusMoveSpeed = 500;
        if (this.ballParent.isNullified()) {
            this.visibleRadius = M.moveToClamp(this.visibleRadius, 0, radiusMoveSpeed, this.delta);
        }
        else if (this.ballParent.isInYourSquadScene) {
            this.visibleRadius = 0;
        }
        else if (this.ballParent.isInShop && !this.ballParent.isBeingMoved()) {
            this.visibleRadius = 0;
        }
        else {
            this.visibleRadius = M.moveToClamp(this.visibleRadius, this.getAbilityRadius(), radiusMoveSpeed, this.delta);
        }
    };
    AbilityAura.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectBefore(this, this.ballParent);
    };
    AbilityAura.prototype.render = function (texture, x, y) {
        var auraTexture = AssetCache.getTexture('aura');
        var scale = this.visibleRadius / 64;
        auraTexture.renderTo(texture, {
            x: x, y: y,
            tint: this.color,
            alpha: this.alpha,
            scaleX: scale,
            scaleY: scale,
        });
        _super.prototype.render.call(this, texture, x, y);
    };
    return AbilityAura;
}(WorldObject));
var AbilityRadius = /** @class */ (function (_super) {
    __extends(AbilityRadius, _super);
    function AbilityRadius(ballParent, getAbilityRadius, color1, color2, alpha) {
        var _this = _super.call(this, {
            copyFromParent: ['layer'],
        }) || this;
        _this.ballParent = ballParent;
        _this.getAbilityRadius = getAbilityRadius;
        _this.color1 = color1;
        _this.color2 = color2;
        _this.alpha = alpha;
        _this.visibleRadius = getAbilityRadius();
        return _this;
    }
    AbilityRadius.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.updateVisibleRadius();
    };
    AbilityRadius.prototype.update = function () {
        _super.prototype.update.call(this);
        this.updateVisibleRadius();
    };
    AbilityRadius.prototype.updateVisibleRadius = function () {
        var radiusMoveSpeed = 500;
        if (this.ballParent.isNullified()) {
            this.visibleRadius = M.moveToClamp(this.visibleRadius, 0, radiusMoveSpeed, this.delta);
        }
        else if (this.ballParent.isInYourSquadScene) {
            this.visibleRadius = 0;
        }
        else if (this.ballParent.isInShop && !this.ballParent.isBeingMoved()) {
            this.visibleRadius = 0;
        }
        else {
            this.visibleRadius = M.moveToClamp(this.visibleRadius, this.getAbilityRadius(), radiusMoveSpeed, this.delta);
        }
    };
    AbilityRadius.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectBefore(this, this.ballParent);
    };
    AbilityRadius.prototype.render = function (texture, x, y) {
        Draw.brush.color = this.color1 === this.color2 ? this.color1
            : Color.lerpColorByLch(this.color1, this.color2, Tween.Easing.OscillateSine(2)(this.life.time));
        Draw.brush.alpha = this.alpha;
        Draw.brush.thickness = 1;
        Draw.circleOutline(texture, x, y, this.visibleRadius, Draw.ALIGNMENT_INNER);
        _super.prototype.render.call(this, texture, x, y);
    };
    return AbilityRadius;
}(WorldObject));
var AcidPool = /** @class */ (function (_super) {
    __extends(AcidPool, _super);
    function AcidPool(x, y, source, radius, dmg) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: Battle.Layers.onground,
        }) || this;
        _this.source = source;
        _this.radius = radius;
        _this.dmg = dmg;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.dmg; } }, 1, 1));
        var pool = _this;
        _this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(0.5, pool, 'radius', 0, radius)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.tween(15, pool, 'radius', radius, 0)];
                    case 2:
                        _a.sent();
                        pool.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    AcidPool.prototype.update = function () {
        var e_190, _a;
        var _this = this;
        _super.prototype.update.call(this);
        var validEnemies = getEnemies(this.world, this.source)
            .filter(function (enemy) { return G.distance(enemy, _this) <= enemy.physicalRadius + _this.radius; });
        try {
            for (var validEnemies_4 = __values(validEnemies), validEnemies_4_1 = validEnemies_4.next(); !validEnemies_4_1.done; validEnemies_4_1 = validEnemies_4.next()) {
                var enemy = validEnemies_4_1.value;
                enemy.leechFor(this.dmg * this.delta, this.source);
            }
        }
        catch (e_190_1) { e_190 = { error: e_190_1 }; }
        finally {
            try {
                if (validEnemies_4_1 && !validEnemies_4_1.done && (_a = validEnemies_4.return)) _a.call(validEnemies_4);
            }
            finally { if (e_190) throw e_190.error; }
        }
    };
    AcidPool.prototype.render = function (texture, x, y) {
        var team = Ball.getTeamForColorAprilFools(this.source.team);
        var tint1 = team === 'enemy' ? 0x00FF00 : 0x4CFF7C;
        var tint2 = team === 'enemy' ? 0xAAFF00 : 0xAAFF5D;
        Draw.brush.color = Color.lerpColorByLch(tint1, tint2, Tween.Easing.OscillateSine(4)(this.life.time));
        Draw.brush.alpha = 1;
        Draw.circleSolid(texture, x, y, this.radius);
        _super.prototype.render.call(this, texture, x, y);
    };
    return AcidPool;
}(WorldObject));
var BallMoverError = /** @class */ (function (_super) {
    __extends(BallMoverError, _super);
    function BallMoverError(x, y, err, life) {
        if (life === void 0) { life = 0.5; }
        return _super.call(this, {
            x: x, y: y,
            text: err,
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.ui,
            life: life,
        }) || this;
    }
    BallMoverError.prototype.update = function () {
        _super.prototype.update.call(this);
        this.style.color = Color.lerpColorByLch(0xFF0000, 0xFFFFFF, Tween.Easing.OscillateSine(8)(this.life.time));
        this.alpha = M.lerp(1, 0, Tween.Easing.InQuad(this.life.progress));
        this.effects.outline.alpha = M.lerp(1, 0, Tween.Easing.InQuad(this.life.progress));
        this.y -= 6 * this.delta;
    };
    return BallMoverError;
}(SpriteText));
var BoomerMortar = /** @class */ (function (_super) {
    __extends(BoomerMortar, _super);
    function BoomerMortar(x, y, startX, startY, radius, dmg, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return dmg; } }, 6, 5));
        var bm = _this;
        _this.runScript(function () {
            var bullet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bullet = bm.addChildKeepWorldPosition(new Sprite({
                            x: startX, y: startY,
                            texture: 'boomerbullet',
                            layer: Battle.Layers.fg,
                        }));
                        bm.addChild(bm.createRing(radius));
                        return [4 /*yield*/, S.tween(0.25, bullet, 'y', bullet.y, bullet.y - 250)];
                    case 1:
                        _a.sent();
                        bullet.localx = 0;
                        return [4 /*yield*/, S.tween(0.25, bullet, 'localy', -250, 0)];
                    case 2:
                        _a.sent();
                        bm.world.addWorldObject(new Explosion(bm.x, bm.y, radius, { ally: 0, enemy: dmg }, source));
                        bm.world.playSound('shake');
                        bm.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    BoomerMortar.prototype.createRing = function (radius) {
        return new Sprite({
            layer: Battle.Layers.onground,
            render: function (screen, x, y) {
                Draw.brush.color = Color.lerpColorByLch(0xFF0000, 0xFF3333, Tween.Easing.OscillateSine(2)(this.life.time));
                Draw.brush.alpha = 0.6;
                Draw.brush.thickness = 1;
                Draw.circleOutline(screen, x, y, radius, Draw.ALIGNMENT_INNER);
            }
        });
    };
    return BoomerMortar;
}(WorldObject));
var Buff = /** @class */ (function (_super) {
    __extends(Buff, _super);
    function Buff(x, y, initialTarget, buff, initialVelocity) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.buff = buff;
        _this.initialVelocity = initialVelocity ? vec2(initialVelocity) : Ball.Random.onCircle(100);
        _this.addChild(new StatViewer({ type: 'buff', getDmg: function () { return _this.buff.dmg; }, getHp: function () { return _this.buff.hp; } }, 1, 1));
        return _this;
    }
    Buff.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.5, this, this.targetPt, this.initialVelocity));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            _this.target.buff(_this.buff.dmg, _this.buff.hp);
            _this.kill();
        })));
    };
    Buff.prototype.update = function () {
        if (!this.target.world) {
            this.kill();
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    return Buff;
}(Sprite));
var BuffPlus = /** @class */ (function (_super) {
    __extends(BuffPlus, _super);
    function BuffPlus(x, y, sign) {
        return _super.call(this, {
            x: x, y: y,
            texture: "buff" + sign,
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.ui,
            life: 0.5,
        }) || this;
    }
    BuffPlus.prototype.update = function () {
        _super.prototype.update.call(this);
        this.localy -= 8 * this.delta;
        this.alpha = M.lerp(1, 0, Tween.Easing.InExp(this.life.progress));
        this.effects.outline.alpha = this.alpha;
    };
    return BuffPlus;
}(Sprite));
var ButterSystem = /** @class */ (function (_super) {
    __extends(ButterSystem, _super);
    function ButterSystem(parentBall, moveSpeedFactor) {
        var _this = _super.call(this) || this;
        _this.parentBall = parentBall;
        _this.moveSpeedFactor = moveSpeedFactor;
        _this.reset();
        return _this;
    }
    ButterSystem.prototype.addGlob = function (position, radius, attack, sustain, release) {
        this.globs.push({
            position: vec2(position),
            radius: radius,
            attack: attack, sustain: sustain, release: release,
            time: 0,
        });
    };
    ButterSystem.prototype.update = function () {
        var e_191, _a, e_192, _b;
        var _this = this;
        _super.prototype.update.call(this);
        this.globs = this.globs.filter(function (glob) {
            glob.time += _this.delta;
            return glob.time < glob.attack + glob.sustain + glob.release;
        });
        var allies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === _this.parentBall.team && !(ball instanceof Balls.Butterball); });
        try {
            for (var allies_3 = __values(allies), allies_3_1 = allies_3.next(); !allies_3_1.done; allies_3_1 = allies_3.next()) {
                var ally = allies_3_1.value;
                try {
                    for (var _c = (e_192 = void 0, __values(this.globs)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var glob = _d.value;
                        if (G.distance(ally, glob.position) < ally.physicalRadius + glob.radius) {
                            ally.addBoostMaxSpeed(this.parentBall, 'other', this.moveSpeedFactor, this.moveSpeedFactor, 2);
                            ally.addScaleAcceleration(this.parentBall, this.moveSpeedFactor, 2);
                        }
                    }
                }
                catch (e_192_1) { e_192 = { error: e_192_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_192) throw e_192.error; }
                }
            }
        }
        catch (e_191_1) { e_191 = { error: e_191_1 }; }
        finally {
            try {
                if (allies_3_1 && !allies_3_1.done && (_a = allies_3.return)) _a.call(allies_3);
            }
            finally { if (e_191) throw e_191.error; }
        }
        if (this.globs.length === 0 && this.parentBall.world !== this.world) {
            this.kill();
        }
    };
    ButterSystem.prototype.render = function (texture, x, y) {
        var e_193, _a;
        var team = Ball.getTeamForColorAprilFools(this.parentBall ? this.parentBall.team : 'neutral');
        Draw.brush.color = team === 'enemy' ? 0xE4F1AE : 0xFFF1B5;
        Draw.brush.alpha = 1;
        try {
            for (var _b = __values(this.globs), _c = _b.next(); !_c.done; _c = _b.next()) {
                var glob = _c.value;
                var t = 0;
                if (glob.time < glob.attack) {
                    t = M.lerp(0, 1, glob.time / glob.attack);
                }
                else if (glob.time - glob.attack < glob.sustain) {
                    t = 1;
                }
                else {
                    t = M.lerp(1, 0, (glob.time - glob.attack - glob.sustain) / glob.release);
                }
                Draw.circleSolid(texture, x + glob.position.x, y + glob.position.y, t * glob.radius);
            }
        }
        catch (e_193_1) { e_193 = { error: e_193_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_193) throw e_193.error; }
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    ButterSystem.prototype.reset = function () {
        this.globs = [];
    };
    return ButterSystem;
}(Sprite));
var CircleImpact = /** @class */ (function (_super) {
    __extends(CircleImpact, _super);
    function CircleImpact(x, y, radius, damageTo, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: Battle.Layers.onground,
        }) || this;
        _this.color = 0xFFFFFF;
        _this.innerRadius = 0;
        _this.outerRadius = radius;
        _this.damageTo = damageTo;
        _this.radius = radius;
        _this.source = source;
        return _this;
    }
    CircleImpact.prototype.onAdd = function () {
        var e_194, _a;
        var _this = this;
        var _b;
        _super.prototype.onAdd.call(this);
        ((_b = global.theater) !== null && _b !== void 0 ? _b : this.world).runScript(shake(this.world, 1, 0.1));
        var balls = this.world.select.typeAll(Ball);
        try {
            for (var balls_19 = __values(balls), balls_19_1 = balls_19.next(); !balls_19_1.done; balls_19_1 = balls_19.next()) {
                var ball = balls_19_1.value;
                if (G.distance(this, ball) > this.radius + ball.physicalRadius)
                    continue;
                if (ball.team === this.source.team && this.damageTo.ally !== 0)
                    ball.takeDamage(this.damageTo.ally, this.source, 'other');
                if (ball.team !== this.source.team && this.damageTo.enemy !== 0)
                    ball.takeDamage(this.damageTo.enemy, this.source, 'other');
            }
        }
        catch (e_194_1) { e_194 = { error: e_194_1 }; }
        finally {
            try {
                if (balls_19_1 && !balls_19_1.done && (_a = balls_19.return)) _a.call(balls_19);
            }
            finally { if (e_194) throw e_194.error; }
        }
        this.runScript(S.chain(S.tween(0.2, this, 'innerRadius', 0, this.outerRadius, Tween.Easing.OutCubic), S.call(function () { return _this.kill(); })));
    };
    CircleImpact.prototype.render = function (texture, x, y) {
        Draw.brush.color = this.color;
        Draw.brush.alpha = 1;
        Draw.annulusSolid(texture, x, y, this.innerRadius, this.outerRadius);
        _super.prototype.render.call(this, texture, x, y);
    };
    return CircleImpact;
}(WorldObject));
var ClawSlash = /** @class */ (function (_super) {
    __extends(ClawSlash, _super);
    function ClawSlash(target, source, dmg, tracking) {
        var _this = _super.call(this, {
            x: target.x, y: target.y,
            animations: [Animations.fromTextureList({ name: 'slash', textureRoot: 'clawslash', textures: [0, 1, 2, 3, 4, 5, 6, 7], frameRate: 32, count: 1 })],
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
            bounds: new CircleBounds(0, 0, 8),
        }) || this;
        _this.target = target;
        _this.source = source;
        _this.dmg = dmg;
        _this.foundTarget = false;
        _this.tracking = tracking;
        return _this;
    }
    ClawSlash.prototype.onAdd = function () {
        var _this = this;
        _super.prototype.onAdd.call(this);
        if (this.target.world && !this.target.dead) {
            this.target.takeDamage(this.dmg, this.source, 'other');
            this.foundTarget = true;
        }
        this.runScript(S.chain(S.playAnimation(this, 'slash'), S.call(function () { return _this.kill(); })));
        this.world.playSound('spike');
    };
    ClawSlash.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (!this.foundTarget && this.life.frames < 4) {
            var targets = getEnemies(this.world, this.source).filter(function (ball) { return ball.isOverlapping(_this.bounds); });
            var closestTarget = M.argmin(targets, function (ball) { return G.distance(ball, _this); });
            if (closestTarget) {
                this.target = closestTarget;
                this.target.takeDamage(this.dmg, this.source, 'other');
                this.foundTarget = true;
            }
        }
    };
    ClawSlash.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        if (this.tracking) {
            this.x = this.target.x;
            this.y = this.target.y;
        }
    };
    return ClawSlash;
}(Sprite));
var Dio = /** @class */ (function (_super) {
    __extends(Dio, _super);
    function Dio(x, y, ballToRevive, health, damage) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'necromancerbeams',
            layer: Battle.Layers.fx,
            vangle: 180,
            scale: 0,
            tags: [Tags.DELAY_RESOLVE(ballToRevive.team), Tags.FORCE_DELAY_RESOLVE],
        }) || this;
        var dio = _this;
        _this.runScript(function () {
            var sprite, ball;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(0.3, dio, 'scale', 0, 16 / 64, Tween.Easing.OutBounce(1))];
                    case 1:
                        _a.sent();
                        sprite = dio.addChild(new Sprite({
                            texture: 'items/bestfriend',
                            alpha: 0,
                            update: function () {
                                this.offsetX = Random.float(-1, 1);
                            }
                        }));
                        dio.world.playSound('diocharge', { humanized: false });
                        return [4 /*yield*/, S.tween(1, sprite, 'alpha', 0, 0.5, Tween.Easing.OutQuad)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.wait(1.5)];
                    case 3:
                        _a.sent();
                        dio.world.playSound('dioboom', { humanized: false });
                        ball = dio.world.addWorldObject(squadBallToWorldBall({
                            x: dio.x,
                            y: dio.y,
                            properties: {
                                type: ballToRevive.properties.type,
                                damage: damage,
                                health: health,
                                equipment: -1,
                                level: ballToRevive.level,
                                metadata: ballToRevive.properties.metadata,
                            },
                        }, ballToRevive.squad, ballToRevive.squadIndexReference, ballToRevive.team));
                        ball.afterAddImmuneTime = 0.5;
                        ball.timesKilledEnemy = ballToRevive.timesKilledEnemy;
                        ball.world.addWorldObject(new BurstPuffSystem({
                            x: ball.x,
                            y: ball.y,
                            layer: Battle.Layers.fx,
                            puffCount: Math.floor(10 * getParticleLevel()),
                            puffConfigFactory: function () { return ({
                                maxLife: 0.7,
                                v: Random.inCircle(80),
                                color: 0xEC77FF,
                                finalColor: 0x57007F,
                                radius: 4,
                                finalRadius: 0,
                            }); },
                        }));
                        dio.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    return Dio;
}(Sprite));
var Explosion = /** @class */ (function (_super) {
    __extends(Explosion, _super);
    function Explosion(x, y, radius, damageTo, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: new AnchoredTexture(Texture.filledCircle(radius, 0xFFFFFF), 0.5, 0.5),
            layer: Battle.Layers.fx,
        }) || this;
        _this.radius = radius;
        _this.damageTo = damageTo;
        _this.source = source;
        _this.runScript(S.chain(S.wait(0.1), S.call(function () { return _this.tint = 0x000000; }), S.wait(0.1), S.call(function () { return _this.kill(); })));
        return _this;
    }
    Explosion.prototype.onAdd = function () {
        var e_195, _a;
        var _b;
        _super.prototype.onAdd.call(this);
        ((_b = global.theater) !== null && _b !== void 0 ? _b : this.world).runScript(shake(this.world, 1, 0.1));
        var balls = this.world.select.typeAll(Ball);
        try {
            for (var balls_20 = __values(balls), balls_20_1 = balls_20.next(); !balls_20_1.done; balls_20_1 = balls_20.next()) {
                var ball = balls_20_1.value;
                if (G.distance(this, ball) > this.radius + ball.physicalRadius)
                    continue;
                if (this.source && ball.team === this.source.team && this.damageTo.ally !== 0)
                    ball.takeDamage(this.damageTo.ally, this.source, 'other');
                if (this.source && ball.team !== this.source.team && this.damageTo.enemy !== 0)
                    ball.takeDamage(this.damageTo.enemy, this.source, 'other');
            }
        }
        catch (e_195_1) { e_195 = { error: e_195_1 }; }
        finally {
            try {
                if (balls_20_1 && !balls_20_1.done && (_a = balls_20.return)) _a.call(balls_20);
            }
            finally { if (e_195) throw e_195.error; }
        }
    };
    return Explosion;
}(Sprite));
var FireExplosion = /** @class */ (function (_super) {
    __extends(FireExplosion, _super);
    function FireExplosion(x, y, radius, burnTime, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: new AnchoredTexture(Texture.filledCircle(radius, 0xFFFFFF), 0.5, 0.5),
            layer: Battle.Layers.fx,
        }) || this;
        _this.radius = radius;
        _this.burnTime = burnTime;
        _this.source = source;
        _this.runScript(S.chain(S.wait(0.1), S.call(function () { return _this.tint = 0xFF8F00; }), S.wait(0.1), S.call(function () { return _this.kill(); })));
        return _this;
    }
    FireExplosion.prototype.onAdd = function () {
        var e_196, _a;
        var _b;
        _super.prototype.onAdd.call(this);
        ((_b = global.theater) !== null && _b !== void 0 ? _b : this.world).runScript(shake(this.world, 1, 0.1));
        var balls = this.world.select.typeAll(Ball);
        try {
            for (var balls_21 = __values(balls), balls_21_1 = balls_21.next(); !balls_21_1.done; balls_21_1 = balls_21.next()) {
                var ball = balls_21_1.value;
                if (G.distance(this, ball) > this.radius + ball.physicalRadius)
                    continue;
                if (ball.team === this.source.team)
                    continue;
                ball.addBurning(this.source, this.burnTime);
            }
        }
        catch (e_196_1) { e_196 = { error: e_196_1 }; }
        finally {
            try {
                if (balls_21_1 && !balls_21_1.done && (_a = balls_21.return)) _a.call(balls_21);
            }
            finally { if (e_196) throw e_196.error; }
        }
    };
    return FireExplosion;
}(Sprite));
var FreezeIce = /** @class */ (function (_super) {
    __extends(FreezeIce, _super);
    function FreezeIce(radius, immediate) {
        var _this = this;
        var freezeTexture;
        if (radius <= 8)
            freezeTexture = 'freeze8';
        else
            freezeTexture = 'freeze16';
        _this = _super.call(this, {
            texture: freezeTexture,
            alpha: 1,
            angle: Random.int(1, 4) * 90,
            copyFromParent: ['layer'],
        }) || this;
        _this.radius = radius;
        if (!immediate) {
            _this.alpha = 0;
            _this.scale = 0.8;
            _this.runScript(S.simul(S.tween(0.2, _this, 'alpha', 0, 1, Tween.Easing.InQuad), S.tween(0.2, _this, 'scale', 0.8, 1, Tween.Easing.InQuad)));
        }
        return _this;
    }
    FreezeIce.prototype.kill = function () {
        var e_197, _a;
        var _this = this;
        var shattered = lazy("freezeIceShattered/" + this.getTextureKey(), function () { return _this.getTexture().subdivide(2, 2, 'FreezeIce.kill').map(function (sd) {
            sd.texture = new AnchoredTexture(sd.texture, 0.5, 0.5);
            return sd;
        }); });
        try {
            for (var shattered_1 = __values(shattered), shattered_1_1 = shattered_1.next(); !shattered_1_1.done; shattered_1_1 = shattered_1.next()) {
                var shatter = shattered_1_1.value;
                this.world.addWorldObject(new Sprite({
                    x: this.x - this.radius * 1.5 + shatter.x,
                    y: this.y - this.radius * 1.5 + shatter.y,
                    texture: shatter.texture,
                    alpha: this.alpha,
                    layer: this.layer,
                    v: Random.inCircle(150),
                    vangle: 720 * Random.sign(),
                    life: 0.3,
                    update: function () {
                        this.alpha = M.lerp(this.alpha, 0, Tween.Easing.InQuad(this.life.progress));
                    }
                }));
            }
        }
        catch (e_197_1) { e_197 = { error: e_197_1 }; }
        finally {
            try {
                if (shattered_1_1 && !shattered_1_1.done && (_a = shattered_1.return)) _a.call(shattered_1);
            }
            finally { if (e_197) throw e_197.error; }
        }
        _super.prototype.kill.call(this);
    };
    return FreezeIce;
}(Sprite));
var GainedGold = /** @class */ (function (_super) {
    __extends(GainedGold, _super);
    function GainedGold(x, y, gold, dir) {
        var _this = _super.call(this, {
            x: x, y: y,
            text: "[gold]<coin>" + gold + "[/gold]",
            anchor: Vector2.CENTER,
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.ui,
            life: 0.5,
        }) || this;
        _this.dir = dir;
        return _this;
    }
    GainedGold.prototype.update = function () {
        _super.prototype.update.call(this);
        this.localy += 12 * this.delta * (this.dir === 'up' ? -1 : 1);
        this.alpha = M.lerp(1, 0, Tween.Easing.InExp(this.life.progress));
        this.effects.outline.alpha = this.alpha;
    };
    return GainedGold;
}(SpriteText));
var Ghost = /** @class */ (function (_super) {
    __extends(Ghost, _super);
    function Ghost(x, y, source, target, dmg) {
        var _this = this;
        var revealFilter = new RevealFilter(0);
        _this = _super.call(this, {
            x: x, y: y,
            texture: 'ghost',
            layer: Battle.Layers.fx,
            alpha: 0.5,
            effects: { pre: { filters: [revealFilter, new FlipbookFilter(2, 2, 60, 2)] }, outline: {}, post: { filters: [] } },
        }) || this;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return dmg; } }, 1, 1));
        var ghost = _this;
        _this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(0.5, revealFilter, 'amount', 0, 1)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!target.world) return [3 /*break*/, 4];
                        ghost.x = M.lerpTime(ghost.x, target.x, 10, ghost.delta);
                        ghost.y = M.lerpTime(ghost.y, target.y, 10, ghost.delta);
                        if (G.distance(ghost, target) <= 64 && ghost.everyNSeconds(1)) {
                            target.takeDamage(dmg, source, 'other');
                            target.world.playSound('whisper');
                        }
                        return [4 /*yield*/];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 2];
                    case 4: return [4 /*yield*/, S.tween(2, revealFilter, 'amount', 1, 0)];
                    case 5:
                        _a.sent();
                        ghost.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    return Ghost;
}(Sprite));
var HomingBoost = /** @class */ (function (_super) {
    __extends(HomingBoost, _super);
    function HomingBoost(x, y, source, initialTarget, levels, time, reacquireTargetFn) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.levels = levels;
        _this.time = time;
        _this.reacquireTargetFn = reacquireTargetFn;
        return _this;
    }
    HomingBoost.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(this.time, this, this.targetPt, Ball.Random.onCircle(100)));
        var levels = this.levels;
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            for (var i = 0; i < levels; i++) {
                _this.target.levelUp(undefined, i === levels - 1, false);
            }
            _this.kill();
        })));
    };
    HomingBoost.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    HomingBoost.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var allies = getAllies(this.world, this.source);
        return this.reacquireTargetFn(allies);
    };
    return HomingBoost;
}(Sprite));
var HomingGoldVisual = /** @class */ (function (_super) {
    __extends(HomingGoldVisual, _super);
    function HomingGoldVisual(x, y, target, gold, gainDir) {
        if (gainDir === void 0) { gainDir = 'up'; }
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.target = target;
        _this.gold = gold;
        _this.gainDir = gainDir;
        return _this;
    }
    HomingGoldVisual.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.7, this, this.target, Ball.Random.onCircle(150)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (_this.life.time > 0.5 && G.distance(_this, _this.target) < 4); }), S.call(function () {
            if (_this.world) {
                var d = _this.gainDir === 'up' ? -8 : 8;
                _this.world.addWorldObject(new GainedGold(_this.target.x, _this.target.y + d, _this.gold, _this.gainDir));
                _this.world.playSound('buyball');
            }
            _this.kill();
        })));
    };
    return HomingGoldVisual;
}(Sprite));
function animateGiveOrTakeShopGold(world, source, gold) {
    world.runScript(function () {
        var displayedGold, homingGold_1, homingGold_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (gold === 0)
                        return [2 /*return*/];
                    displayedGold = world.select.type(DisplayedGold);
                    if (!displayedGold)
                        return [2 /*return*/];
                    if (!(gold > 0)) return [3 /*break*/, 2];
                    displayedGold.addReservedGold(gold);
                    homingGold_1 = world.addWorldObject(new HomingGoldVisual(source.x, source.y, displayedGold.getPosition().add(4, 0), gold, 'down'));
                    return [4 /*yield*/, S.waitUntil(function () { return !homingGold_1.world; })];
                case 1:
                    _a.sent();
                    displayedGold.removeReservedGold(gold);
                    return [3 /*break*/, 4];
                case 2:
                    homingGold_2 = world.addWorldObject(new HomingGoldVisual(displayedGold.x + 4, displayedGold.y, source, -gold, 'up'));
                    return [4 /*yield*/, S.waitUntil(function () { return !homingGold_2.world; })];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    displayedGold.updateText();
                    return [2 /*return*/];
            }
        });
    });
}
var HomingHeal = /** @class */ (function (_super) {
    __extends(HomingHeal, _super);
    function HomingHeal(x, y, source, initialTarget, healAmount, reacquireTargetFn) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0x00FF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.healAmount = healAmount;
        _this.reacquireTargetFn = reacquireTargetFn;
        _this.addChild(new StatViewer({ type: 'heal', getHealth: function () { return _this.healAmount; } }, 1, 1));
        return _this;
    }
    HomingHeal.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(1, this, this.targetPt, Ball.Random.onCircle(150)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (_this.life.time > 0.5 && G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a, _b;
            (_a = _this.target) === null || _a === void 0 ? void 0 : _a.healFor(_this.healAmount, _this.source);
            (_b = _this.world) === null || _b === void 0 ? void 0 : _b.playSound('medkitheal', { limit: 2 });
            _this.kill();
        })));
    };
    HomingHeal.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    HomingHeal.prototype.acquireTarget = function () {
        var _this = this;
        if (!this.reacquireTargetFn)
            return undefined;
        var enemies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === _this.source.team; });
        return this.reacquireTargetFn(enemies);
    };
    return HomingHeal;
}(Sprite));
var HomingItem = /** @class */ (function (_super) {
    __extends(HomingItem, _super);
    function HomingItem(x, y, target, item) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFFFF,
            alpha: 0.7,
            blendMode: Texture.BlendModes.ADD,
            scale: 20 / 64,
            layer: Battle.Layers.ui,
        }) || this;
        _this.target = target;
        _this.targetPt = _this.target.getPosition();
        _this.item = item;
        _this.addChild(item);
        item.localx = 0;
        item.localy = 0;
        return _this;
    }
    HomingItem.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.7, this, this.targetPt, Ball.Random.onCircle(100)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            if (_this.target && _this.item.canApplyToBall(_this.target)) {
                _this.target.useItem(_this.item);
                _this.world.playSound('buyball');
            }
            else {
                _this.world.playSound('error', { humanized: false });
                _this.world.addWorldObject(new BallMoverError(_this.x, _this.y, 'CANNOT APPLY'));
            }
            _this.kill();
        })));
    };
    HomingItem.prototype.update = function () {
        if (!this.target.world) {
            this.kill();
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    HomingItem.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        World.Actions.orderWorldObjectBefore(this.item, this);
    };
    return HomingItem;
}(Sprite));
var HomingMark = /** @class */ (function (_super) {
    __extends(HomingMark, _super);
    function HomingMark(x, y, source, initialTarget, reacquireTargetFn) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'equipments/huntersmark',
            layer: Battle.Layers.fx,
        }) || this;
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.reacquireTargetFn = reacquireTargetFn;
        return _this;
    }
    HomingMark.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('swoosh');
        var sendScript = this.runScript(sendTo(1, this, this.targetPt, Ball.Random.onCircle(150)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (_this.life.time > 0.5 && G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            _this.target.addMarked(Infinity);
            _this.kill();
        })));
    };
    HomingMark.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
        this.angle = M.atan2(this.y - this.lasty, this.x - this.lastx) + 90;
    };
    HomingMark.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var enemies = getEnemies(this.world, this.source);
        return this.reacquireTargetFn(enemies);
    };
    return HomingMark;
}(Sprite));
var HomingSap = /** @class */ (function (_super) {
    __extends(HomingSap, _super);
    function HomingSap(x, y, team, initialTarget) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'sap',
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
        }) || this;
        _this.team = team;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        return _this;
    }
    HomingSap.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('spike', { limit: 2 });
        var sendScript = this.runScript(sendTo(1, this, this.targetPt, Ball.Random.onCircle(150)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (_this.life.time > 0.5 && G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a, _b, _c;
            (_a = _this.target) === null || _a === void 0 ? void 0 : _a.breakEquipment();
            (_c = ((_b = global.theater) !== null && _b !== void 0 ? _b : _this.world)) === null || _c === void 0 ? void 0 : _c.runScript(shake(_this.world, 1, 0.1));
            _this.kill();
        })));
    };
    HomingSap.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
        this.angle = M.atan2(this.y - this.lasty, this.x - this.lastx) + 90;
    };
    HomingSap.prototype.acquireTarget = function () {
        var _this = this;
        var enemies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team !== _this.team && ball.equipment; });
        return Ball.Random.element(enemies);
    };
    return HomingSap;
}(Sprite));
var Projectile = /** @class */ (function (_super) {
    __extends(Projectile, _super);
    function Projectile(source, config) {
        var _this = _super.call(this, config) || this;
        _this.source = source;
        return _this;
    }
    return Projectile;
}(Sprite));
/// <reference path="./projectile.ts" />
var HomingSpike = /** @class */ (function (_super) {
    __extends(HomingSpike, _super);
    function HomingSpike(x, y, source, initialTarget, dmg, hitCount, reacquireTargetFn) {
        var _this = _super.call(this, source, {
            x: x, y: y,
            texture: 'spike',
            tint: Ball.getTeamColor(source.team),
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
            bounds: new CircleBounds(0, 0, 5),
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.dmg = dmg;
        _this.hitCount = hitCount;
        _this.reacquireTargetFn = reacquireTargetFn;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.dmg; } }, 4, 3));
        return _this;
    }
    HomingSpike.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('spike', { limit: 2 });
        var sendScript = this.runScript(sendTo(1, this, this.targetPt, Ball.Random.onCircle(150)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (_this.life.time > 0.5 && G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a, _b, _c;
            for (var i = 0; i < _this.hitCount; i++) {
                (_a = _this.target) === null || _a === void 0 ? void 0 : _a.takeDamage(_this.dmg, _this.source, 'other');
            }
            _this.world.addWorldObject(new Explosion(_this.x, _this.y, 6, { ally: 0, enemy: 0 }));
            (_c = ((_b = global.theater) !== null && _b !== void 0 ? _b : _this.world)) === null || _c === void 0 ? void 0 : _c.runScript(shake(_this.world, 1, 0.1));
            _this.kill();
        })));
    };
    HomingSpike.prototype.update = function () {
        var _a;
        var markedEnemies = getEnemies(this.world, this.source).filter(function (enemy) { return enemy.isMarked(); });
        if (markedEnemies.length > 0 && !((_a = this.target) === null || _a === void 0 ? void 0 : _a.isMarked())) {
            this.target = Ball.Random.element(markedEnemies);
        }
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
        this.angle = M.atan2(this.y - this.lasty, this.x - this.lastx) + 90;
    };
    HomingSpike.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var enemies = getEnemies(this.world, this.source);
        return this.reacquireTargetFn(enemies);
    };
    return HomingSpike;
}(Projectile));
var HomingSpore = /** @class */ (function (_super) {
    __extends(HomingSpore, _super);
    function HomingSpore(x, y, source, target) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0x00FF21,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.source = source;
        _this.target = target;
        _this.targetPt = _this.target.getPosition();
        return _this;
    }
    HomingSpore.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('spike', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.7, this, this.targetPt, Ball.Random.onCircle(100)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a, _b;
            (_a = _this.target) === null || _a === void 0 ? void 0 : _a.equip(14);
            (_b = _this.world) === null || _b === void 0 ? void 0 : _b.playSound('steal', { limit: 2 });
            _this.kill();
        })));
    };
    HomingSpore.prototype.update = function () {
        if (!this.target.world) {
            this.kill();
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    return HomingSpore;
}(Sprite));
var InstantKillSlash = /** @class */ (function (_super) {
    __extends(InstantKillSlash, _super);
    function InstantKillSlash(target, source) {
        var _this = _super.call(this, {
            x: target.x, y: target.y,
            animations: [Animations.fromTextureList({ name: 'slash', textureRoot: 'clawslash', textures: [0, 1, 2, 3, 4, 5, 6, 7], frameRate: 32, count: 1 })],
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
        }) || this;
        _this.target = target;
        _this.source = source;
        return _this;
    }
    InstantKillSlash.prototype.onAdd = function () {
        var _this = this;
        _super.prototype.onAdd.call(this);
        this.target.takeDamage(2 * this.target.hp, this.source, 'other', true);
        this.runScript(S.chain(S.playAnimation(this, 'slash'), S.call(function () { return _this.kill(); })));
        this.world.playSound('spike');
    };
    return InstantKillSlash;
}(Sprite));
var LandMine = /** @class */ (function (_super) {
    __extends(LandMine, _super);
    function LandMine(x, y, v, source, damage) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'landmine',
            animations: [
                Animations.fromTextureList({ name: 'blink', textureRoot: 'landmine', textures: [0, 1], frameRate: 8, count: Infinity }),
            ],
            effects: { post: { filters: [new BallTeamColorFilter(Ball.getTeamColor(source.team))] } },
            layer: Battle.Layers.onground,
            v: v,
            physicsGroup: Battle.PhysicsGroups.droppables,
            bounds: new CircleBounds(0, 0, 12),
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.source = source;
        _this.damage = damage;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.damage; } }, 5, 4));
        var mine = _this;
        _this.stateMachine.addState('idle', {
            script: S.wait(0.5),
            transitions: [{ toState: 'detonate', condition: function () { return _this.isColliding(); } }],
        });
        _this.stateMachine.addState('detonate', {
            callback: function () {
                _this.addTag(Tags.DELAY_RESOLVE(source.team));
            },
            script: function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            mine.world.playSound('beepbeep', { humanized: false });
                            return [4 /*yield*/, S.wait(0.125)];
                        case 1:
                            _a.sent();
                            mine.explode();
                            return [2 /*return*/];
                    }
                });
            },
            update: function () {
                mine.effects.silhouette.enabled = true;
                mine.effects.silhouette.color = 0xFFFFFF;
                mine.effects.silhouette.amount = mine.oscillateNSeconds(0.08) ? 1 : 0;
            }
        });
        _this.setState('idle');
        _this.addTimer(1, function () {
            if (_this.state !== 'detonate')
                _this.removeTag(Tags.DELAY_RESOLVE(source.team));
        });
        return _this;
    }
    LandMine.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.world.playSound('medkitout');
    };
    LandMine.prototype.update = function () {
        PhysicsUtils.applyFriction(this.v, 100, 100, this.delta);
        this.setSpeed(M.clamp(this.getSpeed(), 0, 100));
        _super.prototype.update.call(this);
    };
    LandMine.prototype.explode = function () {
        this.world.addWorldObject(new Explosion(this.x, this.y, 20, { ally: 0, enemy: this.damage }, this.source));
        this.world.playSound('shake');
        this.kill();
    };
    LandMine.prototype.isColliding = function () {
        var _this = this;
        var collisions = this.world.select.overlap(this.bounds, [Battle.PhysicsGroups.balls]);
        var validBalls = collisions.filter(function (ball) { return ball instanceof Ball && ball.team !== _this.source.team; });
        return validBalls.length > 0;
    };
    return LandMine;
}(Sprite));
var MedkitDmg = /** @class */ (function (_super) {
    __extends(MedkitDmg, _super);
    function MedkitDmg(x, y, v, source, damage) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'medkitdmg',
            effects: { post: { filters: [new BallTeamColorFilter(Ball.getTeamColor(source.team))] } },
            layer: Battle.Layers.onground,
            v: v,
            physicsGroup: Battle.PhysicsGroups.droppables,
            bounds: new CircleBounds(0, 0, 5),
        }) || this;
        _this.source = source;
        _this.damage = damage;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.damage; } }, 5, 4));
        return _this;
    }
    MedkitDmg.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.world.playSound('spike');
    };
    MedkitDmg.prototype.update = function () {
        this.updatePull();
        PhysicsUtils.applyFriction(this.v, 100, 100, this.delta);
        this.setSpeed(M.clamp(this.getSpeed(), 0, 100));
        _super.prototype.update.call(this);
        this.updateCollisions();
    };
    MedkitDmg.prototype.updatePull = function () {
        var e_198, _a;
        var _this = this;
        var friendBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === _this.source.team && ball !== _this.source; });
        try {
            for (var friendBalls_1 = __values(friendBalls), friendBalls_1_1 = friendBalls_1.next(); !friendBalls_1_1.done; friendBalls_1_1 = friendBalls_1.next()) {
                var ball = friendBalls_1_1.value;
                if (G.distance(this, ball) > ball.physicalRadius + 12)
                    continue;
                this.v.add(ball.getPosition().subtract(this).setMagnitude(100));
            }
        }
        catch (e_198_1) { e_198 = { error: e_198_1 }; }
        finally {
            try {
                if (friendBalls_1_1 && !friendBalls_1_1.done && (_a = friendBalls_1.return)) _a.call(friendBalls_1);
            }
            finally { if (e_198) throw e_198.error; }
        }
    };
    MedkitDmg.prototype.updateCollisions = function () {
        var _this = this;
        var collisions = this.world.select.overlap(this.bounds, [Battle.PhysicsGroups.balls]);
        var validBalls = collisions.filter(function (ball) { return ball instanceof Ball && ball.team === _this.source.team && ball !== _this.source; });
        if (validBalls.length === 0)
            return;
        var ball = validBalls[0];
        ball.buff(this.damage, 0);
        this.kill();
    };
    MedkitDmg.prototype.kill = function () {
        this.world.playSound('medkitgrab');
        this.world.playSound('buff');
        this.world.addWorldObject(newPuff(this.x, this.y, Battle.Layers.fx, 'small'));
        _super.prototype.kill.call(this);
    };
    return MedkitDmg;
}(Sprite));
var Medpack = /** @class */ (function (_super) {
    __extends(Medpack, _super);
    function Medpack(x, y, v, source, health) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'medkit',
            effects: { post: { filters: [new BallTeamColorFilter(Ball.getTeamColor(source.team))] } },
            layer: Battle.Layers.onground,
            v: v,
            physicsGroup: Battle.PhysicsGroups.droppables,
            bounds: new CircleBounds(0, 0, 5),
        }) || this;
        _this.source = source;
        _this.health = health;
        _this.addChild(new StatViewer({ type: 'heal', getHealth: function () { return _this.health; } }, 5, 4));
        return _this;
    }
    Medpack.prototype.onAdd = function () {
        _super.prototype.onAdd.call(this);
        this.world.playSound('medkitout');
    };
    Medpack.prototype.update = function () {
        this.updatePull();
        PhysicsUtils.applyFriction(this.v, 100, 100, this.delta);
        this.setSpeed(M.clamp(this.getSpeed(), 0, 100));
        _super.prototype.update.call(this);
        this.updateCollisions();
    };
    Medpack.prototype.updatePull = function () {
        var e_199, _a;
        var _this = this;
        var friendBalls = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team === _this.source.team && ball.hp < ball.maxhp && !(ball instanceof Balls.Medic); });
        try {
            for (var friendBalls_2 = __values(friendBalls), friendBalls_2_1 = friendBalls_2.next(); !friendBalls_2_1.done; friendBalls_2_1 = friendBalls_2.next()) {
                var ball = friendBalls_2_1.value;
                if (G.distance(this, ball) > ball.physicalRadius + 12)
                    continue;
                this.v.add(ball.getPosition().subtract(this).setMagnitude(100));
            }
        }
        catch (e_199_1) { e_199 = { error: e_199_1 }; }
        finally {
            try {
                if (friendBalls_2_1 && !friendBalls_2_1.done && (_a = friendBalls_2.return)) _a.call(friendBalls_2);
            }
            finally { if (e_199) throw e_199.error; }
        }
    };
    Medpack.prototype.updateCollisions = function () {
        var _this = this;
        var collisions = this.world.select.overlap(this.bounds, [Battle.PhysicsGroups.balls]);
        var validBalls = collisions.filter(function (ball) { return ball instanceof Ball && ball.team === _this.source.team && ball.hp < ball.maxhp && !(ball instanceof Balls.Medic); });
        if (validBalls.length === 0)
            return;
        var ball = validBalls[0];
        ball.healFor(this.health, this.source);
        this.world.playSound('medkitgrab');
        this.world.playSound('medkitheal');
        this.kill();
    };
    Medpack.prototype.kill = function () {
        this.world.addWorldObject(newPuff(this.x, this.y, Battle.Layers.fx, 'small'));
        _super.prototype.kill.call(this);
    };
    return Medpack;
}(Sprite));
var PhoenixAshes = /** @class */ (function (_super) {
    __extends(PhoenixAshes, _super);
    function PhoenixAshes(x, y, ballToRevive, health, damage) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'phoenixashes',
            tint: 0x603333,
            layer: Battle.Layers.onground,
            tags: [Tags.DELAY_RESOLVE(ballToRevive.team), Tags.FORCE_DELAY_RESOLVE],
        }) || this;
        var ashes = _this;
        _this.runScript(function () {
            var ball;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, S.wait(3)];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/, S.doOverTime(1.5, function (t) {
                                ashes.tint = Color.lerpColorByLch(0x603333, 0xFFFF00, t);
                                ashes.offsetX = ashes.oscillateNSeconds(0.5 * (1 - t * t)) ? 1 : 0;
                                if (ashes.everyNSeconds(0.08)) {
                                    ashes.world.playSound('shaker', { humanized: false }).volume = t * t;
                                }
                            })];
                    case 2:
                        _b.sent();
                        return [4 /*yield*/, S.doOverTime(0.5, function (t) {
                                ashes.offsetX = ashes.oscillateNSeconds(0.03) ? 1 : 0;
                                if (ashes.everyNSeconds(0.08)) {
                                    ashes.world.playSound('shaker', { humanized: false });
                                }
                            })];
                    case 3:
                        _b.sent();
                        ashes.world.playSound('cloak', { humanized: false });
                        ball = ashes.world.addWorldObject(squadBallToWorldBall({
                            x: ashes.x,
                            y: ashes.y,
                            properties: {
                                type: ballToRevive.properties.type,
                                damage: damage,
                                health: health,
                                equipment: ballToRevive.equipment ? ballToRevive.equipment.equipmentType : -1,
                                level: ballToRevive.level,
                                metadata: ballToRevive.properties.metadata,
                            },
                        }, undefined, -1, ballToRevive.team));
                        ball.afterAddImmuneTime = 0.5;
                        ball.timesKilledEnemy = ballToRevive.timesKilledEnemy;
                        if (ball instanceof Balls.Phoenix) {
                            ball.canExplode = false;
                            ball.isResurrection = true;
                            if (!ballToRevive.isResurrection && ball.shouldActivateAbilityTwice()) {
                                ball.canExplode = true;
                            }
                            if (ballToRevive.isResurrection && ((_a = ball.equipment) === null || _a === void 0 ? void 0 : _a.equipmentType) === 34) {
                                ball.unequip(); // Lose the Green Cube after use
                            }
                        }
                        ball.world.addWorldObject(new BurstPuffSystem({
                            x: ball.x,
                            y: ball.y,
                            layer: Battle.Layers.fx,
                            puffCount: Math.floor(10 * getParticleLevel()),
                            puffConfigFactory: function () { return ({
                                maxLife: 0.7,
                                v: Random.inCircle(80),
                                color: 0xFF8F00,
                                finalColor: 0xFFFF00,
                                radius: 4,
                                finalRadius: 0,
                            }); },
                        }));
                        ashes.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    return PhoenixAshes;
}(Sprite));
var RandomBuff = /** @class */ (function (_super) {
    __extends(RandomBuff, _super);
    function RandomBuff(x, y, source, initialTarget, buff, reacquireTargetFn) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.buff = buff;
        _this.reacquireTargetFn = reacquireTargetFn;
        _this.addChild(new StatViewer({ type: 'buff', getDmg: function () { return _this.buff.dmg; }, getHp: function () { return _this.buff.hp; } }, 1, 1));
        return _this;
    }
    RandomBuff.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.7, this, this.targetPt, Ball.Random.onCircle(100)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            _this.target.buff(_this.buff.dmg, _this.buff.hp);
            _this.kill();
        })));
    };
    RandomBuff.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    RandomBuff.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var allies = getAllies(this.world, this.source);
        return this.reacquireTargetFn(allies);
    };
    return RandomBuff;
}(Sprite));
var RandomDeboost = /** @class */ (function (_super) {
    __extends(RandomDeboost, _super);
    function RandomDeboost(x, y, source, initialTarget, time, reacquireTargetFn) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFF0000,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.time = time;
        _this.reacquireTargetFn = reacquireTargetFn;
        return _this;
    }
    RandomDeboost.prototype.onAdd = function () {
        var _this = this;
        this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(this.time, this, this.targetPt, Ball.Random.onCircle(100)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a, _b;
            _this.target.levelDown();
            _this.target.addChild(new Sprite({
                texture: 'reduce',
                copyFromParent: ['layer'],
                offsetY: -4,
                life: 1,
                update: function () {
                    this.offsetY = M.lerp(-4, 4, this.life.progress);
                    this.alpha = M.jumpParabola(0, 1, 0, this.life.progress);
                    World.Actions.orderWorldObjectAfter(this, this.parent);
                },
            }));
            _this.kill();
            (_a = _this.world) === null || _a === void 0 ? void 0 : _a.playSound('shake2', { humanized: false, limit: 3, volume: 0.4 });
            (_b = _this.world) === null || _b === void 0 ? void 0 : _b.playSound('reduce', { humanized: false, limit: 3 });
        })));
    };
    RandomDeboost.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    RandomDeboost.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var enemies = getEnemies(this.world, this.source);
        return this.reacquireTargetFn(enemies);
    };
    return RandomDeboost;
}(Sprite));
var RandomEquipment = /** @class */ (function (_super) {
    __extends(RandomEquipment, _super);
    function RandomEquipment(x, y, source, initialTarget, equipmentType, playSound, reacquireTargetFn, onFail) {
        var _this = _super.call(this, {
            x: x, y: y,
            texture: 'aura',
            tint: 0xFFFF00,
            blendMode: Texture.BlendModes.ADD,
            scale: 0.1,
            layer: Battle.Layers.ui,
        }) || this;
        _this.addChild(new Sprite({
            texture: TYPE_TO_EQUIPMENT_TYPE_DEF[equipmentType].factory().getEquipmentTexture(),
            copyFromParent: ['layer'],
            update: function () {
                if (this.parent)
                    World.Actions.orderWorldObjectBefore(this, this.parent);
            }
        }));
        _this.source = source;
        _this.target = initialTarget;
        _this.targetPt = _this.target.getPosition();
        _this.equipmentType = equipmentType;
        _this.playSound = playSound;
        _this.reacquireTargetFn = reacquireTargetFn;
        _this.onFail = onFail;
        return _this;
    }
    RandomEquipment.prototype.onAdd = function () {
        var _this = this;
        if (this.playSound)
            this.world.playSound('sellball', { limit: 2 });
        var sendScript = this.runScript(sendTo(0.7, this, this.targetPt, Ball.Random.onCircle(100)));
        this.runScript(S.chain(S.waitUntil(function () { return sendScript.done || (G.distance(_this, _this.target) < _this.target.radius); }), S.call(function () {
            var _a;
            _this.target.equip(_this.equipmentType);
            if (_this.life.time > 0.2)
                (_a = _this.world) === null || _a === void 0 ? void 0 : _a.playSound('buyball', { limit: 2 });
            _this.kill();
        })));
    };
    RandomEquipment.prototype.update = function () {
        if (!this.target.world) {
            var newTarget = this.acquireTarget();
            if (newTarget) {
                this.target = newTarget;
            }
            else {
                this.onFail();
                this.kill();
            }
        }
        this.targetPt.x = this.target.x;
        this.targetPt.y = this.target.y;
        _super.prototype.update.call(this);
    };
    RandomEquipment.prototype.acquireTarget = function () {
        if (!this.reacquireTargetFn)
            return undefined;
        var allies = getAllies(this.world, this.source);
        return this.reacquireTargetFn(allies);
    };
    return RandomEquipment;
}(Sprite));
/// <reference path="./projectile.ts" />
var ScrapBullet = /** @class */ (function (_super) {
    __extends(ScrapBullet, _super);
    function ScrapBullet(x, y, v, source, dmg) {
        var _this = _super.call(this, source, {
            x: x, y: y,
            texture: 'scrapbullet',
            layer: Battle.Layers.fx,
            v: v,
            vangle: Random.sign() * 360,
            bounds: new CircleBounds(0, 0, 4),
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.dmg = dmg;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.dmg; } }, 6, 5));
        return _this;
    }
    ScrapBullet.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        var collisions = this.world.select.overlap(this.bounds, [Battle.PhysicsGroups.balls, Battle.PhysicsGroups.walls]);
        var ball = collisions.find(function (c) { return c instanceof Ball && c.team !== _this.source.team; });
        var wall = collisions.find(function (c) { return c.physicsGroup === Battle.PhysicsGroups.walls; });
        if (ball) {
            ball.takeDamage(this.dmg, this.source, 'other');
            this.kill();
        }
        else if (wall) {
            this.world.playSound('hitwall');
            this.kill();
        }
    };
    ScrapBullet.prototype.kill = function () {
        this.world.addWorldObject(newPuff(this.x, this.y, Battle.Layers.fx, 'small'));
        _super.prototype.kill.call(this);
    };
    return ScrapBullet;
}(Projectile));
function sendTo(time, obj, point, startVelocity) {
    return S.doOverTime(time, function (t) {
        var timescale = global.world ? global.world.timeScale : 1;
        var dx = M.lerp(startVelocity.x * global.script.delta, point.x - obj.x, Tween.Easing.InExp(t));
        var dy = M.lerp(startVelocity.y * global.script.delta, point.y - obj.y, Tween.Easing.InExp(t));
        obj.x += dx * timescale;
        obj.y += dy * timescale;
    });
}
/// <reference path="./projectile.ts" />
var Spike = /** @class */ (function (_super) {
    __extends(Spike, _super);
    function Spike(x, y, v, source, dmg, hitCount) {
        var _this = _super.call(this, source, {
            x: x, y: y,
            texture: 'spike',
            tint: Ball.getTeamColor(source.team),
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
            v: v,
            angle: v.angle + 90,
            life: 5,
            bounds: new CircleBounds(0, 0, 5),
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.dmg = dmg;
        _this.hitCount = hitCount;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.dmg; } }, 4, 3));
        return _this;
    }
    Spike.prototype.update = function () {
        var _this = this;
        var _a, _b;
        _super.prototype.update.call(this);
        var markedEnemies = getEnemies(this.world, this.source).filter(function (enemy) { return enemy.isMarked(); });
        if (markedEnemies.length > 0) {
            var targetFn_1 = function (enemies) { return Ball.Random.element(enemies.filter(function (enemy) { return enemy.isMarked(); })); };
            this.world.addWorldObject(new HomingSpike(this.x, this.y, this.source, targetFn_1(markedEnemies), this.dmg, this.hitCount, function (enemies) { return targetFn_1(enemies); }));
            this.kill();
            return;
        }
        var balls = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team !== _this.source.team && ball.bounds.containsPoint(_this); });
        var walls = this.world.physicsGroups[Battle.PhysicsGroups.walls].worldObjects.filter(function (obj) { return obj.bounds.containsPoint(_this); });
        if (balls.length > 0 && this.life.time > 0.1) {
            for (var i = 0; i < this.hitCount; i++) {
                balls[0].takeDamage(this.dmg, this.source, 'other');
            }
            this.world.addWorldObject(new Explosion(this.x, this.y, 6, { ally: 0, enemy: 0 }));
            ((_a = global.theater) !== null && _a !== void 0 ? _a : this.world).runScript(shake(this.world, 1, 0.1));
            this.kill();
        }
        else if (walls.length > 0) {
            (_b = this.world) === null || _b === void 0 ? void 0 : _b.playSound('hitwall', { limit: 5 });
            this.world.addWorldObject(new Explosion(this.x, this.y, 6, { ally: 0, enemy: 0 }));
            this.kill();
        }
    };
    return Spike;
}(Projectile));
var StatViewer = /** @class */ (function (_super) {
    __extends(StatViewer, _super);
    function StatViewer(statType, ox, oy) {
        var _this = _super.call(this, {
            x: ox, y: oy,
            text: StatViewer.getText(statType),
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            effects: { outline: {} },
            copyFromParent: ['layer'],
        }) || this;
        _this.statType = statType;
        return _this;
    }
    StatViewer.prototype.postUpdate = function () {
        var _a, _b;
        _super.prototype.postUpdate.call(this);
        var battleSpeedController = (_b = (_a = global.theater) === null || _a === void 0 ? void 0 : _a.select) === null || _b === void 0 ? void 0 : _b.type(BattleSpeedController, false);
        if (battleSpeedController && (battleSpeedController.paused || battleSpeedController.endOfGame)) {
            this.setVisible(true);
            this.setText(StatViewer.getText(this.statType));
            World.Actions.moveWorldObjectToFront(this);
        }
        else {
            this.setVisible(false);
        }
    };
    return StatViewer;
}(SpriteText));
(function (StatViewer) {
    function getText(statType) {
        if (statType.type === 'damage')
            return "[r]" + getNumberText(statType.getDamage()) + "[/r]";
        if (statType.type === 'heal')
            return "[g]" + getNumberText(statType.getHealth()) + "[/g]";
        if (statType.type === 'buff') {
            var dmg = statType.getDmg();
            var hp = statType.getHp();
            if (dmg === 0 && hp === 0)
                return '';
            if (dmg === 0)
                return "[g]" + getNumberText(statType.getHp()) + "[/g]";
            if (hp === 0)
                return "[r]" + getNumberText(statType.getDmg()) + "[/r]";
            return "[r]" + getNumberText(statType.getDmg()) + "[/r] [offsetx -1][g]" + getNumberText(statType.getHp()) + "[/g][/]";
        }
        return '';
    }
    StatViewer.getText = getText;
    function getNumberText(num) {
        var text = Math.round(num) === num ? "" + num : "" + num.toFixed(1);
        var parts = text.split('.');
        if (parts.length === 2) {
            text = "[offsetx 1]" + parts[0] + "[/].[offsetx -1]" + parts[1] + "[/]";
        }
        return text;
    }
})(StatViewer || (StatViewer = {}));
var Stop = /** @class */ (function (_super) {
    __extends(Stop, _super);
    function Stop(x, y, radius, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: Battle.Layers.onground,
        }) || this;
        _this.alpha = 0.7;
        _this.radius = radius;
        _this.source = source;
        var stop = _this;
        _this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(0.5, stop, 'alpha', 0.7, 0)];
                    case 1:
                        _a.sent();
                        stop.kill();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    Stop.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        this.x = this.source.x;
        this.y = this.source.y;
    };
    Stop.prototype.render = function (texture, x, y) {
        Draw.brush.color = 0xFF0000;
        Draw.brush.alpha = this.alpha;
        Draw.brush.thickness = 1;
        var vertices = G.generatePolygonVertices(x, y, this.radius, 8);
        Draw.polygonSolid(texture, vertices);
        _super.prototype.render.call(this, texture, x, y);
    };
    return Stop;
}(WorldObject));
/// <reference path="./projectile.ts" />
var TurretBullet = /** @class */ (function (_super) {
    __extends(TurretBullet, _super);
    function TurretBullet(x, y, v, source, dmg, hitCount) {
        var _this = _super.call(this, source, {
            x: x, y: y,
            texture: Texture.filledCircle(2, 0x888888),
            effects: { outline: { color: 0x000000 } },
            layer: Battle.Layers.fx,
            v: v,
            bounds: new CircleBounds(0, 0, 3),
            tags: [Tags.DELAY_RESOLVE(source.team)],
        }) || this;
        _this.dmg = dmg;
        _this.hitCount = hitCount;
        _this.addChild(new StatViewer({ type: 'damage', getDamage: function () { return _this.dmg; } }, 6, 5));
        return _this;
    }
    TurretBullet.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        var physicsGroups = [Battle.PhysicsGroups.balls, Battle.PhysicsGroups.walls];
        var collisions = this.world.select.overlap(this.bounds, physicsGroups);
        var raycastCollisions = this.world.select.raycast(this.lastx, this.lasty, this.x - this.lastx, this.y - this.lasty, physicsGroups).filter(function (r) { return 0 <= r.t && r.t <= 1; }).map(function (r) { return r.obj; });
        collisions.push.apply(collisions, __spread(raycastCollisions));
        A.removeDuplicates(collisions);
        var ball = collisions.find(function (c) { return c instanceof Ball && c.team !== _this.source.team && c.alive && !c.dead; });
        var wall = collisions.find(function (c) { return c.physicsGroup === Battle.PhysicsGroups.walls; });
        if (ball) {
            for (var i = 0; i < this.hitCount; i++) {
                ball.takeDamage(this.dmg, this.source, 'other');
            }
            this.kill();
        }
        else if (wall) {
            this.world.playSound('hitwall');
            this.kill();
        }
    };
    TurretBullet.prototype.kill = function () {
        this.world.addWorldObject(newPuff(this.x, this.y, Battle.Layers.fx, 'small'));
        _super.prototype.kill.call(this);
    };
    return TurretBullet;
}(Projectile));
var VampRing = /** @class */ (function (_super) {
    __extends(VampRing, _super);
    function VampRing(x, y) {
        return _super.call(this, {
            x: x, y: y,
            animations: [Animations.fromTextureList({ name: 'default', textureRoot: 'vampring', textures: [0, 1], frameRate: 12, count: Infinity })],
            defaultAnimation: 'default',
            tint: 0xDD0000,
        }) || this;
    }
    return VampRing;
}(Sprite));
var Voodoo = /** @class */ (function (_super) {
    __extends(Voodoo, _super);
    function Voodoo(host) {
        var _this = _super.call(this, {
            x: host.x, y: host.y,
            texture: 'voodoo',
            layer: Battle.Layers.fg,
            tint: 0x000000,
            alpha: 0,
        }) || this;
        _this.host = host;
        return _this;
    }
    Voodoo.prototype.onAdd = function () {
        var _this = this;
        _super.prototype.onAdd.call(this);
        this.addTimer(0.01, function () { return _this.offsetX = Random.int(-1, 0); }, Infinity);
        var voodoo = this;
        this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.wait(0.05)];
                    case 1:
                        _a.sent();
                        voodoo.tint = 0xB200B2;
                        return [2 /*return*/];
                }
            });
        });
        this.runScript(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, S.tween(0.3, voodoo, 'alpha', 0, 1)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, S.tween(0.1, voodoo, 'alpha', 1, 0.8)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, S.wait(0.1)];
                    case 3:
                        _a.sent();
                        voodoo.world.addWorldObject(new BurstPuffSystem({
                            x: voodoo.x,
                            y: voodoo.y,
                            layer: Battle.Layers.fx,
                            puffCount: Math.floor(12 * getParticleLevel()),
                            puffConfigFactory: function () { return ({
                                maxLife: 0.6,
                                v: Random.inCircle(70),
                                color: 0xB200B2,
                                radius: 4,
                                finalRadius: 0,
                            }); },
                        }));
                        voodoo.kill();
                        return [2 /*return*/];
                }
            });
        });
    };
    Voodoo.prototype.postUpdate = function () {
        _super.prototype.postUpdate.call(this);
        this.x = this.host.x;
        this.y = this.host.y;
    };
    return Voodoo;
}(Sprite));
var WatermelonSplash = /** @class */ (function (_super) {
    __extends(WatermelonSplash, _super);
    function WatermelonSplash(x, y, radius, damage, damageTo, source) {
        var _this = _super.call(this, {
            x: x, y: y,
            layer: Battle.Layers.onground,
        }) || this;
        _this.innerRadius = 0;
        _this.outerRadius = radius;
        _this.damageTo = damageTo;
        _this.radius = radius;
        _this.damage = damage;
        _this.source = source;
        return _this;
    }
    WatermelonSplash.prototype.onAdd = function () {
        var e_200, _a;
        var _this = this;
        var _b;
        _super.prototype.onAdd.call(this);
        ((_b = global.theater) !== null && _b !== void 0 ? _b : this.world).runScript(shake(this.world, 1, 0.1));
        try {
            for (var _c = __values(this.damageTo), _d = _c.next(); !_d.done; _d = _c.next()) {
                var ball = _d.value;
                if (G.distance(this, ball) > this.radius + ball.physicalRadius)
                    continue;
                ball.takeDamage(this.damage, this.source, 'other');
            }
        }
        catch (e_200_1) { e_200 = { error: e_200_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_200) throw e_200.error; }
        }
        this.runScript(S.chain(S.tween(0.2, this, 'innerRadius', 0, this.outerRadius, Tween.Easing.OutCubic), S.call(function () { return _this.kill(); })));
    };
    WatermelonSplash.prototype.render = function (texture, x, y) {
        Draw.brush.color = 0xFF0044;
        Draw.brush.alpha = 1;
        Draw.annulusSolid(texture, x, y, this.innerRadius, this.outerRadius);
        _super.prototype.render.call(this, texture, x, y);
    };
    return WatermelonSplash;
}(WorldObject));
var YarnSystem = /** @class */ (function (_super) {
    __extends(YarnSystem, _super);
    function YarnSystem(parentBall, startPoint, slowFactor) {
        var _this = _super.call(this) || this;
        _this.parentBall = parentBall;
        _this.slowFactor = slowFactor;
        _this.reset(startPoint);
        return _this;
    }
    YarnSystem.prototype.addSegment = function (endpoint, life) {
        this.segments.push({
            endpoint: vec2(endpoint),
            life: life,
            maxLife: life,
        });
    };
    YarnSystem.prototype.update = function () {
        var e_201, _a, e_202, _b;
        var _this = this;
        _super.prototype.update.call(this);
        try {
            for (var _c = __values(this.segments), _d = _c.next(); !_d.done; _d = _c.next()) {
                var segment = _d.value;
                segment.life -= this.delta;
            }
        }
        catch (e_201_1) { e_201 = { error: e_201_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_201) throw e_201.error; }
        }
        while (this.segments.length > 0 && this.segments[0].life <= 0) {
            var length_1 = G.distance(this.startPoint, this.segments[0].endpoint);
            var k = Math.ceil((length_1 - this.startDistance) / 4);
            this.startDistance += 4 * k - length_1;
            this.startPoint = this.segments[0].endpoint;
            this.segments.shift();
        }
        var enemies = this.world.select.typeAll(Ball).filter(function (ball) { return ball.team !== _this.parentBall.team; });
        try {
            for (var enemies_7 = __values(enemies), enemies_7_1 = enemies_7.next(); !enemies_7_1.done; enemies_7_1 = enemies_7.next()) {
                var enemy = enemies_7_1.value;
                for (var i = 0; i < this.segments.length; i++) {
                    var start = (i === 0 ? this.startPoint : this.segments[i - 1].endpoint);
                    var end = this.segments[i].endpoint;
                    if (G.circleIntersectsSegment(enemy.x, enemy.y, enemy.physicalRadius, start.x, start.y, end.x, end.y)) {
                        enemy.addSlow('yarn', this.slowFactor, 0.1);
                    }
                }
            }
        }
        catch (e_202_1) { e_202 = { error: e_202_1 }; }
        finally {
            try {
                if (enemies_7_1 && !enemies_7_1.done && (_b = enemies_7.return)) _b.call(enemies_7);
            }
            finally { if (e_202) throw e_202.error; }
        }
        if (this.segments.length === 0 && this.parentBall.world !== this.world) {
            this.kill();
        }
    };
    YarnSystem.prototype.render = function (texture, x, y) {
        var startSegment = Math.max(this.segments.length - 100, 0);
        Draw.brush.color = Ball.getTeamColor(this.parentBall.team);
        Draw.brush.alpha = 1;
        Draw.brush.thickness = IS_MOBILE ? 3 : 2;
        for (var i = startSegment; i < this.segments.length; i++) {
            Draw.brush.alpha = this.segments[i].life / this.segments[i].maxLife;
            var start = (i === 0 ? this.startPoint : this.segments[i - 1].endpoint);
            var end = this.segments[i].endpoint;
            Draw.line(texture, start.x, start.y, end.x, end.y);
        }
        if (!IS_MOBILE) {
            Draw.brush.color = 0x000000;
            Draw.brush.thickness = 1;
            for (var i = startSegment; i < this.segments.length; i++) {
                Draw.brush.alpha = this.segments[i].life / this.segments[i].maxLife;
                var start = (i === 0 ? this.startPoint : this.segments[i - 1].endpoint);
                var end = this.segments[i].endpoint;
                var bandDirection = vec2(end).subtract(start).rotate(90).normalize();
                Draw.line(texture, start.x - bandDirection.x, start.y - bandDirection.y, end.x - bandDirection.x, end.y - bandDirection.y);
                Draw.line(texture, start.x + bandDirection.x, start.y + bandDirection.y, end.x + bandDirection.x, end.y + bandDirection.y);
            }
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    YarnSystem.prototype.setStartPointForBattle = function (startPoint) {
        if (this.segments.length > 0)
            return;
        this.startPoint = vec2(startPoint);
        this.startDistance = 0;
    };
    YarnSystem.prototype.reset = function (startPoint) {
        this.startPoint = vec2(startPoint);
        this.segments = [];
        this.startDistance = 0;
    };
    return YarnSystem;
}(Sprite));
var Zap = /** @class */ (function (_super) {
    __extends(Zap, _super);
    function Zap(start, end) {
        var _this = _super.call(this, {
            layer: Battle.Layers.fx,
        }) || this;
        _this.start = start;
        _this.end = end;
        _this.random = new RandomNumberGenerator();
        _this.randomOffset = Random.float(0, 1);
        return _this;
    }
    Zap.prototype.getDamageMult = function () {
        return M.mapClamp(this.life.time, 0, 1, 1, 0.5);
    };
    Zap.prototype.render = function (texture, x, y) {
        var distance = G.distance(this.start, this.end);
        var segments = Math.floor(distance / 4);
        var segmentD = vec2(this.end).subtract(this.start).withMagnitude(distance / segments);
        var segmentDInv = segmentD.rotated(90).normalize();
        Draw.brush.color = Color.lerpColorByRgb(0x00FFFF, 0x00A5A5, M.map(this.getDamageMult(), 1, 0.5, 0, 1));
        Draw.brush.alpha = 1;
        Draw.brush.thickness = 1;
        this.random.seed(Math.floor(this.randomOffset + this.life.time * 16));
        var currentPoint = vec2(this.start);
        for (var i = 0; i < segments; i++) {
            var currentx = currentPoint.x;
            var currenty = currentPoint.y;
            var rd = this.random.float(-8, 8);
            var nextx = this.start.x + segmentD.x * (i + 1) + segmentDInv.x * rd;
            var nexty = this.start.y + segmentD.y * (i + 1) + segmentDInv.y * rd;
            Draw.line(texture, x + currentx, y + currenty, x + nextx, y + nexty);
            currentPoint.set(nextx, nexty);
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    return Zap;
}(WorldObject));
var ZapRing = /** @class */ (function (_super) {
    __extends(ZapRing, _super);
    function ZapRing(radius, config) {
        var _this = _super.call(this, config) || this;
        _this.radius = radius;
        _this.random = new RandomNumberGenerator();
        _this.randomOffset = Random.float(0, 1);
        return _this;
    }
    ZapRing.prototype.render = function (texture, x, y) {
        Draw.brush.color = 0x00FFFF;
        Draw.brush.alpha = 1;
        Draw.brush.thickness = 1;
        this.random.seed(Math.floor(this.randomOffset + this.life.time * 16));
        var segments = 20;
        var firstRadius = this.radius + this.random.float(0, 4);
        var currentRadius = firstRadius;
        for (var i = 0; i < segments; i++) {
            var lastRadius = currentRadius;
            currentRadius = (i === segments - 1 ? firstRadius : this.radius + this.random.float(0, 4));
            var lastAngle = i / segments * 360;
            var lastx = lastRadius * M.cos(lastAngle);
            var lasty = lastRadius * M.sin(lastAngle);
            var currentAngle = (i + 1) / segments * 360;
            var currentx = currentRadius * M.cos(currentAngle);
            var currenty = currentRadius * M.sin(currentAngle);
            Draw.line(texture, x + lastx, y + lasty, x + currentx, y + currenty);
        }
        _super.prototype.render.call(this, texture, x, y);
    };
    return ZapRing;
}(WorldObject));
var AchievementsMenu = /** @class */ (function (_super) {
    __extends(AchievementsMenu, _super);
    function AchievementsMenu() {
        var e_203, _a;
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
            layers: [
                { name: 'world' },
                {
                    name: 'achievements',
                    mask: {
                        offsetx: 0,
                        offsety: 62,
                        texture: Texture.filledRect(global.gameWidth, 138, 0xFFFFFF),
                    }
                },
            ],
        }) || this;
        var achievementsComplete = getAchievementsCompleteCount();
        var achievementsCount = getAchievementsCount();
        var mainAchievementsComplete = achievementsComplete.completeCount === achievementsCount.count;
        var secretAchievementsComplete = achievementsComplete.secretCompleteCount === achievementsCount.secretCount;
        var wawo = _this.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        wawo.layer = 'world';
        _this.addWorldObjects(lciDocumentToWorldObjects('achievementsmenu'));
        _this.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 3;
        };
        _this.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 1) * 3;
        };
        _this.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.back();
            },
        }));
        _this.addWorldObject(new AbilitySystem());
        var progressWidthScale = (achievementsComplete.completeCount + achievementsComplete.secretCompleteCount) / achievementsCount.count;
        var progressBar = _this.select.name('bar');
        var progressWidth = progressBar.getTexture().width - 2;
        _this.addWorldObject(new Sprite({
            x: progressBar.x + 1, y: progressBar.y + 1,
            texture: Draw.PIXEL_TEXTURE,
            scaleX: progressWidth * progressWidthScale,
            scaleY: 3,
            tint: mainAchievementsComplete ? 0xFFD800 : 0xFFFFFF,
        }));
        if (mainAchievementsComplete && secretAchievementsComplete) {
            _this.select.name('title').tint = 0xFFD800;
        }
        var achievementsCompleteText = "" + achievementsComplete.completeCount;
        if (achievementsComplete.secretCompleteCount > 0) {
            achievementsCompleteText += "[gold]+" + achievementsComplete.secretCompleteCount + "[/gold]";
        }
        _this.addWorldObject(new SpriteText({
            x: progressBar.x - 2, y: progressBar.y + 3,
            text: "[achx]" + achievementsCompleteText + "[/achx]/" + achievementsCount.count,
            font: 'smallnumbers',
            style: { color: mainAchievementsComplete ? 0xFFD800 : 0xFFFFFF },
            effects: { outline: { color: 0x000000 } },
            anchor: Vector2.CENTER_RIGHT,
        }));
        var achievements = _this.addWorldObject(new WorldObject({ x: _this.width / 2, y: 82 }));
        var achievementNameList = Object.keys(ACHIEVEMENTS).map(function (ach) { return ach; }).filter(function (ach) {
            if (ach === 'ArgPart1') {
                return hasCompletedAchievement('ArgPart1') || (!IS_MOBILE && achievementsComplete.completeCount >= 6);
            }
            if (ACHIEVEMENTS[ach].secret && !hasCompletedAchievement(ach)) {
                return false;
            }
            return true;
        });
        var argPart1AchIndex = achievementNameList.indexOf('ArgPart1');
        if (argPart1AchIndex >= 0 && achievementNameList.length >= 6 && !hasCompletedAchievement('ArgPart1')) {
            achievementNameList.splice(argPart1AchIndex, 1);
            achievementNameList.splice(Random.int(5, achievementNameList.length - 1), 0, 'ArgPart1');
        }
        var i = 0;
        var _loop_28 = function (ach) {
            var box = achievements.addChild(new Sprite({
                x: 0, y: 44 * i,
                texture: AchievementsMenu.achievementBox.get(),
                layer: 'achievements',
                bounds: new RectBounds(-103, -20, 206, 40),
            }));
            var iconBox = box.addChild(new Sprite({
                x: -83, y: 0,
                texture: 'achievementrewardbox',
                layer: 'achievements',
            }));
            var complete = hasCompletedAchievement(ach);
            if (complete) {
                var beams = iconBox.addChild(new Sprite({
                    texture: 'buffbeams',
                    scale: 20 / 64,
                    vangle: 90,
                    layer: 'achievements',
                }));
                var reward = iconBox.addChild(ACHIEVEMENTS[ach].rewardObjectFactory());
                reward.layer = 'achievements';
            }
            else {
                var icon = iconBox.addChild(new Sprite({
                    x: 0, y: 0,
                    texture: ACHIEVEMENTS[ach].rewardIconBase + "/" + (complete ? 1 : 0),
                    bounds: new CircleBounds(0, 0, 10),
                    tags: ['reward'],
                    layer: 'achievements',
                }));
            }
            var desc = box.addChild(new SpriteText({
                x: 17, y: 0,
                text: ACHIEVEMENTS[ach].description,
                anchor: Vector2.CENTER,
                justify: 'center',
                maxWidth: 164,
                style: { color: ACHIEVEMENTS[ach].secret ? 0xFFD800 : 0xFFFFFF },
                layer: 'achievements',
            }));
            var progress = box.addChild(new SpriteText({
                x: 100, y: 17,
                text: "[achx]" + Math.floor(ACHIEVEMENTS_PROGRESS[ach]) + "[/achx]/" + ACHIEVEMENTS[ach].completeProgress,
                font: 'smallnumbers',
                style: { color: complete ? 0x00FF00 : 0xFFFFFF },
                anchor: Vector2.BOTTOM_RIGHT,
                layer: 'achievements',
            }));
            var storedAch = ach;
            box.updateCallback = function () {
                var mask = this.world.getLayerByName('achievements').mask;
                var maskRect = mask ? rect(mask.offsetx, mask.offsety, mask.texture.width, mask.texture.height) : rect(0, 0, 0, 0);
                var mousePos = this.world.getWorldMousePosition();
                if (Input.justDown('click') && mask && G.rectContainsPt(maskRect, mousePos) && this.bounds.containsPoint(mousePos)) {
                    this.data.clicks = (this.data.clicks || 0) + 1;
                }
                if (Input.justDown('ach_cheat')) {
                    if (this.data.clicks >= 5 && !hasCompletedAchievement(storedAch)) {
                        grantAchievement(storedAch);
                        global.game.playSound('achievement');
                    }
                    this.data.clicks = 0;
                }
            };
            if (ach === 'ArgPart1' && !complete) {
                iconBox.kill();
                desc.kill();
                progress.kill();
                box.setTexture('argpart1box');
                box.alpha = 0.75;
                box.effects.post.filters.push(new Effects.Filters.Glitch(8, 6, 8));
                var currentUpdateCallback_1 = box.updateCallback;
                box.updateCallback = function () {
                    var _this = this;
                    if (currentUpdateCallback_1)
                        currentUpdateCallback_1.call(this);
                    var mask = this.world.getLayerByName('achievements').mask;
                    var maskRect = mask ? rect(mask.offsetx, mask.offsety, mask.texture.width, mask.texture.height) : rect(0, 0, 0, 0);
                    var mousePos = this.world.getWorldMousePosition();
                    if (mask && G.rectContainsPt(maskRect, mousePos) && this.bounds.containsPoint(mousePos)) {
                        this.data.hoverTime = (this.data.hoverTime || 0) + this.delta;
                        this.effects.outline.enabled = true;
                        this.effects.outline.color = 0xFFFFFF;
                    }
                    else {
                        this.data.hoverTime = 0;
                        this.effects.outline.enabled = false;
                    }
                    if (mask && G.rectContainsRect(maskRect, this.bounds.getBoundingBox())) {
                        this.data.seeTime = (this.data.seeTime || 0) + this.delta;
                    }
                    else {
                        this.data.seeTime = 0;
                    }
                    if (this.data.hoverTime >= 3 || this.data.seeTime >= 8) {
                        global.game.menuSystem.loadMenu(function () { return new ArgIntroMenu(_this.world.takeSnapshot()); });
                    }
                };
            }
            i++;
        };
        try {
            for (var achievementNameList_1 = __values(achievementNameList), achievementNameList_1_1 = achievementNameList_1.next(); !achievementNameList_1_1.done; achievementNameList_1_1 = achievementNameList_1.next()) {
                var ach = achievementNameList_1_1.value;
                _loop_28(ach);
            }
        }
        catch (e_203_1) { e_203 = { error: e_203_1 }; }
        finally {
            try {
                if (achievementNameList_1_1 && !achievementNameList_1_1.done && (_a = achievementNameList_1.return)) _a.call(achievementNameList_1);
            }
            finally { if (e_203) throw e_203.error; }
        }
        var totalAchievementsHeight = i * 44 - 4;
        var totalVisibleHeight = 138;
        var startY = achievements.y;
        var scrollBar = _this.addWorldObject(new ScrollBar(265, 62, 'achievementscrollbar', totalAchievementsHeight, 32, function (p) { return achievements.y = startY - (totalAchievementsHeight - totalVisibleHeight) * p; }));
        _this.addWorldObject(new DragScroller(scrollBar, totalAchievementsHeight, rect(60, 60, 200, 140)));
        _this.addWorldObject(new BallHighlighter());
        var achievementScreenBounds = { x: 57, y: 62, width: 206, height: 138 };
        var infoBox = new InfoBox(achievementScreenBounds);
        infoBox.layer = World.DEFAULT_LAYER;
        _this.addWorldObject(infoBox);
        _this.addWorldObject(new AchievementRewardInfoBox(achievementScreenBounds));
        return _this;
    }
    AchievementsMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_CLOSE_MENU)) {
            Input.consume(Input.GAME_CLOSE_MENU);
            global.game.menuSystem.back();
        }
    };
    AchievementsMenu.achievementBox = new LazyValue(function () { return new AnchoredTexture(Texture.ninepatch(AssetCache.getTexture('infobox_9p'), rect(4, 4, 4, 4), 206, 40), 0.5, 0.5); });
    return AchievementsMenu;
}(Menu));
var AllBallsItemsMenu = /** @class */ (function (_super) {
    __extends(AllBallsItemsMenu, _super);
    function AllBallsItemsMenu(pack, itemPage) {
        var e_204, _a;
        var _this = _super.call(this, {
            backgroundColor: 0xFF00FF,
            volume: 1,
        }) || this;
        var width = 20, height = 20;
        var i = 0, j = 0;
        try {
            for (var _b = __values(getAllBallTypesForPack(pack, undefined)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var type = _c.value;
                var ball = squadBallToWorldBall({
                    x: width * (0.5 + i), y: height * (0.5 + j),
                    properties: {
                        type: type,
                        health: 1,
                        damage: 1,
                        equipment: -1,
                        level: 1,
                        metadata: {},
                    }
                }, undefined, -1, 'friend');
                ball.layer = World.DEFAULT_LAYER;
                ball.effects.addOutline.color = 0xFFFFFF;
                _this.addWorldObject(ball);
                ball.isInShop = true;
                if (ball instanceof Balls.Grenade) {
                    ball.x += 100;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.BallOfYarn) {
                    ball.x += 150;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.BioGrenade) {
                    ball.x += 150;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.DeathStar) {
                    ball.x += 150;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.Turret) {
                    ball.x += 120;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.Cannon) {
                    ball.x += 120;
                    ball.y += 20;
                }
                else if (ball instanceof Balls.GlitchedBallArg) {
                    ball.removeFromWorld();
                }
                else if (ball instanceof Balls.Matryoshka) {
                    ball.setSize(4);
                    ball.x += 100;
                    ball.y += 15;
                }
                else if (ball instanceof Balls.Angel) {
                    ball.x += 170;
                    ball.y += 30;
                }
                else if (ball instanceof Balls.Devil) {
                    ball.x += 180;
                    ball.y += 30;
                }
                else if (ball instanceof Balls.BlackHole) {
                    ball.x += 190;
                    ball.y += 30;
                }
                else if (ball instanceof Balls.Boomer) {
                    ball.x += 200;
                    ball.y += 30;
                }
                else if (ball instanceof Balls.Wizard) {
                    ball.x += 170;
                    ball.y += 45;
                }
                else if (ball instanceof Balls.Stinger) {
                    ball.x += 180;
                    ball.y += 45;
                }
                else if (ball instanceof Balls.Fireball) {
                    ball.x += 190;
                    ball.y += 40;
                }
                else if (ball instanceof Balls.ScrapCannon) {
                    ball.x += 200;
                    ball.y += 40;
                }
                else {
                    World.Actions.removeWorldObjectsFromWorld(ball.children);
                    World.Actions.addWorldObjectToWorld(ball.dmgbox, ball.world);
                    World.Actions.addWorldObjectToWorld(ball.hpbox, ball.world);
                    World.Actions.addWorldObjectToWorld(ball.stars, ball.world);
                }
                i++;
                if (i >= 8) {
                    i = 0;
                    j++;
                }
            }
        }
        catch (e_204_1) { e_204 = { error: e_204_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_204) throw e_204.error; }
        }
        width = 24, height = 24;
        i = 0, j = 0;
        var skipItems = 0;
        for (var type in TYPE_TO_ITEM_TYPE_DEF) {
            if (skipItems < itemPage * 32) {
                skipItems++;
                continue;
            }
            var item = itemTypeToBallItem(parseInt(type), width * (0.5 + i), 144 + height * (0.5 + j));
            item.layer = World.DEFAULT_LAYER;
            item.effects.addOutline.color = 0xFFFFFF;
            _this.addWorldObject(item);
            i++;
            if (i >= 8) {
                i = 0;
                j++;
            }
        }
        _this.addWorldObject(new AbilitySystem());
        return _this;
    }
    return AllBallsItemsMenu;
}(Menu));
var AlmanacMenu = /** @class */ (function (_super) {
    __extends(AlmanacMenu, _super);
    function AlmanacMenu(initialPage) {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
            layers: [
                { name: 'world' },
                {
                    name: 'entries',
                    mask: {
                        offsetx: AlmanacMenu.MASK_X,
                        offsety: AlmanacMenu.MASK_Y,
                        texture: Texture.filledRect(AlmanacMenu.MASK_W, AlmanacMenu.MASK_H, 0xFFFFFF),
                    }
                },
            ],
        }) || this;
        _this.destroyedGift = false;
        _this.loadPage(initialPage);
        return _this;
    }
    AlmanacMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_CLOSE_MENU)) {
            Input.consume(Input.GAME_CLOSE_MENU);
            global.game.menuSystem.back();
        }
    };
    AlmanacMenu.prototype.loadPage = function (page) {
        var e_205, _a;
        var _this = this;
        this.removeWorldObjects(A.clone(this.worldObjects));
        var wawo = this.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        wawo.layer = 'world';
        this.addWorldObjects(lciDocumentToWorldObjects('almanacmenu'));
        this.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 3;
        };
        var progressBar = this.select.name('progressbar');
        var progressWidth = progressBar.getTexture().width - 2;
        var totalCompletionPercent = getAlmanacTotalCompletionPercent();
        this.addWorldObject(new Sprite({
            x: progressBar.x + 1, y: progressBar.y + 1,
            texture: Draw.PIXEL_TEXTURE,
            scaleX: progressWidth * totalCompletionPercent.seen,
            scaleY: 3,
        }));
        this.addWorldObject(new Sprite({
            x: progressBar.x + 1, y: progressBar.y + 1,
            texture: Draw.PIXEL_TEXTURE,
            scaleX: progressWidth * totalCompletionPercent.won,
            scaleY: 3,
            tint: 0xFFD800,
        }));
        this.setupGift(this);
        var _loop_29 = function (p) {
            var baseTint = void 0;
            if (p === 'classic' || p === 'community' || p === 'weekly') {
                baseTint = getAlmanacBallCompletionPercent(p, { week: Weekly.LIVE_WEEK }) >= 1 ? 0xFFDB00 : 0xFFFFFF;
            }
            else {
                baseTint = getAlmanacItemCompletionPercent() >= 1 ? 0xFFDB00 : 0xFFFFFF;
            }
            if (p === page) {
                baseTint = Color.lerpColorByRgb(baseTint, 0x000000, 0.3);
            }
            var packButton = this_6.select.name(p).addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                baseTint: baseTint,
                onJustHovered: juiceButton(1),
                onClick: function () {
                    global.game.playSound('click');
                    _this.loadPage(p);
                },
            }));
            var cp = p;
            this_6.select.name(p).updateCallback = function () {
                if (cp === page)
                    packButton.enabled = false;
            };
            if (p === 'weekly') {
                packButton.enabled = false;
                var packButtonHide_1 = this_6.addWorldObject(new Sprite({
                    p: this_6.select.name(p),
                    texture: new AnchoredTexture(Texture.filledRect(56, 12, 0x000000), 0.5, 0.5),
                }));
                packButtonHide_1.addChild(new Spinner(0, 0, 1.5, 3));
                Weekly.load({
                    onSuccess: function () {
                        packButtonHide_1.kill();
                        packButton.enabled = true;
                    },
                    onError: function () {
                        // Nothing, just let the spinner spin indefinitely.
                    },
                });
            }
        };
        var this_6 = this;
        try {
            for (var _b = __values(['classic', 'community', 'weekly', 'items']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                _loop_29(p);
            }
        }
        catch (e_205_1) { e_205 = { error: e_205_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_205) throw e_205.error; }
        }
        if (page === 'items') {
            this.select.name('levelup').setVisible(false);
            this.select.name('leveldown').setVisible(false);
        }
        else {
            this.select.name('levelup').addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                onJustHovered: juiceButton(1),
                onClick: function () {
                    global.game.playSound('click');
                    global.game.playSound('levelup');
                    juiceObject(_this.select.name('levelup'), 1);
                    _this.levelUpBalls();
                },
            }));
            this.select.name('leveldown').addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                onJustHovered: juiceButton(1),
                onClick: function () {
                    global.game.playSound('click');
                    global.game.playSound('reduce');
                    juiceObject(_this.select.name('leveldown'), 1);
                    _this.levelDownBalls();
                },
            }));
        }
        this.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 1) * 3;
        };
        this.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.back();
            },
        }));
        this.addWorldObject(new AbilitySystem());
        var entriesBase = this.addWorldObject(new WorldObject({ x: this.width / 2, y: AlmanacMenu.MASK_Y + 25 }));
        var textures;
        if (page === 'classic' || page === 'community' || page === 'weekly') {
            textures = this.loadBallEntries(page, entriesBase);
        }
        else {
            textures = this.loadItemEntries(entriesBase);
        }
        var bgSprite = entriesBase.addChild(new Sprite({ x: -AlmanacMenu.MASK_W / 2, y: -25, texture: textures.bg, layer: 'entries' }));
        World.Actions.moveWorldObjectToBack(bgSprite);
        var fgSprite = entriesBase.addChild(new Sprite({ x: -AlmanacMenu.MASK_W / 2, y: -25, texture: textures.fg, layer: 'entries' }));
        World.Actions.moveWorldObjectToFront(fgSprite);
        var totalEntriesHeight = textures.bg.height;
        var startY = entriesBase.y;
        var scrollBar = this.addWorldObject(new ScrollBar(310, 59, 'almanacscrollbar', totalEntriesHeight, 48, function (p) { return entriesBase.y = startY - (totalEntriesHeight - AlmanacMenu.MASK_H) * p; }));
        scrollBar.effects.addOutline.color = 0xFFFFFF;
        this.addWorldObject(new DragScroller(scrollBar, totalEntriesHeight, rect(AlmanacMenu.MASK_X, AlmanacMenu.MASK_Y, AlmanacMenu.MASK_W, AlmanacMenu.MASK_H)));
        this.addWorldObject(new BallHighlighter());
        var infoBox = new InfoBox({ x: AlmanacMenu.MASK_X, y: AlmanacMenu.MASK_Y, width: AlmanacMenu.MASK_W, height: AlmanacMenu.MASK_H });
        infoBox.layer = World.DEFAULT_LAYER;
        infoBox.showCredits = true;
        this.addWorldObject(infoBox);
        this.update();
    };
    AlmanacMenu.prototype.loadBallEntries = function (pack, entriesBase) {
        var e_206, _a;
        var ballTypeList = getAlmanacDisplayedBallTypes(pack, { week: Weekly.LIVE_WEEK });
        var bgTexture = new BasicTexture(AlmanacMenu.MASK_W, Math.ceil(ballTypeList.length / 8) * 52, 'AlmanacMenu.loadBallEntries');
        var fgTexture = new BasicTexture(AlmanacMenu.MASK_W, Math.ceil(ballTypeList.length / 8) * 52, 'AlmanacMenu.loadBallEntries');
        var i = 0, j = 0;
        try {
            for (var ballTypeList_1 = __values(ballTypeList), ballTypeList_1_1 = ballTypeList_1.next(); !ballTypeList_1_1.done; ballTypeList_1_1 = ballTypeList_1.next()) {
                var type = ballTypeList_1_1.value;
                var winCount = getAlmanacBallWinCount(type);
                this.renderEntryBox(bgTexture, i, j, winCount);
                if (hasSeenAlmanacBall(type)) {
                    var ball = entriesBase.addChild(getRewardBall(type));
                    ball.layer = 'entries';
                    ball.hp = ball.maxhp = ball.getShopHp();
                    ball.dmg = ball.getShopDmg();
                    ball.showAllStats();
                    ball.localx = M.equidistantLine(0, 36, 8, i) + ball.getShopRelativePosition().x;
                    ball.localy = 52 * j + ball.getShopRelativePosition().y;
                }
                else {
                    this.renderEntryBoxMystery(bgTexture, i, j);
                }
                if (winCount > 0) {
                    this.renderEntryBoxWinText(fgTexture, i, j, winCount);
                }
                i++;
                if (i >= 8) {
                    i = 0;
                    j++;
                }
            }
        }
        catch (e_206_1) { e_206 = { error: e_206_1 }; }
        finally {
            try {
                if (ballTypeList_1_1 && !ballTypeList_1_1.done && (_a = ballTypeList_1.return)) _a.call(ballTypeList_1);
            }
            finally { if (e_206) throw e_206.error; }
        }
        return { bg: bgTexture, fg: fgTexture };
    };
    AlmanacMenu.prototype.loadItemEntries = function (entriesBase) {
        var e_207, _a;
        var itemTypeList = getAlmanacDisplayedItemTypes();
        var bgTexture = new BasicTexture(AlmanacMenu.MASK_W, Math.ceil(itemTypeList.length / 8) * 52, 'AlmanacMenu.loadItemEntries');
        var fgTexture = new BasicTexture(AlmanacMenu.MASK_W, Math.ceil(itemTypeList.length / 8) * 52, 'AlmanacMenu.loadItemEntries');
        var i = 0, j = 0;
        try {
            for (var itemTypeList_1 = __values(itemTypeList), itemTypeList_1_1 = itemTypeList_1.next(); !itemTypeList_1_1.done; itemTypeList_1_1 = itemTypeList_1.next()) {
                var type = itemTypeList_1_1.value;
                var winCount = getAlmanacItemWinCount(type);
                this.renderEntryBox(bgTexture, i, j, winCount);
                if (hasSeenAlmanacItem(type)) {
                    var item = entriesBase.addChild(getRewardItem(type));
                    item.layer = 'entries';
                    item.localx = M.equidistantLine(0, 36, 8, i);
                    item.localy = 52 * j;
                }
                else {
                    this.renderEntryBoxMystery(bgTexture, i, j);
                }
                if (winCount > 0) {
                    this.renderEntryBoxWinText(fgTexture, i, j, winCount);
                }
                i++;
                if (i >= 8) {
                    i = 0;
                    j++;
                }
            }
        }
        catch (e_207_1) { e_207 = { error: e_207_1 }; }
        finally {
            try {
                if (itemTypeList_1_1 && !itemTypeList_1_1.done && (_a = itemTypeList_1.return)) _a.call(itemTypeList_1);
            }
            finally { if (e_207) throw e_207.error; }
        }
        return { bg: bgTexture, fg: fgTexture };
    };
    AlmanacMenu.prototype.levelUpBalls = function () {
        var e_208, _a;
        var balls = this.select.typeAll(Ball);
        try {
            for (var balls_22 = __values(balls), balls_22_1 = balls_22.next(); !balls_22_1.done; balls_22_1 = balls_22.next()) {
                var ball = balls_22_1.value;
                ball.levelUp(undefined, false, false);
            }
        }
        catch (e_208_1) { e_208 = { error: e_208_1 }; }
        finally {
            try {
                if (balls_22_1 && !balls_22_1.done && (_a = balls_22.return)) _a.call(balls_22);
            }
            finally { if (e_208) throw e_208.error; }
        }
    };
    AlmanacMenu.prototype.levelDownBalls = function () {
        var e_209, _a;
        var balls = this.select.typeAll(Ball);
        try {
            for (var balls_23 = __values(balls), balls_23_1 = balls_23.next(); !balls_23_1.done; balls_23_1 = balls_23.next()) {
                var ball = balls_23_1.value;
                ball.levelDown();
            }
        }
        catch (e_209_1) { e_209 = { error: e_209_1 }; }
        finally {
            try {
                if (balls_23_1 && !balls_23_1.done && (_a = balls_23.return)) _a.call(balls_23);
            }
            finally { if (e_209) throw e_209.error; }
        }
    };
    AlmanacMenu.prototype.renderEntryBox = function (texture, i, j, winCount) {
        var tint = winCount > 0 ? 0xFFDB00 : 0xFFFFFF;
        AssetCache.getTexture('almanacentrybox').renderTo(texture, { x: 17 + 36 * i, y: 25 + 52 * j, tint: tint });
    };
    AlmanacMenu.prototype.renderEntryBoxWinText = function (texture, i, j, winCount) {
        var spriteText = lazy('AlmanacMenuSpriteText', function () { return new SpriteText({
            font: 'smallnumbers',
            style: { color: 0xFFDB00 },
            layer: 'entries',
            effects: { outline: {} },
        }); });
        spriteText.setText("<crown2l><crown2r>" + winCount);
        spriteText.render(texture, 2 + 36 * i, 4 + 52 * j);
    };
    AlmanacMenu.prototype.renderEntryBoxMystery = function (texture, i, j) {
        AssetCache.getTexture('almanacmystery').renderTo(texture, { x: 17 + 36 * i, y: 25 + 52 * j });
    };
    AlmanacMenu.prototype.setupGift = function (world) {
        var _this = this;
        var gift = world.select.name('gift');
        if (IS_MOBILE || this.destroyedGift) {
            gift.setVisible(false);
            return;
        }
        var revealGift = getAlmanacTotalCompletionPercent().won >= 0.25;
        if (revealGift) {
            gift.effects.post.filters.push(new TextureFilter({
                code: "\n                    if (x >= 0.0 && x < width && y >= 0.0 && y < height && (inp.r > 0.0 && inp.r < 1.0)) {\n                        float v = map(pnoise(x, y, 10.6 + 100.0*t), -1.0, 1.0, 0.0, 1.0);\n                        float av = (1.0 - cos(PI*v)) / 2.0;\n                        float aav = (1.0 - cos(PI*av)) / 2.0;\n                        outp.rgb = vec3(1.0, 1.0, 1.0) * aav;\n                    }\n                "
            }));
        }
        gift.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                if (revealGift) {
                    global.game.startGame(function () { return ARG.Stages.CODE(); });
                }
                else {
                    global.game.playSound('arg/glitch_short_low').volume = 1.5;
                    gift.kill();
                    _this.destroyedGift = true;
                }
            },
            onJustHovered: function () {
                world.effects.glitch.enable(1, 0.5, 16);
            },
            onJustUnhovered: function () {
                world.effects.glitch.enabled = false;
            },
        }));
    };
    return AlmanacMenu;
}(Menu));
(function (AlmanacMenu) {
    AlmanacMenu.MASK_X = 17;
    AlmanacMenu.MASK_Y = 62;
    AlmanacMenu.MASK_W = 286;
    AlmanacMenu.MASK_H = 144;
})(AlmanacMenu || (AlmanacMenu = {}));
var _MENUS_ARENA_WORLD;
function setArenaWorld(arena) {
    if (!_MENUS_ARENA_WORLD) {
        _MENUS_ARENA_WORLD = createArenaWorld();
    }
    Arenas.SET_FOR_ARENA(_MENUS_ARENA_WORLD, arena);
}
function createArenaWorld() {
    var arenaWorld = Arenas.BASE();
    arenaWorld.volume = 0.3;
    arenaWorld.addWorldObject(new AbilitySystem());
    arenaWorld.data.battleState = Ball.States.BATTLE;
    arenaWorld.data.packs = [Random.element(['classic', 'community'])];
    arenaWorld.data.summon = function () {
        var e_210, _a;
        for (var i = 0; i < 5; i++) {
            var _loop_30 = function (team) {
                if (arenaWorld.select.typeAll(Ball).filter(function (ball) { return ball.team === team; }).length >= 5)
                    return "continue";
                var p = vec2(Random.int(48, global.gameWidth - 48), Random.int(48, global.gameHeight - 48));
                var squadBall = void 0;
                do {
                    squadBall = randomSquadBall(p.x, p.y, 10, arenaWorld.data.packs, undefined);
                } while (squadBall.properties.type === 113); // No Watchers
                var ball = arenaWorld.addWorldObject(squadBallToWorldBall(squadBall, undefined, -1, team));
                ball.setState(Ball.States.BATTLE);
                ball.v = Random.onCircle(150);
            };
            try {
                for (var _b = (e_210 = void 0, __values(['enemy', 'friend'])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var team = _c.value;
                    _loop_30(team);
                }
            }
            catch (e_210_1) { e_210 = { error: e_210_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_210) throw e_210.error; }
            }
        }
    };
    arenaWorld.runScript(function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!true) return [3 /*break*/, 2];
                    arenaWorld.data.summon();
                    return [4 /*yield*/, S.wait(1)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
    return arenaWorld;
}
function setArenaWorldForPacks(packs) {
    _MENUS_ARENA_WORLD.select.typeAll(Ball).forEach(function (ball) { return ball.kill(); });
    _MENUS_ARENA_WORLD.data.packs = packs;
    _MENUS_ARENA_WORLD.runScript(function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/];
                case 1:
                    _a.sent();
                    _MENUS_ARENA_WORLD.data.summon();
                    return [2 /*return*/];
            }
        });
    });
}
var ArgIntroMenu = /** @class */ (function (_super) {
    __extends(ArgIntroMenu, _super);
    function ArgIntroMenu(snapshot) {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 1,
        }) || this;
        var oldMenu = _this.addWorldObject(new Sprite({
            texture: snapshot,
            effects: { post: { filters: [new Effects.Filters.Glitch(60, 0, 30)] } },
        }));
        var g = new Effects.Filters.Glitch(0, 2, 16);
        var qr = _this.addWorldObject(new Sprite({
            x: _this.width / 2, y: _this.height / 2,
            texture: 'arg/qr_intro',
            effects: { post: { filters: [g] } },
            alpha: 0,
        }));
        _this.runScript(function () {
            var sound;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        global.game.stopMusic();
                        sound = global.game.playSound('arg/glitch_dialog');
                        return [4 /*yield*/, S.wait(0.5)];
                    case 1:
                        _a.sent();
                        sound.hang();
                        return [4 /*yield*/, S.wait(4.5)];
                    case 2:
                        _a.sent();
                        sound.stop();
                        oldMenu.kill();
                        return [4 /*yield*/, S.wait(4)];
                    case 3:
                        _a.sent();
                        global.game.musicManager.playMusic('arg/arg');
                        return [4 /*yield*/, S.wait(4)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, S.tween(4, qr, 'alpha', 0, 1)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (!true) return [3 /*break*/, 9];
                        g.strength = 2;
                        return [4 /*yield*/, S.wait(1.1)];
                    case 7:
                        _a.sent();
                        g.strength = 0;
                        return [4 /*yield*/, S.wait(4)];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    return ArgIntroMenu;
}(Menu));
var CloudSaveScreen;
(function (CloudSaveScreen) {
    function STAGE() {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        "modded_remove_from";
        setArenaWorld(Arenas.ARENA_FIRST);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('cloudsavemenu'));
        world.select.name('cloudsave').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        var synced = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: 64,
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
            update: function () {
                this.effects.outline.alpha = this.alpha;
            }
        }));
        var header = world.select.name('yoursaveid');
        var saveIdText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2 + 1, y: 122,
            text: "<g1><g2><g3><g4><g5><g3><g2><g4>",
            scale: 2,
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
            data: { shown: false },
            update: function () {
                this.effects.outline.alpha = this.alpha;
                if (!this.data.shown && this.everyNSeconds(0.25)) {
                    this.setText(A.range(8).map(function (_) { return "<g" + Random.int(1, 5) + ">"; }).join(''));
                }
            }
        }));
        var showSaveButton = world.select.name('showsave');
        showSaveButton.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 2) * 2;
        };
        showSaveButton.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                world.runScript(showSaveScript(world, saveIdText));
            },
        }));
        var disableSaveButton = world.select.name('disablesave');
        disableSaveButton.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 3) * 2;
        };
        disableSaveButton.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                world.runScript(disableSaveScript(world, synced, saveIdText));
            },
        }));
        var newSaveButton = world.select.name('newsave');
        newSaveButton.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 4) * 2;
        };
        newSaveButton.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                world.runScript(newSaveScript(world, synced, saveIdText));
            },
        }));
        var inputSaveButton = world.select.name('inputsave');
        inputSaveButton.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 5) * 2;
        };
        inputSaveButton.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                world.runScript(inputSaveScript(world));
            },
        }));
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.loadMainMenu();
                global.game.playSound('click');
            },
        }));
        if (getSaveInfo()) {
            synced.setText(getSyncedText(true));
            newSaveButton.getModule(Button).enabled = false;
            newSaveButton.alpha = 0;
            inputSaveButton.getModule(Button).enabled = false;
            inputSaveButton.alpha = 0;
        }
        else {
            synced.setText(getSyncedText(false));
            header.alpha = 0;
            saveIdText.alpha = 0;
            showSaveButton.getModule(Button).enabled = false;
            showSaveButton.alpha = 0;
            disableSaveButton.getModule(Button).enabled = false;
            disableSaveButton.alpha = 0;
        }
        "modded_remove_to";
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.game.loadMainMenu();
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
        };
        return world;
    }
    CloudSaveScreen.STAGE = STAGE;
    "modded_remove_from";
    function showSaveScript(world, saveIdText) {
        return function () {
            var showSaveButton, disableSaveButton, backButton, warningBox;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (saveIdText.data.shown)
                            return [2 /*return*/];
                        showSaveButton = world.select.name('showsave');
                        disableSaveButton = world.select.name('disablesave');
                        backButton = world.select.name('back');
                        showSaveButton.getModule(Button).enabled = false;
                        disableSaveButton.getModule(Button).enabled = false;
                        backButton.getModule(Button).enabled = false;
                        warningBox = world.addWorldObject(new CloudSaveWarningBox(WARNING_SHOW_SAVE));
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox.result; })];
                    case 1:
                        _b.sent();
                        if (warningBox.result === 'cancel') {
                            showSaveButton.getModule(Button).enabled = true;
                            disableSaveButton.getModule(Button).enabled = true;
                            backButton.getModule(Button).enabled = true;
                            return [2 /*return*/];
                        }
                        showSaveButton.getModule(Button).enabled = true;
                        disableSaveButton.getModule(Button).enabled = true;
                        backButton.getModule(Button).enabled = true;
                        saveIdText.setText((_a = getSaveInfo()) === null || _a === void 0 ? void 0 : _a.saveId);
                        saveIdText.data.shown = true;
                        return [2 /*return*/];
                }
            });
        };
    }
    function disableSaveScript(world, synced, saveIdText) {
        return function () {
            var header, showSaveButton, disableSaveButton, newSaveButton, inputSaveButton, backButton, warningBox;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        header = world.select.name('yoursaveid');
                        showSaveButton = world.select.name('showsave');
                        disableSaveButton = world.select.name('disablesave');
                        newSaveButton = world.select.name('newsave');
                        inputSaveButton = world.select.name('inputsave');
                        backButton = world.select.name('back');
                        showSaveButton.getModule(Button).enabled = false;
                        disableSaveButton.getModule(Button).enabled = false;
                        backButton.getModule(Button).enabled = false;
                        warningBox = world.addWorldObject(new CloudSaveWarningBox(WARNING_DISABLE_SAVE));
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox.result; })];
                    case 1:
                        _a.sent();
                        if (warningBox.result === 'cancel') {
                            showSaveButton.getModule(Button).enabled = true;
                            disableSaveButton.getModule(Button).enabled = true;
                            backButton.getModule(Button).enabled = true;
                            return [2 /*return*/];
                        }
                        CloudSave.save();
                        deleteSaveInfo();
                        return [4 /*yield*/, [
                                S.tween(0.5, header, 'alpha', 1, 0),
                                S.tween(0.5, saveIdText, 'alpha', 1, 0),
                                S.tween(0.5, showSaveButton, 'alpha', 1, 0),
                                S.tween(0.5, disableSaveButton, 'alpha', 1, 0),
                            ]];
                    case 2:
                        _a.sent();
                        synced.setText(getSyncedText(false));
                        saveIdText.data.shown = false;
                        return [4 /*yield*/, [
                                S.tween(0.5, newSaveButton, 'alpha', 0, 1),
                                S.tween(0.5, inputSaveButton, 'alpha', 0, 1),
                            ]];
                    case 3:
                        _a.sent();
                        newSaveButton.getModule(Button).enabled = true;
                        inputSaveButton.getModule(Button).enabled = true;
                        backButton.getModule(Button).enabled = true;
                        return [2 /*return*/];
                }
            });
        };
    }
    function newSaveScript(world, synced, saveIdText) {
        return function () {
            var newSaveButton, inputSaveButton, header, showSaveButton, disableSaveButton, backButton, warningBox, result, errorText;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newSaveButton = world.select.name('newsave');
                        inputSaveButton = world.select.name('inputsave');
                        header = world.select.name('yoursaveid');
                        showSaveButton = world.select.name('showsave');
                        disableSaveButton = world.select.name('disablesave');
                        backButton = world.select.name('back');
                        newSaveButton.getModule(Button).enabled = false;
                        inputSaveButton.getModule(Button).enabled = false;
                        backButton.getModule(Button).enabled = false;
                        warningBox = world.addWorldObject(new CloudSaveWarningBox(WARNING_NEW_SAVE, 300));
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox.result; })];
                    case 1:
                        _a.sent();
                        if (warningBox.result === 'cancel') {
                            newSaveButton.getModule(Button).enabled = true;
                            inputSaveButton.getModule(Button).enabled = true;
                            backButton.getModule(Button).enabled = true;
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, [
                                S.tween(0.5, newSaveButton, 'alpha', 1, 0),
                                S.tween(0.5, inputSaveButton, 'alpha', 1, 0),
                            ]];
                    case 2:
                        _a.sent();
                        result = { id: undefined, saveTime: undefined, err: undefined, done: false };
                        return [4 /*yield*/, waitWithTimeout(5000, result, function () {
                                API.createsave(function (createSaveResponse, err) {
                                    result.id = createSaveResponse.id;
                                    result.saveTime = createSaveResponse.saveTime;
                                    result.err = err;
                                    result.done = true;
                                }, encodeCloudSaveData(getLocalCloudSaveData()), loadName(), Persistence.getProfileId());
                            })];
                    case 3:
                        _a.sent();
                        if (!result.err) return [3 /*break*/, 5];
                        console.error('Error creating save:', result.err);
                        errorText = world.addWorldObject(new SpriteText({
                            x: global.gameWidth / 2, y: global.gameHeight / 2,
                            text: 'An error occurred\nPlease try again',
                            alpha: 0,
                            anchor: Vector2.CENTER,
                            justify: 'center',
                            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
                            update: function () {
                                this.effects.outline.alpha = this.alpha;
                            }
                        }));
                        return [4 /*yield*/, [
                                S.tween(0.5, errorText, 'alpha', 0, 1),
                            ]];
                    case 4:
                        _a.sent();
                        backButton.getModule(Button).enabled = true;
                        return [3 /*break*/, 7];
                    case 5:
                        createSaveInfo(result.id, result.saveTime);
                        synced.setText(getSyncedText(true));
                        return [4 /*yield*/, [
                                S.tween(0.5, header, 'alpha', 0, 1),
                                S.tween(0.5, saveIdText, 'alpha', 0, 1),
                                S.tween(0.5, showSaveButton, 'alpha', 0, 1),
                                S.tween(0.5, disableSaveButton, 'alpha', 0, 1),
                            ]];
                    case 6:
                        _a.sent();
                        showSaveButton.getModule(Button).enabled = true;
                        disableSaveButton.getModule(Button).enabled = true;
                        backButton.getModule(Button).enabled = true;
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        };
    }
    function inputSaveScript(world) {
        return function () {
            var newSaveButton, inputSaveButton, backButton, warningBox;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newSaveButton = world.select.name('newsave');
                        inputSaveButton = world.select.name('inputsave');
                        backButton = world.select.name('back');
                        newSaveButton.getModule(Button).enabled = false;
                        inputSaveButton.getModule(Button).enabled = false;
                        backButton.getModule(Button).enabled = false;
                        warningBox = world.addWorldObject(new CloudSaveWarningBox(WARNING_INPUT_SAVE, 300));
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox.result; })];
                    case 1:
                        _a.sent();
                        if (warningBox.result === 'cancel') {
                            newSaveButton.getModule(Button).enabled = true;
                            inputSaveButton.getModule(Button).enabled = true;
                            backButton.getModule(Button).enabled = true;
                            return [2 /*return*/];
                        }
                        global.theater.loadStage(EnterSaveId.STAGE);
                        return [2 /*return*/];
                }
            });
        };
    }
    var CloudSaveWarningBox = /** @class */ (function (_super) {
        __extends(CloudSaveWarningBox, _super);
        function CloudSaveWarningBox(text, maxWidth) {
            if (maxWidth === void 0) { maxWidth = 200; }
            var _this = _super.call(this, {
                x: global.gameWidth / 2, y: global.gameHeight / 2,
            }) || this;
            _this.text = _this.addChild(new SpriteText({
                text: text,
                maxWidth: maxWidth,
                anchor: Vector2.TOP,
                justify: 'center',
                copyFromParent: ['layer'],
            }));
            var width = _this.text.getTextWidth() + 2 * CloudSaveWarningBox.PADDING;
            var height = _this.text.getTextHeight() + 2 * CloudSaveWarningBox.PADDING + 30;
            _this.setTexture(InfoBox.getTextureForSize(width, height));
            _this.text.localy = -height / 2 + CloudSaveWarningBox.PADDING;
            _this.cancelButton = _this.addChild(new MenuTextButton({
                x: -width / 2 + CloudSaveWarningBox.PADDING + 8, y: height / 2 - CloudSaveWarningBox.PADDING,
                text: "Cancel",
                anchor: Vector2.BOTTOM_LEFT,
                copyFromParent: ['layer'],
                onClick: function () {
                    global.game.playSound('click');
                    _this.result = 'cancel';
                    _this.kill();
                }
            }));
            _this.continueButton = _this.addChild(new MenuTextButton({
                x: width / 2 - CloudSaveWarningBox.PADDING - 8, y: height / 2 - CloudSaveWarningBox.PADDING,
                text: "Continue >",
                anchor: Vector2.BOTTOM_RIGHT,
                copyFromParent: ['layer'],
                onClick: function () {
                    global.game.playSound('click');
                    _this.result = 'continue';
                    _this.kill();
                }
            }));
            return _this;
        }
        CloudSaveWarningBox.prototype.update = function () {
            _super.prototype.update.call(this);
            if (Input.justDown(Input.GAME_CLOSE_MENU)) {
                Input.consume(Input.GAME_CLOSE_MENU);
                this.result = 'cancel';
                this.kill();
            }
        };
        CloudSaveWarningBox.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            World.Actions.orderWorldObjectAfter(this.text, this);
            World.Actions.orderWorldObjectAfter(this.cancelButton, this);
            World.Actions.orderWorldObjectAfter(this.continueButton, this);
        };
        CloudSaveWarningBox.PADDING = 6;
        return CloudSaveWarningBox;
    }(Sprite));
    var WARNING_NEW_SAVE = 'NOTE:\n\nThis option will turn on cloud sync. [g]Your save data will NOT be deleted.[/] You can use the same Save ID to sync progress across multiple devices or restore your data if lost. [g]Write down your Save ID somewhere so you can restore your save later.[/] You can disable cloud sync at any time.';
    var WARNING_INPUT_SAVE = 'WARNING:\n\nThis option will turn on cloud sync with an existing save. [r]Your local save data will be merged with whatever data is stored in the cloud[/]. The merge is [r]NOT REVERSIBLE[/].';
    var WARNING_SHOW_SAVE = 'WARNING:\n\nThere is no password protection on saves. Anyone who knows your Save ID can mess with your save data. Do not share your Save ID with anyone.';
    var WARNING_DISABLE_SAVE = 'NOTE:\n\nThis option will turn off cloud sync. [g]Your save data will NOT be deleted.[/]';
    function getSyncedText(synced) {
        return synced ? 'Your save is [g]synced[/]' : 'Your save is [r]not synced[/]';
    }
    "modded_remove_to";
})(CloudSaveScreen || (CloudSaveScreen = {}));
var CreditsMenu = /** @class */ (function (_super) {
    __extends(CreditsMenu, _super);
    function CreditsMenu(oldMenuSnapshot) {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
        }) || this;
        _this.addWorldObject(new Sprite({
            texture: oldMenuSnapshot,
        }));
        var fade = _this.addWorldObject(new Sprite({
            texture: Texture.filledRect(_this.width, _this.height, 0x000000),
            alpha: 0,
        }));
        var objs = _this.addWorldObjects(lciDocumentToWorldObjects('credits/1'));
        objs.forEach(function (obj) { return obj.y += _this.height; });
        var time = 0.2;
        _this.runScript(S.simul.apply(S, __spread([S.tween(time, fade, 'alpha', 0, 1)], objs.map(function (obj) { return S.tween(time, obj, 'y', obj.y, obj.y - _this.height, Tween.Easing.OutQuad); }))));
        var numberOfCreditsMenus = 3;
        var menu = _this;
        _this.runScript(function () {
            var _loop_31, current, state_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _loop_31 = function (current) {
                            var nextButton, clickedNext, next, almanacExperts, i;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        nextButton = menu.select.name("next" + current);
                                        clickedNext = false;
                                        nextButton.addModule(new Button({
                                            hoverTint: 0xFFFF00,
                                            clickTint: 0xBBBB00,
                                            onJustHovered: juiceButton(2),
                                            onClick: function () {
                                                global.game.playSound('click');
                                                this.enabled = false;
                                                clickedNext = true;
                                            },
                                        }));
                                        return [4 /*yield*/, S.waitUntil(function () { return clickedNext; })];
                                    case 1:
                                        _a.sent();
                                        if (current === numberOfCreditsMenus) {
                                            menu.back();
                                            return [2 /*return*/, { value: void 0 }];
                                        }
                                        next = current + 1;
                                        return [4 /*yield*/, S.simul.apply(S, __spread(objs.map(function (obj) { return S.tween(0.2, obj, 'alpha', 1, 0); })))];
                                    case 2:
                                        _a.sent();
                                        World.Actions.removeWorldObjectsFromWorld(objs);
                                        objs = menu.addWorldObjects(lciDocumentToWorldObjects("credits/" + next));
                                        if (next === 3) {
                                            almanacExperts = A.batch(LiveVersion.ALMANAC_EXPERTS, 9);
                                            for (i = 0; i < almanacExperts.length; i++) {
                                                objs.push(menu.addWorldObject(new SpriteText({
                                                    x: M.equidistantLine(menu.width / 2, 90, almanacExperts.length, i), y: 61,
                                                    text: almanacExperts[i].join('\n'),
                                                    style: { color: 0xFFD800 },
                                                    justify: 'center',
                                                    anchor: Vector2.TOP_CENTER,
                                                })));
                                            }
                                        }
                                        objs.forEach(function (obj) { return obj.alpha = 0; });
                                        return [4 /*yield*/, objs.map(function (obj) { return S.tween(0.2, obj, 'alpha', 0, 1); })];
                                    case 3:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        current = 1;
                        _a.label = 1;
                    case 1:
                        if (!(current <= numberOfCreditsMenus)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_31(current)];
                    case 2:
                        state_7 = _a.sent();
                        if (typeof state_7 === "object")
                            return [2 /*return*/, state_7.value];
                        _a.label = 3;
                    case 3:
                        current++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
        global.game.musicManager.volumeScale /= 3;
        return _this;
    }
    CreditsMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_CLOSE_MENU)) {
            Input.consume(Input.GAME_CLOSE_MENU);
            this.back();
        }
    };
    CreditsMenu.prototype.back = function () {
        global.game.musicManager.volumeScale *= 3;
        global.game.menuSystem.back();
    };
    return CreditsMenu;
}(Menu));
var DailyInfoScreen;
(function (DailyInfoScreen) {
    function STAGE() {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        setArenaWorld(Arenas.ARENA_FIRST);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('dailyinfomenu'));
        world.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(DailyScreen.STAGE);
            },
        }));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && this.life.frames > 1 && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.theater.loadStage(DailyScreen.STAGE);
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
            loadPage(world, 'info');
        };
        return world;
    }
    DailyInfoScreen.STAGE = STAGE;
    function loadPage(world, page) {
        world.runScript(function () {
            var box, textx, texty;
            return __generator(this, function (_a) {
                box = world.select.name('box');
                World.Actions.removeWorldObjectsFromWorld(box.children);
                textx = -108;
                texty = -78;
                if (page === 'info') {
                    box.addChild(new SpriteText({
                        x: textx, y: texty,
                        text: "Welcome to Dailies!",
                    }));
                    box.addChild(new SpriteText({
                        x: textx, y: texty + 23,
                        text: "- Everyone faces the same\nopponents and has the same\nshop choices each day",
                    }));
                    box.addChild(new SpriteText({
                        x: textx, y: texty + 76,
                        text: "- You only get one shot!",
                    }));
                    box.addChild(new SpriteText({
                        x: textx, y: texty + 99,
                        text: "- All balls/items are\nunlocked during dailies",
                    }));
                    box.addChild(new MenuTextButton({
                        x: 0, y: 72,
                        text: "Schedule >",
                        anchor: Vector2.CENTER,
                        style: { color: 0xFFD800 },
                        hoverColor: Color.lerpColorByRgb(0xFFD800, 0x000000, 0.5),
                        onClick: function () {
                            global.game.playSound('click');
                            loadPage(world, 'schedule');
                        },
                    }));
                }
                else if (page === 'schedule') {
                    box.addChild(new SpriteText({
                        x: textx, y: texty,
                        text: "Daily Schedule",
                    }));
                    box.addChild(new SpriteText({
                        x: textx, y: texty + 23,
                        text: LiveVersion.DAILY_SCHEDULE.join('\n'),
                    }));
                    box.addChild(new MenuTextButton({
                        x: 0, y: 72,
                        text: "Back >",
                        anchor: Vector2.CENTER,
                        style: { color: 0xFFD800 },
                        hoverColor: Color.lerpColorByRgb(0xFFD800, 0x000000, 0.5),
                        onClick: function () {
                            global.game.playSound('click');
                            global.theater.loadStage(DailyScreen.STAGE);
                        },
                    }));
                }
                return [2 /*return*/];
            });
        });
    }
})(DailyInfoScreen || (DailyInfoScreen = {}));
var DailyScreen;
(function (DailyScreen) {
    function STAGE() {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        "modded_remove_from";
        setArenaWorld(Arenas.ARENA_FIRST);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('dailymenu'));
        if (Random.boolean(0.1)) {
            world.select.name('title').setVisible(false);
            world.select.name('balldle').updateCallback = function () {
                this.angle = Math.sin(2 * this.life.time - 1) * 2;
            };
        }
        else {
            world.select.name('balldle').setVisible(false);
            world.select.name('title').updateCallback = function () {
                this.angle = Math.sin(2 * this.life.time - 1) * 2;
            };
        }
        world.select.name('info').addModule(new Button({
            hoverTint: 0xBBBBBB,
            clickTint: 0x888888,
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(DailyInfoScreen.STAGE);
            },
        }));
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(PlayScreen.STAGE);
            },
        }));
        var storedData = {};
        world.addWorldObject(new SpriteText({
            x: world.width / 2, y: 38,
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: {}, post: { filters: [new DropShadowFilter()] } },
            update: function () {
                if (storedData.nextDailyDate) {
                    this.setText("NEXT DAILY IN: " + secondsToFormattedTime((storedData.nextDailyDate.getTime() - Date.now()) / 1000));
                }
            }
        }));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (storedData.nextDailyDate && Date.now() > storedData.nextDailyDate.getTime()) {
                    storedData = {};
                    loadPage(world, 0, storedData);
                }
            }
        }));
        world.addWorldObject(new BoundsInfoBox(Vector2.BOTTOM_CENTER, 0));
        "modded_remove_to";
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && this.life.frames > 1 && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.theater.loadStage(PlayScreen.STAGE);
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
            "modded_remove_from";
            loadPage(world, 0, storedData);
            "modded_remove_to";
        };
        return world;
    }
    DailyScreen.STAGE = STAGE;
    "modded_remove_from";
    function loadPage(world, relativeDay, storedData) {
        world.runScript(function () {
            var box, spinner, result, daily, err, dateText;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        box = world.select.name('box');
                        World.Actions.removeWorldObjectsFromWorld(box.children);
                        world.select.name('info').setVisible(false);
                        world.select.name('info').setActive(false);
                        spinner = box.addChild(new Spinner(0, 0, 4, 16));
                        result = {};
                        return [4 /*yield*/, getDaily(relativeDay, storedData, result)];
                    case 1:
                        _a.sent();
                        daily = result.daily, err = result.err;
                        if (daily) {
                            daily.results.sort(function (r1, r2) {
                                if (r1.wins < r2.wins)
                                    return 1;
                                if (r1.wins > r2.wins)
                                    return -1;
                                if (r1.health < r2.health)
                                    return 1;
                                if (r1.health > r2.health)
                                    return -1;
                                if (r1.health > 0) {
                                    if (r1.rounds < r2.rounds)
                                        return -1;
                                    if (r1.rounds > r2.rounds)
                                        return 1;
                                }
                                if (r1.health === 0) {
                                    if (r1.rounds < r2.rounds)
                                        return 1;
                                    if (r1.rounds > r2.rounds)
                                        return -1;
                                }
                                if (r1.you)
                                    return -1;
                                if (r2.you)
                                    return 1;
                                return 0;
                            });
                            if (daily.week) {
                                Weekly.set(daily.week);
                            }
                        }
                        spinner.kill();
                        if (relativeDay > -7 && (!storedData.currentDay || storedData.currentDay + relativeDay > 3)) {
                            box.addChild(new MenuTextButton({
                                x: -108, y: -70,
                                text: "\\<",
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                hoverColor: 0xBBBBBB,
                                onClick: function () {
                                    loadPage(world, relativeDay - 1, storedData);
                                },
                            }));
                        }
                        if (relativeDay < 0 || Debug.DEBUG) {
                            box.addChild(new MenuTextButton({
                                x: 108, y: -70,
                                text: ">",
                                anchor: Vector2.CENTER,
                                justify: 'center',
                                hoverColor: 0xBBBBBB,
                                onClick: function () {
                                    loadPage(world, relativeDay + 1, storedData);
                                },
                            }));
                        }
                        else {
                            world.select.name('info').setVisible(relativeDay === 0);
                            world.select.name('info').setActive(relativeDay === 0);
                        }
                        if (err) {
                            console.error('Error fetching daily:', err);
                            box.addChild(new SpriteText({
                                x: 0, y: 0,
                                text: 'Daily not found :(\nPlease try again.',
                                anchor: Vector2.CENTER,
                                justify: 'center',
                            }));
                            return [2 /*return*/];
                        }
                        if (relativeDay >= 0 && daily.version < API.VERSION) {
                            console.log('Warning: Daily made for an earlier version of the game');
                        }
                        storedData.currentDay = daily.day - relativeDay;
                        if (relativeDay === 0) {
                            storedData.nextDailyDate = new Date(Date.now() + daily.timeToNextDailyMs);
                        }
                        dateText = relativeDay === 0 ? 'Today' : transformDailyDate(daily.date);
                        box.addChild(new SpriteText({
                            x: 0, y: -70,
                            text: dateText,
                            anchor: Vector2.CENTER,
                            justify: 'center',
                        }));
                        if (daily.version > API.VERSION) {
                            loadOutdatedVersionPage(box);
                        }
                        else if (relativeDay < 0 || loadLastDailyCompleted() >= daily.day || daily.results.some(function (result) { return result.you; })) {
                            loadLeaderboardPage(box, daily, relativeDay);
                        }
                        else {
                            loadDailyPage(box, daily);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    function loadDailyPage(box, daily) {
        var packData = getPackData(daily.packs);
        var arenaData = getArenaData(daily.arena);
        var iconPadding = 8;
        var packText = box.addChild(new SpriteText({
            x: -iconPadding / 2 - 8, y: -48,
            text: "Pack: " + packData.packName,
            anchor: Vector2.CENTER,
            justify: 'center',
        }));
        var packIcon = box.addChild(getDailyIcon(packText.localx + packText.getTextWidth() / 2 + iconPadding + 8, packText.localy, packData.icon, packData.packName));
        if (_.includes(daily.packs, 'weekly')) {
            var info = box.addChild(new Sprite({
                x: packIcon.localx + 20, y: packIcon.localy - 1,
                texture: 'infoicon',
                bounds: new CircleBounds(0, 0, 8),
            }));
            info.addModule(new Button({
                hoverTint: 0xCCCCCC,
                clickTint: 0x999999,
                onClick: function () {
                    global.game.playSound('click');
                    global.game.menuSystem.loadMenu(function () { return new AlmanacMenu('weekly'); });
                },
            }));
        }
        var arenaText = box.addChild(new SpriteText({
            x: -iconPadding / 2 - 8, y: -28,
            text: "Arena: " + arenaData.arenaName,
            anchor: Vector2.CENTER,
            justify: 'center',
        }));
        box.addChild(getDailyIcon(arenaText.localx + arenaText.getTextWidth() / 2 + iconPadding + 8, arenaText.localy, arenaData.icon, arenaData.arenaName));
        var modifierLabel = box.addChild(new SpriteText({
            text: 'Modifiers: ' + (daily.modifiers.length === 0 ? 'None' : ''),
            anchor: Vector2.CENTER_LEFT,
        }));
        if (daily.modifiers.length === 0) {
            modifierLabel.setText('Modifiers: None');
            modifierLabel.anchor = Vector2.CENTER;
        }
        else {
            var modifierIcons = daily.modifiers.map(function (modifier, i) { return box.addChild(getModifierIcon(modifierLabel.getTextWidth() + 16 + i * 20, 0, modifier)); });
            World.Actions.balanceWorldObjects(__spread([modifierLabel], modifierIcons), box.x - 4, box.y - 8);
        }
        var currentDailyData = loadDailyGameData(daily.day);
        var startDailyText = currentDailyData ? "> Continue Daily \\<" : "> Start Daily \\<";
        box.addChild(new MenuTextButton({
            x: 0, y: 36,
            text: startDailyText,
            anchor: Vector2.CENTER,
            justify: 'center',
            hoverColor: 0xBBBBBB,
            onClick: function () {
                global.game.playSound('click');
                if (currentDailyData) {
                    PlayScreen.startDailyGame(currentDailyData.matchmakingGameData, daily);
                }
                else {
                    API.startdaily(function (_, err) {
                        if (err) {
                            console.error('Failed to start daily:', err);
                            return;
                        }
                    }, daily.day, Persistence.getProfileId(), loadPlayerId(), loadName());
                    var weekly = daily.week ? { week: daily.week } : undefined;
                    PackScreen.startNewGame(daily.arena, daily.packs, weekly, daily.modifiers, false, daily);
                }
            },
        }));
        box.addChild(new SpriteText({
            x: 0, y: 72,
            text: "FINISH THE DAILY TO VIEW TODAY'S LEADERBOARDS",
            font: 'smallnumbers',
            alpha: 0.7,
            anchor: Vector2.CENTER,
            justify: 'center',
        }));
    }
    function loadLeaderboardPage(box, daily, relativeDay) {
        var packData = getPackData(daily.packs);
        var arenaData = getArenaData(daily.arena);
        box.addChild(getDailyIcon(-84, -84, packData.icon, packData.packName));
        box.addChild(getDailyIcon(-64, -84, arenaData.icon, arenaData.arenaName));
        for (var i = 0; i < daily.modifiers.length; i++) {
            box.addChild(getModifierIcon(64 + 20 * i, -84, daily.modifiers[i]));
        }
        if (_.isEmpty(daily.results)) {
            box.addChild(new SpriteText({
                x: 0, y: 0,
                text: 'No results \:(',
                anchor: Vector2.CENTER,
                justify: 'center',
            }));
            return;
        }
        var resultsObj = box.addChild(new WorldObject({ y: -58 }));
        var boxBounds = box.getWorldBounds();
        var maskBounds = rect(boxBounds.left, boxBounds.top + 23, boxBounds.width, boxBounds.height - 23 - 6);
        var mask = {
            offsetx: maskBounds.x,
            offsety: maskBounds.y,
            texture: Texture.filledRect(maskBounds.width, maskBounds.height, 0xFFFFFF),
            type: 'world',
        };
        var dailySquadInfoBox = box.addChild(new DailySquadInfoBox(maskBounds));
        var resultsTexts = [];
        var place = 1;
        for (var i = 0; i < daily.results.length; i++) {
            var result = daily.results[i];
            if (i > 0 && (result.wins !== daily.results[i - 1].wins || result.health !== daily.results[i - 1].health || result.rounds !== daily.results[i - 1].rounds)) {
                place = i + 1;
            }
            var placeText = St.padLeft("" + place, 2, ' ');
            var player = St.padRight(result.player, 14, ' ');
            var color = result.you ? '0xFFD800' : '0xFFFFFF';
            var text = new SpriteText({
                x: -108, y: 16 * i,
                text: "[color " + color + "]\\" + placeText + " " + player + "[/color] [gold]<trophy>[/gold]" + result.wins + " [r]<heart>[/r]" + result.health + " [rb]R[/rb]" + result.rounds,
                mask: mask,
                data: {
                    entry: i,
                    squad: result.squad,
                },
                update: function () {
                    this.alpha = dailySquadInfoBox.currentText === this ? 0.65 : 1;
                },
            });
            text.data.bounds = new RectBounds(0, -1, 216, 18, text);
            resultsObj.addChild(text);
            resultsTexts.push(text);
            if (place === 1 && result.you && relativeDay < 0) {
                updateAchievementProgress('NumberOne', function (p) { return 1; });
            }
        }
        if (resultsTexts.length > 8) {
            var totalEntriesHeight_1 = 15 * resultsTexts.length + 50;
            var startY_1 = resultsObj.y;
            var scrollBar = box.addChild(new ScrollBar(124, -81, 'dailyscrollbar', totalEntriesHeight_1, 48, function (p) { return resultsObj.y = startY_1 - (totalEntriesHeight_1 - maskBounds.height) * p; }));
            scrollBar.effects.addOutline.color = 0xFFFFFF;
            box.addChild(new DragScroller(scrollBar, totalEntriesHeight_1, maskBounds));
        }
    }
    function loadOutdatedVersionPage(box) {
        box.addChild(new SpriteText({
            x: 0, y: 0,
            text: 'This daily is for a newer\nversion of the game! \:o\n\n(Try refreshing!)',
            anchor: Vector2.CENTER,
            justify: 'center',
        }));
        return;
    }
    var DAILY_CACHE = {};
    function getDaily(relativeDay, storedData, result) {
        return function () {
            var daily, err, callDone, startTime, elapsedTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(storedData.currentDay !== undefined && (storedData.currentDay + relativeDay) in DAILY_CACHE)) return [3 /*break*/, 2];
                        result.daily = DAILY_CACHE[storedData.currentDay + relativeDay];
                        return [4 /*yield*/, S.wait(1)];
                    case 1:
                        _a.sent(); // :)
                        return [2 /*return*/];
                    case 2:
                        callDone = false;
                        API.getdaily(function (response, e) {
                            daily = response;
                            err = e;
                            callDone = true;
                            debug('Received daily:', response);
                        }, relativeDay, Persistence.getProfileId(), loadPlayerId(), getAllowProfaneSquadNames());
                        startTime = Date.now();
                        return [4 /*yield*/, S.waitUntil(function () { return callDone || Date.now() - startTime > 5000; })];
                    case 3:
                        _a.sent();
                        if (!callDone) {
                            err = ERROR_TIMED_OUT;
                        }
                        elapsedTime = (Date.now() - startTime) / 1000;
                        return [4 /*yield*/, S.wait(1 - elapsedTime)];
                    case 4:
                        _a.sent(); // :)
                        if (daily && !err && relativeDay < 0) {
                            DAILY_CACHE[daily.day] = daily;
                        }
                        result.daily = daily;
                        result.err = err;
                        return [2 /*return*/];
                }
            });
        };
    }
    "modded_remove_to";
    function getPackData(packs) {
        if (packs.length === 1)
            return { packName: packIdToName(packs[0]), icon: "dailyicons/pack/" + packs[0] };
        if (packs.length === OFFICIAL_PACKS.length && OFFICIAL_PACKS.every(function (pack) { return _.contains(packs, pack); }))
            return { packName: 'All', icon: "dailyicons/pack/all" };
        return { packName: 'Multiple', icon: "dailyicons/pack/all" };
    }
    function getArenaData(arena) {
        if (_.contains(Arenas.ARENAS, arena))
            return { arenaName: arenaIdToName(arena), icon: "dailyicons/arena/" + arena };
        return { arenaName: 'Unknown', icon: "dailyicons/arena/first" };
    }
})(DailyScreen || (DailyScreen = {}));
function getDailyIcon(x, y, iconTexture, description) {
    var icon = new Sprite({
        x: x, y: y,
        texture: iconTexture,
        bounds: new RectBounds(-8, -8, 16, 16),
        tags: [Tags.MODIFIER_ICON],
        data: { infoBoxDescription: description },
        effects: { outline: { color: 0x000000 } },
    });
    icon.addModule(new Button({
        onHover: function () {
            icon.effects.outline.color = 0xFFFF00;
        },
        onUnhover: function () {
            icon.effects.outline.color = 0x000000;
        },
    }));
    return icon;
}
function getModifierIcon(x, y, modifier) {
    return getDailyIcon(x, y, getModifierIconTexture(modifier), getModifierDescription(modifier));
}
var EnterGameCode;
(function (EnterGameCode) {
    var CODE_LENGTH = 4;
    function STAGE_VERSUS() {
        return STAGE(false);
    }
    EnterGameCode.STAGE_VERSUS = STAGE_VERSUS;
    function STAGE_SPECTATE() {
        return STAGE(true);
    }
    EnterGameCode.STAGE_SPECTATE = STAGE_SPECTATE;
    function STAGE(spectate) {
        var world = new World();
        var enterGameIdY = IS_MOBILE ? 28 : 80;
        var gameIdTextY = IS_MOBILE ? 68 : 120;
        var joinButtonTextThingY = IS_MOBILE ? 108 : 160;
        var errorTextY = IS_MOBILE ? 108 : 212;
        var rejoinTextY = IS_MOBILE ? 108 : 212;
        world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: enterGameIdY,
            text: spectate ? 'Enter GAME ID to spectate:' : 'Enter GAME ID:',
            anchor: Vector2.TOP_CENTER,
        }));
        var enteredCode = '';
        var gameIdText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: gameIdTextY,
            text: '_',
            anchor: Vector2.TOP_CENTER,
            update: function () {
                if (this.life.time > 0.1)
                    updateChars(typeChar);
            },
        }));
        var joinButtonTextThing;
        if (IS_MOBILE) {
            joinButtonTextThing = world.addWorldObject(new SpriteText({
                x: global.gameWidth / 2 - 44, y: joinButtonTextThingY,
                text: "",
                anchor: Vector2.CENTER_LEFT,
            }));
            world.addWorldObject(new Keyboard(global.gameWidth / 2, 186, typeChar, 'gameid'));
        }
        else {
            joinButtonTextThing = world.addWorldObject(new MenuTextButton({
                x: global.gameWidth / 2 - 44, y: joinButtonTextThingY,
                text: "join game >",
                onClick: function () {
                    submitCode();
                },
            }));
        }
        var errorText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: errorTextY,
            text: '',
            anchor: Vector2.CENTER,
            justify: 'center',
            style: { color: 0xBB0000 },
        }));
        var rejoinText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: rejoinTextY,
            text: '',
            font: 'smallnumbers',
            anchor: Vector2.CENTER,
            justify: 'center',
            style: { color: 0xBB0000 },
        }));
        world.addWorldObject(new MenuTextButton({
            name: 'backbutton',
            x: 4, y: global.gameHeight - 18,
            text: "\\< back",
            onClick: function () {
                Input.preventRegularKeyboardInput = false;
                global.theater.loadStage(function () { return VSModeScreen.STAGE(loadVsSettings()); });
                global.game.playSound('click');
            }
        }));
        world.onTransitioned = function () {
            global.game.stopMusic();
            Input.preventRegularKeyboardInput = true;
            var lastVsGame = loadVersusModeGameData({ type: 'last' });
            if (lastVsGame && !spectate) {
                enteredCode = lastVsGame.gameData.gameId;
                gameIdText.setText(St.replaceAll(enteredCode, ' ', '\\ ') + "_");
            }
        };
        function submitCode() {
            global.game.playSound('click');
            if (enteredCode.length < CODE_LENGTH) {
                // Pass
            }
            else {
                disable();
                errorText.setText('');
                rejoinText.setText('');
                world.runScript(attemptJoin(world, enteredCode, spectate, joinButtonTextThing, handleJoinError));
            }
        }
        function glitch() {
            world.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            world.playSound('arg/glitch_short_low');
                            world.effects.post.filters.push(new TextureFilters.Tint(0xFF0000));
                            world.effects.glitch.enabled = true;
                            world.effects.glitch.strength = 4;
                            world.effects.glitch.speed = 0.5;
                            world.effects.glitch.spread = 4;
                            return [4 /*yield*/, S.wait(0.1)];
                        case 1:
                            _a.sent();
                            world.effects.glitch.strength = 1;
                            world.effects.glitch.spread = 8;
                            return [2 /*return*/];
                    }
                });
            });
        }
        function unglitch() {
            var i = world.effects.post.filters.findIndex(function (f) { return f instanceof TextureFilters.Tint; });
            if (i >= 0) {
                world.effects.post.filters.splice(i, 1);
            }
            world.effects.glitch.enabled = false;
        }
        function resetWithError(error) {
            var _a;
            rejoinText.setText('');
            errorText.setText(error);
            joinButtonTextThing.style.color = 0xFFFFFF;
            joinButtonTextThing.setText(IS_MOBILE ? "" : "join game >");
            (_a = world.select.name('joinspinner', false)) === null || _a === void 0 ? void 0 : _a.kill();
            enable();
        }
        function handleJoinError(err) {
            if (!err)
                return;
            if (err === 'GAME_DOES_NOT_EXIST') {
                resetWithError("Game does not exist");
            }
            else if (err === 'VERSION_MISMATCH') {
                resetWithError("Version mismatch");
            }
            else if (err === 'GAME_ENDED') {
                resetWithError("The game has already ended");
            }
            else if (err === 'GAME_IN_PROGRESS') {
                resetWithError("Game is in progress");
            }
            else if (err === 'SAME_NAME_AS_HOST') {
                resetWithError("Cannot join with the same name as the host");
            }
            else if (err === 'SAME_PROFILE_AS_HOST') {
                resetWithError("You are already the host of this game");
            }
            else {
                resetWithError("An error occurred");
            }
        }
        function disable() {
            var e_211, _a;
            try {
                for (var _b = __values(world.select.modules(Button)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var b = _c.value;
                    b.enabled = false;
                }
            }
            catch (e_211_1) { e_211 = { error: e_211_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_211) throw e_211.error; }
            }
            gameIdText.setActive(false);
        }
        function enable() {
            var e_212, _a;
            try {
                for (var _b = __values(world.select.modules(Button)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var b = _c.value;
                    b.enabled = true;
                }
            }
            catch (e_212_1) { e_212 = { error: e_212_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_212) throw e_212.error; }
            }
            gameIdText.setActive(true);
        }
        function typeChar(char) {
            if (char === 'Backspace') {
                if (enteredCode.length > 0) {
                    enteredCode = enteredCode.substring(0, enteredCode.length - 1);
                    global.game.playSound('typename');
                    unglitch();
                }
            }
            else if (char === 'Enter') {
                submitCode();
            }
            else if (char === 'Escape') {
                Input.consume(Input.GAME_CLOSE_MENU);
                Input.preventRegularKeyboardInput = false;
                global.theater.loadStage(function () { return VSModeScreen.STAGE(loadVsSettings()); });
            }
            else {
                if (enteredCode.length < CODE_LENGTH) {
                    enteredCode += char;
                    global.game.playSound('typename');
                    if (enteredCode === 'BETA' && !spectate && !IS_MOBILE) {
                        glitch();
                    }
                }
            }
            gameIdText.setText(St.replaceAll(enteredCode, ' ', '\\ ') + "_");
        }
        return world;
    }
    function attemptJoin(world, gameid, spectate, joinButtonTextThing, errorCallback) {
        return function () {
            var joinButtonBounds, joinSpinner, frameRate, err_1, callDone_1, startTime_1, err_2, game_1, startTime_2, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        joinButtonTextThing.style.color = 0x666666;
                        joinButtonTextThing.setText("joining...");
                        joinButtonBounds = joinButtonTextThing.getTextWorldBounds();
                        joinSpinner = world.addWorldObject(new Spinner(joinButtonBounds.x - 10, joinButtonBounds.y + 7, 1.5, 4));
                        joinSpinner.name = 'joinspinner';
                        return [4 /*yield*/, S.wait(1)];
                    case 1:
                        _a.sent();
                        if (gameid === 'BETA' && !spectate && !IS_MOBILE) {
                            Input.preventRegularKeyboardInput = false;
                            if (GAME_DATA.arg2Trigger)
                                GAME_DATA.arg2Trigger.strategy = false;
                            global.theater.playCutscene(ARG.Cutscenes.BEGIN_ARG_2);
                            return [2 /*return*/];
                        }
                        if (!!spectate) return [3 /*break*/, 3];
                        frameRate = Persistence.getAverageFrameRate();
                        callDone_1 = false;
                        API.joinvsgame(function (_, e) {
                            err_1 = e;
                            callDone_1 = true;
                        }, gameid, loadName(), getAvailableBallTypesOnlyUnlocked(), getAvailableItemTypesOnlyUnlocked(), frameRate === 0 ? 1 / 60 : 1 / frameRate, Persistence.getProfileId());
                        startTime_1 = Date.now();
                        return [4 /*yield*/, S.waitUntil(function () { return callDone_1 || Date.now() - startTime_1 > 5000; })];
                    case 2:
                        _a.sent();
                        if (!callDone_1) {
                            err_1 = ERROR_TIMED_OUT;
                        }
                        if (err_1) {
                            console.error('Failed to join game:', err_1);
                            errorCallback(err_1);
                            return [2 /*return*/];
                        }
                        debug('Joined VS game:', gameid);
                        _a.label = 3;
                    case 3:
                        joinButtonTextThing.setText("fetching game\ndetails...");
                        return [4 /*yield*/, S.wait(1)];
                    case 4:
                        _a.sent();
                        if (!spectate) return [3 /*break*/, 7];
                        API.getvsgame(function (result, e) {
                            err_2 = e;
                            game_1 = result;
                        }, gameid, loadName(), spectate, true, Persistence.getProfileId());
                        startTime_2 = Date.now();
                        return [4 /*yield*/, S.waitUntil(function () { return game_1 || err_2 || Date.now() - startTime_2 > 5000; })];
                    case 5:
                        _a.sent();
                        if (!game_1 && !err_2) {
                            err_2 = ERROR_TIMED_OUT;
                        }
                        if (err_2) {
                            console.error('Failed to get VS game details:', err_2);
                            errorCallback(err_2);
                            return [2 /*return*/];
                        }
                        debug('Got VS game details:', gameid, game_1);
                        if (!game_1.enemyname) {
                            joinButtonTextThing.setText("waiting for\nplayers to\njoin...");
                            world.select.name('backbutton').enabled = true;
                        }
                        return [4 /*yield*/, S.wait(2)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        result = {};
                        return [4 /*yield*/, GameFragments.waitForVSGameCondition(gameid, loadName(), spectate, function (game) { return game.enemyname; }, result, function (err) { return errorCallback(err ? 'An error occurred' : ''); })];
                    case 8:
                        _a.sent();
                        GameFragments.startVsGame(gameid, result.game, true, spectate);
                        return [2 /*return*/];
                }
            });
        };
    }
    function updateChars(callback) {
        for (var char in CHARS_DOWN) {
            var oldDown = CHARS_DOWN[char];
            var newDown = Input.isKeyCodeDown(char);
            if (newDown && !oldDown) {
                if (char.length === 1) {
                    callback(char.toUpperCase());
                }
                else {
                    callback(char);
                }
            }
            CHARS_DOWN[char] = newDown;
        }
    }
    var CHARS_DOWN = {
        'a': false, 'b': false, 'c': false, 'd': false, 'e': false, 'f': false, 'g': false, 'h': false, 'i': false, 'j': false, 'k': false, 'l': false, 'm': false,
        'n': false, 'o': false, 'p': false, 'q': false, 'r': false, 's': false, 't': false, 'u': false, 'v': false, 'w': false, 'x': false, 'y': false, 'z': false,
        '0': false, '1': false, '2': false, '3': false, '4': false, '5': false, '6': false, '7': false, '8': false, '9': false,
        'Backspace': false, 'Enter': false, 'Escape': false,
    };
})(EnterGameCode || (EnterGameCode = {}));
var EnterSaveId;
(function (EnterSaveId) {
    var ID_LENGTH = 8;
    function STAGE() {
        var world = new World();
        var enterSaveIdY = IS_MOBILE ? 28 : 80;
        var saveIdTextY = IS_MOBILE ? 68 : 120;
        var useButtonTextThingY = IS_MOBILE ? 108 : 160;
        var errorTextY = IS_MOBILE ? 108 : 212;
        world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: enterSaveIdY,
            text: 'Enter SAVE ID:',
            anchor: Vector2.TOP_CENTER,
        }));
        var enteredId = '';
        var saveIdText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: saveIdTextY,
            text: '_',
            anchor: Vector2.TOP_CENTER,
            update: function () {
                if (this.life.time > 0.1)
                    updateChars(typeChar);
            },
        }));
        var useButtonTextThing;
        if (IS_MOBILE) {
            useButtonTextThing = world.addWorldObject(new SpriteText({
                x: global.gameWidth / 2 - 44, y: useButtonTextThingY,
                text: "",
                anchor: Vector2.CENTER_LEFT,
            }));
            world.addWorldObject(new Keyboard(global.gameWidth / 2, 186, typeChar, 'gameid'));
        }
        else {
            useButtonTextThing = world.addWorldObject(new MenuTextButton({
                x: global.gameWidth / 2 - 44, y: useButtonTextThingY,
                text: "use save id >",
                onClick: function () {
                    submitId();
                },
            }));
        }
        var errorText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: errorTextY,
            text: '',
            anchor: Vector2.CENTER,
            justify: 'center',
            style: { color: 0xBB0000 },
        }));
        world.addWorldObject(new MenuTextButton({
            x: 4, y: global.gameHeight - 18,
            text: "\\< back",
            onClick: function () {
                Input.preventRegularKeyboardInput = false;
                global.theater.loadStage(function () { return CloudSaveScreen.STAGE(); });
                global.game.playSound('click');
            }
        }));
        world.onTransitioned = function () {
            global.game.stopMusic();
            Input.preventRegularKeyboardInput = true;
        };
        function submitId() {
            global.game.playSound('click');
            if (enteredId.length < ID_LENGTH) {
                // Pass
            }
            else {
                disable();
                errorText.setText('');
                world.runScript(attemptUse(world, enteredId, useButtonTextThing, handleUseError));
            }
        }
        function resetWithError(error) {
            var _a;
            errorText.setText(error);
            useButtonTextThing.style.color = 0xFFFFFF;
            useButtonTextThing.setText(IS_MOBILE ? "" : "use save id >");
            (_a = world.select.name('usespinner', false)) === null || _a === void 0 ? void 0 : _a.kill();
            enable();
        }
        function handleUseError(err) {
            if (!err)
                return;
            if (err === 'NOT_FOUND') {
                resetWithError("Save does not exist");
            }
            else {
                resetWithError("An error occurred");
            }
        }
        function disable() {
            var e_213, _a;
            try {
                for (var _b = __values(world.select.modules(Button)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var b = _c.value;
                    b.enabled = false;
                }
            }
            catch (e_213_1) { e_213 = { error: e_213_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_213) throw e_213.error; }
            }
            saveIdText.setActive(false);
        }
        function enable() {
            var e_214, _a;
            try {
                for (var _b = __values(world.select.modules(Button)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var b = _c.value;
                    b.enabled = true;
                }
            }
            catch (e_214_1) { e_214 = { error: e_214_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_214) throw e_214.error; }
            }
            saveIdText.setActive(true);
        }
        function typeChar(char) {
            if (char === 'Backspace') {
                if (enteredId.length > 0) {
                    enteredId = enteredId.substring(0, enteredId.length - 1);
                    global.game.playSound('typename');
                }
            }
            else if (char === 'Enter') {
                submitId();
            }
            else if (char === 'Escape') {
                Input.consume(Input.GAME_CLOSE_MENU);
                Input.preventRegularKeyboardInput = false;
                global.theater.loadStage(function () { return CloudSaveScreen.STAGE(); });
            }
            else {
                if (enteredId.length < ID_LENGTH) {
                    enteredId += char;
                    global.game.playSound('typename');
                }
            }
            saveIdText.setText(St.replaceAll(enteredId, ' ', '\\ ') + "_");
        }
        return world;
    }
    EnterSaveId.STAGE = STAGE;
    function attemptUse(world, saveId, useButtonTextThing, errorCallback) {
        return function () {
            var useButtonBounds, spinner, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        useButtonTextThing.style.color = 0x666666;
                        useButtonTextThing.setText("loading save...");
                        useButtonBounds = useButtonTextThing.getTextWorldBounds();
                        spinner = world.addWorldObject(new Spinner(useButtonBounds.x - 10, useButtonBounds.y + 7, 1.5, 4));
                        spinner.name = 'usespinner';
                        getResult = { saveResponse: undefined, err: undefined, done: false };
                        "modded_remove_from";
                        return [4 /*yield*/, waitWithTimeout(5000, getResult, function () { return API.getsave(function (saveResponse, err) {
                                getResult.saveResponse = saveResponse;
                                getResult.err = err;
                                getResult.done = true;
                            }, saveId, Persistence.getProfileId()); })];
                    case 1:
                        _a.sent();
                        "modded_remove_to";
                        return [4 /*yield*/, S.wait(2)];
                    case 2:
                        _a.sent();
                        if (getResult.err) {
                            console.error('Failed to get save data:', getResult.err);
                            errorCallback(getResult.err);
                            return [2 /*return*/];
                        }
                        debug('Got save:', saveId);
                        createSaveInfo(saveId, getResult.saveResponse.saveTime);
                        mergeCloudSaveDataEncodedToLocal(getResult.saveResponse.saveData);
                        global.theater.loadStage(CloudSaveScreen.STAGE, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
                        return [2 /*return*/];
                }
            });
        };
    }
    function updateChars(callback) {
        for (var char in CHARS_DOWN) {
            var oldDown = CHARS_DOWN[char];
            var newDown = Input.isKeyCodeDown(char);
            if (newDown && !oldDown) {
                if (char.length === 1) {
                    callback(char.toUpperCase());
                }
                else {
                    callback(char);
                }
            }
            CHARS_DOWN[char] = newDown;
        }
    }
    var CHARS_DOWN = {
        'a': false, 'b': false, 'c': false, 'd': false, 'e': false, 'f': false, 'g': false, 'h': false, 'i': false, 'j': false, 'k': false, 'l': false, 'm': false,
        'n': false, 'o': false, 'p': false, 'q': false, 'r': false, 's': false, 't': false, 'u': false, 'v': false, 'w': false, 'x': false, 'y': false, 'z': false,
        '0': false, '1': false, '2': false, '3': false, '4': false, '5': false, '6': false, '7': false, '8': false, '9': false,
        'Backspace': false, 'Enter': false, 'Escape': false,
    };
})(EnterSaveId || (EnterSaveId = {}));
var EnterYourName;
(function (EnterYourName) {
    var MAX_NAME_LENGTH = 14;
    var lectvsNameMessages = [
        "(Hey, that's my name!)",
        "(Come on, as the dev, I should get\nmy own name reserved, right?)",
        "(Seriously? It's MY name.\nNot YOUR name.)",
        "(How else will people know they're\nplaying against me??)",
        "(...  :|)",
        "(...  :|)",
        "(...  :|)",
        "(... >:|)",
        "(...fine. you can play as \"lectvs\"...)",
        "(...but you'd better build a good\nsquad for me! >:])",
    ];
    function STAGE(source) {
        var world = new World();
        var enterYourNameY = IS_MOBILE ? 28 : 80;
        var nameTextY = IS_MOBILE ? 68 : 120;
        world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: enterYourNameY,
            text: 'Enter your name:',
            anchor: Vector2.TOP_CENTER,
        }));
        var enteredName = '';
        var nameText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: nameTextY,
            text: '_',
            anchor: Vector2.TOP_CENTER,
            update: function () {
                if (this.life.time > 0.1)
                    updateChars(typeChar);
            },
        }));
        if (IS_MOBILE) {
            world.addWorldObject(new Keyboard(global.gameWidth / 2, 160, typeChar, 'full'));
        }
        else {
            world.addWorldObject(new MenuTextButton({
                x: global.gameWidth / 2, y: 160,
                text: "that's me! >",
                anchor: Vector2.TOP_CENTER,
                onClick: function () {
                    submitName();
                }
            }));
        }
        var reservedTimes = 0;
        var blankClicks = 0;
        var errorText = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2, y: 212,
            text: '',
            anchor: Vector2.CENTER,
            justify: 'center',
            style: { color: 0x0094FF },
        }));
        world.onTransitioned = function () {
            global.game.stopMusic();
            Input.preventRegularKeyboardInput = true;
            var name = loadName();
            if (name) {
                enteredName = name;
                nameText.setText(St.replaceAll(enteredName, ' ', '\\ ') + "_");
            }
        };
        function submitName() {
            global.game.playSound('click');
            if (enteredName.length === 0) {
                blankClicks++;
                if (blankClicks < 4)
                    return;
                enteredName = 'Guest';
            }
            if (enteredName.trim() === 'lectvs' && reservedTimes < lectvsNameMessages.length && !IS_MOBILE && !Input.isKeyCodeDown('Shift')) {
                resetWithError(lectvsNameMessages[reservedTimes]);
                reservedTimes++;
                return;
            }
            if (enteredName.trim() === '69' && !IS_MOBILE) {
                resetWithError('(Nice.)');
                return;
            }
            saveName(enteredName);
            Input.preventRegularKeyboardInput = false;
            global.theater.loadStage(PlayScreen.STAGE, new Transitions.Curtains({ inTime: 0.2, midTime: 1, outTime: 0.5 }));
        }
        function typeChar(char) {
            if (char === 'Backspace') {
                if (enteredName.length > 0) {
                    enteredName = enteredName.substring(0, enteredName.length - 1);
                    global.game.playSound('typename');
                }
            }
            else if (char === 'Enter') {
                submitName();
            }
            else if (char === 'Escape') {
                back();
            }
            else {
                if (enteredName.length < MAX_NAME_LENGTH) {
                    enteredName += char;
                    global.game.playSound('typename');
                }
            }
            nameText.setText(St.replaceAll(enteredName, ' ', '\\ ') + "_");
        }
        function resetWithError(error) {
            errorText.setText(error);
            enteredName = '';
            nameText.setText('_');
        }
        function back() {
            Input.preventRegularKeyboardInput = false;
            if (source === 'mainmenu') {
                global.game.loadMainMenu();
            }
            else if (source === 'playscreen') {
                global.theater.loadStage(PlayScreen.STAGE);
            }
        }
        return world;
    }
    EnterYourName.STAGE = STAGE;
    function updateChars(callback) {
        for (var char in CHARS_DOWN) {
            var oldDown = CHARS_DOWN[char];
            var newDown = Input.isKeyCodeDown(char);
            if (newDown && !oldDown) {
                if (Input.isKeyCodeDown('Shift') && char.length === 1) {
                    callback(char.toUpperCase());
                }
                else {
                    callback(char);
                }
            }
            CHARS_DOWN[char] = newDown;
        }
    }
    var CHARS_DOWN = {
        'a': false, 'b': false, 'c': false, 'd': false, 'e': false, 'f': false, 'g': false, 'h': false, 'i': false, 'j': false, 'k': false, 'l': false, 'm': false,
        'n': false, 'o': false, 'p': false, 'q': false, 'r': false, 's': false, 't': false, 'u': false, 'v': false, 'w': false, 'x': false, 'y': false, 'z': false,
        '0': false, '1': false, '2': false, '3': false, '4': false, '5': false, '6': false, '7': false, '8': false, '9': false, ' ': false,
        'Backspace': false, 'Enter': false, 'Escape': false,
    };
})(EnterYourName || (EnterYourName = {}));
var LoadMenu = /** @class */ (function (_super) {
    __extends(LoadMenu, _super);
    function LoadMenu() {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 1,
        }) || this;
        var spinner = _this.addWorldObject(new Spinner(global.gameWidth / 2, global.gameHeight / 2 + 40, 2, 8));
        spinner.setVisible(false);
        var logo = _this.addWorldObject(new Sprite({
            x: global.gameWidth / 2, y: global.gameHeight / 2,
            texture: 'lectvslogo',
            effects: { post: { filters: [new Effects.Filters.Glitch(4, 1, 2)] } },
            visible: false,
        }));
        var world = _this;
        _this.runScript(function () {
            var sound;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!Debug.DEBUG) return [3 /*break*/, 2];
                        return [4 /*yield*/, S.waitUntil(function () { return LoadMenu.HAS_LOADED(); })];
                    case 1:
                        _a.sent();
                        global.game.loadMainMenu();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, S.wait(0.5)];
                    case 3:
                        _a.sent();
                        world.playSound('glitch');
                        logo.setVisible(true);
                        return [4 /*yield*/, S.wait(0.25)];
                    case 4:
                        _a.sent();
                        logo.effects.post.filters[0].enabled = false;
                        async(function () {
                            var mm = new MainMenu();
                            _MENUS_ARENA_WORLD.allowSounds = false;
                            global.game.musicManager.stopMusic();
                            mm.update();
                            _MENUS_ARENA_WORLD.allowSounds = true;
                            mm.render(Texture.NOOP, 0, 0);
                        });
                        return [4 /*yield*/, S.wait(1.5)];
                    case 5:
                        _a.sent();
                        if (!!LoadMenu.HAS_LOADED()) return [3 /*break*/, 7];
                        spinner.setVisible(true);
                        return [4 /*yield*/, S.waitUntil(function () { return LoadMenu.HAS_LOADED(); })];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        sound = world.playSound('glitch');
                        spinner.setVisible(false);
                        logo.effects.post.filters[0].enabled = true;
                        return [4 /*yield*/, S.wait(0.25)];
                    case 8:
                        _a.sent();
                        sound.stop();
                        logo.setVisible(false);
                        return [4 /*yield*/, S.wait(0.75)];
                    case 9:
                        _a.sent();
                        global.game.loadMainMenu();
                        return [2 /*return*/];
                }
            });
        });
        return _this;
    }
    LoadMenu.HAS_LOADED = function () {
        return CloudSave.hasLoaded && LiveVersion.hasLoaded && Weekly.hasLoaded;
    };
    return LoadMenu;
}(Menu));
var DONE_YAY = false;
var MainMenu = /** @class */ (function (_super) {
    __extends(MainMenu, _super);
    function MainMenu() {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 1,
        }) || this;
        loadAchievementsProgress();
        loadAlmanacEntries();
        loadSheens();
        loadEquipmentTypesToItemTypes();
        Arenas.loadArenaPolarizationFootprints();
        Main.fixedDelta = undefined;
        GAME_MODE = 'mm';
        setArenaWorld(Arenas.ARENA_FIRST);
        _this.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        _this.addWorldObjects(lciDocumentToWorldObjects('mainmenu'));
        if (IS_MODDED) {
            _this.addWorldObject(new SpriteText({
                x: 2,
                text: "MODDED",
                style: { color: 0xFF0000 },
            }));
        }
        else if (Debug.DEBUG) {
            _this.addWorldObject(new SpriteText({
                x: 2,
                text: "DEBUG",
                style: { color: 0xFF0000 },
            }));
        }
        var visibleMinorVersion = _this.addWorldObject(new SpriteText({
            x: global.gameWidth - 3, y: 13,
            text: "[minorverx]." + API.VISIBLE_MINOR_VERSION + "[/minorverx]",
            font: 'smallnumbers',
            anchor: Vector2.BOTTOM_RIGHT,
        }));
        _this.addWorldObject(new SpriteText({
            x: global.gameWidth - 3 - visibleMinorVersion.getTextWidth(), y: 16,
            text: "[verx]v" + API.VISIBLE_CORE_VERSION + "[/verx]." + API.VISIBLE_MAJOR_VERSION,
            anchor: Vector2.BOTTOM_RIGHT,
        }));
        _this.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 5;
        };
        _this.select.name('title_bday').setVisible(false);
        if (LiveVersion.BDAY) {
            _this.select.name('title').setTexture(_this.select.name('title_bday').getTexture());
            _this.select.name('title').effects.post.filters.push(new HueSpinFilter());
            _this.addWorldObject(new BdayShower());
            if (!DONE_YAY) {
                global.game.playSound('yay').volume = 0.5;
                global.game.playSound('achievement').volume = 0.6;
                DONE_YAY = true;
            }
        }
        if (LiveVersion.APRIL_FOOLS) {
            _this.select.name('title').flipX = true;
        }
        _this.select.name('play').updateCallback = function () {
            this.angle = Math.sin(4 * this.life.time + 12) * 3;
        };
        _this.select.name('play').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                resetData();
                if (loadName()) {
                    global.game.startGame(PlayScreen.STAGE);
                }
                else {
                    global.game.startGame(function () { return EnterYourName.STAGE('mainmenu'); });
                }
            },
        }));
        _this.select.name('howtoplay').updateCallback = function () {
            this.angle = Math.sin(4 * this.life.time + 1) * 3;
        };
        _this.select.name('howtoplay').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('howToPlay', true);
                _this.select.name('howtoplay').effects.post.filters = [];
                global.game.menuSystem.loadMenu(function () { return new TutorialMenu(); });
            },
        }));
        if (shouldSheen('howToPlay')) {
            _this.select.name('howtoplay').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        _this.select.name('unlockables').updateCallback = function () {
            this.angle = Math.sin(4 * this.life.time + 2) * 2.5;
        };
        _this.select.name('unlockables').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('unlockables', true);
                _this.select.name('unlockables').effects.post.filters = [];
                global.game.menuSystem.loadMenu(function () { return new AchievementsMenu(); });
            },
        }));
        if (shouldSheen('unlockables')) {
            _this.select.name('unlockables').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        _this.select.name('almanac').updateCallback = function () {
            this.angle = Math.sin(4 * this.life.time + 3) * 2.5;
        };
        _this.select.name('almanac').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('almanac', true);
                _this.select.name('almanac').effects.post.filters = [];
                global.game.menuSystem.loadMenu(function () { return new AlmanacMenu('classic'); });
            },
        }));
        if (shouldSheen('almanac')) {
            _this.select.name('almanac').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        _this.select.name('credits').updateCallback = function () {
            this.angle = Math.sin(4 * this.life.time + 4) * 3;
        };
        _this.select.name('credits').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.loadMenu(function () { return new CreditsMenu(_this.takeSnapshot()); });
            },
        }));
        if (IS_MOBILE) {
            _this.select.name('googleplay').setVisible(false);
        }
        else {
            _this.select.name('googleplay').updateCallback = function () {
                this.angle = Math.sin(4 * this.life.time + 5) * 2.5;
            };
            _this.select.name('googleplay').addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                onJustHovered: juiceButton(1),
                onClick: function () {
                    global.game.playSound('click');
                    window.open('https://play.google.com/store/apps/details?id=net.lectvs.autoballs', '_blank');
                },
            }));
        }
        var gear = _this.addWorldObject(new Sprite({
            x: 14, y: _this.height - 14,
            texture: 'gear',
            bounds: new CircleBounds(0, 0, 11),
        }));
        gear.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.loadMenu(function () { return new OptionsMenu(); });
            },
        }));
        _this.select.name('follow').updateCallback = function () {
            this.tint = Color.lerpColorByLch(0xFFFFFF, 0xFFFF00, Tween.Easing.OscillateSine(1)(this.life.time));
        };
        var twittery = _this.select.name('twitter').y;
        _this.select.name('twitter').updateCallback = function () {
            this.y = twittery + Math.sin(4 * this.life.time) * 2;
        };
        _this.select.name('twitter').addModule(new Button({
            hoverTint: 0xBBBBBB,
            clickTint: 0x888888,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('twitter', true);
                _this.select.name('twitter').effects.post.filters = [];
                window.open('https://twitter.com/lectvs', '_blank');
            },
        }));
        if (shouldSheen('twitter')) {
            _this.select.name('twitter').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        var discordy = _this.select.name('discord').y;
        _this.select.name('discord').updateCallback = function () {
            this.y = discordy + Math.sin(4 * this.life.time + 2) * 2;
        };
        _this.select.name('discord').addModule(new Button({
            hoverTint: 0xBBBBBB,
            clickTint: 0x888888,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('discord', true);
                _this.select.name('discord').effects.post.filters = [];
                window.open('https://discord.gg/RXw6hHFhMr', '_blank');
            },
        }));
        if (shouldSheen('discord')) {
            _this.select.name('discord').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        _this.select.name('patchnotes').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                setSheenSeen('patchNotes', true);
                _this.select.name('patchnotes').effects.post.filters = [];
                global.game.menuSystem.loadMenu(function () { return new PatchNotesMenu(_this.takeSnapshot()); });
            },
        }));
        if (shouldSheen('patchNotes')) {
            _this.select.name('patchnotes').effects.post.filters.push(new ShineFilter(0xFFFFBB));
        }
        _this.select.name('wiki').addModule(new Button({
            hoverTint: 0xBBBBBB,
            clickTint: 0x888888,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                window.open('https://auto-balls.fandom.com/wiki/Auto_Balls_Wiki', '_blank');
            },
        }));
        if (API.BETA || IS_MODDED) {
            _this.select.name('cloudsave').setVisible(false);
            "modded_remove_from";
        }
        else {
            _this.select.name('cloudsave').addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                onClick: function () {
                    global.game.playSound('click');
                    global.game.startGame(CloudSaveScreen.STAGE);
                },
            }));
            "modded_remove_to";
        }
        _this.addWorldObject(new RestoreCode());
        var playlatestversion = _this.select.name('playlatestversion');
        playlatestversion.addChildKeepWorldPosition(_this.select.name('plvng'));
        playlatestversion.addChildKeepWorldPosition(_this.select.name('plvitch'));
        playlatestversion.setVisible(false);
        API.getliveversion(function (response, err) {
            if (response)
                API.B = response.b;
            if ((!err && response && API.cmpFormattedVersions(API.getFormattedVersion(), response.versions.version) >= 0) || (err === null || err === void 0 ? void 0 : err.startsWith('Throttled'))) {
                return;
            }
            _this.select.name('plvng').addModule(new Button({
                hoverTint: 0xBBBBBB,
                clickTint: 0x888888,
                onClick: function () {
                    global.game.playSound('click');
                    window.open('https://www.newgrounds.com/portal/view/834986', '_blank');
                }
            }));
            _this.select.name('plvitch').addModule(new Button({
                hoverTint: 0xBBBBBB,
                clickTint: 0x888888,
                onClick: function () {
                    global.game.playSound('click');
                    window.open('https://lectvs.itch.io/auto-balls', '_blank');
                }
            }));
            _this.runScript(function () {
                var playlatestversiony;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            playlatestversion.x -= 220;
                            playlatestversion.setVisible(true);
                            return [4 /*yield*/, S.tween(1, playlatestversion, 'x', playlatestversion.x, playlatestversion.x + 220, Tween.Easing.OutCubic)];
                        case 1:
                            _a.sent();
                            playlatestversiony = playlatestversion.y;
                            playlatestversion.updateCallback = function () {
                                this.y = playlatestversiony + Math.sin(4 * this.life.time + 2) * 2;
                            };
                            return [2 /*return*/];
                    }
                });
            });
        });
        global.game.playMusic('music/title', 0.2);
        return _this;
    }
    return MainMenu;
}(Menu));
var OptionsMenu = /** @class */ (function (_super) {
    __extends(OptionsMenu, _super);
    function OptionsMenu() {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
        }) || this;
        _this.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        addOptionsMenu(_this);
        _this.select.name('restart').removeFromWorld();
        _this.select.name('areyousure').removeFromWorld();
        var gear = _this.addWorldObject(new Sprite({
            x: 14, y: _this.height - 14,
            texture: 'gear',
            bounds: new CircleBounds(0, 0, 11),
        }));
        gear.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.back();
            },
        }));
        return _this;
    }
    OptionsMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_CLOSE_MENU)) {
            Input.consume(Input.GAME_CLOSE_MENU);
            global.game.menuSystem.back();
        }
    };
    return OptionsMenu;
}(Menu));
var PackScreen;
(function (PackScreen) {
    function STAGE(isChallengeMode) {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        setArenaWorld(Arenas.ARENA_FIRST);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('packmenu'));
        world.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        var classic = world.select.name('classic');
        classic.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                startNewGame(Arenas.ARENA_FIRST, ['classic'], undefined, [], isChallengeMode, undefined);
            },
        }));
        classic.data.infoBoxDescription = "The classic Auto Balls\nexperience!";
        classic.addChild(new Sprite({
            x: 0, y: 8,
            texture: 'buffbeams',
            scale: 116 / 128,
            vangle: 40,
        }));
        classic.addChild(newBallWorld(-120 / 2, -144 / 2, 'classic'));
        var classicWins = loadWins('classic');
        if (classicWins > 0) {
            classic.addChild(new SpriteText({
                x: -53, y: 71,
                text: "[offsetx -2]<crown>[/]" + classicWins,
                style: { color: 0xFFD800 },
                anchor: Vector2.BOTTOM_LEFT,
            }));
        }
        World.Actions.moveWorldObjectToFront(classic);
        var community = world.select.name('community');
        community.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                startNewGame(Arenas.ARENA_FIRST, ['community'], undefined, [], isChallengeMode, undefined);
            },
        }));
        community.data.infoBoxDescription = "A brand new pack of\nballs suggested by\nthe community!";
        community.addChild(new Sprite({
            x: 0, y: 8,
            texture: 'buffbeams',
            scale: 116 / 128,
            vangle: 40,
        }));
        community.addChild(newBallWorld(-120 / 2, -144 / 2, 'community'));
        var communityWins = loadWins('community');
        if (communityWins > 0) {
            community.addChild(new SpriteText({
                x: 56, y: 71,
                text: "[offsetx -2]<crown>[/]" + communityWins,
                style: { color: 0xFFD800 },
                anchor: Vector2.BOTTOM_RIGHT,
            }));
        }
        World.Actions.moveWorldObjectToFront(community);
        var shuffle = world.select.name('shuffle');
        shuffle.bounds = new CircleBounds(0, 0, 33, shuffle);
        World.Actions.moveWorldObjectToFront(shuffle);
        var shuffleText = shuffle.addChild(new SpriteText({
            x: 0, y: 18,
            text: '',
            font: 'smallnumbers',
            anchor: Vector2.TOP_CENTER,
        }));
        var shuffleButton = shuffle.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                startNewGame(Arenas.ARENA_FIRST, ['weekly'], { week: Weekly.LIVE_WEEK }, [], isChallengeMode, undefined);
            },
            onHover: function () {
                shuffleText.style.color = 0xFFFF00;
            },
            onUnhover: function () {
                shuffleText.style.color = 0xFFFFFF;
            },
            onClickedDown: function () {
                shuffleText.style.color = 0xBBBB00;
            },
            priority: 1,
            enabled: false,
        }));
        shuffle.data.infoBoxDescription = "A mix of both packs\nthat changes every week!";
        var shuffleHide = world.addWorldObject(new Sprite({
            x: shuffle.x, y: shuffle.y + 6,
            texture: new AnchoredTexture(Texture.filledRect(36, 36, 0x000000), 0.5, 0.5),
        }));
        shuffleHide.addChild(new Spinner(0, 0, 3, 10));
        Weekly.load({
            onSuccess: function () {
                shuffleHide.kill();
                shuffleButton.enabled = true;
                shuffleText.setText("WEEK " + Weekly.LIVE_WEEK);
            },
            onError: function () {
                // Nothing, just let the spinner spin indefinitely.
            },
        });
        var wires = world.select.name('wires');
        World.Actions.moveWorldObjectToFront(wires);
        var weeklyWins = loadWins('weekly');
        var shufflewins = world.select.name('shufflewins');
        if (weeklyWins > 0) {
            World.Actions.moveWorldObjectToFront(shufflewins);
            shufflewins.addChild(new SpriteText({
                y: 2,
                text: "<crown2l><crown2r>" + weeklyWins,
                font: 'smallnumbers',
                style: { color: 0xFFDB00 },
                anchor: Vector2.CENTER,
            }));
        }
        else {
            shufflewins.setVisible(false);
        }
        var shuffleinfo = world.select.name('shuffleinfo');
        shuffleinfo.bounds = new CircleBounds(0, 0, 8, shuffleinfo);
        shuffleinfo.addModule(new Button({
            hoverTint: 0xBBBBBB,
            clickTint: 0x888888,
            onClick: function () {
                global.game.playSound('click');
                global.game.menuSystem.loadMenu(function () { return new AlmanacMenu('weekly'); });
            },
            priority: 2,
        }));
        World.Actions.moveWorldObjectToFront(shuffleinfo);
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(PlayScreen.STAGE);
            },
        }));
        world.addWorldObject(new BoundsInfoBox(Vector2.BOTTOM_CENTER, 0.5));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && this.life.frames > 1 && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.game.loadMainMenu();
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
        };
        return world;
    }
    PackScreen.STAGE = STAGE;
    function startNewGame(arena, packs, weekly, modifiers, isChallengeMode, daily) {
        var _a;
        resetData();
        GAME_DATA.squad.name = (_a = loadName()) !== null && _a !== void 0 ? _a : 'Guest';
        GAME_DATA.arena = arena;
        GAME_DATA.packs = packs;
        GAME_DATA.modifiers = modifiers;
        GAME_DATA.weekly = weekly;
        var gameData = {
            gameData: GAME_DATA,
            state: 'startshop',
            lock: gameDataLock(),
        };
        if (daily) {
            PlayScreen.startDailyGame(gameData, daily);
        }
        else if (isChallengeMode) {
            PlayScreen.startChallengeModeGame(gameData);
        }
        else {
            PlayScreen.startMatchmakingGame(gameData);
        }
    }
    PackScreen.startNewGame = startNewGame;
    function newBallWorld(x, y, pack) {
        var _a;
        var validBallTypes = VALID_SQUAD_BALL_TYPES[pack].filter(function (type) { return isBallTypeUnlocked(type); });
        var ball = squadBallToWorldBall({
            x: x, y: y,
            properties: {
                type: Random.element(validBallTypes),
                damage: 1,
                health: 1,
                level: 1,
                equipment: -1,
                metadata: {},
            },
        }, undefined, -1, 'friend');
        ball.changeHighlight(true);
        var scale = 4;
        var world = new World({
            width: 120 / scale,
            height: 144 / scale,
            scaleX: scale,
            scaleY: scale,
            backgroundAlpha: 0,
            layers: [
                { name: Battle.Layers.balls },
            ],
            physicsGroups: (_a = {},
                _a[Battle.PhysicsGroups.balls] = {},
                _a),
        });
        ball.x = world.width / 2;
        ball.y = world.height / 2 + 8 / scale;
        world.addWorldObject(ball);
        world.addWorldObject(new AbilitySystem());
        var wawo = new Theater.WorldAsWorldObject(world);
        wawo.x = x;
        wawo.y = y;
        return wawo;
    }
    var VALID_SQUAD_BALL_TYPES = {
        'classic': [
            2, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 17,
            18, 19, 22, 24, 27, 29, 30, 32, 33, 35,
            36, 37, 38, 39, 40, 43, 44, 45, 46, 47,
            48, 49, 50, 51,
        ],
        'community': [
            101, 102, 105, 106, 107, 109, 110, 111, 112, 117,
            119, 120, 122, 123, 124, 137, 139, 140, 141, 143,
            144,
        ],
        'weekly': [
            0,
        ],
    };
})(PackScreen || (PackScreen = {}));
var PatchNotesMenu = /** @class */ (function (_super) {
    __extends(PatchNotesMenu, _super);
    function PatchNotesMenu(oldMenuSnapshot) {
        var e_215, _a;
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
        }) || this;
        _this.addWorldObject(new Sprite({
            texture: oldMenuSnapshot,
        }));
        var fade = _this.addWorldObject(new Sprite({
            texture: Texture.filledRect(_this.width, _this.height, 0x000000),
            alpha: 0,
        }));
        var objs = _this.addWorldObjects(lciDocumentToWorldObjects('patchnotesmenu'));
        _this.select.name('title').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 3;
        };
        _this.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 1) * 3;
        };
        _this.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                _this.back();
            },
        }));
        var patchNotes = A.clone(PATCH_NOTES);
        if (LiveVersion.BDAY)
            patchNotes.splice(0, 0, '[r]Happy Birthday Auto Balls!!![/r]\n');
        if (LiveVersion.APRIL_FOOLS)
            patchNotes.splice(0, 0, '[r]April Fools! ;)[/r]\n');
        var notesContainer = _this.addWorldObject(new WorldObject({ x: 16, y: 36 }));
        var notes = notesContainer.addChild(new WorldObject());
        var notesHeight = 0;
        try {
            for (var patchNotes_1 = __values(patchNotes), patchNotes_1_1 = patchNotes_1.next(); !patchNotes_1_1.done; patchNotes_1_1 = patchNotes_1.next()) {
                var noteText = patchNotes_1_1.value;
                var noteObject = notes.addChild(new SpriteText({
                    y: notesHeight,
                    text: noteText,
                    style: { color: 0x000000 },
                    maxWidth: 280,
                    mask: {
                        offsetx: 0, offsety: 0,
                        type: 'screen',
                        texture: Texture.filledRect(288, 172, 0xFFFFFF),
                    },
                    update: function () {
                        this.mask.offsetx = notesContainer.x;
                        this.mask.offsety = notesContainer.y;
                    }
                }));
                notesHeight += noteObject.getTextHeight() + 15;
            }
        }
        catch (e_215_1) { e_215 = { error: e_215_1 }; }
        finally {
            try {
                if (patchNotes_1_1 && !patchNotes_1_1.done && (_a = patchNotes_1.return)) _a.call(patchNotes_1);
            }
            finally { if (e_215) throw e_215.error; }
        }
        objs.push(notesContainer);
        var visibleHeight = 172;
        var scrollBar = _this.addWorldObject(new ScrollBar(302, 36, 'patchnotesscrollbar', notesHeight, 32, function (p) { return notes.localy = M.lerp(0, -Math.max(notesHeight - visibleHeight, 0), p); }));
        objs.push(scrollBar);
        _this.addWorldObject(new DragScroller(scrollBar, notesHeight, rect(30, 30, 260, 180)));
        objs.forEach(function (obj) { return obj.y += _this.height; });
        var time = 0.2;
        _this.runScript(S.simul.apply(S, __spread([S.tween(time, fade, 'alpha', 0, 1)], objs.map(function (obj) { return S.tween(time, obj, 'y', obj.y, obj.y - _this.height, Tween.Easing.OutQuad); }))));
        global.game.musicManager.volumeScale /= 3;
        return _this;
    }
    PatchNotesMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_CLOSE_MENU)) {
            Input.consume(Input.GAME_CLOSE_MENU);
            this.back();
        }
    };
    PatchNotesMenu.prototype.back = function () {
        global.game.musicManager.volumeScale *= 3;
        global.game.menuSystem.back();
    };
    return PatchNotesMenu;
}(Menu));
var PauseMenu = /** @class */ (function (_super) {
    __extends(PauseMenu, _super);
    function PauseMenu() {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
        }) || this;
        _this.addWorldObject(new Sprite({
            texture: global.world.takeSnapshot().transform({ filters: [new BlurFilter(26.7)] }, 'PauseMenu'),
        }));
        addOptionsMenu(_this);
        _this.select.name('areyousure').setVisible(false);
        _this.select.name('restart').addModule(new Button({
            hoverTint: 0xFF8800,
            clickTint: 0xBB0000,
            onClick: function () {
                global.game.playSound('click');
                _this.select.name('restart').kill();
                _this.select.name('areyousure').setVisible(true);
                _this.select.name('areyousure').addModule(new Button({
                    hoverTint: 0xFF8800,
                    clickTint: 0xBB0000,
                    onClick: function () {
                        global.game.musicManager.volumeScale *= 3;
                        global.game.playSound('click');
                        global.game.loadMainMenu();
                    },
                }));
            },
        }));
        var gear = _this.addWorldObject(new Sprite({
            x: 11, y: _this.height - 11,
            texture: 'gear',
            bounds: new CircleBounds(0, 0, 11),
        }));
        gear.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                _this.unpause();
            },
        }));
        global.game.musicManager.volumeScale /= 3;
        return _this;
    }
    PauseMenu.prototype.unpause = function () {
        global.game.musicManager.volumeScale *= 3;
        global.game.unpauseGame();
    };
    PauseMenu.prototype.update = function () {
        _super.prototype.update.call(this);
        if (Input.justDown(Input.GAME_PAUSE)) {
            Input.consume(Input.GAME_PAUSE);
            this.unpause();
        }
    };
    return PauseMenu;
}(Menu));
var PlayScreen;
(function (PlayScreen) {
    function STAGE() {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        setArenaWorld(Arenas.ARENA_FIRST);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('playmenu'));
        world.select.name('play').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        var playerName = world.addWorldObject(new SpriteText({
            x: global.gameWidth / 2 + 8, y: 55,
            text: loadName(),
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        }));
        var playerNameGear = world.addWorldObject(new Sprite({
            x: playerName.x - playerName.getTextWidth() / 2 - 9,
            y: playerName.y - 1,
            texture: 'gearsmall',
            bounds: new CircleBounds(0, 0, 7),
        }));
        playerNameGear.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(2),
            onClick: function () {
                global.game.playSound('click');
                global.game.startGame(function () { return EnterYourName.STAGE('playscreen'); });
            },
        }));
        var daily = world.select.name('daily');
        daily.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 3;
        };
        if (API.BETA || IS_MODDED) {
            daily.tint = 0x666666;
            "modded_remove_from";
        }
        else {
            daily.addModule(new Button({
                hoverTint: 0xFFFF00,
                clickTint: 0xBBBB00,
                onJustHovered: juiceButton(1),
                onClick: function () {
                    global.game.playSound('click');
                    global.theater.loadStage(function () { return DailyScreen.STAGE(); });
                },
            }));
            daily.data.infoBoxDescription = "You've only got one shot,\ncompete for the top score!";
            "modded_remove_to";
        }
        var mm = world.select.name('mm');
        mm.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 3;
        };
        mm.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                world.runScript(playMatchmakingScript(world));
            },
        }));
        mm.data.infoBoxDescription = "The classic Auto Balls\nexperience!";
        var mmasterisk = world.select.name('mmasterisk');
        var mmasteriskd = mmasterisk.getPosition().subtract(mm);
        if (loadMatchmakingGameData()) {
            mmasterisk.updateCallback = function () {
                var d = mmasteriskd.rotated(mm.angle * 0.85);
                this.x = mm.x + d.x;
                this.y = mm.y + d.y;
            };
        }
        else {
            mmasterisk.removeFromWorld();
        }
        var challenge = world.select.name('challenge');
        challenge.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 1) * 2;
        };
        challenge.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                world.runScript(playChallengeModeScript(world));
            },
        }));
        challenge.data.infoBoxDescription = "Test your skill against\n[gold][offsetx -3]<crown>[/offsetx][/gold]Winning squads!";
        var challengeasterisk = world.select.name('challengeasterisk');
        var challengeasteriskd = challengeasterisk.getPosition().subtract(challenge);
        if (loadChallengeModeGameData()) {
            challengeasterisk.updateCallback = function () {
                var d = challengeasteriskd.rotated(challenge.angle * 0.85);
                this.x = challenge.x + d.x;
                this.y = challenge.y + d.y;
            };
        }
        else {
            challengeasterisk.removeFromWorld();
        }
        var vs = world.select.name('vs');
        vs.updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 2;
        };
        vs.addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                GAME_MODE = 'vs';
                global.theater.loadStage(function () { return VSModeScreen.STAGE(loadVsSettings()); });
            },
        }));
        vs.data.infoBoxDescription = "Play 1-on-1 against a friend!";
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.game.loadMainMenu();
            },
        }));
        world.addWorldObject(new BoundsInfoBox(Vector2.BOTTOM_CENTER, 0.5));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && this.life.frames > 1 && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.game.loadMainMenu();
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
        };
        return world;
    }
    PlayScreen.STAGE = STAGE;
    function playMatchmakingScript(world) {
        return function () {
            var gameData, enabledButtons, enabledButtons_1, enabledButtons_1_1, button, infoBox, warningBox_1, enabledButtons_2, enabledButtons_2_1, button;
            var e_216, _a, e_217, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        gameData = loadMatchmakingGameData();
                        if (!gameData) return [3 /*break*/, 2];
                        enabledButtons = world.select.modules(Button).filter(function (button) { return button.enabled; });
                        try {
                            for (enabledButtons_1 = __values(enabledButtons), enabledButtons_1_1 = enabledButtons_1.next(); !enabledButtons_1_1.done; enabledButtons_1_1 = enabledButtons_1.next()) {
                                button = enabledButtons_1_1.value;
                                button.enabled = false;
                            }
                        }
                        catch (e_216_1) { e_216 = { error: e_216_1 }; }
                        finally {
                            try {
                                if (enabledButtons_1_1 && !enabledButtons_1_1.done && (_a = enabledButtons_1.return)) _a.call(enabledButtons_1);
                            }
                            finally { if (e_216) throw e_216.error; }
                        }
                        infoBox = world.select.type(BoundsInfoBox);
                        infoBox.enabled = false;
                        warningBox_1 = world.addWorldObject(new PlayWarningBox());
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox_1.result; })];
                    case 1:
                        _c.sent();
                        if (warningBox_1.result === 'cancel') {
                            try {
                                for (enabledButtons_2 = __values(enabledButtons), enabledButtons_2_1 = enabledButtons_2.next(); !enabledButtons_2_1.done; enabledButtons_2_1 = enabledButtons_2.next()) {
                                    button = enabledButtons_2_1.value;
                                    button.enabled = true;
                                }
                            }
                            catch (e_217_1) { e_217 = { error: e_217_1 }; }
                            finally {
                                try {
                                    if (enabledButtons_2_1 && !enabledButtons_2_1.done && (_b = enabledButtons_2.return)) _b.call(enabledButtons_2);
                                }
                                finally { if (e_217) throw e_217.error; }
                            }
                            infoBox.enabled = true;
                            return [2 /*return*/];
                        }
                        if (warningBox_1.result === 'loadgame') {
                            startMatchmakingGame(gameData);
                            return [2 /*return*/];
                        }
                        _c.label = 2;
                    case 2:
                        global.theater.loadStage(function () { return PackScreen.STAGE(false); });
                        return [2 /*return*/];
                }
            });
        };
    }
    function playChallengeModeScript(world) {
        return function () {
            var gameData, enabledButtons, enabledButtons_3, enabledButtons_3_1, button, infoBox, warningBox_2, enabledButtons_4, enabledButtons_4_1, button;
            var e_218, _a, e_219, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        gameData = loadChallengeModeGameData();
                        if (!gameData) return [3 /*break*/, 2];
                        enabledButtons = world.select.modules(Button).filter(function (button) { return button.enabled; });
                        try {
                            for (enabledButtons_3 = __values(enabledButtons), enabledButtons_3_1 = enabledButtons_3.next(); !enabledButtons_3_1.done; enabledButtons_3_1 = enabledButtons_3.next()) {
                                button = enabledButtons_3_1.value;
                                button.enabled = false;
                            }
                        }
                        catch (e_218_1) { e_218 = { error: e_218_1 }; }
                        finally {
                            try {
                                if (enabledButtons_3_1 && !enabledButtons_3_1.done && (_a = enabledButtons_3.return)) _a.call(enabledButtons_3);
                            }
                            finally { if (e_218) throw e_218.error; }
                        }
                        infoBox = world.select.type(BoundsInfoBox);
                        infoBox.enabled = false;
                        warningBox_2 = world.addWorldObject(new PlayWarningBox());
                        return [4 /*yield*/, S.waitUntil(function () { return warningBox_2.result; })];
                    case 1:
                        _c.sent();
                        if (warningBox_2.result === 'cancel') {
                            try {
                                for (enabledButtons_4 = __values(enabledButtons), enabledButtons_4_1 = enabledButtons_4.next(); !enabledButtons_4_1.done; enabledButtons_4_1 = enabledButtons_4.next()) {
                                    button = enabledButtons_4_1.value;
                                    button.enabled = true;
                                }
                            }
                            catch (e_219_1) { e_219 = { error: e_219_1 }; }
                            finally {
                                try {
                                    if (enabledButtons_4_1 && !enabledButtons_4_1.done && (_b = enabledButtons_4.return)) _b.call(enabledButtons_4);
                                }
                                finally { if (e_219) throw e_219.error; }
                            }
                            infoBox.enabled = true;
                            return [2 /*return*/];
                        }
                        if (warningBox_2.result === 'loadgame') {
                            startChallengeModeGame(gameData);
                            return [2 /*return*/];
                        }
                        _c.label = 2;
                    case 2:
                        global.theater.loadStage(function () { return PackScreen.STAGE(true); });
                        return [2 /*return*/];
                }
            });
        };
    }
    function startMatchmakingGame(gameData) {
        GAME_MODE = 'mm';
        global.game.stopMusic(0.5);
        GameFragments.startMatchmakingGame(gameData, false, undefined);
    }
    PlayScreen.startMatchmakingGame = startMatchmakingGame;
    function startChallengeModeGame(gameData) {
        GAME_MODE = 'mm';
        global.game.stopMusic(0.5);
        GameFragments.startMatchmakingGame(gameData, true, undefined);
    }
    PlayScreen.startChallengeModeGame = startChallengeModeGame;
    function startDailyGame(gameData, daily) {
        GAME_MODE = 'mm';
        gameData.gameData.availableBallTypes = getAvailableBallTypesAll();
        gameData.gameData.availableItemTypes = getAvailableItemTypesAll();
        global.game.stopMusic(0.5);
        GameFragments.startMatchmakingGame(gameData, _.contains(daily.modifiers, 'challengemode'), daily);
    }
    PlayScreen.startDailyGame = startDailyGame;
    var PlayWarningBox = /** @class */ (function (_super) {
        __extends(PlayWarningBox, _super);
        function PlayWarningBox(text, maxWidth) {
            if (text === void 0) { text = undefined; }
            if (maxWidth === void 0) { maxWidth = 200; }
            var _this = _super.call(this, {
                x: global.gameWidth / 2, y: global.gameHeight / 2,
            }) || this;
            _this.text = _this.addChild(new SpriteText({
                text: text,
                maxWidth: maxWidth,
                anchor: Vector2.TOP,
                justify: 'center',
                copyFromParent: ['layer'],
            }));
            var width = text ? _this.text.getTextWidth() + 2 * PlayWarningBox.PADDING : 112 + 2 * PlayWarningBox.PADDING;
            var height = text ? _this.text.getTextHeight() + 2 * PlayWarningBox.PADDING + 30 : 16 + 2 * PlayWarningBox.BUTTON_D + 2 * PlayWarningBox.PADDING;
            _this.setTexture(InfoBox.getTextureForSize(width, height));
            _this.text.localy = -height / 2 + PlayWarningBox.PADDING;
            _this.loadGameButton = _this.addChild(new MenuTextButton({
                x: 0, y: height / 2 - PlayWarningBox.PADDING - 2 * PlayWarningBox.BUTTON_D,
                text: "Continue Game",
                anchor: Vector2.BOTTOM_CENTER,
                copyFromParent: ['layer'],
                onClick: function () {
                    global.game.playSound('click');
                    _this.result = 'loadgame';
                    _this.kill();
                }
            }));
            var areYouSure = false;
            _this.newGameButton = _this.addChild(new MenuTextButton({
                x: 0, y: height / 2 - PlayWarningBox.PADDING - PlayWarningBox.BUTTON_D,
                text: "New Game",
                anchor: Vector2.BOTTOM_CENTER,
                copyFromParent: ['layer'],
                onClick: function () {
                    global.game.playSound('click');
                    if (!areYouSure) {
                        areYouSure = true;
                        _this.newGameButton.setText("Are You Sure?");
                    }
                    else {
                        _this.result = 'newgame';
                        _this.kill();
                    }
                }
            }));
            _this.cancelButton = _this.addChild(new MenuTextButton({
                x: 0, y: height / 2 - PlayWarningBox.PADDING,
                text: "Cancel",
                anchor: Vector2.BOTTOM_CENTER,
                copyFromParent: ['layer'],
                onClick: function () {
                    global.game.playSound('click');
                    _this.result = 'cancel';
                    _this.kill();
                }
            }));
            return _this;
        }
        PlayWarningBox.prototype.update = function () {
            _super.prototype.update.call(this);
            if (Input.justDown(Input.GAME_CLOSE_MENU)) {
                Input.consume(Input.GAME_CLOSE_MENU);
                this.result = 'cancel';
                this.kill();
            }
        };
        PlayWarningBox.prototype.postUpdate = function () {
            _super.prototype.postUpdate.call(this);
            World.Actions.orderWorldObjectAfter(this.text, this);
            World.Actions.orderWorldObjectAfter(this.loadGameButton, this);
            World.Actions.orderWorldObjectAfter(this.newGameButton, this);
            World.Actions.orderWorldObjectAfter(this.cancelButton, this);
        };
        PlayWarningBox.PADDING = 6;
        PlayWarningBox.BUTTON_D = 18;
        return PlayWarningBox;
    }(Sprite));
})(PlayScreen || (PlayScreen = {}));
var SquadViewerMenu = /** @class */ (function (_super) {
    __extends(SquadViewerMenu, _super);
    function SquadViewerMenu(gameid, round) {
        if (round === void 0) { round = 1; }
        var _this = _super.call(this, {
            backgroundColor: 0x808080,
            volume: 1,
        }) || this;
        _this.gameid = gameid;
        _this.round = round;
        _this.roundText = _this.addWorldObject(new SpriteText({
            x: _this.width / 2, y: _this.height / 2 - 50,
            anchor: Vector2.CENTER,
            update: function () {
                _this.roundText.setText("Round " + _this.round);
            },
        }));
        _this.cache = {};
        _this.updateForCurrentRound();
        _this.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown('left')) {
                    _this.round = Math.max(_this.round - 1, 1);
                    _this.updateForCurrentRound();
                }
                else if (Input.justDown('right')) {
                    _this.round = _this.round + 1;
                    _this.updateForCurrentRound();
                }
            }
        }));
        global.game.stopMusic();
        return _this;
    }
    SquadViewerMenu.prototype.updateForCurrentRound = function () {
        var _this = this;
        var round = this.round;
        if (round in this.cache) {
            this.updateYourTeamWorldWithSquad(this.cache[round]);
            return;
        }
        API.getsquadforgame(function (squad, err) {
            var _a;
            if (err) {
                console.error(err);
                (_a = _this.yourTeamWorld) === null || _a === void 0 ? void 0 : _a.kill();
                return;
            }
            console.log('got squad', squad);
            _this.cache[round] = squad;
            _this.updateYourTeamWorldWithSquad(squad);
        }, this.gameid, round);
    };
    SquadViewerMenu.prototype.updateYourTeamWorldWithSquad = function (squad) {
        if (this.yourTeamWorld) {
            this.yourTeamWorld.kill();
        }
        this.yourTeamWorld = this.addWorldObject(createTeamWorld(squad.squad, this.height / 2));
        this.yourTeamWorld.alpha = 1;
    };
    return SquadViewerMenu;
}(Menu));
var TrailerMenu;
(function (TrailerMenu) {
    var Trailer1 = /** @class */ (function (_super) {
        __extends(Trailer1, _super);
        function Trailer1() {
            var _this = _super.call(this, {
                backgroundColor: 0x000000,
                volume: 1,
            }) || this;
            global.game.stopMusic();
            _this.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
            var documents = ['trailer/title', 'trailer/build', 'trailer/battle', 'trailer/playfree'];
            var tm = _this;
            _this.runScript(function () {
                var documents_1, documents_1_1, doc, objs, e_220_1;
                var e_220, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, S.waitUntil(function () { return Input.justDown('4'); })];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/];
                        case 2:
                            _b.sent();
                            _b.label = 3;
                        case 3:
                            _b.trys.push([3, 9, 10, 11]);
                            documents_1 = __values(documents), documents_1_1 = documents_1.next();
                            _b.label = 4;
                        case 4:
                            if (!!documents_1_1.done) return [3 /*break*/, 8];
                            doc = documents_1_1.value;
                            objs = tm.addWorldObjects(lciDocumentToWorldObjects(doc));
                            tm.select.name('title').updateCallback = function () {
                                this.angle = Math.sin(2 * this.life.time) * 5;
                            };
                            if (tm.select.name('play', false)) {
                                tm.select.name('play').updateCallback = function () {
                                    this.angle = Math.sin(4 * this.life.time + 12) * 3;
                                };
                            }
                            return [4 /*yield*/, S.waitUntil(function () { return Input.justDown('4'); })];
                        case 5:
                            _b.sent();
                            return [4 /*yield*/];
                        case 6:
                            _b.sent();
                            tm.removeWorldObjects(objs);
                            _b.label = 7;
                        case 7:
                            documents_1_1 = documents_1.next();
                            return [3 /*break*/, 4];
                        case 8: return [3 /*break*/, 11];
                        case 9:
                            e_220_1 = _b.sent();
                            e_220 = { error: e_220_1 };
                            return [3 /*break*/, 11];
                        case 10:
                            try {
                                if (documents_1_1 && !documents_1_1.done && (_a = documents_1.return)) _a.call(documents_1);
                            }
                            finally { if (e_220) throw e_220.error; }
                            return [7 /*endfinally*/];
                        case 11: return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        return Trailer1;
    }(Menu));
    TrailerMenu.Trailer1 = Trailer1;
    var EmptyArena = /** @class */ (function (_super) {
        __extends(EmptyArena, _super);
        function EmptyArena() {
            var _this = _super.call(this, {
                backgroundColor: 0x000000,
                volume: 1,
            }) || this;
            global.game.stopMusic();
            var arena = Arenas.BASE();
            Arenas.SET_FOR_ARENA(arena, 'first');
            _this.addWorldObject(new Theater.WorldAsWorldObject(arena));
            return _this;
        }
        return EmptyArena;
    }(Menu));
    TrailerMenu.EmptyArena = EmptyArena;
    var LectvsPresents = /** @class */ (function (_super) {
        __extends(LectvsPresents, _super);
        function LectvsPresents() {
            var _this = _super.call(this, {
                backgroundColor: 0x000000,
                volume: 1,
            }) || this;
            global.game.stopMusic();
            var glitchFilter = new Effects.Filters.Glitch(4, 1, 2);
            var logo = _this.addWorldObject(new Sprite({
                x: 0, y: -6,
                texture: 'lectvslogo',
                scale: 2,
                effects: { post: { filters: [glitchFilter] } },
                visible: false,
            }));
            var presents = _this.addWorldObject(new SpriteText({
                x: 0, y: 20,
                text: 'presents',
                anchor: Vector2.CENTER,
                effects: { post: { filters: [glitchFilter] } },
                visible: false,
            }));
            World.Actions.balanceWorldObjects([logo, presents], global.gameWidth / 2, global.gameHeight / 2 + 4);
            var world = _this;
            _this.runScript(function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(5)];
                        case 1:
                            _a.sent();
                            world.playSound('glitch');
                            logo.setVisible(true);
                            presents.setVisible(true);
                            return [4 /*yield*/, S.wait(0.5)];
                        case 2:
                            _a.sent();
                            glitchFilter.enabled = false;
                            return [4 /*yield*/, S.wait(1.5)];
                        case 3:
                            _a.sent();
                            world.playSound('glitch');
                            glitchFilter.enabled = true;
                            return [4 /*yield*/, S.wait(0.5)];
                        case 4:
                            _a.sent();
                            logo.setVisible(false);
                            presents.setVisible(false);
                            return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        return LectvsPresents;
    }(Menu));
    TrailerMenu.LectvsPresents = LectvsPresents;
    var BallCount = /** @class */ (function (_super) {
        __extends(BallCount, _super);
        function BallCount() {
            var _this = _super.call(this, {
                backgroundColor: 0x000000,
                volume: 1,
            }) || this;
            global.game.stopMusic();
            var count = _this.addWorldObject(new SpriteText({
                x: global.gameWidth / 2, y: 100,
                text: '',
                anchor: Vector2.CENTER,
                scale: 5,
                update: function () {
                    if (this.getCurrentText() !== this.data.lastText && this.getCurrentText() !== '') {
                        var count_1 = parseInt(this.getCurrentText());
                        var speed = Math.pow(2, count_1 / 30);
                        var sound = count_1 === 30 ? 'ballcountreverb' : 'ballcount';
                        this.world.playSound(sound, { speed: isFinite(speed) ? speed : 1 });
                        this.data.lastText = this.getCurrentText();
                    }
                }
            }));
            var newBallsAndItems = _this.addWorldObject(new SpriteText({
                x: global.gameWidth / 2, y: 150,
                text: 'new balls and items',
                anchor: Vector2.CENTER,
                scale: 2,
            }));
            var world = _this;
            _this.runScript(function () {
                var flash;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, S.wait(5)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(4, function (t) {
                                    var c = Math.floor(M.lerp(0, 30, Tween.Easing.InCubic(t)));
                                    if (c > 0)
                                        count.setText("" + c);
                                })];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, S.wait(1.5)];
                        case 3:
                            _a.sent();
                            count.setText('31');
                            return [4 /*yield*/, S.wait(0.9)];
                        case 4:
                            _a.sent();
                            count.setText('32');
                            return [4 /*yield*/, S.wait(0.5)];
                        case 5:
                            _a.sent();
                            count.setText('33');
                            return [4 /*yield*/, S.wait(0.43)];
                        case 6:
                            _a.sent();
                            return [4 /*yield*/, S.doOverTime(1, function (t) {
                                    var c = Math.floor(M.lerp(31, 50, t));
                                    if (c > 31)
                                        count.setText("" + c);
                                })];
                        case 7:
                            _a.sent();
                            count.style.color = 0xFFD800;
                            newBallsAndItems.style.color = 0xFFD800;
                            world.playSound('buyball');
                            world.playSound('buff');
                            world.playSound('yay');
                            world.playSound('confetti');
                            flash = world.addWorldObject(new Sprite({
                                texture: Texture.filledRect(global.gameWidth, global.gameHeight, 0xFFFFFF),
                            }));
                            world.runScript(S.tween(0.1, flash, 'alpha', 1, 0));
                            return [4 /*yield*/, S.doOverTime(Infinity, function (t) {
                                    count.scale = M.lerp(5, 7, Tween.Easing.OscillateSine(1)(count.life.time));
                                    newBallsAndItems.scale = M.lerp(2, 2.1, Tween.Easing.OscillateSine(1)(count.life.time + 7.38));
                                })];
                        case 8:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
            return _this;
        }
        return BallCount;
    }(Menu));
    TrailerMenu.BallCount = BallCount;
})(TrailerMenu || (TrailerMenu = {}));
var TutorialMenu = /** @class */ (function (_super) {
    __extends(TutorialMenu, _super);
    function TutorialMenu() {
        var _this = _super.call(this, {
            backgroundColor: 0x000000,
            volume: 0,
        }) || this;
        _this.showTutorial('tutorial1', function () { return _this.showTutorial('tutorial2', 
        //() => this.showTutorial('tutorial3',
        function () { return global.game.menuSystem.back(); }); }); //);
        return _this;
    }
    TutorialMenu.prototype.showTutorial = function (lciDocument, onNext) {
        this.removeWorldObjects(A.clone(this.worldObjects));
        var arenaWorld = Arenas.BASE();
        Arenas.SET_FOR_ARENA(arenaWorld, Arenas.ARENA_FIRST);
        arenaWorld.volume = 0.3;
        this.addWorldObject(new Theater.WorldAsWorldObject(arenaWorld));
        this.addWorldObjects(lciDocumentToWorldObjects(lciDocument));
        var tutorialNextFilter = new TutorialNextFilter();
        this.select.name('tutorial').effects.post.filters.push(new DropShadowFilter());
        var tutorialflash = this.select.name('tutorialflash', false);
        if (tutorialflash) {
            tutorialflash.effects.post.filters.push(new DropShadowFilter());
            tutorialflash.updateCallback = function () {
                this.tint = Color.lerpColorByLch(0xFFFFFF, 0xFFBB00, Tween.Easing.OscillateSine(1)(this.life.time));
            };
        }
        this.select.name('next').effects.post.filters.push(tutorialNextFilter, new DropShadowFilter());
        this.select.name('next').updateCallback = function () {
            tutorialNextFilter.setTintColor(M.colorToVec3(Color.lerpColorByLch(0xFF4300, 0xFFE900, Tween.Easing.OscillateSine(2)(this.life.time))));
        };
        this.select.name('next').addModule(new Button({
            hoverTint: 0xAAAAAA,
            clickTint: 0x666666,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                onNext();
            },
        }));
    };
    return TutorialMenu;
}(Menu));
var VSModeScreen;
(function (VSModeScreen) {
    function STAGE(settings) {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        setArenaWorld(settings.arena);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('vsmodemenu'));
        world.select.name('versusmode').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        world.select.name('create').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time) * 3;
        };
        world.select.name('create').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                world.runScript(createVsGame(world, settings));
            },
        }));
        world.select.name('settings').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(VSModeSettings.STAGE);
            },
        }));
        if (_.isEqual(settings, VSModeSettings.GET_DEFAULT_SETTINGS())) {
            world.select.name('changedsettings').setVisible(false);
        }
        world.select.name('join').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 1) * 3;
        };
        world.select.name('join').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(EnterGameCode.STAGE_VERSUS);
            },
        }));
        world.select.name('spectate').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('spectate').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(EnterGameCode.STAGE_SPECTATE);
            },
        }));
        var lastVsGame = loadVersusModeGameData({ type: 'last' });
        if (lastVsGame) {
            world.addWorldObject(new MenuTextButton({
                x: global.gameWidth / 2, y: 180,
                text: "(current game: " + lastVsGame.gameData.gameId + ")",
                anchor: Vector2.TOP_CENTER,
                effects: { outline: { color: 0x000000 } },
                hoverColor: 0xFFFF00,
                onJustHovered: function () {
                    juiceObject(this, 0.5);
                },
                onClick: function () {
                    global.game.playSound('click');
                    global.theater.loadStage(EnterGameCode.STAGE_VERSUS);
                },
            }));
        }
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                global.theater.loadStage(PlayScreen.STAGE);
            },
        }));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU) && this.life.frames > 1 && world.select.name('back').getModule(Button).enabled) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    global.theater.loadStage(PlayScreen.STAGE);
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
        };
        return world;
    }
    VSModeScreen.STAGE = STAGE;
})(VSModeScreen || (VSModeScreen = {}));
var VSModeSettings;
(function (VSModeSettings) {
    function GET_DEFAULT_SETTINGS() {
        return {
            startHealth: 5,
            startRound: 1,
            startGameGold: 10,
            startRoundGold: 10,
            maxSquadSize: 5,
            timeLimit: -1,
            speedCap: true,
            arena: Arenas.ARENA_FIRST,
            hostPack: 'classic',
            nonhostPack: 'classic',
        };
    }
    VSModeSettings.GET_DEFAULT_SETTINGS = GET_DEFAULT_SETTINGS;
    function STAGE() {
        var world = new World({
            backgroundColor: 0x000000,
            volume: 0,
            allowPause: false,
        });
        var settings = loadVsSettings();
        setArenaWorld(settings.arena);
        world.addWorldObject(new Theater.WorldAsWorldObject(_MENUS_ARENA_WORLD));
        world.addWorldObjects(lciDocumentToWorldObjects('vssettingsmenu'));
        world.select.name('gamesettings').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time - 1) * 2;
        };
        var settingsY = 42;
        var padding = 40;
        world.addWorldObject(new SpriteText({
            x: padding, y: settingsY,
            text: "Start With Health\nStart At Round\nStart Game With Gold\nStart Round With Gold\nMax Squad Size\nShop Phase Time Limit\nSpeed Cap\nArena\nHost Pack\nNon-host Pack",
            anchor: Vector2.TOP_LEFT,
            justify: 'left',
            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
        }));
        addNumberSetting(world, global.gameWidth - padding - 24, settingsY, 1, 10, '[r]<heart>[/r]', function () { return settings.startHealth; }, function (n) { return settings.startHealth = n; });
        addNumberSetting(world, global.gameWidth - padding - 24, settingsY + 15, 1, 10, '', function () { return settings.startRound; }, function (n) { return settings.startRound = n; });
        addNumberSetting(world, global.gameWidth - padding - 24, settingsY + 30, 0, 100, '[gold]<coin>[/gold]', function () { return settings.startGameGold; }, function (n) { return settings.startGameGold = n; });
        addNumberSetting(world, global.gameWidth - padding - 24, settingsY + 45, 0, 100, '[gold]<coin>[/gold]', function () { return settings.startRoundGold; }, function (n) { return settings.startRoundGold = n; });
        addNumberSetting(world, global.gameWidth - padding - 24, settingsY + 60, 1, 10, '', function () { return settings.maxSquadSize; }, function (n) { return settings.maxSquadSize = n; });
        addOptionSetting(world, global.gameWidth - padding - 24, settingsY + 75, ['Off', '0:30', '1:00', '1:30', '2:00', '2:30', '3:00', '3:30', '4:00', '4:30', '5:00'], '', function () { return secondsToTime(settings.timeLimit); }, function (v) { return settings.timeLimit = timeToSeconds(v); });
        addOptionSetting(world, global.gameWidth - padding - 24, settingsY + 90, ['On', 'Off'], '', function () { return settings.speedCap ? 'On' : 'Off'; }, function (v) { return settings.speedCap = v !== 'Off'; });
        addOptionSetting(world, global.gameWidth - padding - 24, settingsY + 105, getArenas(), '', function () { return arenaIdToName(settings.arena); }, function (v) { return settings.arena = arenaNameToId(v); }, changeArenaTo);
        addOptionSetting(world, global.gameWidth - padding - 24, settingsY + 120, getPacks(), '', function () { return packIdToNameWithAll(settings.hostPack); }, function (v) {
            var packId = packNameToIdWithAll(v);
            if (settings.hostPack === settings.nonhostPack) {
                settings.nonhostPack = packId;
            }
            settings.hostPack = packId;
        }, changePackTo);
        addOptionSetting(world, global.gameWidth - padding - 24, settingsY + 135, getPacks(), '', function () { return packIdToNameWithAll(settings.nonhostPack); }, function (v) { return settings.nonhostPack = packNameToIdWithAll(v); }, changePackTo);
        world.addWorldObject(new MenuTextButton({
            x: global.gameWidth / 2, y: 206,
            text: 'Reset Defaults',
            anchor: Vector2.CENTER,
            justify: 'center',
            effects: { outline: { color: 0x000000 }, post: { filters: [new DropShadowFilter()] } },
            style: { color: 0xFFFFDD },
            hoverColor: 0xFFFF00,
            onClick: function () {
                global.game.playSound('click');
                settings = VSModeSettings.GET_DEFAULT_SETTINGS();
            },
        }));
        world.select.name('back').updateCallback = function () {
            this.angle = Math.sin(2 * this.life.time + 2) * 3;
        };
        world.select.name('back').addModule(new Button({
            hoverTint: 0xFFFF00,
            clickTint: 0xBBBB00,
            onJustHovered: juiceButton(1),
            onClick: function () {
                global.game.playSound('click');
                back(settings);
            },
        }));
        world.addWorldObject(new WorldObject({
            update: function () {
                if (Input.justDown(Input.GAME_CLOSE_MENU)) {
                    Input.consume(Input.GAME_CLOSE_MENU);
                    back(settings);
                }
            }
        }));
        world.onTransitioned = function () {
            global.game.playMusic('music/title');
        };
        return world;
    }
    VSModeSettings.STAGE = STAGE;
    function back(settings) {
        saveVsSettings(settings);
        global.theater.loadStage(function () { return VSModeScreen.STAGE(settings); });
    }
    function getArenas() {
        var arenas = [ARENA_FIRST_NAME, ARENA_SPACE_NAME, ARENA_ICE_NAME, ARENA_GRAVITY_NAME, ARENA_FACTORY_NAME];
        if (LiveVersion.BDAY_VS) {
            arenas.push(ARENA_BDAY_NAME);
        }
        return arenas;
    }
    function changeArenaTo(name) {
        setArenaWorld(arenaNameToId(name));
    }
    function getPacks() {
        return [PACK_CLASSIC_NAME, PACK_COMMUNITY_NAME, PACK_WEEKLY_NAME, PACK_ALL_NAME];
    }
    function packNameToIdWithAll(name) {
        if (name === PACK_ALL_NAME)
            return PACK_ALL_ID;
        return packNameToId(name);
    }
    function packIdToNameWithAll(id) {
        if (id === PACK_ALL_ID)
            return PACK_ALL_NAME;
        return packIdToName(id);
    }
    function changePackTo(name) {
        var packs = (name === PACK_ALL_NAME || name === PACK_WEEKLY_NAME) ? OFFICIAL_PACKS : [packNameToId(name)];
        setArenaWorldForPacks(packs);
    }
    function timeToSeconds(v) {
        if (!v || v.split(':').length !== 2) {
            return -1;
        }
        try {
            return parseInt(v.split(':')[0]) * 60 + parseInt(v.split(':')[1]);
        }
        catch (_a) {
            console.error('Improper time format:', v);
            return -1;
        }
    }
    function secondsToTime(s) {
        if (s < 0) {
            return 'Off';
        }
        var minutes = Math.floor(s / 60);
        var seconds = s % 60;
        return minutes + ":" + (seconds === 0 ? '00' : seconds);
    }
})(VSModeSettings || (VSModeSettings = {}));
